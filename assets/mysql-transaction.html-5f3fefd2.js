import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as r,c as u,a as n,d as t,w as d,b as e,e as i}from"./app-a569c9af.js";const c={},p=i(`<h2 id="事务简介" tabindex="-1"><a class="header-anchor" href="#事务简介" aria-hidden="true">#</a> 事务简介</h2><p>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。</p><p>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。</p><ul><li><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p></li><li><p>只有使用了 Innodb 数据库引擎的数据库或表才支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p></li></ul><h2 id="事务提交、回滚" tabindex="-1"><a class="header-anchor" href="#事务提交、回滚" aria-hidden="true">#</a> 事务提交、回滚</h2><p>事务提交操作</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; start transaction;#手动开启事务
mysql&gt; insert into t_user(name) values(&#39;pp&#39;);
mysql&gt; commit;#commit之后即可改变底层数据库数据, pp成功插入
mysql&gt; select * from t_user;
+----+------+
| id | name |
+----+------+
|  1 | jay  |
|  2 | man  |
|  3 | pp   |
+----+------+
3 rows in set (0.00 sec)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务回滚操作</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql&gt; insert into t_user(name) values(&#39;yy&#39;);
mysql&gt; rollback;  #事务回滚后，上面的操作也不去执行了，yy没有成功插入
mysql&gt; select * from t_user;
+----+------+
| id | name |
+----+------+
|  1 | jay  |
|  2 | man  |
|  3 | pp   |
+----+------+
3 rows in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>##事务四大特性</p><p>一般来说，事务（transaction）是必须满足4个条件（ACID）</p><p>原子性（Atomicity）</p><p>一致性（Consistency）</p><p>隔离性（Isolation）</p><p>持久性（Durability）</p><p><strong>事务的目的是保障数据的一致性</strong></p><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</strong></p><p><strong>也就是说 A、I、D 是手段，C 是目的</strong></p><hr><blockquote><p>原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></blockquote><blockquote><p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(比如：A向B转账，不可能A扣了钱，B却没有收到)</p></blockquote><blockquote><p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></blockquote><blockquote><p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></blockquote><h2 id="并发事务会带来哪些问题" tabindex="-1"><a class="header-anchor" href="#并发事务会带来哪些问题" aria-hidden="true">#</a> 并发事务会带来哪些问题</h2><h4 id="_1-脏读-读取未提交数据" tabindex="-1"><a class="header-anchor" href="#_1-脏读-读取未提交数据" aria-hidden="true">#</a> 1.脏读：（读取未提交数据）</h4><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>`,26),h=n("thead",null,[n("tr",null,[n("th",null,"时间顺序"),n("th",null,"事务A"),n("th",null,"事务B")])],-1),m=n("tr",null,[n("td",null,"1"),n("td"),n("td",null,"开始事务")],-1),g=n("tr",null,[n("td",null,"2"),n("td",null,"开始事务"),n("td")],-1),_=n("tr",null,[n("td",null,"3"),n("td"),n("td",null,"查询账户余额为2000元")],-1),b=n("tr",null,[n("td",null,"4"),n("td"),n("td",null,"取款1000元，余额被更改为1000元（未提交）")],-1),f=n("td",null,"5",-1),v=n("td",null,null,-1),w=n("tr",null,[n("td",null,"6"),n("td"),n("td",null,"事务回滚，取款操作发生未知错误，余额变更为2000元")],-1),y=n("tr",null,[n("td",null,"7"),n("td",null,"转入2000元，余额被更改为3000元（脏读1000+2000）"),n("td")],-1),x=n("tr",null,[n("td",null,"8"),n("td",null,"提交事务"),n("td")],-1),k=n("td",null,"备注",-1),q=n("td",null,null,-1),V=n("h4",{id:"_2-不可重复读-前后多次读取-数据内容不一致",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2-不可重复读-前后多次读取-数据内容不一致","aria-hidden":"true"},"#"),e(" 2.不可重复读:（前后多次读取，数据内容不一致）")],-1),C=n("p",null,[e("是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）"),n("br"),e(" 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。")],-1),M=n("thead",null,[n("tr",null,[n("th",null,"时间顺序"),n("th",null,"事务A"),n("th",null,"事务B")])],-1),R=n("tr",null,[n("td",null,"1"),n("td",null,"开始事务"),n("td")],-1),A=n("td",null,"2",-1),B=n("td",null,null,-1),z=n("tr",null,[n("td",null,"3"),n("td"),n("td",null,"开始事务")],-1),I=n("tr",null,[n("td",null,"4"),n("td",null,"其他操作"),n("td")],-1),S=n("tr",null,[n("td",null,"5"),n("td"),n("td",null,"更改小明的年龄为30岁")],-1),U=n("tr",null,[n("td",null,"6"),n("td"),n("td",null,"提交事务")],-1),D=n("td",null,"7",-1),L=n("td",null,null,-1),j=n("tr",null,[n("td",null,"备注"),n("td",null,"按照正确逻辑，事务A前后两次读取到的数据应该一致"),n("td")],-1),Q=n("h4",{id:"_3-幻读-前后多次读取-数据总量不一致",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_3-幻读-前后多次读取-数据总量不一致","aria-hidden":"true"},"#"),e(" 3.幻读:（前后多次读取，数据总量不一致）")],-1),N=n("p",null,"事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。",-1),E=n("ul",null,[n("li",null,"例子1：")],-1),T=n("thead",null,[n("tr",null,[n("th",null,"时间顺序"),n("th",null,"事务A"),n("th",null,"事务B")])],-1),P=n("tr",null,[n("td",null,"1"),n("td",null,"开始事务"),n("td")],-1),F=n("td",null,"2",-1),G=n("td",null,null,-1),H=n("tr",null,[n("td",null,"3"),n("td"),n("td",null,"开始事务")],-1),J=n("tr",null,[n("td",null,"4"),n("td",null,"其他操作"),n("td")],-1),K=n("tr",null,[n("td",null,"5"),n("td"),n("td",null,"新增100条数据")],-1),O=n("tr",null,[n("td",null,"6"),n("td"),n("td",null,"提交事务")],-1),W=n("td",null,"7",-1),X=n("td",null,null,-1),Y=n("tr",null,[n("td",null,"备注"),n("td",null,"按照正确逻辑，事务A前后两次读取到的数据总量应该一致，第二次没有插入过查出来却多了100条记录，像见鬼了一样， 产生了幻读问题"),n("td")],-1),Z=i(`<h4 id="不可重复读和幻读的区别" tabindex="-1"><a class="header-anchor" href="#不可重复读和幻读的区别" aria-hidden="true">#</a> 不可重复读和幻读的区别</h4><p>（1）不可重复读是读取了其他事务更改的数据，针对update操作<br> 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。</p><p>（2）幻读是读取了其他事务新增的数据，针对insert与delete操作<br> 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。</p><p>幻读和不可重复读都是指的一个事务范围内的操作受到其他事务的影响了。只不过幻读是重点在插入和删除，不可重复读重点在修改</p><h2 id="事务隔离性" tabindex="-1"><a class="header-anchor" href="#事务隔离性" aria-hidden="true">#</a> 事务隔离性</h2><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h3><p>（1）读未提交：read uncommitted</p><ul><li><p>一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>最低的隔离级别，脏读、不可重复读或幻读都有可能发生，数据库隔离级别一般都高于该级别</p></li></ul><p>（2）读已提交：read committed</p><ul><li><p>一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>可以阻止“脏读”， 但是幻读或不可重复读仍有可能发生。</p></li></ul><p>（3）可重复读：repeatable read</p><ul><li><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>可以阻止“脏读”和“不可重复读”，但幻读仍有可能发生。</p></li><li><p>InnoDB引擎默认隔离级别</p></li></ul><p>（4）串行化：serializable</p><ul><li>事务A和事务B，事务A在操作数据库时，事务B只能排队等待, 必须事务A执行完成，才能继续执行</li><li>这种隔离级别很少使用，吞吐量低，用户体验差</li><li>可以阻止脏读、不可重复读以及幻读。</li></ul><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交 Read uncommitted</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交 Read committed</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读 Repeatable read</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化 Serializable</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><h2 id="事务实现的原理" tabindex="-1"><a class="header-anchor" href="#事务实现的原理" aria-hidden="true">#</a> 事务实现的原理</h2><p>事务的原子性是通过undolog来实现的</p><p>事务的持久性性是通过redolog来实现的</p><p>事务的隔离性是通过(读写锁+MVCC)来实现的</p><p>事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！</p><p>原子性，持久性，隔离性的目的也是为了保障数据的一致性！</p><p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p><p>下面我首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p><h3 id="redo-log-与-undo-log介绍" tabindex="-1"><a class="header-anchor" href="#redo-log-与-undo-log介绍" aria-hidden="true">#</a> redo log 与 undo log介绍</h3><h4 id="什么是redo-log" tabindex="-1"><a class="header-anchor" href="#什么是redo-log" aria-hidden="true">#</a> 什么是redo log ?</h4><p>redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。</p><figure><img src="https:////upload-images.jianshu.io/upload_images/18395032-4c0db75164be9dc6.png?imageMogr2/auto-orient/strip|imageView2/2/w/346/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token class-name">start</span> transaction<span class="token punctuation">;</span>
<span class="token keyword">select</span> balance <span class="token keyword">from</span> bank <span class="token keyword">where</span> <span class="token class-name">name</span><span class="token operator">=</span><span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 生成 重做日志 balance=600</span>
update bank <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">-</span> <span class="token number">400</span><span class="token punctuation">;</span> 
<span class="token comment">// 生成 重做日志 amount=400</span>
update finance <span class="token keyword">set</span> amount <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">400</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https:////upload-images.jianshu.io/upload_images/18395032-7cb235ab22dcc839.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="redo-log作用是什么" tabindex="-1"><a class="header-anchor" href="#redo-log作用是什么" aria-hidden="true">#</a> redo log作用是什么？</h4><p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。</p><p>那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p><p>所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</p><ul><li>总结：redo log是用来恢复数据的，用于保障，已提交事务的持久化特性（记录了已经提交的操作）</li></ul><h4 id="什么是undo-log" tabindex="-1"><a class="header-anchor" href="#什么是undo-log" aria-hidden="true">#</a> 什么是undo log？</h4><p>undo log 叫做回滚日志，用于记录数据被修改前的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。<br> 还用上面那两张表</p><figure><img src="https:////upload-images.jianshu.io/upload_images/18395032-e9d263abcc51546d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。</p><h4 id="undo-log-有什么作用" tabindex="-1"><a class="header-anchor" href="#undo-log-有什么作用" aria-hidden="true">#</a> undo log 有什么作用？</h4><p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><ul><li>总结：undo log是用来回滚数据的用于保障，未提交事务的原子性</li></ul><h3 id="mysql锁技术以及mvcc基础" tabindex="-1"><a class="header-anchor" href="#mysql锁技术以及mvcc基础" aria-hidden="true">#</a> mysql锁技术以及MVCC基础</h3><h4 id="mysql锁技术" tabindex="-1"><a class="header-anchor" href="#mysql锁技术" aria-hidden="true">#</a> mysql锁技术</h4><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br> 读写锁<br> 解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p><ul><li><p>共享锁(shared lock),又叫做&quot;读锁&quot;<br> 读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p></li><li><p>排他锁(exclusive lock),又叫做&quot;写锁&quot;<br> 写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p><figure><img src="https:////upload-images.jianshu.io/upload_images/18395032-d094d81163c2e826.png?imageMogr2/auto-orient/strip|imageView2/2/w/416/format/webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li><li><p>总结：通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行</p></li></ul><h2 id="mvvc-实现原理" tabindex="-1"><a class="header-anchor" href="#mvvc-实现原理" aria-hidden="true">#</a> MVVC 实现原理</h2><p>MySQL在可重复读事务隔离级别下为了保证事务较高的隔离性，采用了**MVCC (Multi-Version Concurrency Control)**机制来保证的。<strong>MVCC全称叫做多版本并发控制</strong>，是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访问，实现事务。<strong>其核心思想是读不加锁，读写不冲突</strong>。对同一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥造成并发性能下降（而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的）。</p><p>MySQL在读已提交和可重复读隔离级别下都实现了MVCC机制。</p><p>MVCC实现原理是数据快照，不同的事务访问不同版本的数据快照，从而实现事务下对数据的隔离级别。虽然说具有多个版本的数据快照，但这并不意味着必须拷贝数据，保存多份数据文件（这样会浪费存储空间），InnoDB存储引擎通过事务的Undo日志巧妙地实现了多版本的数据快照。</p><p><strong>MVCC的实现依赖于Undo日志和Read View</strong>。下面我们先来详细介绍一下这两个机制。</p><p><strong>1）、Undo日志</strong></p><p>Undo存放在数据库内部的一个特殊段（segment）中，这个段称为Undo段（undo segment）。Undo段位于系统表空间内，也可以设置为Undo表空间。</p><p>Undo日志保存了记录修改前的数据，并且用两个隐藏字段trx_id和roll_pointer把这些Undo日志串联起来形成一个历史记录版本链（参考图1）。所以，对于更新和删除操作，InnoDB存储引擎并不是真正的删除原来的记录，而是设置记录的delete mark为1。</p><figure><img src="https://pic3.zhimg.com/80/v2-5ff1b7c9d77ed4ee643a1ab6272406ce_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>2）Read View</strong></p><p>ReadView其实就是一张存储事务id的表。在可重复读隔离级别，当事务开启后，执行任何查询SQL时都会生成当前事务的一致性视图Read View，该视图在事务结束之前永远都不会变化(如果是读已提交隔离级别则在每次执行查询SQL时都会重新生成一致性视图Read View)。这个视图包含的内容有：执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）如图2。事务里的任何SQL查询结果需要从对应的Undo日志版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p><figure><img src="https://pic1.zhimg.com/80/v2-dccd6522b6d468006362681e8b22847c_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>3）版本链比对规则：</strong></p><p>要结合图1和图2一起来看，那图1的每一行数据row跟图2比较：</p><p>a、如果row的trx_id落在最左边部分，即trx_id&lt;min_id，表示这个版本是已提交的事务生成的，该数据是可见的；</p><p>b、如果row的trx_id落在最右边部分，即trx_id&gt;max_id，表示这个版本是由将来启动的事务生成的，是不可见的(若row的trx_id就是当前自己的事务则是可见的）；</p><p>c、如果row的trx_id落在中间部分，即min_id&lt;=trx_id&lt;=max_id，分为两种情况：</p><p>一是：若row的trx_id在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若row的trx_id就是当前自己的事务是可见的)；</p><p>二是：若row的trx_id不在视图数组中，表示这个版本是已经提交了的事务生成的，该数据是可见的。</p><p><strong>举例说明</strong>：假如此时有一张表account表，其属性有：id、name、balance；并且也有一条id为1余额为0的基础数据。如下图：</p><figure><img src="https://pic2.zhimg.com/80/v2-f5b6abc7c011c12ec4d478efac225c1d_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>横轴为不同客户端开启的事务，纵轴为时间（从上到下按照从早到晚的顺序）。</p><p>当#select 1在执行select balance from account where id = 1时，会生成一致性视图Read View，因为此时事务100和事务200还未提交，事务300已经提交，且已生成的最大事务为300，所以生成的一致性视图Read View为：[100,200] 300；Undo日志版本链为：</p><figure><img src="https://pic3.zhimg.com/80/v2-ff5925e91c153f06ceef74c46dba9b52_720w.webp" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>将Undo日志版本连的每一条数跟生成的Read View[100,200] 300做对比，此时最小事务id为100，最大事务id为300，未提交的事务id数组为[100,200]；根据上面的比对规则就可得出：先拿第5条数据做对比，第5条数据事务id为300，满足min_id &lt; 300 &lt;= max_id且300不在[100,200]数组内，因此此条数据是可见的；紧接着第4、3、2条数据，由于Undo版本连上的事务200和100都在[100,200]因此是不可见的，而事务99满足99 &lt; min_id，是已经提交了的数据，因此也是可见的，所以最终查询的结果为500。由于在可重复读隔离级别下，同一个事务内生成的Read View是不变动的，所以selec 1中再次查询相同的语句，得出的结果还是一样的。</p><p>以上便是根据select 1分析的过程，各位可以自己根据select 2分析以加强自己的理解。</p><p>所有由此我们可以看到：Read View和可见性算法其实就是记录了SQL查询那个时刻数据库里提交和未提交所有事务的状态。要实现RR隔离级别，事务里每次执行查询操作Read View都是使用第一次查询时生成的Read View，也就是都是以第一次查询时当时数据库里所有事务提交状态来比对数据是否可见，当然可以实现每次查询的可重复读的效果了。要实现RC隔离级别，事务里每次执行查询操作Read View都会按照数据库当前状态重新生成Read View，也就是每次查询都是跟数据库里当前所有事务提交状态来比对数据是否可见，当然实现的就是每次都能查到已提交的最新数据效果了。</p><p><br><strong>参考文章</strong>：</p><p>《Mysql 实战45讲》</p>`,74),$={href:"https://www.jianshu.com/p/081a3e208e32",target:"_blank",rel:"noopener noreferrer"};function nn(en,tn){const l=a("font"),o=a("ExternalLinkIcon");return r(),u("div",null,[p,n("table",null,[h,n("tbody",null,[m,g,_,b,n("tr",null,[f,n("td",null,[t(l,{color:"red"},{default:d(()=>[e(" 查询账户余额为1000元（读到了事务B还未提交的脏数据）")]),_:1})]),v]),w,y,x,n("tr",null,[k,n("td",null,[t(l,{color:"red"},{default:d(()=>[e(" 按照正常逻辑此时账户应该为4000元")]),_:1})]),q])])]),V,C,n("table",null,[M,n("tbody",null,[R,n("tr",null,[A,n("td",null,[t(l,{color:"red"},{default:d(()=>[e(" 第一次查询，小明的年龄为20岁")]),_:1})]),B]),z,I,S,U,n("tr",null,[D,n("td",null,[t(l,{color:"red"},{default:d(()=>[e(" 第二次查询，小明的年龄为30岁")]),_:1})]),L]),j])]),Q,N,E,n("table",null,[T,n("tbody",null,[P,n("tr",null,[F,n("td",null,[t(l,{color:"red"},{default:d(()=>[e("第一次查询，数据总量为100条")]),_:1})]),G]),H,J,K,O,n("tr",null,[W,n("td",null,[t(l,{color:"red"},{default:d(()=>[e("第二次查询，数据总量为200条")]),_:1})]),X]),Y])]),Z,n("p",null,[n("a",$,[e("Mysql事务"),t(o)])])])}const an=s(c,[["render",nn],["__file","mysql-transaction.html.vue"]]);export{an as default};
