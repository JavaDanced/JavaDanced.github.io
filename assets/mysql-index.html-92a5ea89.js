import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as l,c as s,a as e,b as a,d as t,e as r}from"./app-a569c9af.js";const p="/assets/hash索引-6d28a03b.jpeg",o="/assets/BST-c6397937.jpg",h="/assets/AVL-805d8cf2.jpg",c="/assets/B-Tree-43c7196b.png",g="/assets/B_Tree-3f3a2103.png",u="/assets/密集索引-5986fab2.png",b="/assets/稀疏索引-d871970b.png",f="/assets/page-646dcca5.png",_="/assets/主键索引-辅助索引-966d1f8b.png",m="/assets/最左匹配原则-93cbcb0f.png",x="/assets/图3-e75bcc03.webp",y="/assets/图4-3d99e59a.webp",B="/assets/explain-ff9a62cf.png",L={},I=r('<blockquote><p>作为一名Java老司机，应该清楚，数据库索引这个知识点在面试中基本上必问。</p><p>今天就来彻底搞懂他，跟随企鹅君，一往无前～</p></blockquote><h2 id="索引介绍" tabindex="-1"><a class="header-anchor" href="#索引介绍" aria-hidden="true">#</a> 索引介绍</h2><p>MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。</p><p>● 索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。<br> ● 索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。</p><h2 id="索引数据结构模型" tabindex="-1"><a class="header-anchor" href="#索引数据结构模型" aria-hidden="true">#</a> 索引数据结构模型</h2><h3 id="hash-表" tabindex="-1"><a class="header-anchor" href="#hash-表" aria-hidden="true">#</a> Hash 表</h3><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：<br><img src="'+p+'" alt="image.png" loading="lazy">图 1</p><p>哈希表示意图 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。 你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。 所以，哈希表这种结构适用于只有等值查询的场景， 不适合范围查询的场景</p><h3 id="二叉搜索树-bst" tabindex="-1"><a class="header-anchor" href="#二叉搜索树-bst" aria-hidden="true">#</a> 二叉搜索树(BST)</h3><p>二叉搜索树（Binary Search Tree）具有以下特点：</p><p>二叉搜索树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p><ol start="0"><li>左子树的节点均小于根节点的值。</li><li>右子树的节点均大于根节点的值。</li><li>左右子树也各自成为一个二叉查找树。</li></ol><p>当二叉搜索树保持平衡时，即每个节点的左右子树深度相差不超过1，查询操作的时间复杂度为O(log2(N))，具有较高的效率。然而，当二叉搜索树失去平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂度退化为O(N)。</p><figure><img src="'+o+'" alt="斜树" tabindex="0" loading="lazy"><figcaption>斜树</figcaption></figure><p>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。</p><h3 id="avl-树" tabindex="-1"><a class="header-anchor" href="#avl-树" aria-hidden="true">#</a> AVL 树</h3>',16),k=e("strong",null,"AVL树",-1),S=e("strong",null,"高度平衡树",-1),D={href:"https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC?fromModule=lemma_inlink",target:"_blank",rel:"noopener noreferrer"},q=r('<figure><img src="'+h+'" alt="AVL 树" tabindex="0" loading="lazy"><figcaption>AVL 树</figcaption></figure><p>实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。比如B-树，B+树、红黑树等</p><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B-树</h3><blockquote><p>这里可不是B减树， 就是B树, 中间只是一个横线</p></blockquote><figure><img src="'+c+'" alt="B-Tree" tabindex="0" loading="lazy"><figcaption>B-Tree</figcaption></figure><p><strong>定义：</strong></p><p>1、根节点至少包含两个孩子</p><p>2、每个节点最多包含m个孩子(m &gt;= 2)，m为树的深度</p><p>3、除了根节点和叶子节点，其他节点至少有ceil(m/2)个孩子，ceil函数为取上限，例如ceil(1.2)=2，就是小数位多少，都入，不是四舍五入</p><p>4、叶子节点的高度相同</p><p>如果我们需要寻找key为28的数据，会经历3次磁盘I/O操作过程</p><p>PS：</p><p>1、我们从上图看到B树和二分搜索树有一点相似的地方，数据是有序的，也就是按照关键字进行排序</p><p>2、非叶子节点包含key和value，以及指向其子节点地址的指针</p><p>3、叶子节点只有key和value</p><h3 id="b-树-1" tabindex="-1"><a class="header-anchor" href="#b-树-1" aria-hidden="true">#</a> B+树</h3><figure><img src="'+g+'" alt="B+树" tabindex="0" loading="lazy"><figcaption>B+树</figcaption></figure><ul><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点的子树指针P[i]，指向关键字值的子树</li><li>非叶子节点仅用来索引，数据都保存在叶子节点中</li><li>所有叶子节点均有一个链指针指向下一个叶子节点 （紫色块之间有链指针连接，从左到右升序排列）</li></ul><h3 id="b-树与b-树的区别" tabindex="-1"><a class="header-anchor" href="#b-树与b-树的区别" aria-hidden="true">#</a> B+树与B-树的区别</h3><p>B+树是B树的一种优化<br> 1、B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。非叶子节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，磁盘IO操作次数更少。查询效率更高<br> 2、B+树查询路径都是从非叶子结点， 到叶子节点。 效率比较稳定<br> 3、B+树叶子结点是一个链表， 扫描全表数据速度更快（只需要遍历叶子节点，并且范围查询也有优化）</p><p>因为B+树的这些好处，在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构,</p><p>但是，两者的实现方式不太一样。MyISAM 引擎是使用的非聚簇索引，InnoDB 引擎使用的是聚簇索引</p><p>接下来就介绍下索引类型</p><h2 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> 索引类型</h2><h3 id="按照数据模型维度划分" tabindex="-1"><a class="header-anchor" href="#按照数据模型维度划分" aria-hidden="true">#</a> 按照数据模型维度划分：</h3><ol><li><strong>B-Tree索引</strong>：B树索引是MySQL中最常见的索引类型，适用于大部分场景。它支持等值查询、范围查询和前缀匹配。</li><li><strong>哈希索引</strong>：哈希索引是一种基于哈希表实现的索引，类似键值对的形式，一次即可定位, 等值查询非常快，但是不支持范围查询和前缀匹配</li><li><strong>空间索引</strong>：空间索引是一种用于地理空间数据查询的特殊索引，它基于R树实现。优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li><strong>全文索引</strong>：全文索引是一种用于文本数据模糊查询的特殊索引，它基于倒排索引实现。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ol><h3 id="按照功能逻辑维度划分" tabindex="-1"><a class="header-anchor" href="#按照功能逻辑维度划分" aria-hidden="true">#</a> 按照功能逻辑维度划分：</h3><ol><li><p>主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值(NULL)。一般是在建表的时候同时创建主键索引。</p></li><li><p>普通索引：仅用于加速查询。</p></li><li><p>唯一索引：索引列的值必须唯一，但允许有空值(NULL)。如果是组合索引，则列值的组合必须唯一。</p></li><li><p>联合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</p></li><li><p>覆盖索引：覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。</p></li><li><p>全文索引：全文索引是一种用于文本数据模糊查询的特殊索引，它基于倒排索引实现。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p></li></ol><h3 id="从底层存储方式维度划分" tabindex="-1"><a class="header-anchor" href="#从底层存储方式维度划分" aria-hidden="true">#</a> 从底层存储方式维度划分：</h3><ol><li><p>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</p></li><li><p>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p></li></ol><h4 id="聚簇索引-密集索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引-密集索引" aria-hidden="true">#</a> 聚簇索引(密集索引)</h4><p>行数据和主键索引存储在一起，辅助键索引只存储辅助键和主键，而不保存数据</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>InnoDB使用的是聚簇索引，行数据保存在叶子节点上。如果通过where id = 5，直接通过主键索引找到对应的关键字，然后返回行数据</p><p>如果通过where name = tom，首先通过辅助键索引找到对应id = 5，然后再通过主键索引找到行数据</p><p>PS：</p><p>1).如果存在主键，主键就是密集索引</p><p>2).如果没有主键，表中第一个唯一非空索引为密集索引</p><p>3).如果以上都没有，InnoDB生成一个隐藏主键作为密集索引，是一个6字节的列，随着数据的插入自增</p><p>所以，InnoDB必须有个密集索引，这是因为非主键索引叶子节点不保存行数据，而是保存着主键值</p><h4 id="非聚簇索引-稀疏索引" tabindex="-1"><a class="header-anchor" href="#非聚簇索引-稀疏索引" aria-hidden="true">#</a> 非聚簇索引(稀疏索引)：</h4><p>B+树叶子节点存储的是指向数据的指针</p><figure><img src="'+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>MyISAM使用的为非聚簇索引，主键索引保存了主键，非主键索引保存了非主键，而数据行保存在其他位置，检索的过程都是通过叶子节点内</p><p>保存的地址找到对应的数据行。</p><h4 id="innodb为什么使用聚簇索引呢" tabindex="-1"><a class="header-anchor" href="#innodb为什么使用聚簇索引呢" aria-hidden="true">#</a> InnoDB为什么使用聚簇索引呢？</h4><p>从上面索引过程我们可以看到，对于非主键查询来说，聚簇索引需要经过两次检索，好像效率更低了，那么聚簇索引的优势在哪？</p><p>1、行数据和叶子节点保存在一起，会一起被加载到内存，找到叶子节点就可以将数据库返回。</p><p>2、辅助索引的叶子节点保存主键的指针，而不使用地址值作为指针，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键</p><p>值当作指针会让辅助索引占用更多的空间，InnoDB在移动行时无须更新辅助索引中的这个&quot;指针&quot;。也就是说行的位置（实现中通过16K的Page来定</p><p>位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的</p><p>节点如何变化，辅助索引树都不受影响。</p><h4 id="页page" tabindex="-1"><a class="header-anchor" href="#页page" aria-hidden="true">#</a> 页page:</h4><p>InnoDB数据通过page存储，是最小的存储单位，page默认大小为16k，文件系统最小单位块为4k，通过下面参数设置</p>',55),E={href:"https://img2018.cnblogs.com/blog/1351999/201907/1351999-20190709112105625-1669802737.png",target:"_blank",rel:"noopener noreferrer"},M=e("img",{src:f,alt:"img",tabindex:"0",loading:"lazy"},null,-1),A=e("figcaption",null,"img",-1),N=r('<p>页可以用来存储数据也可以用来存储key和指针，分别对应非叶子节点和叶子节点。通过非叶子节点的二分查找和指针确定数据在哪一页，进</p><p>而查到对应的数据。</p><h4 id="一棵b-树可以存放多少条数据" tabindex="-1"><a class="header-anchor" href="#一棵b-树可以存放多少条数据" aria-hidden="true">#</a> 一棵B+树可以存放多少条数据？</h4><p>假设B+树高度为2，一行数据记录大小为1k(实际上很多互联网业务数据就是1k左右)，单个叶子节点(页)中记录数16K/1K=16</p><p>B+树存在的数据总量 = 根节点节点指针数量 * 每页保存的数据量</p><p>假设主键为bigint，长度为8字节，指针大小在InnoDB源码中为6字节，这样一共14字节，我们一个页中存放<strong>16384/14=1170</strong>。那么一棵高度为</p><p>2的B+树，能存放<strong>1170*16=18720</strong>条这样的数据。</p><p>以此类推，一个高度为3的B+树可以存放：1170<em>1170</em>16=21902400条这样的记录。</p><p>所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。通过主键索引查询通常只需要1-3次IO操作即可查找到数据。</p><hr><br><h2 id="索引概念" tabindex="-1"><a class="header-anchor" href="#索引概念" aria-hidden="true">#</a> 索引概念</h2><p>MySQL中InnoDB引擎要求每张表都有要有一个聚簇索引（clustered index），也称为主键索引（primary key index），它的作用是将数据按照主键值排序，方便快速地访问单条记录。除了聚簇索引外，MySQL还可以有多辅助（二级）索引（secondary index），它们的作用是加速查询和排序操作。</p><h3 id="回表查询" tabindex="-1"><a class="header-anchor" href="#回表查询" aria-hidden="true">#</a> 回表查询</h3><p>InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要有，且只有一个。</p><p>辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做回表查询，它的性能比扫一遍索引树低。</p><h3 id="主键索引" tabindex="-1"><a class="header-anchor" href="#主键索引" aria-hidden="true">#</a> 主键索引</h3><p>数据表的主键列使用的就是主键索引。B+Tree的叶子节点存放的是主键字段值</p><p>通常说的主键索引就是聚簇索引。InnoDB的表要求必须要有聚簇索引：<br> ● 如果表定义了主键，则主键索引就是聚簇索引<br> ● 如果表没有定义主键，则第一个非空unique列作为聚簇索引<br> ● 否则InnoDB会从建一个隐藏的row-id作为聚簇索引</p><p>检索过程： 直接通过主键索引找到存储的数据</p><figure><img src="'+_+'" alt="检索过程" tabindex="0" loading="lazy"><figcaption>检索过程</figcaption></figure><h3 id="二级索引-辅助索引" tabindex="-1"><a class="header-anchor" href="#二级索引-辅助索引" aria-hidden="true">#</a> 二级索引(辅助索引)</h3><p>InnoDB二级索引，也叫作辅助索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。</p><p>检索过程： 先通过辅助索引找到主键索引， 通过回表查询，然后再找到存储的数据</p><h3 id="索引覆盖" tabindex="-1"><a class="header-anchor" href="#索引覆盖" aria-hidden="true">#</a> 索引覆盖</h3><p>在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Usingindex时，能够触发索引覆盖。</p><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖。实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。</p><h3 id="最左匹配原则" tabindex="-1"><a class="header-anchor" href="#最左匹配原则" aria-hidden="true">#</a> 最左匹配原则</h3><p>复合索引使用时遵循最左匹配原则，最左匹配顾名思义，就是最左优先，即查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。<br><img src="'+m+`" alt="最左匹配原则" loading="lazy"></p><h3 id="索引下推" tabindex="-1"><a class="header-anchor" href="#索引下推" aria-hidden="true">#</a> 索引下推</h3><p>我们以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1; 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。 然后呢？ 当然是判断其他条件是否满足。 在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><figure><img src="`+x+'" alt="图3" tabindex="0" loading="lazy"><figcaption>图3</figcaption></figure><p>图 3 无索引下推执行流程</p><figure><img src="'+y+`" alt="图4" tabindex="0" loading="lazy"><figcaption>图4</figcaption></figure><p>图 4 索引下推执行流程</p><p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。 图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。 图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p><p></p><h2 id="索引为什么会失效" tabindex="-1"><a class="header-anchor" href="#索引为什么会失效" aria-hidden="true">#</a> 索引为什么会失效</h2><ol><li>列类型不匹配：如果索引列和查询条件的数据类型不匹配，例如在一个字符串类型的索引列上执行了数值比较，那么索引就会失效。</li><li>函数操作：如果查询条件中使用了函数操作，例如在索引列上使用函数操作或者使用了自定义函数，那么索引也会失效。</li><li>索引列值为空：如果查询条件中使用了IS NULL或者IS NOT NULL操作，那么如果索引列上存在NULL值，那么索引就会失效。</li><li>表达式操作：如果查询条件中使用了表达式操作，例如对索引列进行加减乘除等操作，那么索引也会失效。</li><li>隐式类型转换：如果查询条件中使用了隐式类型转换，例如在一个字符串类型的索引列上执行了数值比较，并且数据库自动将字符串转换为数字类型，那么索引也会失效。</li><li>数据量太大：如果表中的数据量太大，那么对于一些非唯一索引列，索引的查询优化器可能会认为扫描整个表比使用索引更加高效，从而导致索引失效。</li><li>索引列上存在函数：如果索引列上使用了函数，例如在索引列上使用了UPPER()函数，那么索引也会失效。</li><li>最左匹配原则：联合索引要正确使用需满足最左匹配原则，即：符合第一列才会继续判断后面的字段。</li><li>使用OR 一列不是索引</li></ol><h2 id="正确使用索引" tabindex="-1"><a class="header-anchor" href="#正确使用索引" aria-hidden="true">#</a> 正确使用索引</h2><ol><li><p>索引字段占用空间越小越好， 大文本，大对象不要创建索引</p></li><li><p>索引并不是越多越好， 有维护成本，空间成本</p><p>建议单表不超过5个索引</p></li><li><p>频繁更新的字段不适合作为索引</p></li><li><p>我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p>频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li></ol><h2 id="如何分析sql使用索引情况" tabindex="-1"><a class="header-anchor" href="#如何分析sql使用索引情况" aria-hidden="true">#</a> 如何分析sql使用索引情况</h2><p>在 MySQL 中可以通过 <code>EXPLAIN</code> 关键字模拟优化器执行 SQL语句</p><div class="language-explain line-numbers-mode" data-ext="explain"><pre class="language-explain"><code>explain select 列名 FROM 表名 WHERE 条件 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>EXPLAIN</code>输出内容如下：</p><figure><img src="`+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT的查询序列号</td></tr><tr><td>select_type</td><td>主要用来说明查询的类型：普通查询、联合查询、子查询等</td></tr><tr><td>table</td><td>输出的行所引用的表</td></tr><tr><td>partitions</td><td>如果查询是基于分区表的话，显示查询将访问的分区。，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>代表访问类型，是判断sql执行性能比较关键的一个字段</td></tr><tr><td>possible_keys</td><td>MySQL可能使用的键(索引)。</td></tr><tr><td>key</td><td>MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>表示索引的哪一列被使用<br>显示使用哪个列或常数与key一起从表中选择行。</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><hr><p><strong>type</strong></p><p>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:</p><p>type代表访问类型，是判断sql执行性能比较关键的一个字段，性能从高到低依次是：<br> system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li>system:表仅有一行(=系统表)。这是const联接类型的一个特例。</li><li>const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!</li><li>eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。</li><li>ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。</li><li>ref_or_:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</li><li>index_merge:该联接类型表示使用了索引合并优化方法。</li><li>unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</li><li>index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</li><li>range:只检索给定范围的行,使用一个索引来选择行。</li><li>index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。</li><li>ALL:对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。</li></ul><p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p><p><br><strong>参考文章</strong>：</p>',57),v={href:"https://www.cnblogs.com/huigelaile/p/11152781.html",target:"_blank",rel:"noopener noreferrer"},T=e("p",null,"《Mysql 实战45讲》",-1),Q={href:"https://www.cnblogs.com/chihaoyuIsnotHere/p/17004616.html",target:"_blank",rel:"noopener noreferrer"};function R(V,w){const i=d("ExternalLinkIcon");return l(),s("div",null,[I,e("p",null,[k,a("是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为"),S,a("。增加和删除可能需要通过一次或多次"),e("a",D,[a("树旋转"),t(i)]),a("来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis。它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。")]),q,e("figure",null,[e("a",E,[M,t(i)]),A]),N,e("p",null,[e("a",v,[a("InnoDB索引原理"),t(i)])]),T,e("p",null,[e("a",Q,[a("Mysql索引"),t(i)])])])}const O=n(L,[["render",R],["__file","mysql-index.html.vue"]]);export{O as default};
