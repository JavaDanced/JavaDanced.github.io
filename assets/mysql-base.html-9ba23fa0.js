import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,e as n}from"./app-a569c9af.js";const o="/assets/MySQL框架-f3b019a9.png",r={},l=n(`<blockquote><p>跟随企鹅君，一起高效学习～</p><p>学习新知识的时候千万不要一上来就陷入细节，你应该先完成一个整体框架的构建，才可以在高维度视角理解问题。然后再把框架拆解成小的分支，逐个攻破。久而久之，习惯养成，很多问题也就不成问题了。</p></blockquote><h2 id="一-mysql-基本架构" tabindex="-1"><a class="header-anchor" href="#一-mysql-基本架构" aria-hidden="true">#</a> 一 MySQL 基本架构</h2><p>我们在使用MySQL中看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。</p><p>比如我们在执行下面这个查询语句时：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> T <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span>； 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>客户端发出一条SQL查询语句的执行过程:</p><p>连接器 --&gt; 分析器 --&gt; 优化器 --&gt; 执行器 --&gt; 存储引擎</p><figure><img src="`+o+`" alt="MySQL 的逻辑架构图" tabindex="0" loading="lazy"><figcaption>MySQL 的逻辑架构图</figcaption></figure><p>MySQL可以分为 Server 层和存储引擎层两部分：</p><h3 id="server-层" tabindex="-1"><a class="header-anchor" href="#server-层" aria-hidden="true">#</a> Server 层</h3><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><h3 id="存储引擎层" tabindex="-1"><a class="header-anchor" href="#存储引擎层" aria-hidden="true">#</a> 存储引擎层</h3><p>存储引擎层则负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>从图中不难看出，不同的存储引擎共用一个<strong>Server 层</strong>，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p><h3 id="连接器" tabindex="-1"><a class="header-anchor" href="#连接器" aria-hidden="true">#</a> 连接器</h3><p>第一步，你会先登陆数据库系统，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。超时自动断开，建立连接过程复杂，建议使用长链接，连接比较占用内存，需要定时断开，5.7之后可以使用mysql_reset_connection。连接命令一般是这么写的：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>mysql -u 数据库用户名 -p 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输完命令之后，你就需要在交互对话里面输入密码。认证通过后，连接器会到权限表里面查出你拥有的权限。你就可以对数据库进行操作了。</p><h3 id="查询缓存-mysql-8-0版本后被移除" tabindex="-1"><a class="header-anchor" href="#查询缓存-mysql-8-0版本后被移除" aria-hidden="true">#</a> 查询缓存 （MySQL 8.0版本后被移除）</h3><p>其他资料中第二步是去查询缓存, 但是这个功能不实用，MySQL 8.0 版本就直接将查询缓存的整块功能删掉了</p><p>图中博主也直接删掉了</p><p>查询缓存简单来说就是以key-value对的形式存储之前做过的查询，key是查询语句，value是查询的结果，如果正在执行的查询，存在缓存中，那么直接返回结果。表上的任意更新都会导致表上的所有查询缓存清空。</p><h3 id="分析器" tabindex="-1"><a class="header-anchor" href="#分析器" aria-hidden="true">#</a> 分析器</h3><p>成功建立连接后，对于客户端输入的命令，MySQL 需要先知道你要做什么，因此需要对 SQL 语句做解析。</p><p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p>MySQL 从你输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“id”识别成“列 id”。</p><p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> elect <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

ERROR <span class="token number">1064</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">&#39;elect * from t where id=1&#39;</span> at line <span class="token number">1</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h3 id="优化器" tabindex="-1"><a class="header-anchor" href="#优化器" aria-hidden="true">#</a> 优化器</h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p><h3 id="执行器" tabindex="-1"><a class="header-anchor" href="#执行器" aria-hidden="true">#</a> 执行器</h3><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p><h2 id="二-日志模块" tabindex="-1"><a class="header-anchor" href="#二-日志模块" aria-hidden="true">#</a> 二 日志模块</h2><p>上面说完了查询的流程，与查询流程不一样的是，更新流程还涉及两个重要的日志模块，</p><p><strong>redo log（重做日志）和 binlog（归档日志）</strong>。</p><p><strong>这时候有同学要问，这里为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同。</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">update</span> T <span class="token keyword">set</span> c<span class="token operator">=</span>c<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">where</span> ID<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。</p><h2 id="三-总结" tabindex="-1"><a class="header-anchor" href="#三-总结" aria-hidden="true">#</a> 三 总结</h2><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</li><li>更新语句执行流程如下：分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo log(prepare 状态)---&gt;binlog---&gt;redo log(commit 状态)</li></ul><p><br><strong>参考文章</strong>：</p><p>《Mysql 实战45讲》</p>`,53),p=[l];function i(t,d){return a(),s("div",null,p)}const h=e(r,[["render",i],["__file","mysql-base.html.vue"]]);export{h as default};
