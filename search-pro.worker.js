const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":1400,\"nextId\":1400,\"documentIds\":{\"0\":\"v-257c6260\",\"1\":\"v-257c6260#什么是网关\",\"2\":\"v-257c6260#网关能提供哪些功能\",\"3\":\"v-257c6260#有哪些常见的网关系统\",\"4\":\"v-257c6260#netflix-zuul\",\"5\":\"v-257c6260#spring-cloud-gateway\",\"6\":\"v-257c6260#openresty\",\"7\":\"v-257c6260#kong\",\"8\":\"v-257c6260#apisix\",\"9\":\"v-257c6260#shenyu\",\"10\":\"v-257c6260#如何选择\",\"11\":\"v-257c6260#参考\",\"12\":\"v-257c6260@0\",\"13\":\"v-2603c72b\",\"14\":\"v-2603c72b@0\",\"15\":\"v-e63759ea\",\"16\":\"v-e63759ea#场景一-订单系统\",\"17\":\"v-e63759ea#_1、一码付\",\"18\":\"v-e63759ea#_2、订单号\",\"19\":\"v-e63759ea#_3、优惠券和兑换券\",\"20\":\"v-e63759ea#场景二-tracing\",\"21\":\"v-e63759ea#_1、日志跟踪\",\"22\":\"v-e63759ea#_2、traceid-生成规则\",\"23\":\"v-e63759ea#_3、spanid-生成规则\",\"24\":\"v-e63759ea#场景三-短网址\",\"25\":\"v-e63759ea@0\",\"26\":\"v-3d2f27fc\",\"27\":\"v-3d2f27fc#分布式-id-介绍\",\"28\":\"v-3d2f27fc#什么是-id\",\"29\":\"v-3d2f27fc#什么是分布式-id\",\"30\":\"v-3d2f27fc#分布式-id-需要满足哪些要求\",\"31\":\"v-3d2f27fc#分布式-id-常见解决方案\",\"32\":\"v-3d2f27fc#数据库\",\"33\":\"v-3d2f27fc#数据库主键自增\",\"34\":\"v-3d2f27fc#数据库号段模式\",\"35\":\"v-3d2f27fc#nosql\",\"36\":\"v-3d2f27fc#算法\",\"37\":\"v-3d2f27fc#uuid\",\"38\":\"v-3d2f27fc#snowflake-雪花算法\",\"39\":\"v-3d2f27fc#开源框架\",\"40\":\"v-3d2f27fc#uidgenerator-百度\",\"41\":\"v-3d2f27fc#leaf-美团\",\"42\":\"v-3d2f27fc#tinyid-滴滴\",\"43\":\"v-3d2f27fc#总结\",\"44\":\"v-3d2f27fc@0\",\"45\":\"v-2f8329b8\",\"46\":\"v-2f8329b8#基于-redis-实现分布式锁\",\"47\":\"v-2f8329b8#如何基于-redis-实现一个最简易的分布式锁\",\"48\":\"v-2f8329b8#为什么要给锁设置一个过期时间\",\"49\":\"v-2f8329b8#如何实现锁的优雅续期\",\"50\":\"v-2f8329b8#如何实现可重入锁\",\"51\":\"v-2f8329b8#redis-如何解决集群情况下分布式锁的可靠性\",\"52\":\"v-2f8329b8#基于-zookeeper-实现分布式锁\",\"53\":\"v-2f8329b8#如何基于-zookeeper-实现分布式锁\",\"54\":\"v-2f8329b8#为什么要用临时顺序节点\",\"55\":\"v-2f8329b8#为什么要设置对前一个节点的监听\",\"56\":\"v-2f8329b8#如何实现可重入锁-1\",\"57\":\"v-2f8329b8#总结\",\"58\":\"v-2f8329b8@0\",\"59\":\"v-5328cb28\",\"60\":\"v-5328cb28#为什么需要分布式锁\",\"61\":\"v-5328cb28#分布式锁应该具备哪些条件\",\"62\":\"v-5328cb28#分布式锁的常见实现方式有哪些\",\"63\":\"v-5328cb28#总结\",\"64\":\"v-5328cb28@0\",\"65\":\"v-3d4311c6\",\"66\":\"v-3d4311c6@0\",\"67\":\"v-58e5ad96\",\"68\":\"v-58e5ad96#什么是-spring-cloud-gateway\",\"69\":\"v-58e5ad96#spring-cloud-gateway-的工作流程\",\"70\":\"v-58e5ad96#spring-cloud-gateway-的断言是什么\",\"71\":\"v-58e5ad96#spring-cloud-gateway-的路由和断言是什么关系\",\"72\":\"v-58e5ad96#spring-cloud-gateway-如何实现动态路由\",\"73\":\"v-58e5ad96#spring-cloud-gateway-的过滤器有哪些\",\"74\":\"v-58e5ad96#局部过滤器\",\"75\":\"v-58e5ad96#全局过滤器\",\"76\":\"v-58e5ad96#spring-cloud-gateway-支持限流吗\",\"77\":\"v-58e5ad96#spring-cloud-gateway-如何自定义全局异常处理\",\"78\":\"v-58e5ad96#参考\",\"79\":\"v-58e5ad96@0\",\"80\":\"v-59d34958\",\"81\":\"v-59d34958#一-mysql-基本架构\",\"82\":\"v-59d34958#server-层\",\"83\":\"v-59d34958#存储引擎层\",\"84\":\"v-59d34958#连接器\",\"85\":\"v-59d34958#查询缓存-mysql-8-0版本后被移除\",\"86\":\"v-59d34958#分析器\",\"87\":\"v-59d34958#优化器\",\"88\":\"v-59d34958#执行器\",\"89\":\"v-59d34958#二-日志模块\",\"90\":\"v-59d34958#三-总结\",\"91\":\"v-59d34958@0\",\"92\":\"v-59d34958@1\",\"93\":\"v-2a0f1a1b\",\"94\":\"v-2a0f1a1b#索引介绍\",\"95\":\"v-2a0f1a1b#索引数据结构模型\",\"96\":\"v-2a0f1a1b#hash-表\",\"97\":\"v-2a0f1a1b#二叉搜索树-bst\",\"98\":\"v-2a0f1a1b#avl-树\",\"99\":\"v-2a0f1a1b#b-树\",\"100\":\"v-2a0f1a1b#b-树-1\",\"101\":\"v-2a0f1a1b#b-树与b-树的区别\",\"102\":\"v-2a0f1a1b#索引类型\",\"103\":\"v-2a0f1a1b#按照数据模型维度划分\",\"104\":\"v-2a0f1a1b#按照功能逻辑维度划分\",\"105\":\"v-2a0f1a1b#从底层存储方式维度划分\",\"106\":\"v-2a0f1a1b#聚簇索引-密集索引\",\"107\":\"v-2a0f1a1b#非聚簇索引-稀疏索引\",\"108\":\"v-2a0f1a1b#innodb为什么使用聚簇索引呢\",\"109\":\"v-2a0f1a1b#页page\",\"110\":\"v-2a0f1a1b#一棵b-树可以存放多少条数据\",\"111\":\"v-2a0f1a1b#索引概念\",\"112\":\"v-2a0f1a1b#回表查询\",\"113\":\"v-2a0f1a1b#主键索引\",\"114\":\"v-2a0f1a1b#二级索引-辅助索引\",\"115\":\"v-2a0f1a1b#索引覆盖\",\"116\":\"v-2a0f1a1b#最左匹配原则\",\"117\":\"v-2a0f1a1b#索引下推\",\"118\":\"v-2a0f1a1b#索引为什么会失效\",\"119\":\"v-2a0f1a1b#正确使用索引\",\"120\":\"v-2a0f1a1b#如何分析sql使用索引情况\",\"121\":\"v-2a0f1a1b@0\",\"122\":\"v-2a0f1a1b@1\",\"123\":\"v-6a14688f\",\"124\":\"v-6a14688f#事务简介\",\"125\":\"v-6a14688f#事务提交、回滚\",\"126\":\"v-6a14688f#并发事务会带来哪些问题\",\"127\":\"v-6a14688f#_1-脏读-读取未提交数据\",\"128\":\"v-6a14688f#_2-不可重复读-前后多次读取-数据内容不一致\",\"129\":\"v-6a14688f#_3-幻读-前后多次读取-数据总量不一致\",\"130\":\"v-6a14688f#不可重复读和幻读的区别\",\"131\":\"v-6a14688f#事务隔离性\",\"132\":\"v-6a14688f#隔离级别\",\"133\":\"v-6a14688f#事务实现的原理\",\"134\":\"v-6a14688f#redo-log-与-undo-log介绍\",\"135\":\"v-6a14688f#什么是redo-log\",\"136\":\"v-6a14688f#redo-log作用是什么\",\"137\":\"v-6a14688f#什么是undo-log\",\"138\":\"v-6a14688f#undo-log-有什么作用\",\"139\":\"v-6a14688f#mysql锁技术以及mvcc基础\",\"140\":\"v-6a14688f#mysql锁技术\",\"141\":\"v-6a14688f#mvvc-实现原理\",\"142\":\"v-6a14688f@0\",\"143\":\"v-6a14688f@1\",\"144\":\"v-41c22357\",\"145\":\"v-41c22357#cache-aside-pattern-旁路缓存模式\",\"146\":\"v-41c22357#read-write-through-pattern-读写穿透\",\"147\":\"v-41c22357#write-behind-pattern-异步缓存写入\",\"148\":\"v-41c22357@0\",\"149\":\"v-41c22357@1\",\"150\":\"v-35d6531f\",\"151\":\"v-35d6531f@0\",\"152\":\"v-35d6531f@1\",\"153\":\"v-74aa3dfb\",\"154\":\"v-74aa3dfb@0\",\"155\":\"v-74aa3dfb@1\",\"156\":\"v-3963b59a\",\"157\":\"v-3963b59a#o-n-命令\",\"158\":\"v-3963b59a#save-创建-rdb-快照\",\"159\":\"v-3963b59a#aof\",\"160\":\"v-3963b59a#aof-日志记录阻塞\",\"161\":\"v-3963b59a#aof-刷盘阻塞\",\"162\":\"v-3963b59a#aof-重写阻塞\",\"163\":\"v-3963b59a#大-key\",\"164\":\"v-3963b59a#查找大-key\",\"165\":\"v-3963b59a#删除大-key\",\"166\":\"v-3963b59a#清空数据库\",\"167\":\"v-3963b59a#集群扩容\",\"168\":\"v-3963b59a#swap-内存交换\",\"169\":\"v-3963b59a#cpu-竞争\",\"170\":\"v-3963b59a#网络问题\",\"171\":\"v-3963b59a#参考\",\"172\":\"v-3963b59a@0\",\"173\":\"v-3963b59a@1\",\"174\":\"v-53d30eb2\",\"175\":\"v-53d30eb2#string-字符串\",\"176\":\"v-53d30eb2#介绍\",\"177\":\"v-53d30eb2#常用命令\",\"178\":\"v-53d30eb2#应用场景\",\"179\":\"v-53d30eb2#list-列表\",\"180\":\"v-53d30eb2#介绍-1\",\"181\":\"v-53d30eb2#常用命令-1\",\"182\":\"v-53d30eb2#应用场景-1\",\"183\":\"v-53d30eb2#hash-哈希\",\"184\":\"v-53d30eb2#介绍-2\",\"185\":\"v-53d30eb2#常用命令-2\",\"186\":\"v-53d30eb2#应用场景-2\",\"187\":\"v-53d30eb2#set-集合\",\"188\":\"v-53d30eb2#介绍-3\",\"189\":\"v-53d30eb2#常用命令-3\",\"190\":\"v-53d30eb2#应用场景-3\",\"191\":\"v-53d30eb2#sorted-set-有序集合\",\"192\":\"v-53d30eb2#介绍-4\",\"193\":\"v-53d30eb2#常用命令-4\",\"194\":\"v-53d30eb2#应用场景-4\",\"195\":\"v-53d30eb2#总结\",\"196\":\"v-53d30eb2#参考\",\"197\":\"v-53d30eb2@0\",\"198\":\"v-53d30eb2@1\",\"199\":\"v-5587e751\",\"200\":\"v-5587e751#bitmap-位图\",\"201\":\"v-5587e751#介绍\",\"202\":\"v-5587e751#常用命令\",\"203\":\"v-5587e751#应用场景\",\"204\":\"v-5587e751#hyperloglog-基数统计\",\"205\":\"v-5587e751#介绍-1\",\"206\":\"v-5587e751#常用命令-1\",\"207\":\"v-5587e751#应用场景-1\",\"208\":\"v-5587e751#geospatial-地理位置\",\"209\":\"v-5587e751#介绍-2\",\"210\":\"v-5587e751#常用命令-2\",\"211\":\"v-5587e751#应用场景-2\",\"212\":\"v-5587e751#总结\",\"213\":\"v-5587e751#参考\",\"214\":\"v-5587e751@0\",\"215\":\"v-5587e751@1\",\"216\":\"v-8144bf78\",\"217\":\"v-8144bf78#什么是内存碎片\",\"218\":\"v-8144bf78#为什么会有-redis-内存碎片\",\"219\":\"v-8144bf78#如何查看-redis-内存碎片的信息\",\"220\":\"v-8144bf78#如何清理-redis-内存碎片\",\"221\":\"v-8144bf78#参考\",\"222\":\"v-8144bf78@0\",\"223\":\"v-8144bf78@1\",\"224\":\"v-4127de76\",\"225\":\"v-4127de76#rdb-持久化\",\"226\":\"v-4127de76#什么是-rdb-持久化\",\"227\":\"v-4127de76#rdb-创建快照时会阻塞主线程吗\",\"228\":\"v-4127de76#aof-持久化\",\"229\":\"v-4127de76#什么是-aof-持久化\",\"230\":\"v-4127de76#aof-工作基本流程是怎样的\",\"231\":\"v-4127de76#aof-持久化方式有哪些\",\"232\":\"v-4127de76#aof-为什么是在执行完命令之后记录日志\",\"233\":\"v-4127de76#aof-重写了解吗\",\"234\":\"v-4127de76#aof-校验机制了解吗\",\"235\":\"v-4127de76#redis-4-0-对于持久化机制做了什么优化\",\"236\":\"v-4127de76#如何选择-rdb-和-aof\",\"237\":\"v-4127de76#参考\",\"238\":\"v-4127de76@0\",\"239\":\"v-4127de76@1\",\"240\":\"v-6859e19c\",\"241\":\"v-6859e19c#redis-基础\",\"242\":\"v-6859e19c#什么是-redis\",\"243\":\"v-6859e19c#redis-为什么这么快\",\"244\":\"v-6859e19c#分布式缓存常见的技术选型方案有哪些\",\"245\":\"v-6859e19c#说一下-redis-和-memcached-的区别和共同点\",\"246\":\"v-6859e19c#为什么要用-redis-为什么要用缓存\",\"247\":\"v-6859e19c#常见的缓存读写策略有哪些\",\"248\":\"v-6859e19c#redis-应用\",\"249\":\"v-6859e19c#redis-除了做缓存-还能做什么\",\"250\":\"v-6859e19c#如何基于-redis-实现分布式锁\",\"251\":\"v-6859e19c#redis-可以做消息队列么\",\"252\":\"v-6859e19c#redis-数据类型\",\"253\":\"v-6859e19c#redis-常用的数据类型有哪些\",\"254\":\"v-6859e19c#string-的应用场景有哪些\",\"255\":\"v-6859e19c#string-还是-hash-存储对象数据更好呢\",\"256\":\"v-6859e19c#string-的底层实现是什么\",\"257\":\"v-6859e19c#购物车信息用-string-还是-hash-存储更好呢\",\"258\":\"v-6859e19c#使用-redis-实现一个排行榜怎么做\",\"259\":\"v-6859e19c#set-的应用场景是什么\",\"260\":\"v-6859e19c#使用-set-实现抽奖系统怎么做\",\"261\":\"v-6859e19c#使用-bitmap-统计活跃用户怎么做\",\"262\":\"v-6859e19c#使用-hyperloglog-统计页面-uv-怎么做\",\"263\":\"v-6859e19c#redis-持久化机制-重要\",\"264\":\"v-6859e19c#redis-线程模型-重要\",\"265\":\"v-6859e19c#redis-单线程模型了解吗\",\"266\":\"v-6859e19c#redis6-0-之前为什么不使用多线程\",\"267\":\"v-6859e19c#redis6-0-之后为何引入了多线程\",\"268\":\"v-6859e19c#redis-后台线程了解吗\",\"269\":\"v-6859e19c#redis-内存管理\",\"270\":\"v-6859e19c#redis-给缓存数据设置过期时间有啥用\",\"271\":\"v-6859e19c#redis-是如何判断数据是否过期的呢\",\"272\":\"v-6859e19c#过期的数据的删除策略了解么\",\"273\":\"v-6859e19c#redis-内存淘汰机制了解么\",\"274\":\"v-6859e19c#参考\",\"275\":\"v-6859e19c@0\",\"276\":\"v-6859e19c@1\",\"277\":\"v-6a0eba3b\",\"278\":\"v-6a0eba3b#redis-事务\",\"279\":\"v-6a0eba3b#什么是-redis-事务\",\"280\":\"v-6a0eba3b#如何使用-redis-事务\",\"281\":\"v-6a0eba3b#redis-事务支持原子性吗\",\"282\":\"v-6a0eba3b#redis-事务支持持久性吗\",\"283\":\"v-6a0eba3b#如何解决-redis-事务的缺陷\",\"284\":\"v-6a0eba3b#redis-性能优化-重要\",\"285\":\"v-6a0eba3b#使用批量操作减少网络传输\",\"286\":\"v-6a0eba3b#原生批量操作命令\",\"287\":\"v-6a0eba3b#pipeline\",\"288\":\"v-6a0eba3b#lua-脚本\",\"289\":\"v-6a0eba3b#大量-key-集中过期问题\",\"290\":\"v-6a0eba3b#redis-bigkey-大-key\",\"291\":\"v-6a0eba3b#什么是-bigkey\",\"292\":\"v-6a0eba3b#bigkey-是怎么产生的-有什么危害\",\"293\":\"v-6a0eba3b#如何发现-bigkey\",\"294\":\"v-6a0eba3b#如何处理-bigkey\",\"295\":\"v-6a0eba3b#redis-hotkey-热-key\",\"296\":\"v-6a0eba3b#什么是-hotkey\",\"297\":\"v-6a0eba3b#hotkey-有什么危害\",\"298\":\"v-6a0eba3b#如何发现-hotkey\",\"299\":\"v-6a0eba3b#如何解决-hotkey\",\"300\":\"v-6a0eba3b#慢查询命令\",\"301\":\"v-6a0eba3b#为什么会有慢查询命令\",\"302\":\"v-6a0eba3b#如何找到慢查询命令\",\"303\":\"v-6a0eba3b#redis-内存碎片\",\"304\":\"v-6a0eba3b#redis-生产问题-重要\",\"305\":\"v-6a0eba3b#缓存穿透\",\"306\":\"v-6a0eba3b#什么是缓存穿透\",\"307\":\"v-6a0eba3b#有哪些解决办法\",\"308\":\"v-6a0eba3b#缓存击穿\",\"309\":\"v-6a0eba3b#什么是缓存击穿\",\"310\":\"v-6a0eba3b#有哪些解决办法-1\",\"311\":\"v-6a0eba3b#缓存穿透和缓存击穿有什么区别\",\"312\":\"v-6a0eba3b#缓存雪崩\",\"313\":\"v-6a0eba3b#什么是缓存雪崩\",\"314\":\"v-6a0eba3b#有哪些解决办法-2\",\"315\":\"v-6a0eba3b#缓存雪崩和缓存击穿有什么区别\",\"316\":\"v-6a0eba3b#如何保证缓存和数据库数据的一致性\",\"317\":\"v-6a0eba3b#哪些情况可能会导致-redis-阻塞\",\"318\":\"v-6a0eba3b#redis-集群\",\"319\":\"v-6a0eba3b#redis-使用规范\",\"320\":\"v-6a0eba3b#参考\",\"321\":\"v-6a0eba3b@0\",\"322\":\"v-6a0eba3b@1\",\"323\":\"v-497a9ecb\",\"324\":\"v-497a9ecb#回顾一下字节码\",\"325\":\"v-497a9ecb#class-文件结构总结\",\"326\":\"v-497a9ecb#魔数-magic-number\",\"327\":\"v-497a9ecb#class-文件版本号-minor-major-version\",\"328\":\"v-497a9ecb#常量池-constant-pool\",\"329\":\"v-497a9ecb#访问标志-access-flags\",\"330\":\"v-497a9ecb#当前类-this-class-、父类-super-class-、接口-interfaces-索引集合\",\"331\":\"v-497a9ecb#字段表集合-fields\",\"332\":\"v-497a9ecb#方法表集合-methods\",\"333\":\"v-497a9ecb#属性表集合-attributes\",\"334\":\"v-497a9ecb#参考\",\"335\":\"v-497a9ecb@0\",\"336\":\"v-497a9ecb@1\",\"337\":\"v-2f65cc27\",\"338\":\"v-2f65cc27#类的生命周期\",\"339\":\"v-2f65cc27#类加载过程\",\"340\":\"v-2f65cc27#加载\",\"341\":\"v-2f65cc27#验证\",\"342\":\"v-2f65cc27#准备\",\"343\":\"v-2f65cc27#解析\",\"344\":\"v-2f65cc27#初始化\",\"345\":\"v-2f65cc27#类卸载\",\"346\":\"v-2f65cc27@0\",\"347\":\"v-2f65cc27@1\",\"348\":\"v-bbd4b1b6\",\"349\":\"v-bbd4b1b6#回顾一下类加载过程\",\"350\":\"v-bbd4b1b6#类加载器\",\"351\":\"v-bbd4b1b6#类加载器介绍\",\"352\":\"v-bbd4b1b6#类加载器加载规则\",\"353\":\"v-bbd4b1b6#类加载器总结\",\"354\":\"v-bbd4b1b6#自定义类加载器\",\"355\":\"v-bbd4b1b6#双亲委派模型\",\"356\":\"v-bbd4b1b6#双亲委派模型介绍\",\"357\":\"v-bbd4b1b6#双亲委派模型的执行流程\",\"358\":\"v-bbd4b1b6#双亲委派模型的好处\",\"359\":\"v-bbd4b1b6#打破双亲委派模型方法\",\"360\":\"v-bbd4b1b6#推荐阅读\",\"361\":\"v-bbd4b1b6@0\",\"362\":\"v-bbd4b1b6@1\",\"363\":\"v-582b3919\",\"364\":\"v-582b3919#jdk-命令行工具\",\"365\":\"v-582b3919#jps-查看所有-java-进程\",\"366\":\"v-582b3919#jstat-监视虚拟机各种运行状态信息\",\"367\":\"v-582b3919#jinfo-实时地查看和调整虚拟机各项参数\",\"368\":\"v-582b3919#jmap-生成堆转储快照\",\"369\":\"v-582b3919#jhat-分析-heapdump-文件\",\"370\":\"v-582b3919#jstack-生成虚拟机当前时刻的线程快照\",\"371\":\"v-582b3919#jdk-可视化分析工具\",\"372\":\"v-582b3919#jconsole-java-监视与管理控制台\",\"373\":\"v-582b3919#连接-jconsole\",\"374\":\"v-582b3919#查看-java-程序概况\",\"375\":\"v-582b3919#内存监控\",\"376\":\"v-582b3919#线程监控\",\"377\":\"v-582b3919#visual-vm-多合一故障处理工具\",\"378\":\"v-582b3919@0\",\"379\":\"v-582b3919@1\",\"380\":\"v-235112e0\",\"381\":\"v-235112e0#前言\",\"382\":\"v-235112e0#堆空间的基本结构\",\"383\":\"v-235112e0#内存分配和回收原则\",\"384\":\"v-235112e0#对象优先在-eden-区分配\",\"385\":\"v-235112e0#大对象直接进入老年代\",\"386\":\"v-235112e0#长期存活的对象将进入老年代\",\"387\":\"v-235112e0#主要进行-gc-的区域\",\"388\":\"v-235112e0#空间分配担保\",\"389\":\"v-235112e0#死亡对象判断方法\",\"390\":\"v-235112e0#引用计数法\",\"391\":\"v-235112e0#可达性分析算法\",\"392\":\"v-235112e0#引用类型总结\",\"393\":\"v-235112e0#如何判断一个常量是废弃常量\",\"394\":\"v-235112e0#如何判断一个类是无用的类\",\"395\":\"v-235112e0#垃圾收集算法\",\"396\":\"v-235112e0#标记-清除算法\",\"397\":\"v-235112e0#复制算法\",\"398\":\"v-235112e0#标记-整理算法\",\"399\":\"v-235112e0#分代收集算法\",\"400\":\"v-235112e0#垃圾收集器\",\"401\":\"v-235112e0#serial-收集器\",\"402\":\"v-235112e0#parnew-收集器\",\"403\":\"v-235112e0#parallel-scavenge-收集器\",\"404\":\"v-235112e0#serial-old-收集器\",\"405\":\"v-235112e0#parallel-old-收集器\",\"406\":\"v-235112e0#cms-收集器\",\"407\":\"v-235112e0#g1-收集器\",\"408\":\"v-235112e0#zgc-收集器\",\"409\":\"v-235112e0#参考\",\"410\":\"v-235112e0@0\",\"411\":\"v-235112e0@1\",\"412\":\"v-da1978c4\",\"413\":\"v-da1978c4@0\",\"414\":\"v-da1978c4@1\",\"415\":\"v-7ba8e750\",\"416\":\"v-7ba8e750#前言\",\"417\":\"v-7ba8e750#一、jvm-的基本介绍\",\"418\":\"v-7ba8e750#_1-1-java-文件是如何被运行的\",\"419\":\"v-7ba8e750#_1-类加载器\",\"420\":\"v-7ba8e750#_2-方法区\",\"421\":\"v-7ba8e750#_3-堆\",\"422\":\"v-7ba8e750#_4-栈\",\"423\":\"v-7ba8e750#_5-程序计数器\",\"424\":\"v-7ba8e750#小总结\",\"425\":\"v-7ba8e750#_1-2-简单的代码例子\",\"426\":\"v-7ba8e750#二、类加载器的介绍\",\"427\":\"v-7ba8e750#_2-1-类加载器的流程\",\"428\":\"v-7ba8e750#_2-1-1-加载\",\"429\":\"v-7ba8e750#_2-1-2-链接\",\"430\":\"v-7ba8e750#_2-1-3-初始化\",\"431\":\"v-7ba8e750#_2-1-4-卸载\",\"432\":\"v-7ba8e750#_2-2-类加载器的加载顺序\",\"433\":\"v-7ba8e750#_2-3-双亲委派机制\",\"434\":\"v-7ba8e750#三、运行时数据区\",\"435\":\"v-7ba8e750#_3-1-本地方法栈和程序计数器\",\"436\":\"v-7ba8e750#_3-2-方法区\",\"437\":\"v-7ba8e750#_3-3-虚拟机栈和虚拟机堆\",\"438\":\"v-7ba8e750#_3-3-1-虚拟机栈的概念\",\"439\":\"v-7ba8e750#_3-3-2-虚拟机栈存在的异常\",\"440\":\"v-7ba8e750#_3-3-3-虚拟机栈的生命周期\",\"441\":\"v-7ba8e750#_3-3-4-虚拟机栈的执行\",\"442\":\"v-7ba8e750#_3-3-5-局部变量的复用\",\"443\":\"v-7ba8e750#_3-3-6-虚拟机堆的概念\",\"444\":\"v-7ba8e750#_3-3-7-eden-年轻代的介绍\",\"445\":\"v-7ba8e750#_3-3-8-如何判断一个对象需要被干掉\",\"446\":\"v-7ba8e750#_3-3-9-如何宣告一个对象的真正死亡\",\"447\":\"v-7ba8e750#_3-4-垃圾回收算法\",\"448\":\"v-7ba8e750#_3-5-了解-各种各样的垃圾回收器\",\"449\":\"v-7ba8e750#_3-6-了解-jvm-的常用参数\",\"450\":\"v-7ba8e750#四、关于-jvm-调优的一些方面\",\"451\":\"v-7ba8e750#_4-1-调整最大堆内存和最小堆内存\",\"452\":\"v-7ba8e750#_4-2-调整新生代和老年代的比值\",\"453\":\"v-7ba8e750#_4-3-调整-survivor-区和-eden-区的比值\",\"454\":\"v-7ba8e750#_4-4-设置年轻代和老年代的大小\",\"455\":\"v-7ba8e750#_4-5-小总结\",\"456\":\"v-7ba8e750#_4-6-永久区的设置\",\"457\":\"v-7ba8e750#_4-7-jvm-的栈参数调优\",\"458\":\"v-7ba8e750#_4-7-1-调整每个线程栈空间的大小\",\"459\":\"v-7ba8e750#_4-7-2-设置线程栈的大小\",\"460\":\"v-7ba8e750#_4-8-可以直接跳过了-jvm-其他参数介绍\",\"461\":\"v-7ba8e750#_4-8-1-设置内存页的大小\",\"462\":\"v-7ba8e750#_4-8-2-设置原始类型的快速优化\",\"463\":\"v-7ba8e750#_4-8-3-设置关闭手动-gc\",\"464\":\"v-7ba8e750#_4-8-4-设置垃圾最大年龄\",\"465\":\"v-7ba8e750#_4-8-5-加快编译速度\",\"466\":\"v-7ba8e750#_4-8-6-改善锁机制性能\",\"467\":\"v-7ba8e750#_4-8-7-禁用垃圾回收\",\"468\":\"v-7ba8e750#_4-8-8-设置堆空间存活时间\",\"469\":\"v-7ba8e750#_4-8-9-设置对象直接分配在老年代\",\"470\":\"v-7ba8e750#_4-8-10-设置-tlab-占-eden-区的比例\",\"471\":\"v-7ba8e750#_4-8-11-设置是否优先-ygc\",\"472\":\"v-7ba8e750#finally\",\"473\":\"v-7ba8e750@0\",\"474\":\"v-7ba8e750@1\",\"475\":\"v-25aac726\",\"476\":\"v-25aac726#_1-概述\",\"477\":\"v-25aac726#_2-堆内存相关\",\"478\":\"v-25aac726#_2-1-显式指定堆内存–xms和-xmx\",\"479\":\"v-25aac726#_2-2-显式新生代内存-young-generation\",\"480\":\"v-25aac726#_2-3-显式指定永久代-元空间的大小\",\"481\":\"v-25aac726#_3-垃圾收集相关\",\"482\":\"v-25aac726#_3-1-垃圾回收器\",\"483\":\"v-25aac726#_3-2-gc-日志记录\",\"484\":\"v-25aac726#_4-处理-oom\",\"485\":\"v-25aac726#_5-其他\",\"486\":\"v-25aac726#文章推荐\",\"487\":\"v-25aac726@0\",\"488\":\"v-25aac726@1\",\"489\":\"v-1127ccd2\",\"490\":\"v-1127ccd2#前言\",\"491\":\"v-1127ccd2#运行时数据区域\",\"492\":\"v-1127ccd2#程序计数器\",\"493\":\"v-1127ccd2#java-虚拟机栈\",\"494\":\"v-1127ccd2#本地方法栈\",\"495\":\"v-1127ccd2#堆\",\"496\":\"v-1127ccd2#方法区\",\"497\":\"v-1127ccd2#运行时常量池\",\"498\":\"v-1127ccd2#字符串常量池\",\"499\":\"v-1127ccd2#直接内存\",\"500\":\"v-1127ccd2#hotspot-虚拟机对象探秘\",\"501\":\"v-1127ccd2#对象的创建\",\"502\":\"v-1127ccd2#step1-类加载检查\",\"503\":\"v-1127ccd2#step2-分配内存\",\"504\":\"v-1127ccd2#step3-初始化零值\",\"505\":\"v-1127ccd2#step4-设置对象头\",\"506\":\"v-1127ccd2#step5-执行-init-方法\",\"507\":\"v-1127ccd2#对象的内存布局\",\"508\":\"v-1127ccd2#对象的访问定位\",\"509\":\"v-1127ccd2#句柄\",\"510\":\"v-1127ccd2#直接指针\",\"511\":\"v-1127ccd2#参考\",\"512\":\"v-1127ccd2@0\",\"513\":\"v-1127ccd2@1\",\"514\":\"v-ac78ed9a\",\"515\":\"v-ac78ed9a#java特点\",\"516\":\"v-ac78ed9a#jdk-和-jre\",\"517\":\"v-ac78ed9a#java-和-c-区别\",\"518\":\"v-ac78ed9a#面向对象\",\"519\":\"v-ac78ed9a#多态实现原理\",\"520\":\"v-ac78ed9a#抽象类和接口\",\"521\":\"v-ac78ed9a#static和final关键字\",\"522\":\"v-ac78ed9a#泛型以及泛型擦除\",\"523\":\"v-ac78ed9a#反射原理以及使用场景\",\"524\":\"v-ac78ed9a#java异常体系\",\"525\":\"v-ac78ed9a@0\",\"526\":\"v-ac78ed9a@1\",\"527\":\"v-8649ae3c\",\"528\":\"v-8649ae3c#阻塞队列简介\",\"529\":\"v-8649ae3c#阻塞队列的历史\",\"530\":\"v-8649ae3c#阻塞队列的思想\",\"531\":\"v-8649ae3c#arrayblockingqueue-常见方法及测试\",\"532\":\"v-8649ae3c#arrayblockingqueue-源码分析\",\"533\":\"v-8649ae3c#整体设计\",\"534\":\"v-8649ae3c#初始化\",\"535\":\"v-8649ae3c#阻塞式获取和新增元素\",\"536\":\"v-8649ae3c#非阻塞式获取和新增元素\",\"537\":\"v-8649ae3c#指定超时时间内阻塞式获取和新增元素\",\"538\":\"v-8649ae3c#判断元素是否存在\",\"539\":\"v-8649ae3c#arrayblockingqueue-获取和新增元素的方法对比\",\"540\":\"v-8649ae3c#arrayblockingqueue-相关面试题\",\"541\":\"v-8649ae3c#arrayblockingqueue-是什么-它的特点是什么\",\"542\":\"v-8649ae3c#arrayblockingqueue-和-linkedblockingqueue-有什么区别\",\"543\":\"v-8649ae3c#arrayblockingqueue-和-concurrentlinkedqueue-有什么区别\",\"544\":\"v-8649ae3c#arrayblockingqueue-的实现原理是什么\",\"545\":\"v-8649ae3c#参考文献\",\"546\":\"v-8649ae3c@0\",\"547\":\"v-8649ae3c@1\",\"548\":\"v-818fe41c\",\"549\":\"v-818fe41c#arraylist-简介\",\"550\":\"v-818fe41c#arraylist-和-vector-的区别-了解即可\",\"551\":\"v-818fe41c#arraylist-可以添加-null-值吗\",\"552\":\"v-818fe41c#arraylist-与-linkedlist-区别\",\"553\":\"v-818fe41c#arraylist-核心源码解读\",\"554\":\"v-818fe41c#arraylist-扩容机制分析\",\"555\":\"v-818fe41c#先从-arraylist-的构造函数说起\",\"556\":\"v-818fe41c#一步一步分析-arraylist-扩容机制\",\"557\":\"v-818fe41c#add-方法\",\"558\":\"v-818fe41c#grow-方法\",\"559\":\"v-818fe41c#hugecapacity-方法\",\"560\":\"v-818fe41c#system-arraycopy-和-arrays-copyof-方法\",\"561\":\"v-818fe41c#system-arraycopy-方法\",\"562\":\"v-818fe41c#arrays-copyof-方法\",\"563\":\"v-818fe41c#两者联系和区别\",\"564\":\"v-818fe41c#ensurecapacity方法\",\"565\":\"v-818fe41c@0\",\"566\":\"v-818fe41c@1\",\"567\":\"v-8fe68c14\",\"568\":\"v-8fe68c14#_1-concurrenthashmap-1-7\",\"569\":\"v-8fe68c14#_1-存储结构\",\"570\":\"v-8fe68c14#_2-初始化\",\"571\":\"v-8fe68c14#_3-put\",\"572\":\"v-8fe68c14#_4-扩容-rehash\",\"573\":\"v-8fe68c14#_5-get\",\"574\":\"v-8fe68c14#_2-concurrenthashmap-1-8\",\"575\":\"v-8fe68c14#_1-存储结构-1\",\"576\":\"v-8fe68c14#_2-初始化-inittable\",\"577\":\"v-8fe68c14#_3-put-1\",\"578\":\"v-8fe68c14#_4-get\",\"579\":\"v-8fe68c14#_3-总结\",\"580\":\"v-8fe68c14@0\",\"581\":\"v-8fe68c14@1\",\"582\":\"v-5508938e\",\"583\":\"v-5508938e#copyonwritearraylist-简介\",\"584\":\"v-5508938e#copyonwritearraylist-到底有什么厉害之处\",\"585\":\"v-5508938e#copy-on-write-的思想是什么\",\"586\":\"v-5508938e#copyonwritearraylist-源码分析\",\"587\":\"v-5508938e#初始化\",\"588\":\"v-5508938e#插入元素\",\"589\":\"v-5508938e#读取元素\",\"590\":\"v-5508938e#获取列表中元素的个数\",\"591\":\"v-5508938e#删除元素\",\"592\":\"v-5508938e#判断元素是否存在\",\"593\":\"v-5508938e#copyonwritearraylist-常用方法测试\",\"594\":\"v-5508938e@0\",\"595\":\"v-5508938e@1\",\"596\":\"v-c53315d2\",\"597\":\"v-c53315d2#delayqueue-简介\",\"598\":\"v-c53315d2#delayqueue-发展史\",\"599\":\"v-c53315d2#delayqueue-常见使用场景示例\",\"600\":\"v-c53315d2#delayqueue-源码解析\",\"601\":\"v-c53315d2#核心成员变量\",\"602\":\"v-c53315d2#构造方法\",\"603\":\"v-c53315d2#添加元素\",\"604\":\"v-c53315d2#获取元素\",\"605\":\"v-c53315d2#查看元素\",\"606\":\"v-c53315d2#delayqueue-常见面试题\",\"607\":\"v-c53315d2#delayqueue-的实现原理是什么\",\"608\":\"v-c53315d2#delayqueue-的实现是否线程安全\",\"609\":\"v-c53315d2#delayqueue-的使用场景有哪些\",\"610\":\"v-c53315d2#delayqueue-中-delayed-接口的作用是什么\",\"611\":\"v-c53315d2#delayqueue-和-timer-timertask-的区别是什么\",\"612\":\"v-c53315d2#参考文献\",\"613\":\"v-c53315d2@0\",\"614\":\"v-c53315d2@1\",\"615\":\"v-5010378a\",\"616\":\"v-5010378a#hashmap-简介\",\"617\":\"v-5010378a#底层数据结构分析\",\"618\":\"v-5010378a#jdk1-8-之前\",\"619\":\"v-5010378a#jdk1-8-之后\",\"620\":\"v-5010378a#hashmap-源码分析\",\"621\":\"v-5010378a#构造方法\",\"622\":\"v-5010378a#put-方法\",\"623\":\"v-5010378a#get-方法\",\"624\":\"v-5010378a#resize-方法\",\"625\":\"v-5010378a#hashmap-常用方法测试\",\"626\":\"v-5010378a@0\",\"627\":\"v-5010378a@1\",\"628\":\"v-bf556644\",\"629\":\"v-bf556644#集合判空\",\"630\":\"v-bf556644#集合转-map\",\"631\":\"v-bf556644#集合遍历\",\"632\":\"v-bf556644#集合去重\",\"633\":\"v-bf556644#集合转数组\",\"634\":\"v-bf556644#数组转集合\",\"635\":\"v-bf556644@0\",\"636\":\"v-bf556644@1\",\"637\":\"v-39ab84dc\",\"638\":\"v-39ab84dc#集合概述\",\"639\":\"v-39ab84dc#java-集合概览\",\"640\":\"v-39ab84dc#说说-list-set-queue-map-四者的区别\",\"641\":\"v-39ab84dc#集合框架底层数据结构总结\",\"642\":\"v-39ab84dc#list\",\"643\":\"v-39ab84dc#set\",\"644\":\"v-39ab84dc#queue\",\"645\":\"v-39ab84dc#map\",\"646\":\"v-39ab84dc#如何选用集合\",\"647\":\"v-39ab84dc#为什么要使用集合\",\"648\":\"v-39ab84dc#list-1\",\"649\":\"v-39ab84dc#arraylist-和-array-数组-的区别\",\"650\":\"v-39ab84dc#arraylist-和-vector-的区别-了解即可\",\"651\":\"v-39ab84dc#vector-和-stack-的区别-了解即可\",\"652\":\"v-39ab84dc#arraylist-可以添加-null-值吗\",\"653\":\"v-39ab84dc#arraylist-插入和删除元素的时间复杂度\",\"654\":\"v-39ab84dc#linkedlist-插入和删除元素的时间复杂度\",\"655\":\"v-39ab84dc#linkedlist-为什么不能实现-randomaccess-接口\",\"656\":\"v-39ab84dc#arraylist-与-linkedlist-区别\",\"657\":\"v-39ab84dc#补充内容-双向链表和双向循环链表\",\"658\":\"v-39ab84dc#补充内容-randomaccess-接口\",\"659\":\"v-39ab84dc#说一说-arraylist-的扩容机制吧\",\"660\":\"v-39ab84dc#set-1\",\"661\":\"v-39ab84dc#comparable-和-comparator-的区别\",\"662\":\"v-39ab84dc#comparator-定制排序\",\"663\":\"v-39ab84dc#重写-compareto-方法实现按年龄来排序\",\"664\":\"v-39ab84dc#无序性和不可重复性的含义是什么\",\"665\":\"v-39ab84dc#比较-hashset、linkedhashset-和-treeset-三者的异同\",\"666\":\"v-39ab84dc#queue-1\",\"667\":\"v-39ab84dc#queue-与-deque-的区别\",\"668\":\"v-39ab84dc#arraydeque-与-linkedlist-的区别\",\"669\":\"v-39ab84dc#说一说-priorityqueue\",\"670\":\"v-39ab84dc#什么是-blockingqueue\",\"671\":\"v-39ab84dc#blockingqueue-的实现类有哪些\",\"672\":\"v-39ab84dc#arrayblockingqueue-和-linkedblockingqueue-有什么区别\",\"673\":\"v-39ab84dc@0\",\"674\":\"v-39ab84dc@1\",\"675\":\"v-3641d39e\",\"676\":\"v-3641d39e#map-重要\",\"677\":\"v-3641d39e#hashmap-和-hashtable-的区别\",\"678\":\"v-3641d39e#hashmap-和-hashset-区别\",\"679\":\"v-3641d39e#hashmap-和-treemap-区别\",\"680\":\"v-3641d39e#hashset-如何检查重复\",\"681\":\"v-3641d39e#hashmap-的底层实现\",\"682\":\"v-3641d39e#jdk1-8-之前\",\"683\":\"v-3641d39e#jdk1-8-之后\",\"684\":\"v-3641d39e#hashmap-的长度为什么是-2-的幂次方\",\"685\":\"v-3641d39e#hashmap-多线程操作导致死循环问题\",\"686\":\"v-3641d39e#hashmap-为什么线程不安全\",\"687\":\"v-3641d39e#hashmap-常见的遍历方式\",\"688\":\"v-3641d39e#concurrenthashmap-和-hashtable-的区别\",\"689\":\"v-3641d39e#concurrenthashmap-线程安全的具体实现方式-底层具体实现\",\"690\":\"v-3641d39e#jdk1-8-之前-1\",\"691\":\"v-3641d39e#jdk1-8-之后-1\",\"692\":\"v-3641d39e#jdk-1-7-和-jdk-1-8-的-concurrenthashmap-实现有什么不同\",\"693\":\"v-3641d39e#concurrenthashmap-为什么-key-和-value-不能为-null\",\"694\":\"v-3641d39e#concurrenthashmap-能保证复合操作的原子性吗\",\"695\":\"v-3641d39e#collections-工具类-不重要\",\"696\":\"v-3641d39e#排序操作\",\"697\":\"v-3641d39e#查找-替换操作\",\"698\":\"v-3641d39e#同步控制\",\"699\":\"v-3641d39e@0\",\"700\":\"v-3641d39e@1\",\"701\":\"v-2ee3f458\",\"702\":\"v-2ee3f458#linkedhashmap-简介\",\"703\":\"v-2ee3f458#linkedhashmap-使用示例\",\"704\":\"v-2ee3f458#插入顺序遍历\",\"705\":\"v-2ee3f458#访问顺序遍历\",\"706\":\"v-2ee3f458#lru-缓存\",\"707\":\"v-2ee3f458#linkedhashmap-源码解析\",\"708\":\"v-2ee3f458#node-的设计\",\"709\":\"v-2ee3f458#构造方法\",\"710\":\"v-2ee3f458#get-方法\",\"711\":\"v-2ee3f458#remove-方法后置操作——afternoderemoval\",\"712\":\"v-2ee3f458#put-方法后置操作——afternodeinsertion\",\"713\":\"v-2ee3f458#linkedhashmap-和-hashmap-遍历性能比较\",\"714\":\"v-2ee3f458#linkedhashmap-常见面试题\",\"715\":\"v-2ee3f458#什么是-linkedhashmap\",\"716\":\"v-2ee3f458#linkedhashmap-如何按照插入顺序迭代元素\",\"717\":\"v-2ee3f458#linkedhashmap-如何按照访问顺序迭代元素\",\"718\":\"v-2ee3f458#linkedhashmap-如何实现-lru-缓存\",\"719\":\"v-2ee3f458#linkedhashmap-和-hashmap-有什么区别\",\"720\":\"v-2ee3f458#参考文献\",\"721\":\"v-2ee3f458@0\",\"722\":\"v-2ee3f458@1\",\"723\":\"v-750f9124\",\"724\":\"v-750f9124#linkedlist-简介\",\"725\":\"v-750f9124#linkedlist-插入和删除元素的时间复杂度\",\"726\":\"v-750f9124#linkedlist-为什么不能实现-randomaccess-接口\",\"727\":\"v-750f9124#linkedlist-源码分析\",\"728\":\"v-750f9124#初始化\",\"729\":\"v-750f9124#插入元素\",\"730\":\"v-750f9124#获取元素\",\"731\":\"v-750f9124#删除元素\",\"732\":\"v-750f9124#遍历链表\",\"733\":\"v-750f9124#linkedlist-常用方法测试\",\"734\":\"v-750f9124@0\",\"735\":\"v-750f9124@1\",\"736\":\"v-0ab03f88\",\"737\":\"v-0ab03f88@0\",\"738\":\"v-0ab03f88@1\",\"739\":\"v-76fec490\",\"740\":\"v-76fec490#aqs-介绍\",\"741\":\"v-76fec490#aqs-原理\",\"742\":\"v-76fec490#aqs-核心思想\",\"743\":\"v-76fec490#aqs-资源共享方式\",\"744\":\"v-76fec490#自定义同步器\",\"745\":\"v-76fec490#常见同步工具类\",\"746\":\"v-76fec490#semaphore-信号量\",\"747\":\"v-76fec490#介绍\",\"748\":\"v-76fec490#原理\",\"749\":\"v-76fec490#实战\",\"750\":\"v-76fec490#countdownlatch-倒计时器\",\"751\":\"v-76fec490#介绍-1\",\"752\":\"v-76fec490#原理-1\",\"753\":\"v-76fec490#实战-1\",\"754\":\"v-76fec490#cyclicbarrier-循环栅栏\",\"755\":\"v-76fec490#介绍-2\",\"756\":\"v-76fec490#原理-2\",\"757\":\"v-76fec490#实战-2\",\"758\":\"v-76fec490#参考\",\"759\":\"v-76fec490@0\",\"760\":\"v-76fec490@1\",\"761\":\"v-32aeba53\",\"762\":\"v-32aeba53#atomic-原子类介绍\",\"763\":\"v-32aeba53#基本类型原子类\",\"764\":\"v-32aeba53#基本数据类型原子类的优势\",\"765\":\"v-32aeba53#atomicinteger-线程安全原理简单分析\",\"766\":\"v-32aeba53#数组类型原子类\",\"767\":\"v-32aeba53#引用类型原子类\",\"768\":\"v-32aeba53#对象的属性修改类型原子类\",\"769\":\"v-32aeba53#参考\",\"770\":\"v-32aeba53@0\",\"771\":\"v-32aeba53@1\",\"772\":\"v-71f16d33\",\"773\":\"v-71f16d33#future-介绍\",\"774\":\"v-71f16d33#completablefuture-介绍\",\"775\":\"v-71f16d33#completablefuture-常见操作\",\"776\":\"v-71f16d33#创建-completablefuture\",\"777\":\"v-71f16d33#new-关键字\",\"778\":\"v-71f16d33#静态工厂方法\",\"779\":\"v-71f16d33#处理异步结算的结果\",\"780\":\"v-71f16d33#异常处理\",\"781\":\"v-71f16d33#组合-completablefuture\",\"782\":\"v-71f16d33#并行运行多个-completablefuture\",\"783\":\"v-71f16d33#completablefuture-使用建议\",\"784\":\"v-71f16d33#使用自定义线程池\",\"785\":\"v-71f16d33#尽量避免使用-get\",\"786\":\"v-71f16d33#正确进行异常处理\",\"787\":\"v-71f16d33#合理组合多个异步任务\",\"788\":\"v-71f16d33#后记\",\"789\":\"v-71f16d33@0\",\"790\":\"v-71f16d33@1\",\"791\":\"v-04cbc3d1\",\"792\":\"v-04cbc3d1#concurrenthashmap\",\"793\":\"v-04cbc3d1#copyonwritearraylist\",\"794\":\"v-04cbc3d1#concurrentlinkedqueue\",\"795\":\"v-04cbc3d1#blockingqueue\",\"796\":\"v-04cbc3d1#blockingqueue-简介\",\"797\":\"v-04cbc3d1#arrayblockingqueue\",\"798\":\"v-04cbc3d1#linkedblockingqueue\",\"799\":\"v-04cbc3d1#priorityblockingqueue\",\"800\":\"v-04cbc3d1#concurrentskiplistmap\",\"801\":\"v-04cbc3d1#参考\",\"802\":\"v-04cbc3d1@0\",\"803\":\"v-04cbc3d1@1\",\"804\":\"v-1ecd552b\",\"805\":\"v-1ecd552b#什么是线程和进程\",\"806\":\"v-1ecd552b#何为进程\",\"807\":\"v-1ecd552b#何为线程\",\"808\":\"v-1ecd552b#java-线程和操作系统的线程有啥区别\",\"809\":\"v-1ecd552b#请简要描述线程与进程的关系-区别及优缺点\",\"810\":\"v-1ecd552b#图解进程和线程的关系\",\"811\":\"v-1ecd552b#程序计数器为什么是私有的\",\"812\":\"v-1ecd552b#虚拟机栈和本地方法栈为什么是私有的\",\"813\":\"v-1ecd552b#一句话简单了解堆和方法区\",\"814\":\"v-1ecd552b#并发与并行的区别\",\"815\":\"v-1ecd552b#同步和异步的区别\",\"816\":\"v-1ecd552b#为什么要使用多线程\",\"817\":\"v-1ecd552b#使用多线程可能带来什么问题\",\"818\":\"v-1ecd552b#如何理解线程安全和不安全\",\"819\":\"v-1ecd552b#单核-cpu-上运行多个线程效率一定会高吗\",\"820\":\"v-1ecd552b#说说线程的生命周期和状态\",\"821\":\"v-1ecd552b#什么是线程上下文切换\",\"822\":\"v-1ecd552b#什么是线程死锁-如何避免死锁\",\"823\":\"v-1ecd552b#认识线程死锁\",\"824\":\"v-1ecd552b#如何预防和避免线程死锁\",\"825\":\"v-1ecd552b#sleep-方法和-wait-方法对比\",\"826\":\"v-1ecd552b#为什么-wait-方法不定义在-thread-中\",\"827\":\"v-1ecd552b#可以直接调用-thread-类的-run-方法吗\",\"828\":\"v-1ecd552b@0\",\"829\":\"v-1ecd552b@1\",\"830\":\"v-20822dca\",\"831\":\"v-20822dca#jmm-java-内存模型\",\"832\":\"v-20822dca#volatile-关键字\",\"833\":\"v-20822dca#如何保证变量的可见性\",\"834\":\"v-20822dca#如何禁止指令重排序\",\"835\":\"v-20822dca#volatile-可以保证原子性么\",\"836\":\"v-20822dca#乐观锁和悲观锁\",\"837\":\"v-20822dca#什么是悲观锁\",\"838\":\"v-20822dca#什么是乐观锁\",\"839\":\"v-20822dca#如何实现乐观锁\",\"840\":\"v-20822dca#版本号机制\",\"841\":\"v-20822dca#cas-算法\",\"842\":\"v-20822dca#乐观锁存在哪些问题\",\"843\":\"v-20822dca#aba-问题\",\"844\":\"v-20822dca#循环时间长开销大\",\"845\":\"v-20822dca#只能保证一个共享变量的原子操作\",\"846\":\"v-20822dca#synchronized-关键字\",\"847\":\"v-20822dca#synchronized-是什么-有什么用\",\"848\":\"v-20822dca#如何使用-synchronized\",\"849\":\"v-20822dca#构造方法可以用-synchronized-修饰么\",\"850\":\"v-20822dca#synchronized-底层原理了解吗\",\"851\":\"v-20822dca#synchronized-同步语句块的情况\",\"852\":\"v-20822dca#synchronized-修饰方法的的情况\",\"853\":\"v-20822dca#总结\",\"854\":\"v-20822dca#jdk1-6-之后的-synchronized-底层做了哪些优化\",\"855\":\"v-20822dca#synchronized-和-volatile-有什么区别\",\"856\":\"v-20822dca#reentrantlock\",\"857\":\"v-20822dca#reentrantlock-是什么\",\"858\":\"v-20822dca#公平锁和非公平锁有什么区别\",\"859\":\"v-20822dca#synchronized-和-reentrantlock-有什么区别\",\"860\":\"v-20822dca#两者都是可重入锁\",\"861\":\"v-20822dca#synchronized-依赖于-jvm-而-reentrantlock-依赖于-api\",\"862\":\"v-20822dca#reentrantlock-比-synchronized-增加了一些高级功能\",\"863\":\"v-20822dca#可中断锁和不可中断锁有什么区别\",\"864\":\"v-20822dca#reentrantreadwritelock\",\"865\":\"v-20822dca#reentrantreadwritelock-是什么\",\"866\":\"v-20822dca#reentrantreadwritelock-适合什么场景\",\"867\":\"v-20822dca#共享锁和独占锁有什么区别\",\"868\":\"v-20822dca#线程持有读锁还能获取写锁吗\",\"869\":\"v-20822dca#读锁为什么不能升级为写锁\",\"870\":\"v-20822dca#stampedlock\",\"871\":\"v-20822dca#stampedlock-是什么\",\"872\":\"v-20822dca#stampedlock-的性能为什么更好\",\"873\":\"v-20822dca#stampedlock-适合什么场景\",\"874\":\"v-20822dca#stampedlock-的底层原理了解吗\",\"875\":\"v-20822dca#atomic-原子类\",\"876\":\"v-20822dca#参考\",\"877\":\"v-20822dca@0\",\"878\":\"v-20822dca@1\",\"879\":\"v-22370669\",\"880\":\"v-22370669#threadlocal\",\"881\":\"v-22370669#threadlocal-有什么用\",\"882\":\"v-22370669#如何使用-threadlocal\",\"883\":\"v-22370669#threadlocal-原理了解吗\",\"884\":\"v-22370669#threadlocal-内存泄露问题是怎么导致的\",\"885\":\"v-22370669#线程池\",\"886\":\"v-22370669#什么是线程池\",\"887\":\"v-22370669#为什么要用线程池\",\"888\":\"v-22370669#如何创建线程池\",\"889\":\"v-22370669#为什么不推荐使用内置线程池\",\"890\":\"v-22370669#线程池常见参数有哪些-如何解释\",\"891\":\"v-22370669#线程池的饱和策略有哪些\",\"892\":\"v-22370669#线程池常用的阻塞队列有哪些\",\"893\":\"v-22370669#线程池处理任务的流程了解吗\",\"894\":\"v-22370669#如何给线程池命名\",\"895\":\"v-22370669#如何设定线程池的大小\",\"896\":\"v-22370669#如何动态修改线程池的参数\",\"897\":\"v-22370669#如何设计一个能够根据任务的优先级来执行的线程池\",\"898\":\"v-22370669#future\",\"899\":\"v-22370669#future-类有什么用\",\"900\":\"v-22370669#callable-和-future-有什么关系\",\"901\":\"v-22370669#completablefuture-类有什么用\",\"902\":\"v-22370669#aqs\",\"903\":\"v-22370669#aqs-是什么\",\"904\":\"v-22370669#aqs-的原理是什么\",\"905\":\"v-22370669#semaphore-有什么用\",\"906\":\"v-22370669#semaphore-的原理是什么\",\"907\":\"v-22370669#countdownlatch-有什么用\",\"908\":\"v-22370669#countdownlatch-的原理是什么\",\"909\":\"v-22370669#用过-countdownlatch-么-什么场景下用的\",\"910\":\"v-22370669#cyclicbarrier-有什么用\",\"911\":\"v-22370669#cyclicbarrier-的原理是什么\",\"912\":\"v-22370669#虚拟线程\",\"913\":\"v-22370669#参考\",\"914\":\"v-22370669@0\",\"915\":\"v-22370669@1\",\"916\":\"v-df6b5bda\",\"917\":\"v-df6b5bda#_1、正确声明线程池\",\"918\":\"v-df6b5bda#_2、监测线程池运行状态\",\"919\":\"v-df6b5bda#_3、建议不同类别的业务用不同的线程池\",\"920\":\"v-df6b5bda#_4、别忘记给线程池命名\",\"921\":\"v-df6b5bda#_5、正确配置线程池参数\",\"922\":\"v-df6b5bda#常规操作\",\"923\":\"v-df6b5bda#美团的骚操作\",\"924\":\"v-df6b5bda#_6、别忘记关闭线程池\",\"925\":\"v-df6b5bda#_7、线程池尽量不要放耗时任务\",\"926\":\"v-df6b5bda#_8、线程池使用的一些小坑\",\"927\":\"v-df6b5bda#重复创建线程池的坑\",\"928\":\"v-df6b5bda#spring-内部线程池的坑\",\"929\":\"v-df6b5bda#线程池和-threadlocal-共用的坑\",\"930\":\"v-df6b5bda@0\",\"931\":\"v-df6b5bda@1\",\"932\":\"v-95eca96c\",\"933\":\"v-95eca96c#线程池介绍\",\"934\":\"v-95eca96c#executor-框架介绍\",\"935\":\"v-95eca96c#threadpoolexecutor-类介绍-重要\",\"936\":\"v-95eca96c#构造方法介绍\",\"937\":\"v-95eca96c#线程池创建两种方式\",\"938\":\"v-95eca96c#线程池常用的阻塞队列总结\",\"939\":\"v-95eca96c#线程池原理分析-重要\",\"940\":\"v-95eca96c#threadpoolexecutor-示例代码\",\"941\":\"v-95eca96c#线程池原理分析\",\"942\":\"v-95eca96c#几个常见的对比\",\"943\":\"v-95eca96c#runnable-vs-callable\",\"944\":\"v-95eca96c#execute-vs-submit\",\"945\":\"v-95eca96c#shutdown-vsshutdownnow\",\"946\":\"v-95eca96c#isterminated-vs-isshutdown\",\"947\":\"v-95eca96c#几种常见的内置线程池\",\"948\":\"v-95eca96c#fixedthreadpool\",\"949\":\"v-95eca96c#介绍\",\"950\":\"v-95eca96c#执行任务过程介绍\",\"951\":\"v-95eca96c#为什么不推荐使用fixedthreadpool\",\"952\":\"v-95eca96c#singlethreadexecutor\",\"953\":\"v-95eca96c#介绍-1\",\"954\":\"v-95eca96c#执行任务过程介绍-1\",\"955\":\"v-95eca96c#为什么不推荐使用singlethreadexecutor\",\"956\":\"v-95eca96c#cachedthreadpool\",\"957\":\"v-95eca96c#介绍-2\",\"958\":\"v-95eca96c#执行任务过程介绍-2\",\"959\":\"v-95eca96c#为什么不推荐使用cachedthreadpool\",\"960\":\"v-95eca96c#scheduledthreadpool\",\"961\":\"v-95eca96c#介绍-3\",\"962\":\"v-95eca96c#scheduledthreadpoolexecutor-和-timer-对比\",\"963\":\"v-95eca96c#线程池最佳实践\",\"964\":\"v-95eca96c#参考\",\"965\":\"v-95eca96c@0\",\"966\":\"v-95eca96c@1\",\"967\":\"v-e4d59e5e\",\"968\":\"v-e4d59e5e#从-cpu-缓存模型说起\",\"969\":\"v-e4d59e5e#指令重排序\",\"970\":\"v-e4d59e5e#jmm-java-memory-model\",\"971\":\"v-e4d59e5e#什么是-jmm-为什么需要-jmm\",\"972\":\"v-e4d59e5e#jmm-是如何抽象线程和主内存之间的关系\",\"973\":\"v-e4d59e5e#java-内存区域和-jmm-有何区别\",\"974\":\"v-e4d59e5e#happens-before-原则是什么\",\"975\":\"v-e4d59e5e#happens-before-常见规则有哪些-谈谈你的理解\",\"976\":\"v-e4d59e5e#happens-before-和-jmm-什么关系\",\"977\":\"v-e4d59e5e#再看并发编程三个重要特性\",\"978\":\"v-e4d59e5e#原子性\",\"979\":\"v-e4d59e5e#可见性\",\"980\":\"v-e4d59e5e#有序性\",\"981\":\"v-e4d59e5e#总结\",\"982\":\"v-e4d59e5e#参考\",\"983\":\"v-e4d59e5e@0\",\"984\":\"v-e4d59e5e@1\",\"985\":\"v-c822305c\",\"986\":\"v-c822305c#什么是悲观锁\",\"987\":\"v-c822305c#什么是乐观锁\",\"988\":\"v-c822305c#如何实现乐观锁\",\"989\":\"v-c822305c#版本号机制\",\"990\":\"v-c822305c#cas-算法\",\"991\":\"v-c822305c#乐观锁存在哪些问题\",\"992\":\"v-c822305c#aba-问题\",\"993\":\"v-c822305c#循环时间长开销大\",\"994\":\"v-c822305c#只能保证一个共享变量的原子操作\",\"995\":\"v-c822305c#总结\",\"996\":\"v-c822305c#参考\",\"997\":\"v-c822305c@0\",\"998\":\"v-c822305c@1\",\"999\":\"v-61dda43a\",\"1000\":\"v-61dda43a#_1-reentrantlock\",\"1001\":\"v-61dda43a#_1-1-reentrantlock-特性概览\",\"1002\":\"v-61dda43a#_1-2-reentrantlock-与-aqs-的关联\",\"1003\":\"v-61dda43a#_2-aqs\",\"1004\":\"v-61dda43a#_2-1-原理概览\",\"1005\":\"v-61dda43a#_2-1-1-aqs-数据结构\",\"1006\":\"v-61dda43a#_2-1-2-同步状态-state\",\"1007\":\"v-61dda43a#_2-2-aqs-重要方法与-reentrantlock-的关联\",\"1008\":\"v-61dda43a#_3-通过-reentrantlock-理解-aqs\",\"1009\":\"v-61dda43a#_3-1-线程加入等待队列\",\"1010\":\"v-61dda43a#_3-1-1-加入队列的时机\",\"1011\":\"v-61dda43a#_3-1-2-如何加入队列\",\"1012\":\"v-61dda43a#_3-1-3-等待队列中线程出队列时机\",\"1013\":\"v-61dda43a#_3-2-cancelled-状态节点生成\",\"1014\":\"v-61dda43a#_3-3-如何解锁\",\"1015\":\"v-61dda43a#_3-4-中断恢复后的执行流程\",\"1016\":\"v-61dda43a#_3-5-小结\",\"1017\":\"v-61dda43a#_4-aqs-应用\",\"1018\":\"v-61dda43a#_4-1-reentrantlock-的可重入应用\",\"1019\":\"v-61dda43a#_4-2-juc-中的应用场景\",\"1020\":\"v-61dda43a#_4-3-自定义同步工具\",\"1021\":\"v-61dda43a#_5-总结\",\"1022\":\"v-61dda43a#参考资料\",\"1023\":\"v-61dda43a@0\",\"1024\":\"v-61dda43a@1\",\"1025\":\"v-14494dcc\",\"1026\":\"v-14494dcc#前言\",\"1027\":\"v-14494dcc#目录\",\"1028\":\"v-14494dcc#threadlocal代码演示\",\"1029\":\"v-14494dcc#threadlocal的数据结构\",\"1030\":\"v-14494dcc#gc-之后-key-是否为-null\",\"1031\":\"v-14494dcc#threadlocal-set-方法源码详解\",\"1032\":\"v-14494dcc#threadlocalmap-hash-算法\",\"1033\":\"v-14494dcc#threadlocalmap-hash-冲突\",\"1034\":\"v-14494dcc#threadlocalmap-set-详解\",\"1035\":\"v-14494dcc#threadlocalmap-set-原理图解\",\"1036\":\"v-14494dcc#threadlocalmap-set-源码详解\",\"1037\":\"v-14494dcc#threadlocalmap过期-key-的探测式清理流程\",\"1038\":\"v-14494dcc#threadlocalmap扩容机制\",\"1039\":\"v-14494dcc#threadlocalmap-get-详解\",\"1040\":\"v-14494dcc#threadlocalmap-get-图解\",\"1041\":\"v-14494dcc#threadlocalmap-get-源码详解\",\"1042\":\"v-14494dcc#threadlocalmap过期-key-的启发式清理流程\",\"1043\":\"v-14494dcc#inheritablethreadlocal\",\"1044\":\"v-14494dcc#threadlocal项目中使用实战\",\"1045\":\"v-14494dcc#threadlocal使用场景\",\"1046\":\"v-14494dcc#feign-远程调用解决方案\",\"1047\":\"v-14494dcc#线程池异步调用-requestid-传递\",\"1048\":\"v-14494dcc#使用-mq-发送消息给第三方系统\",\"1049\":\"v-14494dcc@0\",\"1050\":\"v-14494dcc@1\",\"1051\":\"v-6712fecb\",\"1052\":\"v-6712fecb#什么是虚拟线程\",\"1053\":\"v-6712fecb#虚拟线程和平台线程有什么关系\",\"1054\":\"v-6712fecb#虚拟线程有什么优点和缺点\",\"1055\":\"v-6712fecb#优点\",\"1056\":\"v-6712fecb#缺点\",\"1057\":\"v-6712fecb#四种创建虚拟线程的方法\",\"1058\":\"v-6712fecb#使用-thread-startvirtualthread-创建\",\"1059\":\"v-6712fecb#使用-thread-ofvirtual-创建\",\"1060\":\"v-6712fecb#使用-threadfactory-创建\",\"1061\":\"v-6712fecb#使用-executors-newvirtualthreadpertaskexecutor-创建\",\"1062\":\"v-6712fecb#虚拟线程和平台线程性能对比\",\"1063\":\"v-6712fecb@0\",\"1064\":\"v-6712fecb@1\",\"1065\":\"v-8db574ae\",\"1066\":\"v-8db574ae#cap-理论\",\"1067\":\"v-8db574ae#简介\",\"1068\":\"v-8db574ae#不是所谓的-3-选-2\",\"1069\":\"v-8db574ae#cap-实际应用案例\",\"1070\":\"v-8db574ae#总结\",\"1071\":\"v-8db574ae#推荐阅读\",\"1072\":\"v-8db574ae#base-理论\",\"1073\":\"v-8db574ae#简介-1\",\"1074\":\"v-8db574ae#base-理论的核心思想\",\"1075\":\"v-8db574ae#base-理论三要素\",\"1076\":\"v-8db574ae#基本可用\",\"1077\":\"v-8db574ae#软状态\",\"1078\":\"v-8db574ae#最终一致性\",\"1079\":\"v-8db574ae#总结-1\",\"1080\":\"v-8db574ae@0\",\"1081\":\"v-8db574ae@1\",\"1082\":\"v-5a587647\",\"1083\":\"v-5a587647#背景\",\"1084\":\"v-5a587647#gossip-协议介绍\",\"1085\":\"v-5a587647#gossip-协议应用\",\"1086\":\"v-5a587647#gossip-协议消息传播模式\",\"1087\":\"v-5a587647#反熵-anti-entropy\",\"1088\":\"v-5a587647#谣言传播-rumor-mongering\",\"1089\":\"v-5a587647#总结\",\"1090\":\"v-5a587647#gossip-协议优势和缺陷\",\"1091\":\"v-5a587647#总结-1\",\"1092\":\"v-5a587647#参考\",\"1093\":\"v-5a587647@0\",\"1094\":\"v-5a587647@1\",\"1095\":\"v-bf3776aa\",\"1096\":\"v-bf3776aa#背景\",\"1097\":\"v-bf3776aa#介绍\",\"1098\":\"v-bf3776aa#basic-paxos-算法\",\"1099\":\"v-bf3776aa#multi-paxos-思想\",\"1100\":\"v-bf3776aa#参考\",\"1101\":\"v-bf3776aa@0\",\"1102\":\"v-bf3776aa@1\",\"1103\":\"v-2c0d4cdb\",\"1104\":\"v-2c0d4cdb#_1-背景\",\"1105\":\"v-2c0d4cdb#_1-1-拜占庭将军\",\"1106\":\"v-2c0d4cdb#_1-2-共识算法\",\"1107\":\"v-2c0d4cdb#_2-基础\",\"1108\":\"v-2c0d4cdb#_2-1-节点类型\",\"1109\":\"v-2c0d4cdb#_2-2-任期\",\"1110\":\"v-2c0d4cdb#_2-3-日志\",\"1111\":\"v-2c0d4cdb#_3-领导人选举\",\"1112\":\"v-2c0d4cdb#_4-日志复制\",\"1113\":\"v-2c0d4cdb#_5-安全性\",\"1114\":\"v-2c0d4cdb#_5-1-选举限制\",\"1115\":\"v-2c0d4cdb#_5-2-节点崩溃\",\"1116\":\"v-2c0d4cdb#_5-3-时间与可用性\",\"1117\":\"v-2c0d4cdb#_6-参考\",\"1118\":\"v-2c0d4cdb@0\",\"1119\":\"v-2c0d4cdb@1\",\"1120\":\"v-012ed27d\",\"1121\":\"v-012ed27d#dubbo-基础\",\"1122\":\"v-012ed27d#什么是-dubbo\",\"1123\":\"v-012ed27d#为什么要用-dubbo\",\"1124\":\"v-012ed27d#分布式基础\",\"1125\":\"v-012ed27d#什么是分布式\",\"1126\":\"v-012ed27d#为什么要分布式\",\"1127\":\"v-012ed27d#dubbo-架构\",\"1128\":\"v-012ed27d#dubbo-架构中的核心角色有哪些\",\"1129\":\"v-012ed27d#dubbo-中的-invoker-概念了解么\",\"1130\":\"v-012ed27d#dubbo-的工作原理了解么\",\"1131\":\"v-012ed27d#dubbo-的-spi-机制了解么-如何扩展-dubbo-中的默认实现\",\"1132\":\"v-012ed27d#dubbo-的微内核架构了解吗\",\"1133\":\"v-012ed27d#关于-dubbo-架构的一些自测小问题\",\"1134\":\"v-012ed27d#注册中心的作用了解么\",\"1135\":\"v-012ed27d#服务提供者宕机后-注册中心会做什么\",\"1136\":\"v-012ed27d#监控中心的作用呢\",\"1137\":\"v-012ed27d#注册中心和监控中心都宕机的话-服务都会挂掉吗\",\"1138\":\"v-012ed27d#dubbo-的负载均衡策略\",\"1139\":\"v-012ed27d#什么是负载均衡\",\"1140\":\"v-012ed27d#dubbo-提供的负载均衡策略有哪些\",\"1141\":\"v-012ed27d#randomloadbalance\",\"1142\":\"v-012ed27d#leastactiveloadbalance\",\"1143\":\"v-012ed27d#consistenthashloadbalance\",\"1144\":\"v-012ed27d#roundrobinloadbalance\",\"1145\":\"v-012ed27d#dubbo-序列化协议\",\"1146\":\"v-012ed27d#dubbo-支持哪些序列化方式呢\",\"1147\":\"v-012ed27d#谈谈你对这些序列化协议了解\",\"1148\":\"v-012ed27d@0\",\"1149\":\"v-012ed27d@1\",\"1150\":\"v-08748fc9\",\"1151\":\"v-08748fc9#从-tcp-聊起\",\"1152\":\"v-08748fc9#使用纯裸-tcp-会有什么问题\",\"1153\":\"v-08748fc9#http-和-rpc\",\"1154\":\"v-08748fc9#rpc-其实是一种调用方式\",\"1155\":\"v-08748fc9#那既然有-rpc-了-为什么还要有-http-呢\",\"1156\":\"v-08748fc9#http-和-rpc-有什么区别\",\"1157\":\"v-08748fc9#服务发现\",\"1158\":\"v-08748fc9#底层连接形式\",\"1159\":\"v-08748fc9#传输的内容\",\"1160\":\"v-08748fc9#为什么既然有了-http2-还要有-rpc-协议\",\"1161\":\"v-08748fc9#总结\",\"1162\":\"v-08748fc9@0\",\"1163\":\"v-08748fc9@1\",\"1164\":\"v-02979ab7\",\"1165\":\"v-02979ab7#rpc-是什么\",\"1166\":\"v-02979ab7#rpc-的原理是什么\",\"1167\":\"v-02979ab7#有哪些常见的-rpc-框架\",\"1168\":\"v-02979ab7#dubbo\",\"1169\":\"v-02979ab7#motan\",\"1170\":\"v-02979ab7#grpc\",\"1171\":\"v-02979ab7#thrift\",\"1172\":\"v-02979ab7#总结\",\"1173\":\"v-02979ab7#如何设计并实现一个-rpc-框架\",\"1174\":\"v-02979ab7#既然有了-http-协议-为什么还要有-rpc\",\"1175\":\"v-02979ab7@0\",\"1176\":\"v-02979ab7@1\",\"1177\":\"v-5f63e78e\",\"1178\":\"v-5f63e78e#disruptor-是什么\",\"1179\":\"v-5f63e78e#为什么要用-disruptor\",\"1180\":\"v-5f63e78e#kafka-和-disruptor-什么区别\",\"1181\":\"v-5f63e78e#哪些组件用到了-disruptor\",\"1182\":\"v-5f63e78e#disruptor-核心概念有哪些\",\"1183\":\"v-5f63e78e#disruptor-等待策略有哪些\",\"1184\":\"v-5f63e78e#disruptor-为什么这么快\",\"1185\":\"v-5f63e78e#参考\",\"1186\":\"v-5f63e78e@0\",\"1187\":\"v-5f63e78e@1\",\"1188\":\"v-4eaf7939\",\"1189\":\"v-4eaf7939#kafka-基础\",\"1190\":\"v-4eaf7939#kafka-是什么-主要应用场景有哪些\",\"1191\":\"v-4eaf7939#和其他消息队列相比-kafka-的优势在哪里\",\"1192\":\"v-4eaf7939#队列模型了解吗-kafka-的消息模型知道吗\",\"1193\":\"v-4eaf7939#队列模型-早期的消息模型\",\"1194\":\"v-4eaf7939#发布-订阅模型-kafka-消息模型\",\"1195\":\"v-4eaf7939#kafka-核心概念\",\"1196\":\"v-4eaf7939#什么是-producer、consumer、broker、topic、partition\",\"1197\":\"v-4eaf7939#kafka-的多副本机制了解吗-带来了什么好处\",\"1198\":\"v-4eaf7939#zookeeper-和-kafka\",\"1199\":\"v-4eaf7939#zookeeper-在-kafka-中的作用是什么\",\"1200\":\"v-4eaf7939#使用-kafka-能否不引入-zookeeper\",\"1201\":\"v-4eaf7939#kafka-消费顺序、消息丢失和重复消费\",\"1202\":\"v-4eaf7939#kafka-如何保证消息的消费顺序\",\"1203\":\"v-4eaf7939#kafka-如何保证消息不丢失\",\"1204\":\"v-4eaf7939#生产者丢失消息的情况\",\"1205\":\"v-4eaf7939#消费者丢失消息的情况\",\"1206\":\"v-4eaf7939#kafka-弄丢了消息\",\"1207\":\"v-4eaf7939#kafka-如何保证消息不重复消费\",\"1208\":\"v-4eaf7939#kafka-重试机制\",\"1209\":\"v-4eaf7939#消费失败会怎么样\",\"1210\":\"v-4eaf7939#默认会重试多少次\",\"1211\":\"v-4eaf7939#如何自定义重试次数以及时间间隔\",\"1212\":\"v-4eaf7939#如何在重试失败后进行告警\",\"1213\":\"v-4eaf7939#重试失败后的数据如何再次处理\",\"1214\":\"v-4eaf7939#参考\",\"1215\":\"v-4eaf7939@0\",\"1216\":\"v-4eaf7939@1\",\"1217\":\"v-4e715dc6\",\"1218\":\"v-4e715dc6#什么是消息队列\",\"1219\":\"v-4e715dc6#消息队列有什么用\",\"1220\":\"v-4e715dc6#通过异步处理提高系统性能-减少响应所需时间\",\"1221\":\"v-4e715dc6#削峰-限流\",\"1222\":\"v-4e715dc6#降低系统耦合性\",\"1223\":\"v-4e715dc6#实现分布式事务\",\"1224\":\"v-4e715dc6#使用消息队列会带来哪些问题\",\"1225\":\"v-4e715dc6#jms-和-amqp\",\"1226\":\"v-4e715dc6#jms-是什么\",\"1227\":\"v-4e715dc6#jms-两种消息模型\",\"1228\":\"v-4e715dc6#点到点-p2p-模型\",\"1229\":\"v-4e715dc6#发布-订阅-pub-sub-模型\",\"1230\":\"v-4e715dc6#amqp-是什么\",\"1231\":\"v-4e715dc6#jms-vs-amqp\",\"1232\":\"v-4e715dc6#rpc-和消息队列的区别\",\"1233\":\"v-4e715dc6#分布式消息队列技术选型\",\"1234\":\"v-4e715dc6#常见的消息队列有哪些\",\"1235\":\"v-4e715dc6#kafka\",\"1236\":\"v-4e715dc6#rocketmq\",\"1237\":\"v-4e715dc6#rabbitmq\",\"1238\":\"v-4e715dc6#pulsar\",\"1239\":\"v-4e715dc6#activemq\",\"1240\":\"v-4e715dc6#如何选择\",\"1241\":\"v-4e715dc6#参考\",\"1242\":\"v-4e715dc6@0\",\"1243\":\"v-4e715dc6@1\",\"1244\":\"v-523ec17a\",\"1245\":\"v-523ec17a#rabbitmq-是什么\",\"1246\":\"v-523ec17a#rabbitmq-特点\",\"1247\":\"v-523ec17a#rabbitmq-核心概念\",\"1248\":\"v-523ec17a#producer-生产者-和-consumer-消费者\",\"1249\":\"v-523ec17a#exchange-交换器\",\"1250\":\"v-523ec17a#queue-消息队列\",\"1251\":\"v-523ec17a#broker-消息中间件的服务节点\",\"1252\":\"v-523ec17a#exchange-types-交换器类型\",\"1253\":\"v-523ec17a#amqp-是什么\",\"1254\":\"v-523ec17a#说说生产者-producer-和消费者-consumer\",\"1255\":\"v-523ec17a#说说-broker-服务节点、queue-队列、exchange-交换器\",\"1256\":\"v-523ec17a#什么是死信队列-如何导致的\",\"1257\":\"v-523ec17a#什么是延迟队列-rabbitmq-怎么实现延迟队列\",\"1258\":\"v-523ec17a#什么是优先级队列\",\"1259\":\"v-523ec17a#rabbitmq-有哪些工作模式\",\"1260\":\"v-523ec17a#rabbitmq-消息怎么传输\",\"1261\":\"v-523ec17a#如何保证消息的可靠性\",\"1262\":\"v-523ec17a#如何保证-rabbitmq-消息的顺序性\",\"1263\":\"v-523ec17a#如何保证-rabbitmq-高可用的\",\"1264\":\"v-523ec17a#如何解决消息队列的延时以及过期失效问题\",\"1265\":\"v-523ec17a@0\",\"1266\":\"v-523ec17a@1\",\"1267\":\"v-2cd0cbc9\",\"1268\":\"v-2cd0cbc9#消息队列扫盲\",\"1269\":\"v-2cd0cbc9#消息队列为什么会出现\",\"1270\":\"v-2cd0cbc9#消息队列能用来干什么\",\"1271\":\"v-2cd0cbc9#异步\",\"1272\":\"v-2cd0cbc9#解耦\",\"1273\":\"v-2cd0cbc9#削峰\",\"1274\":\"v-2cd0cbc9#消息队列能带来什么好处\",\"1275\":\"v-2cd0cbc9#消息队列会带来副作用吗\",\"1276\":\"v-2cd0cbc9#rocketmq-是什么\",\"1277\":\"v-2cd0cbc9#队列模型和主题模型是什么\",\"1278\":\"v-2cd0cbc9#队列模型\",\"1279\":\"v-2cd0cbc9#主题模型\",\"1280\":\"v-2cd0cbc9#rocketmq-中的消息模型\",\"1281\":\"v-2cd0cbc9#rocketmq-的架构图\",\"1282\":\"v-2cd0cbc9#rocketmq-功能特性\",\"1283\":\"v-2cd0cbc9#消息\",\"1284\":\"v-2cd0cbc9#普通消息\",\"1285\":\"v-2cd0cbc9#定时消息\",\"1286\":\"v-2cd0cbc9#顺序消息\",\"1287\":\"v-2cd0cbc9#事务消息\",\"1288\":\"v-2cd0cbc9#关于发送消息\",\"1289\":\"v-2cd0cbc9#不建议单一进程创建大量生产者\",\"1290\":\"v-2cd0cbc9#不建议频繁创建和销毁生产者\",\"1291\":\"v-2cd0cbc9#消费者分类\",\"1292\":\"v-2cd0cbc9#pushconsumer\",\"1293\":\"v-2cd0cbc9#simpleconsumer\",\"1294\":\"v-2cd0cbc9#pullconsumer\",\"1295\":\"v-2cd0cbc9#消费者分组和生产者分组\",\"1296\":\"v-2cd0cbc9#生产者分组\",\"1297\":\"v-2cd0cbc9#消费者分组\",\"1298\":\"v-2cd0cbc9#如何解决顺序消费和重复消费\",\"1299\":\"v-2cd0cbc9#顺序消费\",\"1300\":\"v-2cd0cbc9#特殊情况处理\",\"1301\":\"v-2cd0cbc9#发送异常\",\"1302\":\"v-2cd0cbc9#消息过大\",\"1303\":\"v-2cd0cbc9#重复消费\",\"1304\":\"v-2cd0cbc9#rocketmq-如何实现分布式事务\",\"1305\":\"v-2cd0cbc9#如何解决消息堆积问题\",\"1306\":\"v-2cd0cbc9#什么是回溯消费\",\"1307\":\"v-2cd0cbc9#rocketmq-如何保证高性能读写\",\"1308\":\"v-2cd0cbc9#传统-io-方式\",\"1309\":\"v-2cd0cbc9#零拷贝技术\",\"1310\":\"v-2cd0cbc9#mmap\",\"1311\":\"v-2cd0cbc9#sendfile\",\"1312\":\"v-2cd0cbc9#rocketmq-的刷盘机制\",\"1313\":\"v-2cd0cbc9#同步刷盘和异步刷盘\",\"1314\":\"v-2cd0cbc9#同步复制和异步复制\",\"1315\":\"v-2cd0cbc9#存储机制\",\"1316\":\"v-2cd0cbc9#总结\",\"1317\":\"v-2cd0cbc9@0\",\"1318\":\"v-2cd0cbc9@1\",\"1319\":\"v-44f4881a\",\"1320\":\"v-44f4881a#zookeeper-安装\",\"1321\":\"v-44f4881a#使用-docker-安装-zookeeper\",\"1322\":\"v-44f4881a#连接-zookeeper-服务\",\"1323\":\"v-44f4881a#zookeeper-常用命令演示\",\"1324\":\"v-44f4881a#查看常用命令-help-命令\",\"1325\":\"v-44f4881a#创建节点-create-命令\",\"1326\":\"v-44f4881a#更新节点数据内容-set-命令\",\"1327\":\"v-44f4881a#获取节点的数据-get-命令\",\"1328\":\"v-44f4881a#查看某个目录下的子节点-ls-命令\",\"1329\":\"v-44f4881a#查看节点状态-stat-命令\",\"1330\":\"v-44f4881a#查看节点信息和状态-ls2-命令\",\"1331\":\"v-44f4881a#删除节点-delete-命令\",\"1332\":\"v-44f4881a#zookeeper-java-客户端-curator-简单使用\",\"1333\":\"v-44f4881a#连接-zookeeper-客户端\",\"1334\":\"v-44f4881a#数据节点的增删改查\",\"1335\":\"v-44f4881a#创建节点\",\"1336\":\"v-44f4881a#删除节点\",\"1337\":\"v-44f4881a#获取-更新节点数据内容\",\"1338\":\"v-44f4881a#获取某个节点的所有子节点路径\",\"1339\":\"v-44f4881a@0\",\"1340\":\"v-44f4881a@1\",\"1341\":\"v-0f86d225\",\"1342\":\"v-0f86d225#zookeeper-介绍\",\"1343\":\"v-0f86d225#zookeeper-由来\",\"1344\":\"v-0f86d225#zookeeper-概览\",\"1345\":\"v-0f86d225#zookeeper-特点\",\"1346\":\"v-0f86d225#zookeeper-应用场景\",\"1347\":\"v-0f86d225#zookeeper-重要概念\",\"1348\":\"v-0f86d225#data-model-数据模型\",\"1349\":\"v-0f86d225#znode-数据节点\",\"1350\":\"v-0f86d225#版本-version\",\"1351\":\"v-0f86d225#acl-权限控制\",\"1352\":\"v-0f86d225#watcher-事件监听器\",\"1353\":\"v-0f86d225#会话-session\",\"1354\":\"v-0f86d225#zookeeper-集群\",\"1355\":\"v-0f86d225#zookeeper-集群角色\",\"1356\":\"v-0f86d225#zookeeper-集群-leader-选举过程\",\"1357\":\"v-0f86d225#zookeeper-集群为啥最好奇数台\",\"1358\":\"v-0f86d225#zookeeper-选举的过半机制防止脑裂\",\"1359\":\"v-0f86d225#zab-协议和-paxos-算法\",\"1360\":\"v-0f86d225#zab-协议介绍\",\"1361\":\"v-0f86d225#zab-协议两种基本的模式-崩溃恢复和消息广播\",\"1362\":\"v-0f86d225#总结\",\"1363\":\"v-0f86d225#参考\",\"1364\":\"v-0f86d225@0\",\"1365\":\"v-0f86d225@1\",\"1366\":\"v-1f29e847\",\"1367\":\"v-1f29e847#什么是-zookeeper\",\"1368\":\"v-1f29e847#一致性问题\",\"1369\":\"v-1f29e847#一致性协议和算法\",\"1370\":\"v-1f29e847#_2pc-两阶段提交\",\"1371\":\"v-1f29e847#_3pc-三阶段提交\",\"1372\":\"v-1f29e847#paxos-算法\",\"1373\":\"v-1f29e847#prepare-阶段\",\"1374\":\"v-1f29e847#accept-阶段\",\"1375\":\"v-1f29e847#paxos-算法的死循环问题\",\"1376\":\"v-1f29e847#引出-zab\",\"1377\":\"v-1f29e847#zookeeper-架构\",\"1378\":\"v-1f29e847#zab-中的三个角色\",\"1379\":\"v-1f29e847#消息广播模式\",\"1380\":\"v-1f29e847#崩溃恢复模式\",\"1381\":\"v-1f29e847#zookeeper-的几个理论知识\",\"1382\":\"v-1f29e847#数据模型\",\"1383\":\"v-1f29e847#会话\",\"1384\":\"v-1f29e847#acl\",\"1385\":\"v-1f29e847#watcher-机制\",\"1386\":\"v-1f29e847#zookeeper-的几个典型应用场景\",\"1387\":\"v-1f29e847#选主\",\"1388\":\"v-1f29e847#分布式锁\",\"1389\":\"v-1f29e847#命名服务\",\"1390\":\"v-1f29e847#集群管理和注册中心\",\"1391\":\"v-1f29e847#总结\",\"1392\":\"v-1f29e847@0\",\"1393\":\"v-1f29e847@1\",\"1394\":\"v-15054f24\",\"1395\":\"v-1fe6b9c2\",\"1396\":\"v-34bda13c\",\"1397\":\"v-d8eaf050\",\"1398\":\"v-ea6d4ed2\",\"1399\":\"v-56a15198\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2,44],\"2\":[2,81],\"3\":[2],\"4\":[2,73],\"5\":[3,53],\"6\":[1,74],\"7\":[1,114],\"8\":[1,115],\"9\":[1,32],\"10\":[2,62],\"11\":[1,43],\"12\":[null,null,1],\"13\":[3,11],\"14\":[null,null,1],\"15\":[1,21],\"16\":[2,13],\"17\":[2,81],\"18\":[2,63],\"19\":[2,173],\"20\":[2],\"21\":[2,33],\"22\":[3,74],\"23\":[3,52],\"24\":[2,50],\"25\":[null,null,1],\"26\":[2],\"27\":[3],\"28\":[3,17],\"29\":[3,27],\"30\":[4,50],\"31\":[3],\"32\":[1],\"33\":[1,85],\"34\":[1,119],\"35\":[1,99],\"36\":[1],\"37\":[1,130],\"38\":[3,92],\"39\":[1],\"40\":[3,27],\"41\":[3,63],\"42\":[3,64],\"43\":[1,24],\"44\":[null,null,1],\"45\":[1,13],\"46\":[3],\"47\":[4,78],\"48\":[2,48],\"49\":[2,184],\"50\":[2,42],\"51\":[3,76],\"52\":[3,7],\"53\":[4,114],\"54\":[2,60],\"55\":[2,30],\"56\":[2,107],\"57\":[1,14],\"58\":[null,null,1],\"59\":[1,8],\"60\":[2,98],\"61\":[2,26],\"62\":[2,20],\"63\":[1,27],\"64\":[null,null,1],\"65\":[3,11],\"66\":[null,null,1],\"67\":[3,12],\"68\":[5,52],\"69\":[5,71],\"70\":[5,35],\"71\":[5,30],\"72\":[5,42],\"73\":[5,28],\"74\":[1,20],\"75\":[1,43],\"76\":[5,31],\"77\":[5,35],\"78\":[1,30],\"79\":[null,null,1],\"80\":[1,11],\"81\":[3,24],\"82\":[2,17],\"83\":[1,23],\"84\":[1,26],\"85\":[5,16],\"86\":[1,83],\"87\":[1,8],\"88\":[1,10],\"89\":[2,177],\"90\":[2,42],\"91\":[null,null,1],\"92\":[null,null,1],\"93\":[1,6],\"94\":[1,15],\"95\":[1],\"96\":[2,67],\"97\":[3,31],\"98\":[2,49],\"99\":[2,35],\"100\":[1,11],\"101\":[2,33],\"102\":[1],\"103\":[2,29],\"104\":[2,35],\"105\":[2,18],\"106\":[3,32],\"107\":[3,9],\"108\":[2,27],\"109\":[2,12],\"110\":[2,30],\"111\":[1,15],\"112\":[1,13],\"113\":[1,13],\"114\":[3,15],\"115\":[1,12],\"116\":[1,8],\"117\":[1,89],\"118\":[1,35],\"119\":[1,14],\"120\":[1,119],\"121\":[null,null,1],\"122\":[null,null,1],\"123\":[1],\"124\":[1,41],\"125\":[2,96],\"126\":[1],\"127\":[4,30],\"128\":[5,37],\"129\":[5,24],\"130\":[1,19],\"131\":[1],\"132\":[1,48],\"133\":[1,28],\"134\":[5],\"135\":[3,32],\"136\":[3,25],\"137\":[3,14],\"138\":[4,8],\"139\":[1],\"140\":[1,28],\"141\":[2,174],\"142\":[null,null,1],\"143\":[null,null,1],\"144\":[1,22],\"145\":[5,95],\"146\":[6,58],\"147\":[5,42],\"148\":[null,null,1],\"149\":[null,null,1],\"150\":[3,12],\"151\":[null,null,1],\"152\":[null,null,1],\"153\":[3,13],\"154\":[null,null,1],\"155\":[null,null,1],\"156\":[1,21],\"157\":[3,76],\"158\":[4,22],\"159\":[1],\"160\":[2,24],\"161\":[2,71],\"162\":[2,31],\"163\":[2,58],\"164\":[2,31],\"165\":[2,24],\"166\":[1,10],\"167\":[1,20],\"168\":[3,72],\"169\":[2,20],\"170\":[1,6],\"171\":[1,18],\"172\":[null,null,1],\"173\":[null,null,1],\"174\":[3,68],\"175\":[3],\"176\":[1,39],\"177\":[1,70],\"178\":[1,28],\"179\":[3],\"180\":[1,27],\"181\":[1,67],\"182\":[1,23],\"183\":[3],\"184\":[1,26],\"185\":[1,72],\"186\":[1,16],\"187\":[3],\"188\":[1,29],\"189\":[1,69],\"190\":[1,41],\"191\":[4],\"192\":[1,19],\"193\":[1,81],\"194\":[1,25],\"195\":[1,52],\"196\":[1,26],\"197\":[null,null,1],\"198\":[null,null,1],\"199\":[3,11],\"200\":[3],\"201\":[1,76],\"202\":[1,50],\"203\":[1,16],\"204\":[3],\"205\":[1,69],\"206\":[1,42],\"207\":[1,17],\"208\":[3],\"209\":[1,14],\"210\":[1,92],\"211\":[1,8],\"212\":[1,48],\"213\":[1,30],\"214\":[null,null,1],\"215\":[null,null,1],\"216\":[1],\"217\":[2,18],\"218\":[4,112],\"219\":[4,63],\"220\":[4,48],\"221\":[1,30],\"222\":[null,null,1],\"223\":[null,null,1],\"224\":[1,37],\"225\":[2],\"226\":[4,36],\"227\":[3,21],\"228\":[2],\"229\":[4,46],\"230\":[3,68],\"231\":[3,107],\"232\":[3,24],\"233\":[3,129],\"234\":[3,35],\"235\":[5,36],\"236\":[5,105],\"237\":[1,40],\"238\":[null,null,1],\"239\":[null,null,1],\"240\":[3,3],\"241\":[2],\"242\":[3,64],\"243\":[3,26],\"244\":[2,48],\"245\":[5,70],\"246\":[4,48],\"247\":[2,5],\"248\":[2],\"249\":[4,63],\"250\":[4,6],\"251\":[3,137],\"252\":[2,9],\"253\":[3,30],\"254\":[3,34],\"255\":[5,21],\"256\":[3,188],\"257\":[6,32],\"258\":[4,25],\"259\":[3,34],\"260\":[4,17],\"261\":[4,52],\"262\":[6,27],\"263\":[4,13],\"264\":[4,14],\"265\":[3,88],\"266\":[4,52],\"267\":[4,63],\"268\":[3,80],\"269\":[2],\"270\":[3,55],\"271\":[3,31],\"272\":[2,52],\"273\":[3,51],\"274\":[1,26],\"275\":[null,null,1],\"276\":[null,null,1],\"277\":[3,3],\"278\":[2],\"279\":[4,19],\"280\":[4,91],\"281\":[3,53],\"282\":[3,47],\"283\":[4,45],\"284\":[4,9],\"285\":[1,47],\"286\":[1,73],\"287\":[1,79],\"288\":[2,38],\"289\":[3,38],\"290\":[5],\"291\":[3,30],\"292\":[4,54],\"293\":[3,193],\"294\":[3,50],\"295\":[5],\"296\":[3,21],\"297\":[3,21],\"298\":[3,201],\"299\":[3,34],\"300\":[1],\"301\":[2,86],\"302\":[2,138],\"303\":[2,9],\"304\":[4],\"305\":[1],\"306\":[2,17],\"307\":[2,122],\"308\":[1],\"309\":[2,18],\"310\":[2,8],\"311\":[2,13],\"312\":[1],\"313\":[2,20],\"314\":[2,15],\"315\":[2,5],\"316\":[2,49],\"317\":[4,5],\"318\":[2,37],\"319\":[2,55],\"320\":[1,40],\"321\":[null,null,1],\"322\":[null,null,1],\"323\":[1],\"324\":[1,41],\"325\":[2,72],\"326\":[4,18],\"327\":[6,41],\"328\":[4,101],\"329\":[4,34],\"330\":[8,38],\"331\":[3,51],\"332\":[3,31],\"333\":[3,24],\"334\":[1,45],\"335\":[null,null,1],\"336\":[null,null,1],\"337\":[1],\"338\":[1,24],\"339\":[1,25],\"340\":[1,64],\"341\":[1,84],\"342\":[1,69],\"343\":[1,27],\"344\":[1,93],\"345\":[1,64],\"346\":[null,null,1],\"347\":[null,null,1],\"348\":[3],\"349\":[1,20],\"350\":[1],\"351\":[1,141],\"352\":[1,38],\"353\":[1,170],\"354\":[1,58],\"355\":[1],\"356\":[1,110],\"357\":[1,112],\"358\":[1,39],\"359\":[1,201],\"360\":[1,48],\"361\":[null,null,1],\"362\":[null,null,1],\"363\":[1],\"364\":[2,53],\"365\":[4,54],\"366\":[2,86],\"367\":[2,38],\"368\":[2,59],\"369\":[4,55],\"370\":[2,137],\"371\":[2],\"372\":[3,15],\"373\":[2,29],\"374\":[3,4],\"375\":[1,33],\"376\":[1,11],\"377\":[3,106],\"378\":[null,null,1],\"379\":[null,null,1],\"380\":[3,36],\"381\":[1,6],\"382\":[1,56],\"383\":[1],\"384\":[3,73],\"385\":[1,26],\"386\":[1,140],\"387\":[3,42],\"388\":[1,41],\"389\":[1,4],\"390\":[1,41],\"391\":[1,75],\"392\":[1,99],\"393\":[2,45],\"394\":[2,30],\"395\":[1],\"396\":[2,39],\"397\":[1,21],\"398\":[2,17],\"399\":[1,26],\"400\":[1,32],\"401\":[2,34],\"402\":[2,41],\"403\":[3,73],\"404\":[3,15],\"405\":[3,15],\"406\":[2,58],\"407\":[2,91],\"408\":[2,39],\"409\":[1,26],\"410\":[null,null,1],\"411\":[null,null,1],\"412\":[1,166],\"413\":[null,null,1],\"414\":[null,null,1],\"415\":[2,8],\"416\":[1,4],\"417\":[3,21],\"418\":[3,16],\"419\":[2,13],\"420\":[2,10],\"421\":[2,10],\"422\":[2,17],\"423\":[2,9],\"424\":[1,18],\"425\":[3,66],\"426\":[2,15],\"427\":[3,13],\"428\":[3,9],\"429\":[3,33],\"430\":[4,29],\"431\":[4,2],\"432\":[2,17],\"433\":[3,53],\"434\":[2],\"435\":[3,27],\"436\":[3,6],\"437\":[2,6],\"438\":[3,24],\"439\":[3,10],\"440\":[2,9],\"441\":[3,29],\"442\":[3,25],\"443\":[3,56],\"444\":[4,133],\"445\":[3,77],\"446\":[3,63],\"447\":[3,6],\"448\":[4,38],\"449\":[5,165],\"450\":[4,28],\"451\":[3,124],\"452\":[3,23],\"453\":[7,17],\"454\":[2,19],\"455\":[3,34],\"456\":[3,26],\"457\":[4],\"458\":[4,16],\"459\":[4,13],\"460\":[5,4],\"461\":[4,5],\"462\":[4,4],\"463\":[5,6],\"464\":[3,14],\"465\":[4,4],\"466\":[4,3],\"467\":[4,2],\"468\":[3,5],\"469\":[4,5],\"470\":[8,5],\"471\":[5,5],\"472\":[1,14],\"473\":[null,null,1],\"474\":[null,null,1],\"475\":[1,14],\"476\":[2,5],\"477\":[2,7],\"478\":[6,32],\"479\":[5,69],\"480\":[4,162],\"481\":[2],\"482\":[3,20],\"483\":[4,53],\"484\":[3,62],\"485\":[2,82],\"486\":[1,51],\"487\":[null,null,1],\"488\":[null,null,1],\"489\":[3,23],\"490\":[1,20],\"491\":[1,31],\"492\":[1,33],\"493\":[2,91],\"494\":[1,27],\"495\":[1,165],\"496\":[1,125],\"497\":[1,39],\"498\":[1,95],\"499\":[1,55],\"500\":[2,8],\"501\":[1,4],\"502\":[2,9],\"503\":[2,82],\"504\":[2,8],\"505\":[2,14],\"506\":[4,18],\"507\":[1,37],\"508\":[1,11],\"509\":[1,9],\"510\":[1,16],\"511\":[1,76],\"512\":[null,null,1],\"513\":[null,null,1],\"514\":[1],\"515\":[1,23],\"516\":[3,28],\"517\":[4,15],\"518\":[1,18],\"519\":[1,26],\"520\":[1,44],\"521\":[1,41],\"522\":[1,29],\"523\":[1,70],\"524\":[1,40],\"525\":[null,null,1],\"526\":[null,null,1],\"527\":[2],\"528\":[1],\"529\":[1,56],\"530\":[1,51],\"531\":[2,172],\"532\":[2,5],\"533\":[1,155],\"534\":[1,87],\"535\":[1,204],\"536\":[1,95],\"537\":[1,67],\"538\":[1,43],\"539\":[2,38],\"540\":[2],\"541\":[4,32],\"542\":[5,39],\"543\":[5,24],\"544\":[3,66],\"545\":[1,25],\"546\":[null,null,1],\"547\":[null,null,1],\"548\":[2,3],\"549\":[2,48],\"550\":[6,14],\"551\":[5,23],\"552\":[5,74],\"553\":[2,379],\"554\":[2],\"555\":[3,87],\"556\":[3,4],\"557\":[2,99],\"558\":[2,145],\"559\":[2,45],\"560\":[6,13],\"561\":[3,76],\"562\":[3,52],\"563\":[1,14],\"564\":[2,96],\"565\":[null,null,1],\"566\":[null,null,1],\"567\":[2,23],\"568\":[3],\"569\":[2,26],\"570\":[2,152],\"571\":[2,290],\"572\":[3,105],\"573\":[2,60],\"574\":[4],\"575\":[2,22],\"576\":[3,78],\"577\":[2,119],\"578\":[2,74],\"579\":[2,44],\"580\":[null,null,1],\"581\":[null,null,1],\"582\":[2],\"583\":[2,33],\"584\":[3,35],\"585\":[5,69],\"586\":[2,36],\"587\":[1,37],\"588\":[1,101],\"589\":[1,49],\"590\":[1,13],\"591\":[1,71],\"592\":[1,40],\"593\":[2,56],\"594\":[null,null,1],\"595\":[null,null,1],\"596\":[2],\"597\":[2,42],\"598\":[2,45],\"599\":[2,89],\"600\":[2,23],\"601\":[1,61],\"602\":[1,21],\"603\":[1,59],\"604\":[1,173],\"605\":[1,28],\"606\":[2],\"607\":[3,23],\"608\":[3,9],\"609\":[3,19],\"610\":[5,18],\"611\":[6,17],\"612\":[1,31],\"613\":[null,null,1],\"614\":[null,null,1],\"615\":[2,7],\"616\":[2,51],\"617\":[1],\"618\":[3,99],\"619\":[3,205],\"620\":[2],\"621\":[1,128],\"622\":[2,154],\"623\":[2,45],\"624\":[2,112],\"625\":[2,102],\"626\":[null,null,1],\"627\":[null,null,1],\"628\":[1,8],\"629\":[1,68],\"630\":[2,116],\"631\":[1,86],\"632\":[1,81],\"633\":[1,59],\"634\":[1,208],\"635\":[null,null,1],\"636\":[null,null,1],\"637\":[3,3],\"638\":[1],\"639\":[2,27],\"640\":[7,26],\"641\":[1,4],\"642\":[1,14],\"643\":[1,19],\"644\":[1,12],\"645\":[1,38],\"646\":[2,27],\"647\":[2,23],\"648\":[1],\"649\":[6,75],\"650\":[6,14],\"651\":[6,22],\"652\":[5,23],\"653\":[3,52],\"654\":[3,29],\"655\":[5,13],\"656\":[5,93],\"657\":[2,15],\"658\":[3,67],\"659\":[3,4],\"660\":[1],\"661\":[4,36],\"662\":[2,37],\"663\":[3,69],\"664\":[1,13],\"665\":[6,26],\"666\":[1],\"667\":[4,58],\"668\":[4,39],\"669\":[2,37],\"670\":[3,18],\"671\":[3,37],\"672\":[5,41],\"673\":[null,null,1],\"674\":[null,null,1],\"675\":[3,3],\"676\":[3],\"677\":[4,133],\"678\":[4,39],\"679\":[4,83],\"680\":[3,81],\"681\":[2],\"682\":[3,100],\"683\":[3,90],\"684\":[4,53],\"685\":[2,31],\"686\":[3,113],\"687\":[3,68],\"688\":[4,148],\"689\":[3],\"690\":[3,56],\"691\":[3,46],\"692\":[9,34],\"693\":[8,133],\"694\":[3,76],\"695\":[4,11],\"696\":[1,27],\"697\":[2,41],\"698\":[1,45],\"699\":[null,null,1],\"700\":[null,null,1],\"701\":[2],\"702\":[2,28],\"703\":[2],\"704\":[1,37],\"705\":[1,56],\"706\":[2,90],\"707\":[2],\"708\":[2,186],\"709\":[1,30],\"710\":[2,140],\"711\":[3,115],\"712\":[3,151],\"713\":[4,130],\"714\":[2],\"715\":[3,16],\"716\":[3,8],\"717\":[3,14],\"718\":[5,19],\"719\":[5,22],\"720\":[1,34],\"721\":[null,null,1],\"722\":[null,null,1],\"723\":[2,3],\"724\":[2,37],\"725\":[3,18],\"726\":[5,13],\"727\":[2,78],\"728\":[1,13],\"729\":[1,106],\"730\":[1,72],\"731\":[1,120],\"732\":[1,115],\"733\":[2,48],\"734\":[null,null,1],\"735\":[null,null,1],\"736\":[4,12],\"737\":[null,null,1],\"738\":[null,null,1],\"739\":[2],\"740\":[2,32],\"741\":[2,10],\"742\":[2,185],\"743\":[2,22],\"744\":[1,57],\"745\":[1,4],\"746\":[3],\"747\":[1,63],\"748\":[1,153],\"749\":[1,118],\"750\":[3],\"751\":[1,12],\"752\":[1,138],\"753\":[1,130],\"754\":[3],\"755\":[1,31],\"756\":[1,151],\"757\":[1,95],\"758\":[1,28],\"759\":[null,null,1],\"760\":[null,null,1],\"761\":[2],\"762\":[2,74],\"763\":[1,63],\"764\":[1,32],\"765\":[2,62],\"766\":[1,78],\"767\":[1,188],\"768\":[1,63],\"769\":[1,6],\"770\":[null,null,1],\"771\":[null,null,1],\"772\":[2,48],\"773\":[2,79],\"774\":[2,62],\"775\":[2],\"776\":[2,11],\"777\":[2,71],\"778\":[1,51],\"779\":[1,116],\"780\":[1,63],\"781\":[2,132],\"782\":[2,78],\"783\":[2],\"784\":[1,29],\"785\":[3,49],\"786\":[1,22],\"787\":[1,15],\"788\":[1,43],\"789\":[null,null,1],\"790\":[null,null,1],\"791\":[2,32],\"792\":[1,51],\"793\":[1,76],\"794\":[1,27],\"795\":[1],\"796\":[2,37],\"797\":[1,44],\"798\":[1,56],\"799\":[1,48],\"800\":[1,75],\"801\":[1,17],\"802\":[null,null,1],\"803\":[null,null,1],\"804\":[3,3],\"805\":[2],\"806\":[2,24],\"807\":[2,90],\"808\":[3,85],\"809\":[3,4],\"810\":[1,33],\"811\":[2,24],\"812\":[2,27],\"813\":[1,9],\"814\":[1,11],\"815\":[1,10],\"816\":[2,57],\"817\":[2,8],\"818\":[2,9],\"819\":[4,44],\"820\":[2,142],\"821\":[2,36],\"822\":[3],\"823\":[1,79],\"824\":[2,80],\"825\":[4,33],\"826\":[6,22],\"827\":[6,34],\"828\":[null,null,1],\"829\":[null,null,1],\"830\":[3,3],\"831\":[4,9],\"832\":[2],\"833\":[2,28],\"834\":[2,80],\"835\":[3,124],\"836\":[1],\"837\":[2,35],\"838\":[2,65],\"839\":[2,6],\"840\":[1,62],\"841\":[2,118],\"842\":[2,3],\"843\":[2,51],\"844\":[1,23],\"845\":[1,14],\"846\":[2],\"847\":[4,42],\"848\":[3,69],\"849\":[4,7],\"850\":[3,5],\"851\":[2,87],\"852\":[2,31],\"853\":[1,27],\"854\":[6,24],\"855\":[5,18],\"856\":[1],\"857\":[3,54],\"858\":[2,12],\"859\":[5],\"860\":[1,44],\"861\":[6,30],\"862\":[4,68],\"863\":[2,12],\"864\":[1,10],\"865\":[3,60],\"866\":[3,9],\"867\":[2,5],\"868\":[2,21],\"869\":[2,14],\"870\":[1,5],\"871\":[3,100],\"872\":[3,11],\"873\":[3,31],\"874\":[3,28],\"875\":[2,4],\"876\":[1,70],\"877\":[null,null,1],\"878\":[null,null,1],\"879\":[3,3],\"880\":[1],\"881\":[3,26],\"882\":[3,126],\"883\":[3,91],\"884\":[3,72],\"885\":[1],\"886\":[2,7],\"887\":[2,29],\"888\":[2,47],\"889\":[2,81],\"890\":[3,75],\"891\":[2,59],\"892\":[2,52],\"893\":[2,17],\"894\":[2,73],\"895\":[2,162],\"896\":[2,81],\"897\":[2,74],\"898\":[1],\"899\":[3,79],\"900\":[5,61],\"901\":[3,41],\"902\":[1],\"903\":[3,32],\"904\":[3,150],\"905\":[3,63],\"906\":[3,79],\"907\":[3,12],\"908\":[3,35],\"909\":[5,124],\"910\":[3,31],\"911\":[3,151],\"912\":[1,11],\"913\":[1,46],\"914\":[null,null,1],\"915\":[null,null,1],\"916\":[2,3],\"917\":[2,44],\"918\":[2,65],\"919\":[2,36],\"920\":[2,73],\"921\":[2,6],\"922\":[1,166],\"923\":[1,73],\"924\":[2,55],\"925\":[2,15],\"926\":[2],\"927\":[1,29],\"928\":[2,52],\"929\":[3,50],\"930\":[null,null,1],\"931\":[null,null,1],\"932\":[2,9],\"933\":[1,26],\"934\":[2,123],\"935\":[4,6],\"936\":[1,122],\"937\":[1,103],\"938\":[1,52],\"939\":[3,10],\"940\":[2,139],\"941\":[1,259],\"942\":[1],\"943\":[3,49],\"944\":[4,71],\"945\":[4,12],\"946\":[4,8],\"947\":[1],\"948\":[1],\"949\":[1,47],\"950\":[1,22],\"951\":[3,38],\"952\":[1],\"953\":[1,30],\"954\":[1,17],\"955\":[3,18],\"956\":[1],\"957\":[1,37],\"958\":[1,41],\"959\":[3,11],\"960\":[1],\"961\":[1,49],\"962\":[4,29],\"963\":[1,4],\"964\":[1,16],\"965\":[null,null,1],\"966\":[null,null,1],\"967\":[4,12],\"968\":[3,92],\"969\":[1,73],\"970\":[5],\"971\":[4,63],\"972\":[3,152],\"973\":[5,20],\"974\":[4,113],\"975\":[5,48],\"976\":[6,9],\"977\":[1],\"978\":[1,24],\"979\":[1,16],\"980\":[1,13],\"981\":[1,34],\"982\":[1,50],\"983\":[null,null,1],\"984\":[null,null,1],\"985\":[1,23],\"986\":[2,35],\"987\":[2,69],\"988\":[2,6],\"989\":[1,62],\"990\":[2,118],\"991\":[2,3],\"992\":[2,51],\"993\":[1,23],\"994\":[1,14],\"995\":[1,40],\"996\":[1,32],\"997\":[null,null,1],\"998\":[null,null,1],\"999\":[1,49],\"1000\":[2],\"1001\":[3,57],\"1002\":[6,122],\"1003\":[2,30],\"1004\":[3,35],\"1005\":[4,57],\"1006\":[4,53],\"1007\":[5,161],\"1008\":[5,61],\"1009\":[3],\"1010\":[3,13],\"1011\":[4,216],\"1012\":[3,137],\"1013\":[4,146],\"1014\":[2,167],\"1015\":[3,103],\"1016\":[3,45],\"1017\":[3],\"1018\":[4,74],\"1019\":[4,51],\"1020\":[3,78],\"1021\":[2,13],\"1022\":[1,26],\"1023\":[null,null,1],\"1024\":[null,null,1],\"1025\":[2,8],\"1026\":[1,39],\"1027\":[1,4],\"1028\":[2,39],\"1029\":[2,23],\"1030\":[6,158],\"1031\":[3,29],\"1032\":[3,56],\"1033\":[3,56],\"1034\":[3],\"1035\":[3,93],\"1036\":[3,159],\"1037\":[4,120],\"1038\":[2,88],\"1039\":[3,8],\"1040\":[3,38],\"1041\":[3,32],\"1042\":[4,48],\"1043\":[1,79],\"1044\":[2],\"1045\":[2,34],\"1046\":[2,58],\"1047\":[3,33],\"1048\":[3,8],\"1049\":[null,null,1],\"1050\":[null,null,1],\"1051\":[1,9],\"1052\":[2,17],\"1053\":[2,45],\"1054\":[2],\"1055\":[1,15],\"1056\":[1,16],\"1057\":[1,15],\"1058\":[4,22],\"1059\":[4,27],\"1060\":[3,27],\"1061\":[4,25],\"1062\":[1,153],\"1063\":[null,null,1],\"1064\":[null,null,1],\"1065\":[2,14],\"1066\":[2,27],\"1067\":[1,42],\"1068\":[5,83],\"1069\":[2,82],\"1070\":[1,33],\"1071\":[1,14],\"1072\":[2,13],\"1073\":[1,25],\"1074\":[2,44],\"1075\":[2,1],\"1076\":[1,20],\"1077\":[1,6],\"1078\":[1,56],\"1079\":[1,12],\"1080\":[null,null,1],\"1081\":[null,null,1],\"1082\":[2],\"1083\":[1,18],\"1084\":[2,54],\"1085\":[2,88],\"1086\":[2,10],\"1087\":[4,60],\"1088\":[4,22],\"1089\":[1,12],\"1090\":[2,32],\"1091\":[1,15],\"1092\":[1,15],\"1093\":[null,null,1],\"1094\":[null,null,3],\"1095\":[2],\"1096\":[1,88],\"1097\":[1,80],\"1098\":[3,37],\"1099\":[3,34],\"1100\":[1,15],\"1101\":[null,null,1],\"1102\":[null,null,3],\"1103\":[2,6],\"1104\":[2,14],\"1105\":[2,41],\"1106\":[3,60],\"1107\":[2],\"1108\":[3,33],\"1109\":[2,39],\"1110\":[3,30],\"1111\":[2,66],\"1112\":[2,98],\"1113\":[2],\"1114\":[3,31],\"1115\":[3,25],\"1116\":[3,35],\"1117\":[2,27],\"1118\":[null,null,1],\"1119\":[null,null,3],\"1120\":[1,24],\"1121\":[2],\"1122\":[3,47],\"1123\":[3,61],\"1124\":[1],\"1125\":[2,10],\"1126\":[2,16],\"1127\":[2],\"1128\":[3,25],\"1129\":[5,27],\"1130\":[3,63],\"1131\":[7,78],\"1132\":[3,78],\"1133\":[3],\"1134\":[2,4],\"1135\":[3,2],\"1136\":[2,3],\"1137\":[3,6],\"1138\":[2],\"1139\":[2,30],\"1140\":[3,62],\"1141\":[1,82],\"1142\":[1,134],\"1143\":[1,43],\"1144\":[1,37],\"1145\":[2],\"1146\":[3,14],\"1147\":[2,37],\"1148\":[null,null,1],\"1149\":[null,null,1],\"1150\":[6,31],\"1151\":[3,60],\"1152\":[3,73],\"1153\":[3],\"1154\":[2,64],\"1155\":[7,86],\"1156\":[4,6],\"1157\":[1,47],\"1158\":[1,38],\"1159\":[1,90],\"1160\":[6,11],\"1161\":[1,59],\"1162\":[null,null,1],\"1163\":[null,null,1],\"1164\":[1,4],\"1165\":[3,39],\"1166\":[3,78],\"1167\":[4,19],\"1168\":[1,48],\"1169\":[1,40],\"1170\":[1,51],\"1171\":[1,35],\"1172\":[1,44],\"1173\":[4,19],\"1174\":[6,10],\"1175\":[null,null,1],\"1176\":[null,null,1],\"1177\":[1,21],\"1178\":[3,96],\"1179\":[3,44],\"1180\":[5,8],\"1181\":[3,20],\"1182\":[3,52],\"1183\":[3,56],\"1184\":[3,114],\"1185\":[1,27],\"1186\":[null,null,1],\"1187\":[null,null,1],\"1188\":[1],\"1189\":[2],\"1190\":[4,21],\"1191\":[4,40],\"1192\":[4,17],\"1193\":[2,26],\"1194\":[4,30],\"1195\":[2],\"1196\":[7,48],\"1197\":[4,48],\"1198\":[3],\"1199\":[5,89],\"1200\":[5,42],\"1201\":[3],\"1202\":[3,70],\"1203\":[3],\"1204\":[1,79],\"1205\":[1,33],\"1206\":[2,115],\"1207\":[3,43],\"1208\":[2,20],\"1209\":[2,91],\"1210\":[2,127],\"1211\":[2,33],\"1212\":[2,46],\"1213\":[2,93],\"1214\":[1,16],\"1215\":[null,null,1],\"1216\":[null,null,1],\"1217\":[1,17],\"1218\":[2,64],\"1219\":[2,11],\"1220\":[3,19],\"1221\":[2,9],\"1222\":[1,64],\"1223\":[1,16],\"1224\":[2,23],\"1225\":[3],\"1226\":[3,39],\"1227\":[2],\"1228\":[3,14],\"1229\":[5,13],\"1230\":[3,21],\"1231\":[3,72],\"1232\":[2,26],\"1233\":[1],\"1234\":[2],\"1235\":[1,63],\"1236\":[1,61],\"1237\":[1,82],\"1238\":[1,70],\"1239\":[1,4],\"1240\":[2,100],\"1241\":[1,23],\"1242\":[null,null,1],\"1243\":[null,null,1],\"1244\":[1,5],\"1245\":[3,53],\"1246\":[3,52],\"1247\":[3,16],\"1248\":[6,35],\"1249\":[3,75],\"1250\":[3,37],\"1251\":[3,25],\"1252\":[4,108],\"1253\":[3,56],\"1254\":[5,18],\"1255\":[8,20],\"1256\":[3,30],\"1257\":[4,45],\"1258\":[2,16],\"1259\":[3,10],\"1260\":[3,28],\"1261\":[2,25],\"1262\":[4,18],\"1263\":[4,83],\"1264\":[2,48],\"1265\":[null,null,1],\"1266\":[null,null,1],\"1267\":[1,10],\"1268\":[1,10],\"1269\":[2,7],\"1270\":[2],\"1271\":[1,97],\"1272\":[1,58],\"1273\":[1,28],\"1274\":[2,8],\"1275\":[2,73],\"1276\":[3,48],\"1277\":[2,24],\"1278\":[1,21],\"1279\":[1,24],\"1280\":[2,109],\"1281\":[2,200],\"1282\":[2],\"1283\":[1],\"1284\":[1,45],\"1285\":[1,72],\"1286\":[1,21],\"1287\":[1,2],\"1288\":[1],\"1289\":[1,10],\"1290\":[1,27],\"1291\":[1],\"1292\":[1,61],\"1293\":[1,95],\"1294\":[1,2],\"1295\":[1],\"1296\":[1,16],\"1297\":[1,33],\"1298\":[2,24],\"1299\":[1,102],\"1300\":[1],\"1301\":[1,17],\"1302\":[1,9],\"1303\":[1,71],\"1304\":[3,92],\"1305\":[2,27],\"1306\":[2,26],\"1307\":[2],\"1308\":[3,40],\"1309\":[1],\"1310\":[1,60],\"1311\":[1,71],\"1312\":[2,17],\"1313\":[1,28],\"1314\":[1,84],\"1315\":[1,206],\"1316\":[1,31],\"1317\":[null,null,1],\"1318\":[null,null,2],\"1319\":[2,13],\"1320\":[2],\"1321\":[4,19],\"1322\":[3,39],\"1323\":[2],\"1324\":[4,5],\"1325\":[4,17],\"1326\":[4,10],\"1327\":[4,40],\"1328\":[4,28],\"1329\":[4,42],\"1330\":[4,45],\"1331\":[4,23],\"1332\":[5,42],\"1333\":[3,58],\"1334\":[1],\"1335\":[1,83],\"1336\":[1,11],\"1337\":[2,17],\"1338\":[1,10],\"1339\":[null,null,1],\"1340\":[null,null,1],\"1341\":[3,62],\"1342\":[2],\"1343\":[2,41],\"1344\":[2,77],\"1345\":[2,19],\"1346\":[2,42],\"1347\":[2,4],\"1348\":[4,35],\"1349\":[3,143],\"1350\":[3,19],\"1351\":[3,49],\"1352\":[3,17],\"1353\":[3,33],\"1354\":[2,38],\"1355\":[2,47],\"1356\":[4,53],\"1357\":[3,33],\"1358\":[2,47],\"1359\":[4,20],\"1360\":[2,14],\"1361\":[3,44],\"1362\":[1,47],\"1363\":[1,9],\"1364\":[null,null,1],\"1365\":[null,null,1],\"1366\":[3,3],\"1367\":[2,75],\"1368\":[1,42],\"1369\":[1,31],\"1370\":[3,97],\"1371\":[3,104],\"1372\":[2,21],\"1373\":[2,30],\"1374\":[2,62],\"1375\":[2,47],\"1376\":[2],\"1377\":[2,12],\"1378\":[2,34],\"1379\":[1,115],\"1380\":[1,215],\"1381\":[2,24],\"1382\":[1,98],\"1383\":[1,26],\"1384\":[1,24],\"1385\":[2,18],\"1386\":[2,7],\"1387\":[1,46],\"1388\":[1,79],\"1389\":[1,26],\"1390\":[1,52],\"1391\":[1,36],\"1392\":[null,null,1],\"1393\":[null,null,1],\"1394\":[1],\"1395\":[1],\"1396\":[1],\"1397\":[2],\"1398\":[1],\"1399\":[3]},\"averageFieldLength\":[2.3082253950521037,48.69944806675256,0.4383637503346962],\"storedFields\":{\"0\":{\"h\":\"API网关基础知识总结\"},\"1\":{\"h\":\"什么是网关？\",\"t\":[\"微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。\",\"网关示意图\",\"一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换等功能。\",\"上面介绍了这么多功能，实际上，网关主要做了两件事情：请求转发 + 请求过滤。\",\"由于引入网关之后，会多一步网络转发，因此性能会有一点影响（几乎可以忽略不计，尤其是内网访问的情况下）。 另外，我们需要保障网关服务的高可用，避免单点风险。\",\"如下图所示，网关服务外层通过 Nginx（其他负载均衡设备/软件也行） 进⾏负载转发以达到⾼可⽤。Nginx 在部署的时候，尽量也要考虑高可用，避免单点风险。\",\"基于 Nginx 的服务端负载均衡\"]},\"2\":{\"h\":\"网关能提供哪些功能？\",\"t\":[\"绝大部分网关可以提供下面这些功能（有一些功能需要借助其他框架或者中间件）：\",\"请求转发：将请求转发到目标微服务。\",\"负载均衡：根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡。\",\"安全认证：对用户请求进行身份验证并仅允许可信客户端访问 API，并且还能够使用类似 RBAC 等方式来授权。\",\"参数校验：支持参数映射与校验逻辑。\",\"日志记录：记录所有请求的行为日志供后续使用。\",\"监控告警：从业务指标、机器指标、JVM 指标等方面进行监控并提供配套的告警机制。\",\"流量控制：对请求的流量进行控制，也就是限制某一时刻内的请求数。\",\"熔断降级：实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。\",\"响应缓存：当用户请求获取的是一些静态的或更新不频繁的数据时，一段时间内多次请求获取到的数据很可能是一样的。对于这种情况可以将响应缓存起来。这样用户请求可以直接在网关层得到响应数据，无需再去访问业务服务，减轻业务服务的负担。\",\"响应聚合：某些情况下用户请求要获取的响应内容可能会来自于多个业务服务。网关作为业务服务的调用方，可以把多个服务的响应整合起来，再一并返回给用户。\",\"灰度发布：将请求动态分流到不同的服务版本（最基本的一种灰度发布）。\",\"异常处理：对于业务服务返回的异常响应，可以在网关层在返回给用户之前做转换处理。这样可以把一些业务侧返回的异常细节隐藏，转换成用户友好的错误提示返回。\",\"API 文档： 如果计划将 API 暴露给组织以外的开发人员，那么必须考虑使用 API 文档，例如 Swagger 或 OpenAPI。\",\"协议转换：通过协议转换整合后台基于 REST、AMQP、Dubbo 等不同风格和实现技术的微服务，面向 Web Mobile、开放平台等特定客户端提供统一服务。\",\"证书管理：将 SSL 证书部署到 API 网关，由一个统一的入口管理接口，降低了证书更换时的复杂度。\",\"下图来源于百亿规模 API 网关服务 Shepherd 的设计与实现 - 美团技术团队 - 2021这篇文章。\"]},\"3\":{\"h\":\"有哪些常见的网关系统？\"},\"4\":{\"h\":\"Netflix Zuul\",\"t\":[\"Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务，基于 Java 技术栈开发，可以和 Eureka、Ribbon、Hystrix 等组件配合使用。\",\"Zuul 核心架构如下：\",\"Zuul 核心架构\",\"Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。\",\"Zuul 请求声明周期\",\"我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 spring-cloud-zuul-ratelimit (这里只是举例说明，一般是配合 hystrix 来做限流)：\",\"<dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-zuul</artifactId> </dependency> <dependency> <groupId>com.marcosbarbero.cloud</groupId> <artifactId>spring-cloud-zuul-ratelimit</artifactId> <version>2.2.0.RELEASE</version> </dependency> \",\"Zuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。\",\"Zuul2 架构\",\"GitHub 地址： https://github.com/Netflix/zuul\",\"官方 Wiki： https://github.com/Netflix/zuul/wiki\"]},\"5\":{\"h\":\"Spring Cloud Gateway\",\"t\":[\"SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 Zuul。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。\",\"为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。\",\"Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。\",\"Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。\",\"Github 地址： https://github.com/spring-cloud/spring-cloud-gateway\",\"官网： https://spring.io/projects/spring-cloud-gateway\"]},\"6\":{\"h\":\"OpenResty\",\"t\":[\"根据官方介绍：\",\"OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\",\"OpenResty 和 Nginx 以及 Lua 的关系\",\"OpenResty 基于 Nginx，主要还是看中了其优秀的高并发能力。不过，由于 Nginx 采用 C 语言开发，二次开发门槛较高。如果想在 Nginx 上实现一些自定义的逻辑或功能，就需要编写 C 语言的模块，并重新编译 Nginx。\",\"为了解决这个问题，OpenResty 通过实现 ngx_lua 和 stream_lua 等 Nginx 模块，把 Lua/LuaJIT 完美地整合进了 Nginx，从而让我们能够在 Nginx 内部里嵌入 Lua 脚本，使得可以通过简单的 Lua 语言来扩展网关的功能，比如实现自定义的路由规则、过滤器、缓存策略等。\",\"Lua 是一种非常快速的动态脚本语言，它的运行速度接近于 C 语言。LuaJIT 是 Lua 的一个即时编译器，它可以显著提高 Lua 代码的执行效率。LuaJIT 将一些常用的 Lua 函数和工具库预编译并缓存，这样在下次调用时就可以直接使用缓存的字节码，从而大大加快了执行速度。\",\"关于 OpenResty 的入门以及网关安全实战推荐阅读这篇文章：每个后端都应该了解的 OpenResty 入门以及网关安全实战。\",\"Github 地址： https://github.com/openresty/openresty\",\"官网地址： https://openresty.org/\"]},\"7\":{\"h\":\"Kong\",\"t\":[\"Kong 是一款基于 OpenResty （Nginx + Lua）的高性能、云原生、可扩展、生态丰富的网关系统，主要由 3 个组件组成：\",\"Kong Server：基于 Nginx 的服务器，用来接收 API 请求。\",\"Apache Cassandra/PostgreSQL：用来存储操作数据。\",\"Kong Dashboard：官方推荐 UI 管理工具，当然，也可以使用 RESTful 方式 管理 Admin api。\",\"由于默认使用 Apache Cassandra/PostgreSQL 存储数据，Kong 的整个架构比较臃肿，并且会带来高可用的问题。\",\"Kong 提供了插件机制来扩展其功能，插件在 API 请求响应循环的生命周期中被执行。比如在服务上启用 Zipkin 插件：\",\"$ curl -X POST http://kong:8001/services/{service}/plugins \\\\ --data \\\"name=zipkin\\\" \\\\ --data \\\"config.http_endpoint=http://your.zipkin.collector:9411/api/v2/spans\\\" \\\\ --data \\\"config.sample_ratio=0.001\\\" \",\"Kong 本身就是一个 Lua 应用程序，并且是在 Openresty 的基础之上做了一层封装的应用。归根结底就是利用 Lua 嵌入 Nginx 的方式，赋予了 Nginx 可编程的能力，这样以插件的形式在 Nginx 这一层能够做到无限想象的事情。例如限流、安全访问策略、路由、负载均衡等等。编写一个 Kong 插件，就是按照 Kong 插件编写规范，写一个自己自定义的 Lua 脚本，然后加载到 Kong 中，最后引用即可。\",\"除了 Lua，Kong 还可以基于 Go 、JavaScript、Python 等语言开发插件，得益于对应的 PDK（插件开发工具包）。\",\"关于 Kong 插件的详细介绍，推荐阅读官方文档：https://docs.konghq.com/gateway/latest/kong-plugins/，写的比较详细。\",\"Github 地址： https://github.com/Kong/kong\",\"官网地址： https://konghq.com/kong\"]},\"8\":{\"h\":\"APISIX\",\"t\":[\"APISIX 是一款基于 OpenResty 和 etcd 的高性能、云原生、可扩展的网关系统。\",\"etcd 是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。\",\"与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。\",\"APISIX 架构图\",\"作为 Nginx 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。\",\"根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。\",\"APISIX 同样支持定制化的插件开发。开发者除了能够使用 Lua 语言开发插件，还能通过下面两种方式开发来避开 Lua 语言的学习成本：\",\"通过 Plugin Runner 来支持更多的主流编程语言（比如 Java、Python、Go 等等）。通过这样的方式，可以让后端工程师通过本地 RPC 通信，使用熟悉的编程语言开发 APISIX 的插件。这样做的好处是减少了开发成本，提高了开发效率，但是在性能上会有一些损失。\",\"使用 Wasm（WebAssembly） 开发插件。Wasm 被嵌入到了 APISIX 中，用户可以使用 Wasm 去编译成 Wasm 的字节码在 APISIX 中运行。\",\"Wasm 是基于堆栈的虚拟机的二进制指令格式，一种低级汇编语言，旨在非常接近已编译的机器代码，并且非常接近本机性能。Wasm 最初是为浏览器构建的，但是随着技术的成熟，在服务器端看到了越来越多的用例。\",\"Github 地址：https://github.com/apache/apisix\",\"官网地址： https://apisix.apache.org/zh/\",\"相关阅读：\",\"为什么说 Apache APISIX 是最好的 API 网关？\",\"有了 NGINX 和 Kong，为什么还需要 Apache APISIX\",\"APISIX 技术博客\",\"APISIX 用户案例（推荐）\"]},\"9\":{\"h\":\"Shenyu\",\"t\":[\"Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。\",\"Shenyu 架构\",\"Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发、重写、重定向、和路由监控等插件。\",\"Github 地址： https://github.com/apache/incubator-shenyu\",\"官网地址： https://shenyu.apache.org/\"]},\"10\":{\"h\":\"如何选择？\",\"t\":[\"上面介绍的几个常见的网关系统，最常用的是 Spring Cloud Gateway、Kong、APISIX 这三个。\",\"对于公司业务以 Java 为主要开发语言的情况下，Spring Cloud Gateway 通常是个不错的选择，其优点有：简单易用、成熟稳定、与 Spring Cloud 生态系统兼容、Spring 社区成熟等等。不过，Spring Cloud Gateway 也有一些局限性和不足之处， 一般还需要结合其他网关一起使用比如 OpenResty。并且，其性能相比较于 Kong 和 APISIX，还是差一些。如果对性能要求比较高的话，Spring Cloud Gateway 不是一个好的选择。\",\"Kong 和 APISIX 功能更丰富，性能更强大，技术架构更贴合云原生。Kong 是开源 API 网关的鼻祖，生态丰富，用户群体庞大。APISIX 属于后来者，更优秀一些，根据 APISIX 官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。下面简单对比一下二者：\",\"APISIX 基于 etcd 来做配置中心，不存在单点问题，云原生友好；而 Kong 基于 Apache Cassandra/PostgreSQL ，存在单点风险，需要额外的基础设施保障做高可用。\",\"APISIX 支持热更新，并且实现了毫秒级别的热更新响应；而 Kong 不支持热更新。\",\"APISIX 的性能要优于 Kong 。\",\"APISIX 支持的插件更多，功能更丰富。\"]},\"11\":{\"h\":\"参考\",\"t\":[\"Kong 插件开发教程[通俗易懂]：https://cloud.tencent.com/developer/article/2104299\",\"API 网关 Kong 实战：https://xie.infoq.cn/article/10e4dab2de0bdb6f2c3c93da6\",\"Spring Cloud Gateway 原理介绍和应用：https://blog.fintopia.tech/60e27b0e2078082a378ec5ed/\",\"微服务为什么要用到 API 网关？：https://apisix.apache.org/zh/blog/2023/03/08/why-do-microservices-need-an-api-gateway/\",\"File not found\"]},\"12\":{\"c\":[\"分布式\"]},\"13\":{\"h\":\"分布式配置中心常见问题总结(付费)\",\"t\":[\"分布式配置中心 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。\",\"File not found\",\"File not found\"]},\"14\":{\"c\":[\"分布式\"]},\"15\":{\"h\":\"分布式ID设计指南\",\"t\":[\"提示\",\"看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：分布式 ID 生成服务的技术原理和项目实战 。\",\"网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。\",\"本文结合一些使用场景，进一步探讨业务场景中对 ID 有哪些具体的要求。\"]},\"16\":{\"h\":\"场景一：订单系统\",\"t\":[\"我们在商场买东西一码付二维码，下单生成的订单号，使用到的优惠券码，联合商品兑换券码，这些是在网上购物经常使用到的单号，那么为什么有些单号那么长，有些只有几位数？有些单号一看就知道年月日的信息，有些却看不出任何意义？下面展开分析下订单系统中不同场景的 id 服务的具体实现。\"]},\"17\":{\"h\":\"1、一码付\",\"t\":[\"我们常见的一码付，指的是一个二维码可以使用支付宝或者微信进行扫码支付。\",\"二维码的本质是一个字符串。聚合码的本质就是一个链接地址。用户使用支付宝微信直接扫一个码付钱，不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码，这极大减少了用户扫码支付的时间。\",\"实现原理是当客户用 APP 扫码后，网站后台就会判断客户的扫码环境。（微信、支付宝、QQ 钱包、京东支付、云闪付等）。\",\"判断扫码环境的原理就是根据打开链接浏览器的 HTTP header。任何浏览器打开 http 链接时，请求的 header 都会有 User-Agent(UA、用户代理)信息。\",\"UA 是一个特殊字符串头，服务器依次可以识别出客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等很多信息。\",\"各渠道对应支付产品的名称不一样，一定要仔细看各支付产品的 API 介绍。\",\"微信支付：JSAPI 支付支付\",\"支付宝：手机网站支付\",\"QQ 钱包：公众号支付\",\"其本质均为在 APP 内置浏览器中实现 HTML5 支付。\",\"文库会员支付示例\",\"文库的研发同学在这个思路上，做了优化迭代。动态生成一码付的二维码预先绑定用户所选的商品信息和价格，根据用户所选的商品动态更新。这样不仅支持一码多平台调起支付，而且不用用户选择商品输入金额，即可完成订单支付的功能，很丝滑。用户在真正扫码后，服务端才通过前端获取用户 UID，结合二维码绑定的商品信息，真正的生成订单，发送支付信息到第三方（qq、微信、支付宝），第三方生成支付订单推给用户设备，从而调起支付。\",\"区别于固定的一码付，在文库的应用中，使用到了动态二维码，二维码本质是一个短网址，ID 服务提供短网址的唯一标志参数。唯一的短网址映射的 ID 绑定了商品的订单信息，技术和业务的深度结合，缩短了支付流程，提升用户的支付体验。\"]},\"18\":{\"h\":\"2、订单号\",\"t\":[\"订单号在实际的业务过程中作为一个订单的唯一标识码存在，一般实现以下业务场景：\",\"用户订单遇到问题，需要找客服进行协助；\",\"对订单进行操作，如线下收款，订单核销；\",\"下单，改单，成单，退单，售后等系统内部的订单流程处理和跟进。\",\"很多时候搜索订单相关信息的时候都是以订单 ID 作为唯一标识符，这是由于订单号的生成规则的唯一性决定的。从技术角度看，除了 ID 服务必要的特性之外，在订单号的设计上需要体现几个特性：\",\"（1）信息安全\",\"编号不能透露公司的运营情况，比如日销、公司流水号等信息，以及商业信息和用户手机号，身份证等隐私信息。并且不能有明显的整体规律（可以有局部规律），任意修改一个字符就能查询到另一个订单信息，这也是不允许的。\",\"类比于我们高考时候的考生编号的生成规则，一定不能是连号的，否则只需要根据顺序往下查询就能搜索到别的考生的成绩，这是绝对不可允许。\",\"（2）部分可读\",\"位数要便于操作，因此要求订单号的位数适中，且局部有规律。这样可以方便在订单异常，或者退货时客服查询。\",\"过长的订单号或易读性差的订单号会导致客服输入困难且易错率较高，影响用户体验的售后体验。因此在实际的业务场景中，订单号的设计通常都会适当携带一些允许公开的对使用场景有帮助的信息，如时间，星期，类型等等，这个主要根据所涉及的编号对应的使用场景来。\",\"而且像时间、星期这些自增长的属于作为订单号的设计的一部分元素，有助于解决业务累积而导致的订单号重复的问题。\",\"（3）查询效率\",\"常见的电商平台订单号大多是纯数字组成，兼具可读性的同时，int 类型相对 varchar 类型的查询效率更高，对在线业务更加友好。\"]},\"19\":{\"h\":\"3、优惠券和兑换券\",\"t\":[\"优惠券、兑换券是运营推广最常用的促销工具之一，合理使用它们，可以让买家得到实惠，商家提升商品销量。常见场景有：\",\"在文库购买【文库 VIP+QQ 音乐年卡】联合商品，支付成功后会得到 QQ 音乐年卡的兑换码，可以去 QQ 音乐 App 兑换音乐会员年卡；\",\"疫情期间，部分地方政府发放的消费券；\",\"瓶装饮料经常会出现输入优惠编码兑换奖品。\",\"优惠编码兑换奖品\",\"从技术角度看，有些场景适合 ID 即时生成，比如电商平台购物领取的优惠券，只需要在用户领取时分配优惠券信息即可。有些线上线下结合的场景，比如疫情优惠券，瓶盖开奖，京东卡，超市卡这种，则需要预先生成，预先生成的券码具备以下特性：\",\"1.预先生成，在活动正式开始前提供出来进行活动预热；\",\"2.优惠券体量大，以万为单位，通常在 10 万级别以上；\",\"3.不可破解、仿制券码；\",\"4.支持用后核销；\",\"5.优惠券、兑换券属于广撒网的策略，所以利用率低，也就不适合使用数据库进行存储 （占空间，有效的数据又少）。\",\"设计思路上，需要设计一种有效的兑换码生成策略，支持预先生成，支持校验，内容简洁，生成的兑换码都具有唯一性，那么这种策略就是一种特殊的编解码策略，按照约定的编解码规则支撑上述需求。\",\"既然是一种编解码规则，那么需要约定编码空间(也就是用户看到的组成兑换码的字符)，编码空间由字符 a-z,A-Z,数字 0-9 组成，为了增强兑换码的可识别度，剔除大写字母 O 以及 I,可用字符如下所示，共 60 个字符：\",\"abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXZY0123456789\",\"之前说过，兑换码要求近可能简洁，那么设计时就需要考虑兑换码的字符数，假设上限为 12 位，而字符空间有 60 位，那么可以表示的空间范围为 60^12=130606940160000000000000(也就是可以 12 位的兑换码可以生成天量,应该够运营同学挥霍了)，转换成 2 进制：\",\"1001000100000000101110011001101101110011000000000000000000000(61 位)\",\"兑换码组成成分分析\",\"兑换码可以预先生成，并且不需要额外的存储空间保存这些信息，每一个优惠方案都有独立的一组兑换码(指运营同学组织的每一场运营活动都有不同的兑换码,不能混合使用, 例如双 11 兑换码不能使用在双 12 活动上)，每个兑换码有自己的编号，防止重复，为了保证兑换码的有效性，对兑换码的数据需要进行校验，当前兑换码的数据组成如下所示：\",\"优惠方案 ID + 兑换码序列号 i + 校验码\",\"编码方案\",\"兑换码序列号 i，代表当前兑换码是当前活动中第 i 个兑换码，兑换码序列号的空间范围决定了优惠活动可以发行的兑换码数目，当前采用 30 位 bit 位表示，可表示范围：1073741824（10 亿个券码）。\",\"优惠方案 ID, 代表当前优惠方案的 ID 号，优惠方案的空间范围决定了可以组织的优惠活动次数，当前采用 15 位表示，可以表示范围：32768（考虑到运营活动的频率，以及 ID 的初始值 10000，15 位足够，365 天每天有运营活动，可以使用 54 年）。\",\"校验码，校验兑换码是否有效，主要为了快捷的校验兑换码信息的是否正确，其次可以起到填充数据的目的，增强数据的散列性，使用 13 位表示校验位，其中分为两部分，前 6 位和后 7 位。\",\"深耕业务还会有区分通用券和单独券的情况，分别具备以下特点，技术实现需要因地制宜地思考。\",\"通用券：多个玩家都可以输入兑换，然后有总量限制，期限限制。\",\"单独券：运营同学可以在后台设置兑换码的奖励物品、期限、个数，然后由后台生成兑换码的列表，兑换之后核销。\"]},\"20\":{\"h\":\"场景二：Tracing\"},\"21\":{\"h\":\"1、日志跟踪\",\"t\":[\"在分布式服务架构下，一个 Web 请求从网关流入，有可能会调用多个服务对请求进行处理，拿到最终结果。这个过程中每个服务之间的通信又是单独的网络请求，无论请求经过的哪个服务出了故障或者处理过慢都会对前端造成影响。\",\"处理一个 Web 请求要调用的多个服务，为了能更方便的查询哪个环节的服务出现了问题，现在常用的解决方案是为整个系统引入分布式链路跟踪。\",\"在分布式链路跟踪\",\"在分布式链路跟踪中有两个重要的概念：跟踪（trace）和 跨度（ span)。trace 是请求在分布式系统中的整个链路视图，span 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。\",\"在整个请求的调用链中，请求会一直携带 traceid 往下游服务传递，每个服务内部也会生成自己的 spanid 用于生成自己的内部调用视图，并和 traceid 一起传递给下游服务。\"]},\"22\":{\"h\":\"2、TraceId 生成规则\",\"t\":[\"这种场景下，生成的 ID 除了要求唯一之外，还要求生成的效率高、吞吐量大。traceid 需要具备接入层的服务器实例自主生成的能力，如果每个 trace 中的 ID 都需要请求公共的 ID 服务生成，纯纯的浪费网络带宽资源。且会阻塞用户请求向下游传递，响应耗时上升，增加了没必要的风险。所以需要服务器实例最好可以自行计算 tracid，spanid，避免依赖外部服务。\",\"产生规则：服务器 IP + ID 产生的时间 + 自增序列 + 当前进程号 ，比如：\",\"0ad1348f1403169275002100356696\",\"前 8 位 0ad1348f 即产生 TraceId 的机器的 IP，这是一个十六进制的数字，每两位代表 IP 中的一段，我们把这个数字，按每两位转成 10 进制即可得到常见的 IP 地址表示方式 10.209.52.143，您也可以根据这个规律来查找到请求经过的第一个服务器。\",\"后面的 13 位 1403169275002 是产生 TraceId 的时间。之后的 4 位 1003 是一个自增的序列，从 1000 涨到 9000，到达 9000 后回到 1000 再开始往上涨。最后的 5 位 56696 是当前的进程 ID，为了防止单机多进程出现 TraceId 冲突的情况，所以在 TraceId 末尾添加了当前的进程 ID。\"]},\"23\":{\"h\":\"3、SpanId 生成规则\",\"t\":[\"span 是层的意思，比如在第一个实例算是第一层， 请求代理或者分流到下一个实例处理，就是第二层，以此类推。通过层，SpanId 代表本次调用在整个调用链路树中的位置。\",\"假设一个 服务器实例 A 接收了一次用户请求，代表是整个调用的根节点，那么 A 层处理这次请求产生的非服务调用日志记录 spanid 的值都是 0，A 层需要通过 RPC 依次调用 B、C、D 三个服务器实例，那么在 A 的日志中，SpanId 分别是 0.1，0.2 和 0.3，在 B、C、D 中，SpanId 也分别是 0.1，0.2 和 0.3；如果 C 系统在处理请求的时候又调用了 E，F 两个服务器实例，那么 C 系统中对应的 spanid 是 0.2.1 和 0.2.2，E、F 两个系统对应的日志也是 0.2.1 和 0.2.2。\",\"根据上面的描述可以知道，如果把一次调用中所有的 SpanId 收集起来，可以组成一棵完整的链路树。\",\"spanid 的生成本质：在跨层传递透传的同时，控制大小版本号的自增来实现的。\"]},\"24\":{\"h\":\"场景三：短网址\",\"t\":[\"短网址主要功能包括网址缩短与还原两大功能。相对于长网址，短网址可以更方便地在电子邮件，社交网络，微博和手机上传播，例如原来很长的网址通过短网址服务即可生成相应的短网址，避免折行或超出字符限制。\",\"短网址作用\",\"常用的 ID 生成服务比如：MySQL ID 自增、 Redis 键自增、号段模式，生成的 ID 都是一串数字。短网址服务把客户的长网址转换成短网址，\",\"实际是在 dwz.cn 域名后面拼接新产生的数字类型 ID，直接用数字 ID，网址长度也有些长，服务可以通过数字 ID 转更高进制的方式压缩长度。这种算法在短网址的技术实现上越来越多了起来，它可以进一步压缩网址长度。转进制的压缩算法在生活中有广泛的应用场景，举例：\",\"客户的长网址：https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner\",\"ID 映射的短网址：https://dwz.cn/2047601319t66 (演示使用，可能无法正确打开)\",\"转进制后的短网址：https://dwz.cn/2ezwDJ0 (演示使用，可能无法正确打开)\",\"File not found\"]},\"25\":{\"c\":[\"分布式\"]},\"26\":{\"h\":\"分布式ID介绍&实现方案总结\"},\"27\":{\"h\":\"分布式 ID 介绍\"},\"28\":{\"h\":\"什么是 ID？\",\"t\":[\"日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。\",\"我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应\",\"简单来说，ID 就是数据的唯一标识。\"]},\"29\":{\"h\":\"什么是分布式 ID？\",\"t\":[\"分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。\",\"我简单举一个分库分表的例子。\",\"我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。\",\"在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？\",\"这个时候就需要生成分布式 ID了。\"]},\"30\":{\"h\":\"分布式 ID 需要满足哪些要求?\",\"t\":[\"分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。\",\"一个最基本的分布式 ID 需要满足下面这些要求：\",\"全局唯一：ID 的全局唯一性肯定是首先要满足的！\",\"高性能：分布式 ID 的生成速度要快，对本地资源消耗要小。\",\"高可用：生成分布式 ID 的服务要保证可用性无限接近于 100%。\",\"方便易用：拿来即用，使用方便，快速接入！\",\"除了这些之外，一个比较好的分布式 ID 还应保证：\",\"安全：ID 中不包含敏感信息。\",\"有序递增：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。\",\"有具体的业务含义：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。\",\"独立部署：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。\"]},\"31\":{\"h\":\"分布式 ID 常见解决方案\"},\"32\":{\"h\":\"数据库\"},\"33\":{\"h\":\"数据库主键自增\",\"t\":[\"这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。\",\"数据库主键自增\",\"以 MySQL 举例，我们通过下面的方式即可。\",\"1.创建一个数据库表。\",\"CREATE TABLE `sequence_id` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `stub` char(10) NOT NULL DEFAULT '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \",\"stub 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 stub 字段创建了唯一索引，保证其唯一性。\",\"2.通过 replace into 来插入数据。\",\"BEGIN; REPLACE INTO sequence_id (stub) VALUES ('stub'); SELECT LAST_INSERT_ID(); COMMIT; \",\"插入数据这里，我们没有使用 insert into 而是使用 replace into 来插入数据，具体步骤是这样的：\",\"第一步：尝试把数据插入到表中。\",\"第二步：如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。\",\"这种方式的优缺点也比较明显：\",\"优点：实现起来比较简单、ID 有序递增、存储消耗空间小\",\"缺点：支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）\"]},\"34\":{\"h\":\"数据库号段模式\",\"t\":[\"数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。\",\"如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 基于数据库的号段模式来生成分布式 ID。\",\"数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的Tinyid 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。\",\"以 MySQL 举例，我们通过下面的方式即可。\",\"1. 创建一个数据库表。\",\"CREATE TABLE `sequence_id_generator` ( `id` int(10) NOT NULL, `current_max_id` bigint(20) NOT NULL COMMENT '当前最大id', `step` int(10) NOT NULL COMMENT '号段的长度', `version` int(20) NOT NULL COMMENT '版本号', `biz_type` int(20) NOT NULL COMMENT '业务类型', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; \",\"current_max_id 字段和step字段主要用于获取批量 ID，获取的批量 id 为：current_max_id ~ current_max_id+step。\",\"数据库号段模式\",\"version 字段主要用于解决并发问题（乐观锁）,biz_type 主要用于表示业务类型。\",\"2. 先插入一行数据。\",\"INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`) VALUES (1, 0, 100, 0, 101); \",\"3. 通过 SELECT 获取指定业务下的批量唯一 ID\",\"SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101 \",\"结果：\",\"id current_max_id step version biz_type 1 0 100 0 101 \",\"4. 不够用的话，更新之后重新 SELECT 即可。\",\"UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0 AND `biz_type` = 101 SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101 \",\"结果：\",\"id current_max_id step version biz_type 1 100 100 1 101 \",\"相比于数据库主键自增的方式，数据库的号段模式对于数据库的访问次数更少，数据库压力更小。\",\"另外，为了避免单点问题，你可以从使用主从模式来提高可用性。\",\"数据库号段模式的优缺点:\",\"优点：ID 有序递增、存储消耗空间小\",\"缺点：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）\"]},\"35\":{\"h\":\"NoSQL\",\"t\":[\"一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 incr 命令即可实现对 id 原子顺序递增。\",\"127.0.0.1:6379> set sequence_id_biz_type 1 OK 127.0.0.1:6379> incr sequence_id_biz_type (integer) 2 127.0.0.1:6379> get sequence_id_biz_type \\\"2\\\" \",\"为了提高可用性和并发，我们可以使用 Redis Cluster。Redis Cluster 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。\",\"除了 Redis Cluster 之外，你也可以使用开源的 Redis 集群方案Codis （大规模集群比如上百个节点的时候比较推荐）。\",\"除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：快照（snapshotting，RDB）、只追加文件（append-only file, AOF）。 并且，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\",\"关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 JavaGuide 对于 Redis 知识点的总结。\",\"Redis 方案的优缺点：\",\"优点：性能不错并且生成的 ID 是有序递增的\",\"缺点：和数据库主键自增方案的缺点类似\",\"除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。\",\"MongoDB ObjectId 一共需要 12 个字节存储：\",\"0~3：时间戳\",\"3~6：代表机器 ID\",\"7~8：机器进程 ID\",\"9~11：自增值\",\"MongoDB 方案的优缺点：\",\"优点：性能不错并且生成的 ID 是有序递增的\",\"缺点：需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）、有安全性问题（ID 生成有规律性）\"]},\"36\":{\"h\":\"算法\"},\"37\":{\"h\":\"UUID\",\"t\":[\"UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。\",\"JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。\",\"//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa UUID.randomUUID() \",\"RFC 4122 中关于 UUID 的示例是这样的：\",\"我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。\",\"5 种不同的 Version(版本)值分别对应的含义（参考维基百科对于 UUID 的介绍）：\",\"版本 1 : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；\",\"版本 2 : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；\",\"版本 3、版本 5 : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；\",\"版本 4 : UUID 使用随机性或伪随机性生成。\",\"下面是 Version 1 版本下生成的 UUID 的示例：\",\"Version 1 版本下生成的 UUID 的示例\",\"JDK 中通过 UUID 的 randomUUID() 方法生成的 UUID 的版本默认为 4。\",\"UUID uuid = UUID.randomUUID(); int version = uuid.version();// 4 \",\"另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。\",\"需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。\",\"从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。\",\"虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。\",\"比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：\",\"数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。\",\"UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。\",\"最后，我们再简单分析一下 UUID 的优缺点 （面试的时候可能会被问到的哦！） :\",\"优点：生成速度比较快、简单易用\",\"缺点：存储消耗空间大（32 个字符串，128 位）、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）\"]},\"38\":{\"h\":\"Snowflake(雪花算法)\",\"t\":[\"Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：\",\"第 0 位：符号位（标识正负），始终为 0，没有用，不用管。\",\"第 1~41 位：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）\",\"第 42~52 位：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。\",\"第 53~64 位：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。\",\"Snowflake 示意图\",\"如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。\",\"另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。\",\"我们再来看看 Snowflake 算法的优缺点：\",\"优点：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）\",\"缺点：需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。\"]},\"39\":{\"h\":\"开源框架\"},\"40\":{\"h\":\"UidGenerator(百度)\",\"t\":[\"UidGenerator 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。\",\"不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。\",\"可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。\",\"UidGenerator 官方文档中的介绍如下：\",\"自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 UidGenerator 的官方介绍。\"]},\"41\":{\"h\":\"Leaf(美团)\",\"t\":[\"Leaf 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！\",\"Leaf 提供了 号段模式 和 Snowflake(雪花算法) 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。\",\"Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。\",\"Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：《Leaf——美团点评分布式 ID 生成系统》）。\",\"根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。\"]},\"42\":{\"h\":\"Tinyid(滴滴)\",\"t\":[\"Tinyid 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。\",\"数据库号段模式的原理我们在上面已经介绍过了。Tinyid 有哪些亮点呢？\",\"为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:《Tinyid 原理介绍》）\",\"在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。\",\"这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：\",\"获取新号段的情况下，程序获取唯一 ID 的速度比较慢。\",\"需要保证 DB 高可用，这个是比较麻烦且耗费资源的。\",\"除此之外，HTTP 调用也存在网络开销。\",\"Tinyid 的原理比较简单，其架构如下图所示：\",\"相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：\",\"双号段缓存：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。\",\"增加多 db 支持：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。\",\"增加 tinyid-client：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。\",\"Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。\"]},\"43\":{\"h\":\"总结\",\"t\":[\"通过这篇文章，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。\",\"除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。没有银弹，一定要结合实际项目来选择最适合自己的方案。\",\"不过，本文主要介绍的是分布式 ID 的理论知识。在实际的面试中，面试官可能会结合具体的业务场景来考察你对分布式 ID 的设计，你可以参考这篇文章：分布式 ID 设计指南（对于实际工作中分布式 ID 的设计也非常有帮助）。\",\"File not found\"]},\"44\":{\"c\":[\"分布式\"]},\"45\":{\"h\":\"分布式锁常见实现方案总结\",\"t\":[\"File not found\",\"通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。\"]},\"46\":{\"h\":\"基于 Redis 实现分布式锁\"},\"47\":{\"h\":\"如何基于 Redis 实现一个最简易的分布式锁？\",\"t\":[\"不论是本地锁还是分布式锁，核心都在于“互斥”。\",\"在 Redis 中， SETNX 命令是可以帮助我们实现互斥。SETNX 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， SETNX 啥也不做。\",\"> SETNX lockKey uniqueValue (integer) 1 > SETNX lockKey uniqueValue (integer) 0 \",\"释放锁的话，直接通过 DEL 命令删除对应的 key 即可。\",\"> DEL lockKey (integer) 1 \",\"为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。\",\"选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。\",\"// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放 if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end \",\"Redis 实现简易分布式锁\",\"这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。\"]},\"48\":{\"h\":\"为什么要给锁设置一个过期时间？\",\"t\":[\"为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间 。\",\"127.0.0.1:6379> SET lockKey uniqueValue EX 3 NX OK \",\"lockKey：加锁的锁名；\",\"uniqueValue：能够唯一标示锁的随机字符串；\",\"NX：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；\",\"EX：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。\",\"一定要保证设置指定 key 的值和过期时间是一个原子操作！！！ 不然的话，依然可能会出现锁无法被释放的问题。\",\"这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。\",\"你或许在想：如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！\"]},\"49\":{\"h\":\"如何实现锁的优雅续期？\",\"t\":[\"对于 Java 开发的小伙伴来说，已经有了现成的解决方案：Redisson 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。\",\"Distributed locks with Redis\",\"Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。\",\"Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。\",\"Redisson 看门狗自动续期\",\"看门狗名字的由来于 getLockWatchdogTimeout() 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（redisson-3.17.6）。\",\"//默认 30秒，支持修改 private long lockWatchdogTimeout = 30 * 1000; public Config setLockWatchdogTimeout(long lockWatchdogTimeout) { this.lockWatchdogTimeout = lockWatchdogTimeout; return this; } public long getLockWatchdogTimeout() { return lockWatchdogTimeout; } \",\"renewExpiration() 方法包含了看门狗的主要逻辑：\",\"private void renewExpiration() { //...... Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { //...... // 异步续期，基于 Lua 脚本 CompletionStage<Boolean> future = renewExpirationAsync(threadId); future.whenComplete((res, e) -> { if (e != null) { // 无法续期 log.error(\\\"Can't update lock \\\" + getRawName() + \\\" expiration\\\", e); EXPIRATION_RENEWAL_MAP.remove(getEntryName()); return; } if (res) { // 递归调用实现续期 renewExpiration(); } else { // 取消续期 cancelExpirationRenewal(null); } }); } // 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用 }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); ee.setTimeout(task); } \",\"默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。\",\"Watch Dog 通过调用 renewExpirationAsync() 方法实现锁的异步续期：\",\"protected CompletionStage<Boolean> renewExpirationAsync(long threadId) { return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, // 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认） \\\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \\\" + \\\"redis.call('pexpire', KEYS[1], ARGV[1]); \\\" + \\\"return 1; \\\" + \\\"end; \\\" + \\\"return 0;\\\", Collections.singletonList(getRawName()), internalLockLeaseTime, getLockName(threadId)); } \",\"可以看出， renewExpirationAsync 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。\",\"我这里以 Redisson 的分布式可重入锁 RLock 为例来说明如何使用 Redisson 实现分布式锁：\",\"// 1.获取指定的分布式锁对象 RLock lock = redisson.getLock(\\\"lock\\\"); // 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制 lock.lock(); // 3.执行业务 ... // 4.释放锁 lock.unlock(); \",\"只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。\",\"// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制 lock.lock(10, TimeUnit.SECONDS); \",\"如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。\"]},\"50\":{\"h\":\"如何实现可重入锁？\",\"t\":[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。\",\"不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。\",\"可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。\",\"实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 Redisson ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。\"]},\"51\":{\"h\":\"Redis 如何解决集群情况下分布式锁的可靠性？\",\"t\":[\"为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。\",\"Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。\",\"针对这个问题，Redis 之父 antirez 设计了 Redlock 算法 来解决。\",\"Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\",\"即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。\",\"Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。\",\"Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（How to do distributed locking - Martin Kleppmann - 2016）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看Redis 锁从面试连环炮聊到神仙打架这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。\",\"实际项目中不建议使用 Redlock 算法，成本和收益不成正比。\",\"如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。\"]},\"52\":{\"h\":\"基于 ZooKeeper 实现分布式锁\",\"t\":[\"Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。\"]},\"53\":{\"h\":\"如何基于 ZooKeeper 实现分布式锁？\",\"t\":[\"ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的。\",\"获取锁：\",\"首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。\",\"假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。\",\"如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。\",\"如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。\",\"释放锁：\",\"成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。\",\"成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。\",\"我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。\",\"实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\",\"Curator主要实现了下面四种锁：\",\"InterProcessMutex：分布式可重入排它锁\",\"InterProcessSemaphoreMutex：分布式不可重入排它锁\",\"InterProcessReadWriteLock：分布式读写锁\",\"InterProcessMultiLock：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。\",\"CuratorFramework client = ZKUtils.getClient(); client.start(); // 分布式可重入排它锁 InterProcessLock lock1 = new InterProcessMutex(client, lockPath1); // 分布式不可重入排它锁 InterProcessLock lock2 = new InterProcessSemaphoreMutex(client, lockPath2); // 将多个锁作为一个整体 InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(lock1, lock2)); if (!lock.acquire(10, TimeUnit.SECONDS)) { throw new IllegalStateException(\\\"不能获取多锁\\\"); } System.out.println(\\\"已获取多锁\\\"); System.out.println(\\\"是否有第一个锁: \\\" + lock1.isAcquiredInThisProcess()); System.out.println(\\\"是否有第二个锁: \\\" + lock2.isAcquiredInThisProcess()); try { // 资源操作 resource.use(); } finally { System.out.println(\\\"释放多个锁\\\"); lock.release(); } System.out.println(\\\"是否有第一个锁: \\\" + lock1.isAcquiredInThisProcess()); System.out.println(\\\"是否有第二个锁: \\\" + lock2.isAcquiredInThisProcess()); client.close(); \"]},\"54\":{\"h\":\"为什么要用临时顺序节点？\",\"t\":[\"每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。\",\"我们通常是将 znode 分为 4 大类：\",\"持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\",\"临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\",\"持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\",\"临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\",\"可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。\",\"使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。\",\"假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。\"]},\"55\":{\"h\":\"为什么要设置对前一个节点的监听？\",\"t\":[\"Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\",\"同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。\",\"这个事件监听器的作用是：当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 wait/notifyAll ），让它尝试去获取锁，然后就成功获取锁了。\"]},\"56\":{\"h\":\"如何实现可重入锁？\",\"t\":[\"这里以 Curator 的 InterProcessMutex 对可重入锁的实现来介绍（源码地址：InterProcessMutex.java）。\",\"当我们调用 InterProcessMutex#acquire方法获取锁的时候，会调用InterProcessMutex#internalLock方法。\",\"// 获取可重入互斥锁，直到获取成功为止 @Override public void acquire() throws Exception { if (!internalLock(-1, null)) { throw new IOException(\\\"Lost connection while trying to acquire lock: \\\" + basePath); } } \",\"internalLock 方法会先获取当前请求锁的线程，然后从 threadData( ConcurrentMap<Thread, LockData> 类型)中获取当前线程对应的 lockData 。 lockData 包含锁的信息和加锁的次数，是实现可重入锁的关键。\",\"第一次获取锁的时候，lockData为 null。获取锁成功之后，会将当前线程和对应的 lockData 放到 threadData 中\",\"private boolean internalLock(long time, TimeUnit unit) throws Exception { // 获取当前请求锁的线程 Thread currentThread = Thread.currentThread(); // 拿对应的 lockData LockData lockData = threadData.get(currentThread); // 第一次获取锁的话，lockData 为 null if (lockData != null) { // 当前线程获取过一次锁之后 // 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入. lockData.lockCount.incrementAndGet(); return true; } // 尝试获取锁 String lockPath = internals.attemptLock(time, unit, getLockNodeBytes()); if (lockPath != null) { LockData newLockData = new LockData(currentThread, lockPath); // 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中 threadData.put(currentThread, newLockData); return true; } return false; } \",\"LockData是 InterProcessMutex中的一个静态内部类。\",\"private final ConcurrentMap<Thread, LockData> threadData = Maps.newConcurrentMap(); private static class LockData { // 当前持有锁的线程 final Thread owningThread; // 锁对应的子节点 final String lockPath; // 加锁的次数 final AtomicInteger lockCount = new AtomicInteger(1); private LockData(Thread owningThread, String lockPath) { this.owningThread = owningThread; this.lockPath = lockPath; } } \",\"如果已经获取过一次锁，后面再来获取锁的话，直接就会在 if (lockData != null) 这里被拦下了，然后就会执行lockData.lockCount.incrementAndGet(); 将加锁次数加 1。\",\"整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。\"]},\"57\":{\"h\":\"总结\",\"t\":[\"这篇文章我们介绍了实现分布式锁的两种常见方式。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。如果对性能要求比较高的话，建议使用 Redis 实现分布式锁。如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁。\",\"File not found\"]},\"58\":{\"c\":[\"分布式\"]},\"59\":{\"h\":\"分布式锁介绍\",\"t\":[\"File not found\",\"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。\",\"这篇文章我们先介绍一下分布式锁的基本概念。\"]},\"60\":{\"h\":\"为什么需要分布式锁？\",\"t\":[\"在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。\",\"举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：\",\"线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。\",\"线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。\",\"线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。\",\"线程 1 继续执行，将库存数量减少 1 个，然后返回成功。\",\"线程 2 继续执行，将库存数量减少 1 个，然后返回成功。\",\"此时就发生了超卖问题，导致商品被多卖了一份。\",\"共享资源未互斥访问导致出现问题\",\"为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。\",\"如何才能实现共享资源的互斥访问呢？ 锁是一个比较通用的解决方案，更准确点来说是悲观锁。\",\"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\",\"对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。\",\"下面是我对本地锁画的一张示意图。\",\"本地锁\",\"从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。\",\"分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，分布式锁 就诞生了。\",\"举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。\",\"下面是我对分布式锁画的一张示意图。\",\"分布式锁\",\"从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。\"]},\"61\":{\"h\":\"分布式锁应该具备哪些条件？\",\"t\":[\"一个最基本的分布式锁需要满足：\",\"互斥：任意一个时刻，锁只能被一个线程持有。\",\"高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。\",\"可重入：一个节点获取了锁之后，还可以再次获取锁。\",\"除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：\",\"高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。\",\"非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。\"]},\"62\":{\"h\":\"分布式锁的常见实现方式有哪些？\",\"t\":[\"常见分布式锁实现方案如下：\",\"基于关系型数据库比如 MySQL 实现分布式锁。\",\"基于分布式协调服务 ZooKeeper 实现分布式锁。\",\"基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。\",\"关系型数据库的方式一般是通过唯一索引或者排他锁实现。不过，一般不会使用这种方式，问题太多比如性能太差、不具备锁失效机制。\",\"基于 ZooKeeper 或者 Redis 实现分布式锁这两种实现方式要用的更多一些，我专门写了一篇文章来详细介绍这两种方案：分布式锁常见实现方案总结。\"]},\"63\":{\"h\":\"总结\",\"t\":[\"这篇文章我们主要介绍了：\",\"分布式锁的用途：分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。\",\"分布式锁的应该具备的条件：互斥、高可用、可重入、高性能、非阻塞。\",\"分布式锁的常见实现方式：关系型数据库比如 MySQL、分布式协调服务 ZooKeeper、分布式键值存储系统比如 Redis 、Etcd 。\",\"File not found\"]},\"64\":{\"c\":[\"分布式\"]},\"65\":{\"h\":\"分布式事务常见解决方案总结(付费)\",\"t\":[\"分布式事务 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。\",\"File not found\",\"File not found\"]},\"66\":{\"c\":[\"分布式\"]},\"67\":{\"h\":\"Spring Cloud Gateway常见问题总结\",\"t\":[\"本文重构完善自6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构这篇文章。\"]},\"68\":{\"h\":\"什么是 Spring Cloud Gateway？\",\"t\":[\"Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 Zuul。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。\",\"为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。\",\"Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。\",\"Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。\",\"GitHub 地址： https://github.com/spring-cloud/spring-cloud-gateway\",\"官网： https://spring.io/projects/spring-cloud-gateway\"]},\"69\":{\"h\":\"Spring Cloud Gateway 的工作流程？\",\"t\":[\"Spring Cloud Gateway 的工作流程如下图所示：\",\"Spring Cloud Gateway 的工作流程\",\"这是 Spring 官方博客中的一张图，原文地址：https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter。\",\"具体的流程分析：\",\"路由判断：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。\",\"请求过滤：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。\",\"服务处理：后端服务会对请求进行处理。\",\"响应过滤：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。\",\"响应返回：响应经过过滤处理后，返回给客户端。\",\"总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。\"]},\"70\":{\"h\":\"Spring Cloud Gateway 的断言是什么？\",\"t\":[\"断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。\",\"在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。\",\"断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 api/thirdparty，就匹配到了第一个路由 route_thirdparty。\",\"断言配置示例\",\"常见的路由断言规则如下图所示：\",\"Spring Cloud GateWay 路由断言规则\"]},\"71\":{\"h\":\"Spring Cloud Gateway 的路由和断言是什么关系？\",\"t\":[\"Route 路由和 Predicate 断言的对应关系如下：：\",\"路由和断言的对应关系\",\"一对多：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。\",\"同时满足：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。\",\"第一个匹配成功：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。\"]},\"72\":{\"h\":\"Spring Cloud Gateway 如何实现动态路由？\",\"t\":[\"在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。\",\"Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。\",\"实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 注册中心来做。 Spring Cloud Gateway 可以从注册中心获取服务的元数据（例如服务名称、路径等），然后根据这些信息自动生成路由规则。这样，当你添加、移除或更新服务实例时，网关会自动感知并相应地调整路由规则，无需手动维护路由配置。\",\"其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址：https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config 。\"]},\"73\":{\"h\":\"Spring Cloud Gateway 的过滤器有哪些？\",\"t\":[\"过滤器 Filter 按照请求和响应可以分为两种：\",\"Pre 类型：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。\",\"Post 类型：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。\",\"另外一种分类是按照过滤器 Filter 作用的范围进行划分：\",\"GatewayFilter：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。\",\"GlobalFilter：全局过滤器，应用在所有路由上的过滤器。\"]},\"74\":{\"h\":\"局部过滤器\",\"t\":[\"常见的局部过滤器如下图所示：\",\"具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。\",\"filters: #过滤器 - RewritePath=/api/(?<segment>.*),/$\\\\{segment} # 将跳转路径中包含的 “api” 替换成空 \",\"当然我们也可以自定义过滤器，本篇不做展开。\"]},\"75\":{\"h\":\"全局过滤器\",\"t\":[\"常见的全局过滤器如下图所示：\",\"全局过滤器最常见的用法是进行负载均衡。配置如下所示：\",\"spring: cloud: gateway: routes: - id: route_member # 第三方微服务路由规则 uri: lb://passjava-member # 负载均衡，将请求转发到注册中心注册的 passjava-member 服务 predicates: # 断言 - Path=/api/member/** # 如果前端请求路径包含 api/member，则应用这条路由规则 filters: #过滤器 - RewritePath=/api/(?<segment>.*),/$\\\\{segment} # 将跳转路径中包含的api替换成空 \",\"这里有个关键字 lb，用到了全局过滤器 LoadBalancerClientFilter，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。\"]},\"76\":{\"h\":\"Spring Cloud Gateway 支持限流吗？\",\"t\":[\"Spring Cloud Gateway 自带了限流过滤器，对应的接口是 RateLimiter，RateLimiter 接口只有一个实现类 RedisRateLimiter （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。\",\"从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。\"]},\"77\":{\"h\":\"Spring Cloud Gateway 如何自定义全局异常处理？\",\"t\":[\"在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 @RestControllerAdvice和 @ExceptionHandler就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。\",\"Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现ErrorWebExceptionHandler并重写其中的handle方法。\",\"@Order(-1) @Component @RequiredArgsConstructor public class GlobalErrorWebExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper; @Override public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) { // ... } } \"]},\"78\":{\"h\":\"参考\",\"t\":[\"Spring Cloud Gateway 官方文档：https://cloud.spring.io/spring-cloud-gateway/reference/html/\",\"Creating a custom Spring Cloud Gateway Filter：https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter\",\"全局异常处理: https://zhuanlan.zhihu.com/p/347028665\",\"File not found\"]},\"79\":{\"c\":[\"分布式\"]},\"80\":{\"h\":\"MySQL基础框架\",\"t\":[\"跟随企鹅君，一起高效学习～\",\"学习新知识的时候千万不要一上来就陷入细节，你应该先完成一个整体框架的构建，才可以在高维度视角理解问题。然后再把框架拆解成小的分支，逐个攻破。久而久之，习惯养成，很多问题也就不成问题了。\"]},\"81\":{\"h\":\"一 MySQL 基本架构\",\"t\":[\"我们在使用MySQL中看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。\",\"比如我们在执行下面这个查询语句时：\",\"mysql> select * from T where id=1； \",\"客户端发出一条SQL查询语句的执行过程:\",\"连接器 --> 分析器 --> 优化器 --> 执行器 --> 存储引擎\",\"MySQL 的逻辑架构图\",\"MySQL可以分为 Server 层和存储引擎层两部分：\"]},\"82\":{\"h\":\"Server 层\",\"t\":[\"Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\"]},\"83\":{\"h\":\"存储引擎层\",\"t\":[\"存储引擎层则负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。\",\"从图中不难看出，不同的存储引擎共用一个Server 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条 SQL 语句，带你走一遍整个执行流程，依次看下每个组件的作用。\"]},\"84\":{\"h\":\"连接器\",\"t\":[\"第一步，你会先登陆数据库系统，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。超时自动断开，建立连接过程复杂，建议使用长链接，连接比较占用内存，需要定时断开，5.7之后可以使用mysql_reset_connection。连接命令一般是这么写的：\",\"mysql -u 数据库用户名 -p \",\"输完命令之后，你就需要在交互对话里面输入密码。认证通过后，连接器会到权限表里面查出你拥有的权限。你就可以对数据库进行操作了。\"]},\"85\":{\"h\":\"查询缓存 （MySQL 8.0版本后被移除）\",\"t\":[\"其他资料中第二步是去查询缓存, 但是这个功能不实用，MySQL 8.0 版本就直接将查询缓存的整块功能删掉了\",\"图中博主也直接删掉了\",\"查询缓存简单来说就是以key-value对的形式存储之前做过的查询，key是查询语句，value是查询的结果，如果正在执行的查询，存在缓存中，那么直接返回结果。表上的任意更新都会导致表上的所有查询缓存清空。\"]},\"86\":{\"h\":\"分析器\",\"t\":[\"成功建立连接后，对于客户端输入的命令，MySQL 需要先知道你要做什么，因此需要对 SQL 语句做解析。\",\"第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\",\"MySQL 从你输入的\\\"select\\\"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“id”识别成“列 id”。\",\"第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。\",\"mysql> elect * from t where id=1; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where id=1' at line 1 \",\"一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。\",\"完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。\"]},\"87\":{\"h\":\"优化器\",\"t\":[\"优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。\",\"可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\"]},\"88\":{\"h\":\"执行器\",\"t\":[\"当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\"]},\"89\":{\"h\":\"二 日志模块\",\"t\":[\"上面说完了查询的流程，与查询流程不一样的是，更新流程还涉及两个重要的日志模块，\",\"redo log（重做日志）和 binlog（归档日志）。\",\"这时候有同学要问，这里为什么要用两个日志模块，用一个日志模块不行吗?\",\"因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。\",\"这两种日志有以下三点不同。\",\"redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\",\"redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\",\"redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\",\"接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：\",\"mysql> update T set c=c+1 where ID=2; \",\"我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。\",\"执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。\",\"执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。\",\"引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。\",\"执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\",\"执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。\",\"为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？\",\"先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。\",\"先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。\",\"如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。\"]},\"90\":{\"h\":\"三 总结\",\"t\":[\"MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。\",\"引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。\",\"查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎\",\"更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit 状态)\",\"参考文章：\",\"《Mysql 实战45讲》\"]},\"91\":{\"c\":[\"数据库\"]},\"92\":{\"c\":[\"Mysql\"]},\"93\":{\"h\":\"MySQL索引详解\",\"t\":[\"作为一名Java老司机，应该清楚，数据库索引这个知识点在面试中基本上必问。\",\"今天就来彻底搞懂他，跟随企鹅君，一往无前～\"]},\"94\":{\"h\":\"索引介绍\",\"t\":[\"MySQL官方对索引定义：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。\",\"● 索引是物理数据页存储，在数据文件中（InnoDB，ibd文件），利用数据页(page)存储。 ● 索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价。\"]},\"95\":{\"h\":\"索引数据结构模型\"},\"96\":{\"h\":\"Hash 表\",\"t\":[\"哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。 不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。 假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：图 1\",\"哈希表示意图 图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。 你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。 所以，哈希表这种结构适用于只有等值查询的场景， 不适合范围查询的场景\"]},\"97\":{\"h\":\"二叉搜索树(BST)\",\"t\":[\"二叉搜索树（Binary Search Tree）具有以下特点：\",\"二叉搜索树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：\",\"左子树的节点均小于根节点的值。\",\"右子树的节点均大于根节点的值。\",\"左右子树也各自成为一个二叉查找树。\",\"当二叉搜索树保持平衡时，即每个节点的左右子树深度相差不超过1，查询操作的时间复杂度为O(log2(N))，具有较高的效率。然而，当二叉搜索树失去平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂度退化为O(N)。\",\"斜树\",\"为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。\"]},\"98\":{\"h\":\"AVL 树\",\"t\":[\"AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis。它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\",\"AVL 树\",\"实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。\",\"为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。比如B-树，B+树、红黑树等\"]},\"99\":{\"h\":\"B-树\",\"t\":[\"这里可不是B减树， 就是B树, 中间只是一个横线\",\"B-Tree\",\"定义：\",\"1、根节点至少包含两个孩子\",\"2、每个节点最多包含m个孩子(m >= 2)，m为树的深度\",\"3、除了根节点和叶子节点，其他节点至少有ceil(m/2)个孩子，ceil函数为取上限，例如ceil(1.2)=2，就是小数位多少，都入，不是四舍五入\",\"4、叶子节点的高度相同\",\"如果我们需要寻找key为28的数据，会经历3次磁盘I/O操作过程\",\"PS：\",\"1、我们从上图看到B树和二分搜索树有一点相似的地方，数据是有序的，也就是按照关键字进行排序\",\"2、非叶子节点包含key和value，以及指向其子节点地址的指针\",\"3、叶子节点只有key和value\"]},\"100\":{\"h\":\"B+树\",\"t\":[\"B+树\",\"非叶子节点的子树指针与关键字个数相同\",\"非叶子节点的子树指针P[i]，指向关键字值的子树\",\"非叶子节点仅用来索引，数据都保存在叶子节点中\",\"所有叶子节点均有一个链指针指向下一个叶子节点 （紫色块之间有链指针连接，从左到右升序排列）\"]},\"101\":{\"h\":\"B+树与B-树的区别\",\"t\":[\"B+树是B树的一种优化 1、B树的每个结点都存储了key和data，B+树的data存储在叶子节点上。非叶子节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，磁盘IO操作次数更少。查询效率更高 2、B+树查询路径都是从非叶子结点， 到叶子节点。 效率比较稳定 3、B+树叶子结点是一个链表， 扫描全表数据速度更快（只需要遍历叶子节点，并且范围查询也有优化）\",\"因为B+树的这些好处，在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构,\",\"但是，两者的实现方式不太一样。MyISAM 引擎是使用的非聚簇索引，InnoDB 引擎使用的是聚簇索引\",\"接下来就介绍下索引类型\"]},\"102\":{\"h\":\"索引类型\"},\"103\":{\"h\":\"按照数据模型维度划分：\",\"t\":[\"B-Tree索引：B树索引是MySQL中最常见的索引类型，适用于大部分场景。它支持等值查询、范围查询和前缀匹配。\",\"哈希索引：哈希索引是一种基于哈希表实现的索引，类似键值对的形式，一次即可定位, 等值查询非常快，但是不支持范围查询和前缀匹配\",\"空间索引：空间索引是一种用于地理空间数据查询的特殊索引，它基于R树实现。优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。\",\"全文索引：全文索引是一种用于文本数据模糊查询的特殊索引，它基于倒排索引实现。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。效率较低，通常使用搜索引擎如 ElasticSearch 代替。\"]},\"104\":{\"h\":\"按照功能逻辑维度划分：\",\"t\":[\"主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值(NULL)。一般是在建表的时候同时创建主键索引。\",\"普通索引：仅用于加速查询。\",\"唯一索引：索引列的值必须唯一，但允许有空值(NULL)。如果是组合索引，则列值的组合必须唯一。\",\"联合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。\",\"覆盖索引：覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。\",\"全文索引：全文索引是一种用于文本数据模糊查询的特殊索引，它基于倒排索引实现。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。效率较低，通常使用搜索引擎如 ElasticSearch 代替。\"]},\"105\":{\"h\":\"从底层存储方式维度划分：\",\"t\":[\"聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。\",\"非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\"]},\"106\":{\"h\":\"聚簇索引(密集索引)\",\"t\":[\"行数据和主键索引存储在一起，辅助键索引只存储辅助键和主键，而不保存数据\",\"img\",\"InnoDB使用的是聚簇索引，行数据保存在叶子节点上。如果通过where id = 5，直接通过主键索引找到对应的关键字，然后返回行数据\",\"如果通过where name = tom，首先通过辅助键索引找到对应id = 5，然后再通过主键索引找到行数据\",\"PS：\",\"1).如果存在主键，主键就是密集索引\",\"2).如果没有主键，表中第一个唯一非空索引为密集索引\",\"3).如果以上都没有，InnoDB生成一个隐藏主键作为密集索引，是一个6字节的列，随着数据的插入自增\",\"所以，InnoDB必须有个密集索引，这是因为非主键索引叶子节点不保存行数据，而是保存着主键值\"]},\"107\":{\"h\":\"非聚簇索引(稀疏索引)：\",\"t\":[\"B+树叶子节点存储的是指向数据的指针\",\"img\",\"MyISAM使用的为非聚簇索引，主键索引保存了主键，非主键索引保存了非主键，而数据行保存在其他位置，检索的过程都是通过叶子节点内\",\"保存的地址找到对应的数据行。\"]},\"108\":{\"h\":\"InnoDB为什么使用聚簇索引呢？\",\"t\":[\"从上面索引过程我们可以看到，对于非主键查询来说，聚簇索引需要经过两次检索，好像效率更低了，那么聚簇索引的优势在哪？\",\"1、行数据和叶子节点保存在一起，会一起被加载到内存，找到叶子节点就可以将数据库返回。\",\"2、辅助索引的叶子节点保存主键的指针，而不使用地址值作为指针，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键\",\"值当作指针会让辅助索引占用更多的空间，InnoDB在移动行时无须更新辅助索引中的这个\\\"指针\\\"。也就是说行的位置（实现中通过16K的Page来定\",\"位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的\",\"节点如何变化，辅助索引树都不受影响。\"]},\"109\":{\"h\":\"页page:\",\"t\":[\"InnoDB数据通过page存储，是最小的存储单位，page默认大小为16k，文件系统最小单位块为4k，通过下面参数设置\",\"img\",\"页可以用来存储数据也可以用来存储key和指针，分别对应非叶子节点和叶子节点。通过非叶子节点的二分查找和指针确定数据在哪一页，进\",\"而查到对应的数据。\"]},\"110\":{\"h\":\"一棵B+树可以存放多少条数据？\",\"t\":[\"假设B+树高度为2，一行数据记录大小为1k(实际上很多互联网业务数据就是1k左右)，单个叶子节点(页)中记录数16K/1K=16\",\"B+树存在的数据总量 = 根节点节点指针数量 * 每页保存的数据量\",\"假设主键为bigint，长度为8字节，指针大小在InnoDB源码中为6字节，这样一共14字节，我们一个页中存放16384/14=1170。那么一棵高度为\",\"2的B+树，能存放1170*16=18720条这样的数据。\",\"以此类推，一个高度为3的B+树可以存放：1170117016=21902400条这样的记录。\",\"所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。通过主键索引查询通常只需要1-3次IO操作即可查找到数据。\"]},\"111\":{\"h\":\"索引概念\",\"t\":[\"MySQL中InnoDB引擎要求每张表都有要有一个聚簇索引（clustered index），也称为主键索引（primary key index），它的作用是将数据按照主键值排序，方便快速地访问单条记录。除了聚簇索引外，MySQL还可以有多辅助（二级）索引（secondary index），它们的作用是加速查询和排序操作。\"]},\"112\":{\"h\":\"回表查询\",\"t\":[\"InnoDB索引有聚簇索引和辅助索引。聚簇索引的叶子节点存储行记录，InnoDB必须要有，且只有一个。\",\"辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做回表查询，它的性能比扫一遍索引树低。\"]},\"113\":{\"h\":\"主键索引\",\"t\":[\"数据表的主键列使用的就是主键索引。B+Tree的叶子节点存放的是主键字段值\",\"通常说的主键索引就是聚簇索引。InnoDB的表要求必须要有聚簇索引： ● 如果表定义了主键，则主键索引就是聚簇索引 ● 如果表没有定义主键，则第一个非空unique列作为聚簇索引 ● 否则InnoDB会从建一个隐藏的row-id作为聚簇索引\",\"检索过程： 直接通过主键索引找到存储的数据\",\"检索过程\"]},\"114\":{\"h\":\"二级索引(辅助索引)\",\"t\":[\"InnoDB二级索引，也叫作辅助索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。\",\"检索过程： 先通过辅助索引找到主键索引， 通过回表查询，然后再找到存储的数据\"]},\"115\":{\"h\":\"索引覆盖\",\"t\":[\"在MySQL官网，类似的说法出现在explain查询计划优化章节，即explain的输出结果Extra字段为Usingindex时，能够触发索引覆盖。\",\"只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫做索引覆盖。实现索引覆盖最常见的方法就是：将被查询的字段，建立到组合索引。\"]},\"116\":{\"h\":\"最左匹配原则\",\"t\":[\"复合索引使用时遵循最左匹配原则，最左匹配顾名思义，就是最左优先，即查询中使用到最左边的列，那么查询就会使用到索引，如果从索引的第二列开始查找，索引将失效。\"]},\"117\":{\"h\":\"索引下推\",\"t\":[\"我们以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：\",\"mysql> select * from tuser where name like '张%' and age=10 and ismale=1; \",\"你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。 然后呢？ 当然是判断其他条件是否满足。 在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。\",\"图3\",\"图 3 无索引下推执行流程\",\"图4\",\"图 4 索引下推执行流程\",\"在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。 图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。 图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。\"]},\"118\":{\"h\":\"索引为什么会失效\",\"t\":[\"列类型不匹配：如果索引列和查询条件的数据类型不匹配，例如在一个字符串类型的索引列上执行了数值比较，那么索引就会失效。\",\"函数操作：如果查询条件中使用了函数操作，例如在索引列上使用函数操作或者使用了自定义函数，那么索引也会失效。\",\"索引列值为空：如果查询条件中使用了IS NULL或者IS NOT NULL操作，那么如果索引列上存在NULL值，那么索引就会失效。\",\"表达式操作：如果查询条件中使用了表达式操作，例如对索引列进行加减乘除等操作，那么索引也会失效。\",\"隐式类型转换：如果查询条件中使用了隐式类型转换，例如在一个字符串类型的索引列上执行了数值比较，并且数据库自动将字符串转换为数字类型，那么索引也会失效。\",\"数据量太大：如果表中的数据量太大，那么对于一些非唯一索引列，索引的查询优化器可能会认为扫描整个表比使用索引更加高效，从而导致索引失效。\",\"索引列上存在函数：如果索引列上使用了函数，例如在索引列上使用了UPPER()函数，那么索引也会失效。\",\"最左匹配原则：联合索引要正确使用需满足最左匹配原则，即：符合第一列才会继续判断后面的字段。\",\"使用OR 一列不是索引\"]},\"119\":{\"h\":\"正确使用索引\",\"t\":[\"索引字段占用空间越小越好， 大文本，大对象不要创建索引\",\"索引并不是越多越好， 有维护成本，空间成本\",\"建议单表不超过5个索引\",\"频繁更新的字段不适合作为索引\",\"我们创建索引的字段应该是查询操作非常频繁的字段。\",\"频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。\"]},\"120\":{\"h\":\"如何分析sql使用索引情况\",\"t\":[\"在 MySQL 中可以通过 EXPLAIN 关键字模拟优化器执行 SQL语句\",\"explain select 列名 FROM 表名 WHERE 条件 ; \",\"EXPLAIN输出内容如下：\",\"各个字段的含义如下：\",\"列名\",\"含义\",\"id\",\"SELECT的查询序列号\",\"select_type\",\"主要用来说明查询的类型：普通查询、联合查询、子查询等\",\"table\",\"输出的行所引用的表\",\"partitions\",\"如果查询是基于分区表的话，显示查询将访问的分区。，对于未分区的表，值为 NULL\",\"type\",\"代表访问类型，是判断sql执行性能比较关键的一个字段\",\"possible_keys\",\"MySQL可能使用的键(索引)。\",\"key\",\"MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。\",\"key_len\",\"所选索引的长度\",\"ref\",\"表示索引的哪一列被使用显示使用哪个列或常数与key一起从表中选择行。\",\"rows\",\"预计要读取的行数\",\"filtered\",\"按表条件过滤后，留存的记录数的百分比\",\"Extra\",\"附加信息\",\"type\",\"联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:\",\"type代表访问类型，是判断sql执行性能比较关键的一个字段，性能从高到低依次是： system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\",\"system:表仅有一行(=系统表)。这是const联接类型的一个特例。\",\"const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!\",\"eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。\",\"ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。\",\"ref_or_:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。\",\"index_merge:该联接类型表示使用了索引合并优化方法。\",\"unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。\",\"index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)\",\"range:只检索给定范围的行,使用一个索引来选择行。\",\"index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。\",\"ALL:对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。\",\"一般来说，得保证查询至少达到range级别，最好能达到ref。\",\"参考文章：\",\"InnoDB索引原理\",\"《Mysql 实战45讲》\",\"Mysql索引\"]},\"121\":{\"c\":[\"数据库\"]},\"122\":{\"c\":[\"索引\"]},\"123\":{\"h\":\"MySQL事务详解\"},\"124\":{\"h\":\"事务简介\",\"t\":[\"提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。\",\"转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。\",\"简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。\",\"只有使用了 Innodb 数据库引擎的数据库或表才支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。\"]},\"125\":{\"h\":\"事务提交、回滚\",\"t\":[\"事务提交操作\",\"mysql> start transaction;#手动开启事务 mysql> insert into t_user(name) values('pp'); mysql> commit;#commit之后即可改变底层数据库数据, pp成功插入 mysql> select * from t_user; +----+------+ | id | name | +----+------+ | 1 | jay | | 2 | man | | 3 | pp | +----+------+ 3 rows in set (0.00 sec) \",\"事务回滚操作\",\"mysql> insert into t_user(name) values('yy'); mysql> rollback; #事务回滚后，上面的操作也不去执行了，yy没有成功插入 mysql> select * from t_user; +----+------+ | id | name | +----+------+ | 1 | jay | | 2 | man | | 3 | pp | +----+------+ 3 rows in set (0.00 sec) \",\"##事务四大特性\",\"一般来说，事务（transaction）是必须满足4个条件（ACID）\",\"原子性（Atomicity）\",\"一致性（Consistency）\",\"隔离性（Isolation）\",\"持久性（Durability）\",\"事务的目的是保障数据的一致性\",\"只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。\",\"也就是说 A、I、D 是手段，C 是目的\",\"原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\",\"一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(比如：A向B转账，不可能A扣了钱，B却没有收到)\",\"隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\",\"持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\"]},\"126\":{\"h\":\"并发事务会带来哪些问题\"},\"127\":{\"h\":\"1.脏读：（读取未提交数据）\",\"t\":[\"脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。\",\"时间顺序\",\"事务A\",\"事务B\",\"1\",\"开始事务\",\"2\",\"开始事务\",\"3\",\"查询账户余额为2000元\",\"4\",\"取款1000元，余额被更改为1000元（未提交）\",\"5\",\"6\",\"事务回滚，取款操作发生未知错误，余额变更为2000元\",\"7\",\"转入2000元，余额被更改为3000元（脏读1000+2000）\",\"8\",\"提交事务\",\"备注\"]},\"128\":{\"h\":\"2.不可重复读:（前后多次读取，数据内容不一致）\",\"t\":[\"是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容） 例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。\",\"时间顺序\",\"事务A\",\"事务B\",\"1\",\"开始事务\",\"2\",\"3\",\"开始事务\",\"4\",\"其他操作\",\"5\",\"更改小明的年龄为30岁\",\"6\",\"提交事务\",\"7\",\"备注\",\"按照正确逻辑，事务A前后两次读取到的数据应该一致\"]},\"129\":{\"h\":\"3.幻读:（前后多次读取，数据总量不一致）\",\"t\":[\"事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。\",\"例子1：\",\"时间顺序\",\"事务A\",\"事务B\",\"1\",\"开始事务\",\"2\",\"3\",\"开始事务\",\"4\",\"其他操作\",\"5\",\"新增100条数据\",\"6\",\"提交事务\",\"7\",\"备注\",\"按照正确逻辑，事务A前后两次读取到的数据总量应该一致，第二次没有插入过查出来却多了100条记录，像见鬼了一样， 产生了幻读问题\"]},\"130\":{\"h\":\"不可重复读和幻读的区别\",\"t\":[\"（1）不可重复读是读取了其他事务更改的数据，针对update操作 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。\",\"（2）幻读是读取了其他事务新增的数据，针对insert与delete操作 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。\",\"幻读和不可重复读都是指的一个事务范围内的操作受到其他事务的影响了。只不过幻读是重点在插入和删除，不可重复读重点在修改\"]},\"131\":{\"h\":\"事务隔离性\"},\"132\":{\"h\":\"隔离级别\",\"t\":[\"（1）读未提交：read uncommitted\",\"一个事务还没提交时，它做的变更就能被别的事务看到。\",\"最低的隔离级别，脏读、不可重复读或幻读都有可能发生，数据库隔离级别一般都高于该级别\",\"（2）读已提交：read committed\",\"一个事务提交之后，它做的变更才会被其他事务看到。\",\"可以阻止“脏读”， 但是幻读或不可重复读仍有可能发生。\",\"（3）可重复读：repeatable read\",\"一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\",\"可以阻止“脏读”和“不可重复读”，但幻读仍有可能发生。\",\"InnoDB引擎默认隔离级别\",\"（4）串行化：serializable\",\"事务A和事务B，事务A在操作数据库时，事务B只能排队等待, 必须事务A执行完成，才能继续执行\",\"这种隔离级别很少使用，吞吐量低，用户体验差\",\"可以阻止脏读、不可重复读以及幻读。\",\"脏读\",\"不可重复读\",\"幻读\",\"读未提交 Read uncommitted\",\"可能\",\"可能\",\"可能\",\"读已提交 Read committed\",\"不可能\",\"可能\",\"可能\",\"可重复读 Repeatable read\",\"不可能\",\"不可能\",\"可能\",\"串行化 Serializable\",\"不可能\",\"不可能\",\"不可能\"]},\"133\":{\"h\":\"事务实现的原理\",\"t\":[\"事务的原子性是通过undolog来实现的\",\"事务的持久性性是通过redolog来实现的\",\"事务的隔离性是通过(读写锁+MVCC)来实现的\",\"事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！\",\"原子性，持久性，隔离性的目的也是为了保障数据的一致性！\",\"总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。\",\"下面我首先讲实现事务功能的三个技术，分别是日志文件(redo log 和 undo log)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完\"]},\"134\":{\"h\":\"redo log 与 undo log介绍\"},\"135\":{\"h\":\"什么是redo log ?\",\"t\":[\"redo log叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。\",\"img\",\"start transaction; select balance from bank where name=\\\"zhangsan\\\"; // 生成 重做日志 balance=600 update bank set balance = balance - 400; // 生成 重做日志 amount=400 update finance set amount = amount + 400; \",\"img\"]},\"136\":{\"h\":\"redo log作用是什么？\",\"t\":[\"mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。\",\"那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！\",\"所以引入了redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。\",\"总结：redo log是用来恢复数据的，用于保障，已提交事务的持久化特性（记录了已经提交的操作）\"]},\"137\":{\"h\":\"什么是undo log？\",\"t\":[\"undo log 叫做回滚日志，用于记录数据被修改前的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。 还用上面那两张表\",\"img\",\"每次写入数据或者修改数据之前都会把修改前的信息记录到 undo log。\"]},\"138\":{\"h\":\"undo log 有什么作用？\",\"t\":[\"undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。\",\"总结：undo log是用来回滚数据的用于保障，未提交事务的原子性\"]},\"139\":{\"h\":\"mysql锁技术以及MVCC基础\"},\"140\":{\"h\":\"mysql锁技术\",\"t\":[\"当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。 读写锁 解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：\",\"共享锁(shared lock),又叫做\\\"读锁\\\" 读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。\",\"排他锁(exclusive lock),又叫做\\\"写锁\\\" 写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。\",\"img\",\"总结：通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行\"]},\"141\":{\"h\":\"MVVC 实现原理\",\"t\":[\"MySQL在可重复读事务隔离级别下为了保证事务较高的隔离性，采用了**MVCC (Multi-Version Concurrency Control)**机制来保证的。MVCC全称叫做多版本并发控制，是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访问，实现事务。其核心思想是读不加锁，读写不冲突。对同一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥造成并发性能下降（而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的）。\",\"MySQL在读已提交和可重复读隔离级别下都实现了MVCC机制。\",\"MVCC实现原理是数据快照，不同的事务访问不同版本的数据快照，从而实现事务下对数据的隔离级别。虽然说具有多个版本的数据快照，但这并不意味着必须拷贝数据，保存多份数据文件（这样会浪费存储空间），InnoDB存储引擎通过事务的Undo日志巧妙地实现了多版本的数据快照。\",\"MVCC的实现依赖于Undo日志和Read View。下面我们先来详细介绍一下这两个机制。\",\"1）、Undo日志\",\"Undo存放在数据库内部的一个特殊段（segment）中，这个段称为Undo段（undo segment）。Undo段位于系统表空间内，也可以设置为Undo表空间。\",\"Undo日志保存了记录修改前的数据，并且用两个隐藏字段trx_id和roll_pointer把这些Undo日志串联起来形成一个历史记录版本链（参考图1）。所以，对于更新和删除操作，InnoDB存储引擎并不是真正的删除原来的记录，而是设置记录的delete mark为1。\",\"img\",\"2）Read View\",\"ReadView其实就是一张存储事务id的表。在可重复读隔离级别，当事务开启后，执行任何查询SQL时都会生成当前事务的一致性视图Read View，该视图在事务结束之前永远都不会变化(如果是读已提交隔离级别则在每次执行查询SQL时都会重新生成一致性视图Read View)。这个视图包含的内容有：执行查询时所有未提交事务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）如图2。事务里的任何SQL查询结果需要从对应的Undo日志版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\",\"img\",\"3）版本链比对规则：\",\"要结合图1和图2一起来看，那图1的每一行数据row跟图2比较：\",\"a、如果row的trx_id落在最左边部分，即trx_id<min_id，表示这个版本是已提交的事务生成的，该数据是可见的；\",\"b、如果row的trx_id落在最右边部分，即trx_id>max_id，表示这个版本是由将来启动的事务生成的，是不可见的(若row的trx_id就是当前自己的事务则是可见的）；\",\"c、如果row的trx_id落在中间部分，即min_id<=trx_id<=max_id，分为两种情况：\",\"一是：若row的trx_id在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若row的trx_id就是当前自己的事务是可见的)；\",\"二是：若row的trx_id不在视图数组中，表示这个版本是已经提交了的事务生成的，该数据是可见的。\",\"举例说明：假如此时有一张表account表，其属性有：id、name、balance；并且也有一条id为1余额为0的基础数据。如下图：\",\"img\",\"横轴为不同客户端开启的事务，纵轴为时间（从上到下按照从早到晚的顺序）。\",\"当#select 1在执行select balance from account where id = 1时，会生成一致性视图Read View，因为此时事务100和事务200还未提交，事务300已经提交，且已生成的最大事务为300，所以生成的一致性视图Read View为：[100,200] 300；Undo日志版本链为：\",\"img\",\"将Undo日志版本连的每一条数跟生成的Read View[100,200] 300做对比，此时最小事务id为100，最大事务id为300，未提交的事务id数组为[100,200]；根据上面的比对规则就可得出：先拿第5条数据做对比，第5条数据事务id为300，满足min_id < 300 <= max_id且300不在[100,200]数组内，因此此条数据是可见的；紧接着第4、3、2条数据，由于Undo版本连上的事务200和100都在[100,200]因此是不可见的，而事务99满足99 < min_id，是已经提交了的数据，因此也是可见的，所以最终查询的结果为500。由于在可重复读隔离级别下，同一个事务内生成的Read View是不变动的，所以selec 1中再次查询相同的语句，得出的结果还是一样的。\",\"以上便是根据select 1分析的过程，各位可以自己根据select 2分析以加强自己的理解。\",\"所有由此我们可以看到：Read View和可见性算法其实就是记录了SQL查询那个时刻数据库里提交和未提交所有事务的状态。要实现RR隔离级别，事务里每次执行查询操作Read View都是使用第一次查询时生成的Read View，也就是都是以第一次查询时当时数据库里所有事务提交状态来比对数据是否可见，当然可以实现每次查询的可重复读的效果了。要实现RC隔离级别，事务里每次执行查询操作Read View都会按照数据库当前状态重新生成Read View，也就是每次查询都是跟数据库里当前所有事务提交状态来比对数据是否可见，当然实现的就是每次都能查到已提交的最新数据效果了。\",\"参考文章：\",\"《Mysql 实战45讲》\",\"Mysql事务\"]},\"142\":{\"c\":[\"数据库\"]},\"143\":{\"c\":[\"事务\"]},\"144\":{\"h\":\"3种常用的缓存读写策略详解\",\"t\":[\"看到很多小伙伴简历上写了“熟练使用缓存”，但是被我问到“缓存常用的 3 种读写策略”的时候却一脸懵逼。\",\"在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。\",\"但是，搞懂 3 种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！\",\"下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。\"]},\"145\":{\"h\":\"Cache Aside Pattern（旁路缓存模式）\",\"t\":[\"Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。\",\"Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\",\"下面我们来看一下这个策略模式下的缓存读写步骤。\",\"写：\",\"先更新 db\",\"然后直接删除 cache 。\",\"简单画了一张图帮助大家理解写的步骤。\",\"读 :\",\"从 cache 中读取数据，读取到就直接返回\",\"cache 中读取不到的话，就从 db 中读取数据返回\",\"再把数据放到 cache 中。\",\"简单画了一张图帮助大家理解读的步骤。\",\"你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。\",\"比如说面试官很可能会追问：“在写数据的过程中，可以先删除 cache ，后更新 db 么？”\",\"答案： 那肯定是不行的！因为这样可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。\",\"举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。\",\"这个过程可以简单描述为：\",\"请求 1 先把 cache 中的 A 数据删除 -> 请求 2 从 db 中读取数据->请求 1 再把 db 中的 A 数据更新\",\"当你这样回答之后，面试官可能会紧接着就追问：“在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？”\",\"答案： 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\",\"举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。\",\"这个过程可以简单描述为：\",\"请求 1 从 db 读数据 A-> 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -> 请求 1 将数据 A 写入 cache\",\"现在我们再来分析一下 Cache Aside Pattern 的缺陷。\",\"缺陷 1：首次请求数据一定不在 cache 的问题\",\"解决办法：可以将热点数据可以提前放入 cache 中。\",\"缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\",\"解决办法：\",\"数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。\",\"可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。\"]},\"146\":{\"h\":\"Read/Write Through Pattern（读写穿透）\",\"t\":[\"Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\",\"这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。\",\"写（Write Through）：\",\"先查 cache，cache 中不存在，直接更新 db。\",\"cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。\",\"简单画了一张图帮助大家理解写的步骤。\",\"读(Read Through)：\",\"从 cache 中读取数据，读取到就直接返回 。\",\"读取不到的话，先从 db 加载，写入到 cache 后返回响应。\",\"简单画了一张图帮助大家理解读的步骤。\",\"Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。\",\"和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\"]},\"147\":{\"h\":\"Write Behind Pattern（异步缓存写入）\",\"t\":[\"Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\",\"但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\",\"很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\",\"这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。\",\"Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。\",\"File not found\"]},\"148\":{\"c\":[\"数据库\"]},\"149\":{\"c\":[\"Redis\"]},\"150\":{\"h\":\"缓存基础常见面试题总结(付费)\",\"t\":[\"缓存基础 相关的面试题为我的 知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。\",\"File not found\",\"File not found\"]},\"151\":{\"c\":[\"数据库\"]},\"152\":{\"c\":[\"Redis\"]},\"153\":{\"h\":\"Redis集群详解(付费)\",\"t\":[\"Redis 集群 相关的面试题为我的 知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。\",\"File not found\",\"File not found\"]},\"154\":{\"c\":[\"数据库\"]},\"155\":{\"c\":[\"Redis\"]},\"156\":{\"h\":\"Redis常见阻塞原因总结\",\"t\":[\"本文整理完善自：https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA ，作者：阿 Q 说代码\",\"这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！\"]},\"157\":{\"h\":\"O(n) 命令\",\"t\":[\"Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\",\"KEYS *：会返回所有符合规则的 key。\",\"HGETALL：会返回一个 Hash 中所有的键值对。\",\"LRANGE：会返回 List 中指定范围内的元素。\",\"SMEMBERS：返回 Set 中的所有元素。\",\"SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。\",\"……\",\"由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\",\"除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\",\"ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"……\"]},\"158\":{\"h\":\"SAVE 创建 RDB 快照\",\"t\":[\"Redis 提供了两个命令来生成 RDB 快照文件：\",\"save : 同步保存操作，会阻塞 Redis 主线程；\",\"bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\",\"默认情况下，Redis 默认配置会使用 bgsave 命令。如果手动使用 save 命令生成 RDB 快照文件的话，就会阻塞主线程。\"]},\"159\":{\"h\":\"AOF\"},\"160\":{\"h\":\"AOF 日志记录阻塞\",\"t\":[\"Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。\",\"AOF 记录日志过程\",\"为什么是在执行完命令之后记录日志呢？\",\"避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；\",\"在命令执行完之后再记录，不会阻塞当前的命令执行。\",\"这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\",\"如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；\",\"可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。\"]},\"161\":{\"h\":\"AOF 刷盘阻塞\",\"t\":[\"开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。\",\"在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\",\"appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。\",\"appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）\",\"appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。\",\"当后台线程（ aof_fsync 线程）调用 fsync 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 fsync 操作发生阻塞，主线程调用 write 函数时也会被阻塞。fsync 完成后，主线程执行 write 才能成功返回。\",\"关于 AOF 工作流程的详细介绍可以查看：Redis 持久化机制详解，有助于理解 AOF 刷盘阻塞。\"]},\"162\":{\"h\":\"AOF 重写阻塞\",\"t\":[\"fork 出一条子线程来将文件重写，在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。\",\"当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。\",\"最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\",\"阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生阻塞。\",\"相关阅读：Redis AOF 重写阻塞问题分析。\"]},\"163\":{\"h\":\"大 Key\",\"t\":[\"如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：\",\"string 类型的 value 超过 1MB\",\"复合类型（列表、哈希、集合、有序集合等）的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。\",\"大 key 造成的阻塞问题如下：\",\"客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。\",\"引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。\",\"阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。\"]},\"164\":{\"h\":\"查找大 key\",\"t\":[\"当我们在使用 Redis 自带的 --bigkeys 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会阻塞主节点。\",\"我们还可以使用 SCAN 命令来查找大 key；\",\"通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：\",\"redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具\",\"rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。\"]},\"165\":{\"h\":\"删除大 key\",\"t\":[\"删除操作的本质是要释放键值对占用的内存空间。\",\"释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。\",\"所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。\",\"删除大 key 时建议采用分批次删除和异步删除的方式进行。\"]},\"166\":{\"h\":\"清空数据库\",\"t\":[\"清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。\"]},\"167\":{\"h\":\"集群扩容\",\"t\":[\"Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。\",\"在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。\",\"执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。\"]},\"168\":{\"h\":\"Swap（内存交换）\",\"t\":[\"什么是 Swap？ Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。\",\"Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘的读写速度差几个数量级，会导致发生交换后的 Redis 性能急剧下降。\",\"识别 Redis 发生 Swap 的检查方法如下：\",\"1、查询 Redis 进程号\",\"reids-cli -p 6383 info server | grep process_id process_id: 4476 \",\"2、根据进程号查询内存交换信息\",\"cat /proc/4476/smaps | grep Swap Swap: 0kB Swap: 0kB Swap: 4kB Swap: 0kB Swap: 0kB ..... \",\"如果交换量都是 0KB 或者个别的是 4KB，则正常。\",\"预防内存交换的方法：\",\"保证机器充足的可用内存\",\"确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长\",\"降低系统使用 swap 优先级，如echo 10 > /proc/sys/vm/swappiness\"]},\"169\":{\"h\":\"CPU 竞争\",\"t\":[\"Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\",\"可以通过reids-cli --stat获取当前 Redis 使用情况。通过top命令获取进程对 CPU 的利用率等信息 通过info commandstats统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。\"]},\"170\":{\"h\":\"网络问题\",\"t\":[\"连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\"]},\"171\":{\"h\":\"参考\",\"t\":[\"Redis 阻塞的 6 大类场景分析与总结：https://mp.weixin.qq.com/s/eaZCEtTjTuEmXfUubVHjew\",\"Redis 开发与运维笔记-Redis 的噩梦-阻塞：https://mp.weixin.qq.com/s/TDbpz9oLH6ifVv6ewqgSgA\",\"File not found\"]},\"172\":{\"c\":[\"数据库\"]},\"173\":{\"c\":[\"Redis\"]},\"174\":{\"h\":\"Redis 5 种基本数据类型详解\",\"t\":[\"Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。\",\"Redis 5 种基本数据类型对应的底层数据结构实现如下表所示：\",\"String\",\"List\",\"Hash\",\"Set\",\"Zset\",\"SDS\",\"LinkedList/ZipList/QuickList\",\"Dict、ZipList\",\"Dict、Intset\",\"ZipList、SkipList\",\"Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。\",\"你可以在 Redis 官网上找到 Redis 数据类型/结构非常详细的介绍：\",\"Redis Data Structures\",\"Redis Data types tutorial\",\"未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。\"]},\"175\":{\"h\":\"String（字符串）\"},\"176\":{\"h\":\"介绍\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据类型。\",\"String 是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（Simple Dynamic String，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\"]},\"177\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SET key value\",\"设置指定 key 的值\",\"SETNX key value\",\"只有在 key 不存在时设置 key 的值\",\"GET key\",\"获取指定 key 的值\",\"MSET key1 value1 key2 value2 ……\",\"设置一个或多个指定 key 的值\",\"MGET key1 key2 ...\",\"获取一个或多个指定 key 的值\",\"STRLEN key\",\"返回 key 所储存的字符串值的长度\",\"INCR key\",\"将 key 中储存的数字值增一\",\"DECR key\",\"将 key 中储存的数字值减一\",\"EXISTS key\",\"判断指定 key 是否存在\",\"DEL key（通用）\",\"删除指定的 key\",\"EXPIRE key seconds（通用）\",\"给指定 key 设置过期时间\",\"更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=string 。\",\"基本操作：\",\"> SET key value OK > GET key \\\"value\\\" > EXISTS key (integer) 1 > STRLEN key (integer) 5 > DEL key (integer) 1 > GET key (nil) \",\"批量设置：\",\"> MSET key1 value1 key2 value2 OK > MGET key1 key2 # 批量获取多个 key 对应的 value 1) \\\"value1\\\" 2) \\\"value2\\\" \",\"计数器（字符串的内容为整数的时候可以使用）：\",\"> SET number 1 OK > INCR number # 将 key 中储存的数字值增一 (integer) 2 > GET number \\\"2\\\" > DECR number # 将 key 中储存的数字值减一 (integer) 1 > GET number \\\"1\\\" \",\"设置过期时间（默认为永不过期）：\",\"> EXPIRE key 60 (integer) 1 > SETEX key 60 value # 设置值并设置过期时间 OK > TTL key (integer) 56 \"]},\"178\":{\"h\":\"应用场景\",\"t\":[\"需要存储常规数据的场景\",\"举例：缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。\",\"相关命令：SET、GET。\",\"需要计数的场景\",\"举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。\",\"相关命令：SET、GET、 INCR、DECR 。\",\"分布式锁\",\"利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。\"]},\"179\":{\"h\":\"List（列表）\"},\"180\":{\"h\":\"介绍\",\"t\":[\"Redis 中的 List 其实就是链表数据结构的实现。我在 线性数据结构 :数组、链表、栈、队列 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。\",\"许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\"]},\"181\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"RPUSH key value1 value2 ...\",\"在指定列表的尾部（右边）添加一个或多个元素\",\"LPUSH key value1 value2 ...\",\"在指定列表的头部（左边）添加一个或多个元素\",\"LSET key index value\",\"将指定列表索引 index 位置的值设置为 value\",\"LPOP key\",\"移除并获取指定列表的第一个元素(最左边)\",\"RPOP key\",\"移除并获取指定列表的最后一个元素(最右边)\",\"LLEN key\",\"获取列表元素数量\",\"LRANGE key start end\",\"获取列表 start 和 end 之间 的元素\",\"更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=list 。\",\"通过 RPUSH/LPOP 或者 LPUSH/RPOP实现队列：\",\"> RPUSH myList value1 (integer) 1 > RPUSH myList value2 value3 (integer) 3 > LPOP myList \\\"value1\\\" > LRANGE myList 0 1 1) \\\"value2\\\" 2) \\\"value3\\\" > LRANGE myList 0 -1 1) \\\"value2\\\" 2) \\\"value3\\\" \",\"通过 RPUSH/RPOP或者LPUSH/LPOP 实现栈：\",\"> RPUSH myList2 value1 value2 value3 (integer) 3 > RPOP myList2 # 将 list的最右边的元素取出 \\\"value3\\\" \",\"我专门画了一个图方便大家理解 RPUSH , LPOP , lpush , RPOP 命令：\",\"通过 LRANGE 查看对应下标范围的列表元素：\",\"> RPUSH myList value1 value2 value3 (integer) 3 > LRANGE myList 0 1 1) \\\"value1\\\" 2) \\\"value2\\\" > LRANGE myList 0 -1 1) \\\"value1\\\" 2) \\\"value2\\\" 3) \\\"value3\\\" \",\"通过 LRANGE 命令，你可以基于 List 实现分页查询，性能非常高！\",\"通过 LLEN 查看链表长度：\",\"> LLEN myList (integer) 3 \"]},\"182\":{\"h\":\"应用场景\",\"t\":[\"信息流展示\",\"举例：最新文章、最新动态。\",\"相关命令：LPUSH、LRANGE。\",\"消息队列\",\"List 可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。\",\"相对来说，Redis 5.0 新增加的一个数据结构 Stream 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。\"]},\"183\":{\"h\":\"Hash（哈希）\"},\"184\":{\"h\":\"介绍\",\"t\":[\"Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。\",\"Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。\"]},\"185\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"HSET key field value\",\"设置指定哈希表中指定字段的值\",\"HSETNX key field value\",\"只有指定字段不存在时设置指定字段的值\",\"HMSET key field1 value1 field2 value2 ...\",\"同时将一个或多个 field-value (域-值)对设置到指定哈希表中\",\"HGET key field\",\"获取指定哈希表中指定字段的值\",\"HMGET key field1 field2 ...\",\"获取指定哈希表中一个或者多个指定字段的值\",\"HGETALL key\",\"获取指定哈希表中所有的键值对\",\"HEXISTS key field\",\"查看指定哈希表中指定的字段是否存在\",\"HDEL key field1 field2 ...\",\"删除一个或多个哈希表字段\",\"HLEN key\",\"获取指定哈希表中字段的数量\",\"HINCRBY key field increment\",\"对指定哈希中的指定字段做运算操作（正数为加，负数为减）\",\"更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=hash 。\",\"模拟对象数据存储：\",\"> HMSET userInfoKey name \\\"guide\\\" description \\\"dev\\\" age 24 OK > HEXISTS userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。 (integer) 1 > HGET userInfoKey name # 获取存储在哈希表中指定字段的值。 \\\"guide\\\" > HGET userInfoKey age \\\"24\\\" > HGETALL userInfoKey # 获取在哈希表中指定 key 的所有字段和值 1) \\\"name\\\" 2) \\\"guide\\\" 3) \\\"description\\\" 4) \\\"dev\\\" 5) \\\"age\\\" 6) \\\"24\\\" > HSET userInfoKey name \\\"GuideGeGe\\\" > HGET userInfoKey name \\\"GuideGeGe\\\" > HINCRBY userInfoKey age 2 (integer) 26 \"]},\"186\":{\"h\":\"应用场景\",\"t\":[\"对象数据存储场景\",\"举例：用户信息、商品信息、文章信息、购物车信息。\",\"相关命令：HSET （设置单个字段的值）、HMSET（设置多个字段的值）、HGET（获取单个字段的值）、HMGET（获取多个字段的值）。\"]},\"187\":{\"h\":\"Set（集合）\"},\"188\":{\"h\":\"介绍\",\"t\":[\"Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。\",\"你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。\"]},\"189\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SADD key member1 member2 ...\",\"向指定集合添加一个或多个元素\",\"SMEMBERS key\",\"获取指定集合中的所有元素\",\"SCARD key\",\"获取指定集合的元素数量\",\"SISMEMBER key member\",\"判断指定元素是否在指定集合中\",\"SINTER key1 key2 ...\",\"获取给定所有集合的交集\",\"SINTERSTORE destination key1 key2 ...\",\"将给定所有集合的交集存储在 destination 中\",\"SUNION key1 key2 ...\",\"获取给定所有集合的并集\",\"SUNIONSTORE destination key1 key2 ...\",\"将给定所有集合的并集存储在 destination 中\",\"SDIFF key1 key2 ...\",\"获取给定所有集合的差集\",\"SDIFFSTORE destination key1 key2 ...\",\"将给定所有集合的差集存储在 destination 中\",\"SPOP key count\",\"随机移除并获取指定集合中一个或多个元素\",\"SRANDMEMBER key count\",\"随机获取指定集合中指定数量的元素\",\"更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=set 。\",\"基本操作：\",\"> SADD mySet value1 value2 (integer) 2 > SADD mySet value1 # 不允许有重复元素，因此添加失败 (integer) 0 > SMEMBERS mySet 1) \\\"value1\\\" 2) \\\"value2\\\" > SCARD mySet (integer) 2 > SISMEMBER mySet value1 (integer) 1 > SADD mySet2 value2 value3 (integer) 2 \",\"mySet : value1、value2 。\",\"mySet2：value2、value3 。\",\"求交集：\",\"> SINTERSTORE mySet3 mySet mySet2 (integer) 1 > SMEMBERS mySet3 1) \\\"value2\\\" \",\"求并集：\",\"> SUNION mySet mySet2 1) \\\"value3\\\" 2) \\\"value2\\\" 3) \\\"value1\\\" \",\"求差集：\",\"> SDIFF mySet mySet2 # 差集是由所有属于 mySet 但不属于 A 的元素组成的集合 1) \\\"value1\\\" \"]},\"190\":{\"h\":\"应用场景\",\"t\":[\"需要存放的数据不能重复的场景\",\"举例：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等场景。\",\"相关命令：SCARD（获取集合数量） 。\",\"需要获取多个数据源交集、并集和差集的场景\",\"举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。\",\"相关命令：SINTER（交集）、SINTERSTORE （交集）、SUNION （并集）、SUNIONSTORE（并集）、SDIFF（差集）、SDIFFSTORE （差集）。\",\"需要随机获取数据源中的元素的场景\",\"举例：抽奖系统、随机点名等场景。\",\"相关命令：SPOP（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、SRANDMEMBER（随机获取集合中的元素，适合允许重复中奖的场景）。\"]},\"191\":{\"h\":\"Sorted Set（有序集合）\"},\"192\":{\"h\":\"介绍\",\"t\":[\"Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\"]},\"193\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"ZADD key score1 member1 score2 member2 ...\",\"向指定有序集合添加一个或多个元素\",\"ZCARD KEY\",\"获取指定有序集合的元素数量\",\"ZSCORE key member\",\"获取指定有序集合中指定元素的 score 值\",\"ZINTERSTORE destination numkeys key1 key2 ...\",\"将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量\",\"ZUNIONSTORE destination numkeys key1 key2 ...\",\"求并集，其它和 ZINTERSTORE 类似\",\"ZDIFFSTORE destination numkeys key1 key2 ...\",\"求差集，其它和 ZINTERSTORE 类似\",\"ZRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从低到高）\",\"ZREVRANGE key start end\",\"获取指定有序集合 start 和 end 之间的元素（score 从高到底）\",\"ZREVRANK key member\",\"获取指定有序集合中指定元素的排名(score 从大到小排序)\",\"更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=sorted-set 。\",\"基本操作：\",\"> ZADD myZset 2.0 value1 1.0 value2 (integer) 2 > ZCARD myZset 2 > ZSCORE myZset value1 2.0 > ZRANGE myZset 0 1 1) \\\"value2\\\" 2) \\\"value1\\\" > ZREVRANGE myZset 0 1 1) \\\"value1\\\" 2) \\\"value2\\\" > ZADD myZset2 4.0 value2 3.0 value3 (integer) 2 \",\"myZset : value1(2.0)、value2(1.0) 。\",\"myZset2：value2 （4.0）、value3(3.0) 。\",\"获取指定元素的排名：\",\"> ZREVRANK myZset value1 0 > ZREVRANK myZset value2 1 \",\"求交集：\",\"> ZINTERSTORE myZset3 2 myZset myZset2 1 > ZRANGE myZset3 0 1 WITHSCORES value2 5 \",\"求并集：\",\"> ZUNIONSTORE myZset4 2 myZset myZset2 3 > ZRANGE myZset4 0 2 WITHSCORES value1 2 value3 3 value2 5 \",\"求差集：\",\"> ZDIFF 2 myZset myZset2 WITHSCORES value1 2 \"]},\"194\":{\"h\":\"应用场景\",\"t\":[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",\"举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\",\"《Java 面试指北》 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。\",\"需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。\",\"举例：优先级任务队列。\",\"相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\"]},\"195\":{\"h\":\"总结\",\"t\":[\"数据类型\",\"说明\",\"String\",\"一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"List\",\"Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\",\"Hash\",\"一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。\",\"Set\",\"无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\",\"Zset\",\"和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\"]},\"196\":{\"h\":\"参考\",\"t\":[\"Redis Data Structures：https://redis.com/redis-enterprise/data-structures/ 。\",\"Redis Commands：https://redis.io/commands/ 。\",\"Redis Data types tutorial：https://redis.io/docs/manual/data-types/data-types-tutorial/ 。\",\"Redis 存储对象信息是用 Hash 还是 String : https://segmentfault.com/a/1190000040032006\",\"File not found\"]},\"197\":{\"c\":[\"数据库\"]},\"198\":{\"c\":[\"Redis\"]},\"199\":{\"h\":\"Redis 3 种特殊数据类型详解\",\"t\":[\"除了 5 种基本的数据类型之外，Redis 还支持 3 种特殊的数据类型：Bitmap、HyperLogLog、GEO。\"]},\"200\":{\"h\":\"Bitmap （位图）\"},\"201\":{\"h\":\"介绍\",\"t\":[\"根据官网介绍：\",\"Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.\",\"Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。\",\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\",\"你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\"]},\"202\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"SETBIT key offset value\",\"设置指定 offset 位置的值\",\"GETBIT key offset\",\"获取指定 offset 位置的值\",\"BITCOUNT key start end\",\"获取 start 和 end 之前值为 1 的元素个数\",\"BITOP operation destkey key1 key2 ...\",\"对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT\",\"Bitmap 基本操作演示：\",\"# SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位 > SETBIT mykey 7 1 (integer) 0 > SETBIT mykey 7 0 (integer) 1 > GETBIT mykey 7 (integer) 0 > SETBIT mykey 6 1 (integer) 0 > SETBIT mykey 8 1 (integer) 0 # 通过 bitcount 统计被被设置为 1 的位的数量。 > BITCOUNT mykey (integer) 2 \"]},\"203\":{\"h\":\"应用场景\",\"t\":[\"需要保存状态信息（0/1 即可表示）的场景\",\"举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。\",\"相关命令：SETBIT、GETBIT、BITCOUNT、BITOP。\"]},\"204\":{\"h\":\"HyperLogLog（基数统计）\"},\"205\":{\"h\":\"介绍\",\"t\":[\"HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。\",\"Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：\",\"稀疏矩阵：计数较少的时候，占用空间很小。\",\"稠密矩阵：计数达到某个阈值的时候，占用 12k 的空间。\",\"Redis 官方文档中有对应的详细说明：\",\"基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\",\"HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的 。\",\"再推荐一个可以帮助理解 HyperLogLog 原理的工具：Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure 。\",\"除了 HyperLogLog 之外，Redis 还提供了其他的概率数据结构，对应的官方文档地址：https://redis.io/docs/data-types/probabilistic/ 。\"]},\"206\":{\"h\":\"常用命令\",\"t\":[\"HyperLogLog 相关的命令非常少，最常用的也就 3 个。\",\"命令\",\"介绍\",\"PFADD key element1 element2 ...\",\"添加一个或多个元素到 HyperLogLog 中\",\"PFCOUNT key1 key2\",\"获取一个或者多个 HyperLogLog 的唯一计数。\",\"PFMERGE destkey sourcekey1 sourcekey2 ...\",\"将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。\",\"HyperLogLog 基本操作演示：\",\"> PFADD hll foo bar zap (integer) 1 > PFADD hll zap zap zap (integer) 0 > PFADD hll foo bar (integer) 0 > PFCOUNT hll (integer) 3 > PFADD some-other-hll 1 2 3 (integer) 1 > PFCOUNT hll some-other-hll (integer) 6 > PFMERGE desthll hll some-other-hll \\\"OK\\\" > PFCOUNT desthll (integer) 6 \"]},\"207\":{\"h\":\"应用场景\",\"t\":[\"数量量巨大（百万、千万级别以上）的计数场景\",\"举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、\",\"相关命令：PFADD、PFCOUNT 。\"]},\"208\":{\"h\":\"Geospatial (地理位置)\"},\"209\":{\"h\":\"介绍\",\"t\":[\"Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\",\"通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\"]},\"210\":{\"h\":\"常用命令\",\"t\":[\"命令\",\"介绍\",\"GEOADD key longitude1 latitude1 member1 ...\",\"添加一个或多个元素对应的经纬度信息到 GEO 中\",\"GEOPOS key member1 member2 ...\",\"返回给定元素的经纬度信息\",\"GEODIST key member1 member2 M/KM/FT/MI\",\"返回两个给定元素之间的距离\",\"GEORADIUS key longitude latitude radius distance\",\"获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数\",\"GEORADIUSBYMEMBER key member radius distance\",\"类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素\",\"基本操作：\",\"> GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3 3 > GEOPOS personLocation user1 116.3299986720085144 39.89000061669732844 > GEODIST personLocation user1 user2 km 1.4018 \",\"通过 Redis 可视化工具查看 personLocation ，果不其然，底层就是 Sorted Set。\",\"GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。\",\"获取指定位置范围内的其他元素：\",\"> GEORADIUS personLocation 116.33 39.87 3 km user3 user1 > GEORADIUS personLocation 116.33 39.87 2 km > GEORADIUS personLocation 116.33 39.87 5 km user3 user1 user2 > GEORADIUSBYMEMBER personLocation user1 5 km user3 user1 user2 > GEORADIUSBYMEMBER personLocation user1 2 km user1 user2 \",\"GEORADIUS 命令的底层原理解析可以看看阿里的这篇文章：Redis 到底是怎么实现“附近的人”这个功能的呢？ 。\",\"移除元素：\",\"GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。\",\"> ZREM personLocation user1 1 > ZRANGE personLocation 0 -1 user3 user2 > ZSCORE personLocation user2 4069879562983946 \"]},\"211\":{\"h\":\"应用场景\",\"t\":[\"需要管理使用地理空间数据的场景\",\"举例：附近的人。\",\"相关命令: GEOADD、GEORADIUS、GEORADIUSBYMEMBER 。\"]},\"212\":{\"h\":\"总结\",\"t\":[\"数据类型\",\"说明\",\"Bitmap\",\"你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\",\"HyperLogLog\",\"Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\",\"Geospatial index\",\"Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\"]},\"213\":{\"h\":\"参考\",\"t\":[\"Redis Data Structures：https://redis.com/redis-enterprise/data-structures/ 。\",\"《Redis 深度历险：核心原理与应用实践》1.6 四两拨千斤——HyperLogLog\",\"布隆过滤器,位图,HyperLogLog：https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html\",\"File not found\"]},\"214\":{\"c\":[\"数据库\"]},\"215\":{\"c\":[\"Redis\"]},\"216\":{\"h\":\"Redis内存碎片详解\"},\"217\":{\"h\":\"什么是内存碎片?\",\"t\":[\"你可以将内存碎片简单地理解为那些不可用的空闲内存。\",\"举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。\",\"内存碎片\",\"Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。\"]},\"218\":{\"h\":\"为什么会有 Redis 内存碎片?\",\"t\":[\"Redis 内存碎片产生比较常见的 2 个原因：\",\"1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\",\"以下是这段 Redis 官方的原话：\",\"To store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible).\",\"Redis 使用 zmalloc 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 size 大小的内存之外，还会多分配 PREFIX_SIZE 大小的内存。\",\"zmalloc 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：\",\"void *zmalloc(size_t size) { // 分配指定大小的内存 void *ptr = malloc(size+PREFIX_SIZE); if (!ptr) zmalloc_oom_handler(size); #ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif } \",\"另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemalloc，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示：\",\"jemalloc 内存单元示意图\",\"当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。\",\"2、频繁修改 Redis 中的数据也会产生内存碎片。\",\"当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。\",\"这个在 Redis 官方文档中也有对应的原话:\",\"文档地址：https://redis.io/topics/memory-optimization 。\"]},\"219\":{\"h\":\"如何查看 Redis 内存碎片的信息？\",\"t\":[\"使用 info memory 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。\",\"Redis 内存碎片率的计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)\",\"也就是说，mem_fragmentation_ratio （内存碎片率）的值越大代表内存碎片率越严重。\",\"一定不要误认为used_memory_rss 减去 used_memory值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。\",\"很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。\",\"通常情况下，我们认为 mem_fragmentation_ratio > 1.5 的话才需要清理内存碎片。 mem_fragmentation_ratio > 1.5 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。\",\"如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：\",\"> redis-cli -p 6379 info | grep mem_fragmentation_ratio \",\"另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区 。\"]},\"220\":{\"h\":\"如何清理 Redis 内存碎片？\",\"t\":[\"Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。\",\"直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可。\",\"config set activedefrag yes \",\"具体什么时候清理需要通过下面两个参数控制：\",\"# 内存碎片占用空间达到 500mb 的时候开始清理 config set active-defrag-ignore-bytes 500mb # 内存碎片率大于 1.5 的时候开始清理 config set active-defrag-threshold-lower 50 \",\"通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：\",\"# 内存碎片清理所占用 CPU 时间的比例不低于 20% config set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不高于 50% config set active-defrag-cycle-max 50 \",\"另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。\"]},\"221\":{\"h\":\"参考\",\"t\":[\"Redis 官方文档：https://redis.io/topics/memory-optimization\",\"Redis 核心技术与实战 - 极客时间 - 删除数据后，为什么内存占用率还是很高？：https://time.geekbang.org/column/article/289140\",\"Redis 源码解析——内存分配：<https://shinerio.cc/2020/05/17/redis/Redis 源码解析——内存管理>\",\"File not found\"]},\"222\":{\"c\":[\"数据库\"]},\"223\":{\"c\":[\"Redis\"]},\"224\":{\"h\":\"Redis持久化机制详解\",\"t\":[\"使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。\",\"Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\",\"快照（snapshotting，RDB）\",\"只追加文件（append-only file, AOF）\",\"RDB 和 AOF 的混合持久化(Redis 4.0 新增)\",\"官方文档地址：https://redis.io/topics/persistence 。\"]},\"225\":{\"h\":\"RDB 持久化\"},\"226\":{\"h\":\"什么是 RDB 持久化？\",\"t\":[\"Redis 可以通过创建快照来获得存储在内存里面的数据在 某个时间点 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。\",\"快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：\",\"save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。 \"]},\"227\":{\"h\":\"RDB 创建快照时会阻塞主线程吗？\",\"t\":[\"Redis 提供了两个命令来生成 RDB 快照文件：\",\"save : 同步保存操作，会阻塞 Redis 主线程；\",\"bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。\",\"这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。\"]},\"228\":{\"h\":\"AOF 持久化\"},\"229\":{\"h\":\"什么是 AOF 持久化？\",\"t\":[\"与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 appendonly 参数开启：\",\"appendonly yes \",\"开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ fsync策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。\",\"只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。\",\"AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\"]},\"230\":{\"h\":\"AOF 工作基本流程是怎样的？\",\"t\":[\"AOF 持久化功能的实现可以简单分为 5 步：\",\"命令追加（append）：所有的写命令会追加到 AOF 缓冲区中。\",\"文件写入（write）：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。\",\"文件同步（fsync）：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。\",\"文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。\",\"重启加载（load）：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。\",\"Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 系统调用（syscall）。\",\"这里对上面提到的一些 Linux 系统调用再做一遍解释：\",\"write：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。\",\"fsync：fsync用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。\",\"AOF 工作流程图如下：\",\"AOF 工作基本流程\"]},\"231\":{\"h\":\"AOF 持久化方式有哪些？\",\"t\":[\"在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\",\"appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。\",\"appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）\",\"appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。\",\"可以看出：这 3 种持久化方式的主要区别在于 fsync 同步 AOF 文件的时机（刷盘）。\",\"为了兼顾数据和写入性能，可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\",\"从 Redis 7.0.0 开始，Redis 使用了 Multi Part AOF 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：\",\"BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。\",\"INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。\",\"HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。\",\"Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的Redis 7.0 Multi Part AOF 的设计和实现 这篇文章。\",\"相关 issue：Redis 的 AOF 方式 #783。\"]},\"232\":{\"h\":\"AOF 为什么是在执行完命令之后记录日志？\",\"t\":[\"关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。\",\"AOF 记录日志过程\",\"为什么是在执行完命令之后记录日志呢？\",\"避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；\",\"在命令执行完之后再记录，不会阻塞当前的命令执行。\",\"这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\",\"如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；\",\"可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。\"]},\"233\":{\"h\":\"AOF 重写了解吗？\",\"t\":[\"当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\",\"AOF 重写\",\"AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。\",\"由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。\",\"AOF 文件重写期间，Redis 还会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\",\"开启 AOF 重写功能，可以调用 BGREWRITEAOF 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：\",\"auto-aof-rewrite-min-size：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;\",\"auto-aof-rewrite-percentage：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。\",\"Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。\",\"Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的从 Redis7.0 发布看 Redis 的过去与未来 这篇文章。\",\"AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。\",\"阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。\",\"相关 issue：Redis AOF 重写描述不准确 #1439。\"]},\"234\":{\"h\":\"AOF 校验机制了解吗？\",\"t\":[\"AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 校验和（checksum） 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。\",\"类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。\"]},\"235\":{\"h\":\"Redis 4.0 对于持久化机制做了什么优化？\",\"t\":[\"由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\",\"如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。\",\"官方文档地址：https://redis.io/topics/persistence\"]},\"236\":{\"h\":\"如何选择 RDB 和 AOF？\",\"t\":[\"关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明Redis persistence，这里结合自己的理解简单总结一下。\",\"RDB 比 AOF 优秀的地方：\",\"RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。\",\"使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。\",\"AOF 比 RDB 优秀的地方：\",\"RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。\",\"RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。\",\"AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。\",\"综上：\",\"Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。\",\"不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。\",\"如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。\"]},\"237\":{\"h\":\"参考\",\"t\":[\"《Redis 设计与实现》\",\"Redis persistence - Redis 官方文档：https://redis.io/docs/management/persistence/\",\"The difference between AOF and RDB persistence：https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/\",\"Redis AOF 持久化详解 - 程序员历小冰：http://remcarpediem.net/article/376c55d8/\",\"Redis RDB 与 AOF 持久化 · Analyze：https://wingsxdu.com/posts/database/redis/rdb-and-aof/\",\"File not found\"]},\"238\":{\"c\":[\"数据库\"]},\"239\":{\"c\":[\"Redis\"]},\"240\":{\"h\":\"Redis常见面试题总结(上)\",\"t\":[\"File not found\"]},\"241\":{\"h\":\"Redis 基础\"},\"242\":{\"h\":\"什么是 Redis？\",\"t\":[\"Redis （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。\",\"为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。\",\"Redis 数据类型概览\",\"Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。\",\"个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的在线 Redis 环境（少部分命令无法使用）来实际体验 Redis。\",\"try-redis\",\"全世界有非常多的网站使用到了 Redis ，techstacks.io 专门维护了一个使用 Redis 的热门站点列表 ，感兴趣的话可以看看。\"]},\"243\":{\"h\":\"Redis 为什么这么快？\",\"t\":[\"Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：\",\"Redis 基于内存，内存的访问速度是磁盘的上千倍；\",\"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；\",\"Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。\",\"下面这张图片总结的挺不错的，分享一下，出自 Why is Redis so fast? 。\",\"why-redis-so-fast\"]},\"244\":{\"h\":\"分布式缓存常见的技术选型方案有哪些？\",\"t\":[\"分布式缓存的话，比较老牌同时也是使用的比较多的还是 Memcached 和 Redis。不过，现在基本没有看过还有项目使用 Memcached 来做缓存，都是直接用 Redis。\",\"Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。\",\"另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 RocksDB 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 Tendis。\",\"关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：Redis vs Tendis：冷热混合存储版架构揭秘 ，可以简单参考一下。\",\"从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。\"]},\"245\":{\"h\":\"说一下 Redis 和 Memcached 的区别和共同点\",\"t\":[\"现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！\",\"共同点：\",\"都是基于内存的数据库，一般都用来当做缓存使用。\",\"都有过期策略。\",\"两者的性能都非常高。\",\"区别：\",\"Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\",\"Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。\",\"Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。\",\"Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\",\"Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。\",\"Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 针对网络数据的读写引入了多线程）\",\"Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\",\"Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。\",\"相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。\"]},\"246\":{\"h\":\"为什么要用 Redis/为什么要用缓存？\",\"t\":[\"下面我们主要从“高性能”和“高并发”这两点来回答这个问题。\",\"1、高性能\",\"假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\",\"这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\",\"2、高并发\",\"一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\",\"QPS（Query Per Second）：服务器每秒可以执行的查询次数；\",\"由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。\"]},\"247\":{\"h\":\"常见的缓存读写策略有哪些？\",\"t\":[\"关于常见的缓存读写策略的详细介绍，可以看我写的这篇文章：3 种常用的缓存读写策略详解 。\"]},\"248\":{\"h\":\"Redis 应用\"},\"249\":{\"h\":\"Redis 除了做缓存，还能做什么？\",\"t\":[\"分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：分布式锁详解 。\",\"限流：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》。\",\"消息队列：Redis 自带的 List 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。\",\"延时队列：Redisson 内置了延时队列（基于 Sorted Set 实现的）。\",\"分布式 Session ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。\",\"复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。\",\"……\"]},\"250\":{\"h\":\"如何基于 Redis 实现分布式锁？\",\"t\":[\"关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：分布式锁详解 。\"]},\"251\":{\"h\":\"Redis 可以做消息队列么？\",\"t\":[\"实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。\",\"先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。\",\"Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。\",\"通过 RPUSH/LPOP 或者 LPUSH/RPOP即可实现简易版消息队列：\",\"# 生产者生产消息 > RPUSH myList msg1 msg2 (integer) 2 > RPUSH myList msg3 (integer) 3 # 消费者消费消息 > LPOP myList \\\"msg1\\\" \",\"不过，通过 RPUSH/LPOP 或者 LPUSH/RPOP这样的方式存在性能问题，我们需要不断轮询去调用 RPOP 或 LPOP 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。\",\"因此，Redis 还提供了 BLPOP、BRPOP 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息\",\"# 超时时间为 10s # 如果有数据立刻返回，否则最多等待10秒 > BRPOP myList 10 null \",\"List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。\",\"Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。\",\"Redis 发布订阅 (pub/sub) 功能\",\"pub/sub 中引入了一个概念叫 channel（频道），发布订阅机制的实现就是基于这个 channel 来做的。\",\"pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：\",\"发布者通过 PUBLISH 投递消息给指定 channel。\",\"订阅者通过SUBSCRIBE订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。\",\"我们这里启动 3 个 Redis 客户端来简单演示一下：\",\"pub/sub 实现消息队列演示\",\"pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。\",\"为此，Redis 5.0 新增加的一个数据结构 Stream 来做消息队列。Stream 支持：\",\"发布 / 订阅模式\",\"按照消费者组进行消费\",\"消息持久化（ RDB 和 AOF）\",\"Stream 使用起来相对要麻烦一些，这里就不演示了。而且，Stream 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。\",\"综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。\",\"相关阅读：Redis 消息队列发展历程 - 阿里开发者 - 2022。\"]},\"252\":{\"h\":\"Redis 数据类型\",\"t\":[\"关于 Redis 5 种基础数据类型和 3 种特殊数据类型的详细介绍请看下面这两篇文章以及 Redis 官方文档 ：\",\"Redis 5 种基本数据类型详解\",\"Redis 3 种特殊数据类型详解\"]},\"253\":{\"h\":\"Redis 常用的数据类型有哪些？\",\"t\":[\"Redis 中比较常见的数据类型有下面这些：\",\"5 种基础数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\",\"3 种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)。\",\"除了上面提到的之外，还有一些其他的比如 Bloom filter（布隆过滤器）、Bitfield（位域）。\"]},\"254\":{\"h\":\"String 的应用场景有哪些？\",\"t\":[\"String 是 Redis 中最简单同时也是最常用的一个数据类型。它是一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\",\"String 的常见应用场景如下：\",\"常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存；\",\"计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；\",\"分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)；\",\"……\",\"关于 String 的详细介绍请看这篇文章：Redis 5 种基本数据类型详解。\"]},\"255\":{\"h\":\"String 还是 Hash 存储对象数据更好呢？\",\"t\":[\"String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。\",\"String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。\",\"在绝大部分情况，我们建议使用 String 来存储对象数据即可！\"]},\"256\":{\"h\":\"String 的底层实现是什么？\",\"t\":[\"Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \\\\0 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。\",\"SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。\",\"Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：\",\"/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; \",\"通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。\",\"类型\",\"字节\",\"位\",\"sdshdr5\",\"< 1\",\"<8\",\"sdshdr8\",\"1\",\"8\",\"sdshdr16\",\"2\",\"16\",\"sdshdr32\",\"4\",\"32\",\"sdshdr64\",\"8\",\"64\",\"对于后四种实现都包含了下面这 4 个属性：\",\"len：字符串的长度也就是已经使用的字节数\",\"alloc：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小\",\"buf[]：实际存储字符串的数组\",\"flags：低三位保存类型标志\",\"SDS 相比于 C 语言中的字符串有如下提升：\",\"可以避免缓冲区溢出：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。\",\"获取字符串长度的复杂度较低：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。\",\"减少内存分配次数：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。\",\"二进制安全：C 语言中的字符串以空字符 \\\\0 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。\",\"🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：\",\"struct sdshdr { unsigned int len; unsigned int free; char buf[]; }; \",\"这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，len 和 free 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。\"]},\"257\":{\"h\":\"购物车信息用 String 还是 Hash 存储更好呢?\",\"t\":[\"由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\",\"用户 id 为 key\",\"商品 id 为 field，商品数量为 value\",\"Hash维护简单的购物车信息\",\"那用户购物车信息的维护具体应该怎么操作呢？\",\"用户添加商品就是往 Hash 里面增加新的 field 与 value；\",\"查询购物车信息就是遍历对应的 Hash；\",\"更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；\",\"删除商品就是删除 Hash 中对应的 field；\",\"清空购物车直接删除对应的 key 即可。\",\"这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。\"]},\"258\":{\"h\":\"使用 Redis 实现一个排行榜怎么做？\",\"t\":[\"Redis 中有一个叫做 Sorted Set 的数据类型经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\",\"相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\",\"《Java 面试指北》 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜，感兴趣的小伙伴可以看看。\"]},\"259\":{\"h\":\"Set 的应用场景是什么？\",\"t\":[\"Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\",\"Set 的常见应用场景如下：\",\"存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。\",\"需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。\",\"需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。\"]},\"260\":{\"h\":\"使用 Set 实现抽奖系统怎么做？\",\"t\":[\"如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\",\"SADD key member1 member2 ...：向指定集合添加一个或多个元素。\",\"SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。\",\"SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。\"]},\"261\":{\"h\":\"使用 Bitmap 统计活跃用户怎么做？\",\"t\":[\"Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\",\"你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\",\"img\",\"如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\",\"初始化数据：\",\"> SETBIT 20210308 1 1 (integer) 0 > SETBIT 20210308 2 1 (integer) 0 > SETBIT 20210309 1 1 (integer) 0 \",\"统计 20210308~20210309 总活跃用户数:\",\"> BITOP and desk1 20210308 20210309 (integer) 1 > BITCOUNT desk1 (integer) 1 \",\"统计 20210308~20210309 在线活跃用户数:\",\"> BITOP or desk2 20210308 20210309 (integer) 1 > BITCOUNT desk2 (integer) 2 \"]},\"262\":{\"h\":\"使用 HyperLogLog 统计页面 UV 怎么做？\",\"t\":[\"使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：\",\"PFADD key element1 element2 ...：添加一个或多个元素到 HyperLogLog 中。\",\"PFCOUNT key1 key2：获取一个或者多个 HyperLogLog 的唯一计数。\",\"1、将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。\",\"PFADD PAGE_1:UV USER1 USER2 ...... USERn \",\"2、统计指定页面的 UV。\",\"PFCOUNT PAGE_1:UV \"]},\"263\":{\"h\":\"Redis 持久化机制（重要）\",\"t\":[\"Redis 持久化机制（RDB 持久化、AOF 持久化、RDB 和 AOF 的混合持久化） 相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 Redis 持久化机制相关的知识点和问题：Redis 持久化机制详解 。\"]},\"264\":{\"h\":\"Redis 线程模型（重要）\",\"t\":[\"对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。\"]},\"265\":{\"h\":\"Redis 单线程模型了解吗？\",\"t\":[\"Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。\",\"《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。\",\"Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。\",\"文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。\",\"当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。\",\"虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。\",\"既然是单线程，那怎么监听大量的客户端连接呢？\",\"Redis 通过 IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。\",\"这样的好处非常明显：I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。\",\"文件事件处理器（file event handler）主要是包含 4 个部分：\",\"多个 socket（客户端连接）\",\"IO 多路复用程序（支持多个客户端连接的关键）\",\"文件事件分派器（将 socket 关联到相应的事件处理器）\",\"事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）\",\"文件事件处理器（file event handler）\",\"相关阅读：Redis 事件机制详解 。\"]},\"266\":{\"h\":\"Redis6.0 之前为什么不使用多线程？\",\"t\":[\"虽然说 Redis 是单线程模型，但是，实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。\",\"不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。\",\"为此，Redis 4.0 之后新增了UNLINK（可以看作是 DEL 的异步版本）、FLUSHALL ASYNC（清空所有数据库的所有 key，不仅仅是当前 SELECT 的数据库）、FLUSHDB ASYNC（清空当前 SELECT 数据库中的所有 key）等异步命令。\",\"redis4.0 more thread\",\"大体上来说，Redis 6.0 之前主要还是单线程处理。\",\"那 Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点：\",\"单线程编程容易并且更容易维护；\",\"Redis 的性能瓶颈不在 CPU ，主要在内存和网络；\",\"多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。\",\"相关阅读：为什么 Redis 选择单线程模型？ 。\"]},\"267\":{\"h\":\"Redis6.0 之后为何引入了多线程？\",\"t\":[\"Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。\",\"虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。\",\"Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 > 1，需要修改 redis 配置文件 redis.conf：\",\"io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程 \",\"另外：\",\"io-threads 的个数一旦设置，不能通过 config 动态设置。\",\"当设置 ssl 后，io-threads 将不工作。\",\"开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 redis.conf :\",\"io-threads-do-reads yes \",\"但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启\",\"相关阅读：\",\"Redis 6.0 新特性-多线程连环 13 问！\",\"Redis 多线程网络模型全面揭秘（推荐）\"]},\"268\":{\"h\":\"Redis 后台线程了解吗？\",\"t\":[\"我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：\",\"通过 bio_close_file 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。\",\"通过 bio_aof_fsync 后台线程调用 fsync 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。\",\"通过 bio_lazy_free后台线程释放大对象（已删除）占用的内存空间.\",\"在bio.h 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：\",\"#ifndef __BIO_H #define __BIO_H /* Exported API */ void bioInit(void); void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3); unsigned long long bioPendingJobsOfType(int type); unsigned long long bioWaitStepOfType(int type); time_t bioOlderJobOfType(int type); void bioKillThreads(void); /* Background job opcodes */ #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */ #define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */ #define BIO_LAZY_FREE 2 /* Deferred objects freeing. */ #define BIO_NUM_OPS 3 #endif \",\"关于 Redis 后台线程的详细介绍可以查看 Redis 6.0 后台线程有哪些？ 这篇就文章。\"]},\"269\":{\"h\":\"Redis 内存管理\"},\"270\":{\"h\":\"Redis 给缓存数据设置过期时间有啥用？\",\"t\":[\"一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？\",\"因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。\",\"Redis 自带了给缓存数据设置过期时间的功能，比如：\",\"127.0.0.1:6379> expire key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379> ttl key # 查看数据还有多久过期 (integer) 56 \",\"注意：Redis 中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间。\",\"过期时间除了有助于缓解内存的消耗，还有什么其他用么？\",\"很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 Token 可能只在 1 天内有效。\",\"如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。\"]},\"271\":{\"h\":\"Redis 是如何判断数据是否过期的呢？\",\"t\":[\"Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。\",\"redis过期字典\",\"过期字典是存储在 redisDb 这个结构里的：\",\"typedef struct redisDb { ... dict *dict; //数据库键空间,保存着数据库中所有键值对 dict *expires // 过期字典,保存着键的过期时间 ... } redisDb; \"]},\"272\":{\"h\":\"过期的数据的删除策略了解么？\",\"t\":[\"如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？\",\"常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：\",\"惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。\",\"定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。\",\"定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。\",\"但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。\",\"怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。\"]},\"273\":{\"h\":\"Redis 内存淘汰机制了解么？\",\"t\":[\"相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?\",\"Redis 提供 6 种数据淘汰策略：\",\"volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。\",\"volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。\",\"volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。\",\"allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\",\"allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。\",\"no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！\",\"4.0 版本后增加以下两种：\",\"volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。\",\"allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。\"]},\"274\":{\"h\":\"参考\",\"t\":[\"《Redis 开发与运维》\",\"《Redis 设计与实现》\",\"Redis 命令手册：https://www.redis.com.cn/commands.html\",\"WHY Redis choose single thread (vs multi threads): https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153\",\"File not found\"]},\"275\":{\"c\":[\"数据库\"]},\"276\":{\"c\":[\"Redis\"]},\"277\":{\"h\":\"Redis常见面试题总结(下)\",\"t\":[\"File not found\"]},\"278\":{\"h\":\"Redis 事务\"},\"279\":{\"h\":\"什么是 Redis 事务？\",\"t\":[\"你可以将 Redis 中的事务理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。\",\"Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。\",\"除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。\",\"因此，Redis 事务是不建议在日常开发中使用的。\"]},\"280\":{\"h\":\"如何使用 Redis 事务？\",\"t\":[\"Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(Transaction)功能。\",\"> MULTI OK > SET PROJECT \\\"JavaGuide\\\" QUEUED > GET PROJECT QUEUED > EXEC 1) OK 2) \\\"JavaGuide\\\" \",\"MULTI 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令后，再执行所有的命令。\",\"这个过程是这样的：\",\"开始事务（MULTI）；\",\"命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；\",\"执行事务(EXEC)。\",\"你也可以通过 DISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令。\",\"> MULTI OK > SET PROJECT \\\"JavaGuide\\\" QUEUED > GET PROJECT QUEUED > DISCARD OK \",\"你可以通过WATCH 命令监听指定的 Key，当调用 EXEC 命令执行事务时，如果一个被 WATCH 命令监视的 Key 被 其他客户端/Session 修改的话，整个事务都不会被执行。\",\"# 客户端 1 > SET PROJECT \\\"RustGuide\\\" OK > WATCH PROJECT OK > MULTI OK > SET PROJECT \\\"JavaGuide\\\" QUEUED # 客户端 2 # 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值 > SET PROJECT \\\"GoGuide\\\" # 客户端 1 # 修改失败，因为 PROJECT 的值被客户端2修改了 > EXEC (nil) > GET PROJECT \\\"GoGuide\\\" \",\"不过，如果 WATCH 与 事务 在同一个 Session 里，并且被 WATCH 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：WATCH 命令碰到 MULTI 命令时的不同效果）。\",\"事务内部修改 WATCH 监视的 Key：\",\"> SET PROJECT \\\"JavaGuide\\\" OK > WATCH PROJECT OK > MULTI OK > SET PROJECT \\\"JavaGuide1\\\" QUEUED > SET PROJECT \\\"JavaGuide2\\\" QUEUED > SET PROJECT \\\"JavaGuide3\\\" QUEUED > EXEC 1) OK 2) OK 3) OK 127.0.0.1:6379> GET PROJECT \\\"JavaGuide3\\\" \",\"事务外部修改 WATCH 监视的 Key：\",\"> SET PROJECT \\\"JavaGuide\\\" OK > WATCH PROJECT OK > SET PROJECT \\\"JavaGuide2\\\" OK > MULTI OK > GET USER QUEUED > EXEC (nil) \",\"Redis 官网相关介绍 https://redis.io/topics/transactions 如下：\",\"Redis 事务\"]},\"281\":{\"h\":\"Redis 事务支持原子性吗？\",\"t\":[\"Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：1. 原子性，2. 隔离性，3. 持久性，4. 一致性。\",\"原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\",\"隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\",\"持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\",\"一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\",\"Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。\",\"Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。\",\"Redis 为什么不支持回滚\",\"相关 issue :\",\"issue#452: 关于 Redis 事务不满足原子性的问题 。\",\"Issue#491:关于 Redis 没有事务回滚？\"]},\"282\":{\"h\":\"Redis 事务支持持久性吗？\",\"t\":[\"Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\",\"快照（snapshotting，RDB）\",\"只追加文件（append-only file, AOF）\",\"RDB 和 AOF 的混合持久化(Redis 4.0 新增)\",\"与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\",\"appendfsync always #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度 appendfsync everysec #每秒钟调用fsync函数同步一次AOF文件 appendfsync no #让操作系统决定何时进行同步，一般为30秒一次 \",\"AOF 持久化的fsync策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。\",\"因此，Redis 事务的持久性也是没办法保证的。\"]},\"283\":{\"h\":\"如何解决 Redis 事务的缺陷？\",\"t\":[\"Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。\",\"一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。\",\"不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， 严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。\",\"如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。\",\"另外，Redis 7.0 新增了 Redis functions 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。\"]},\"284\":{\"h\":\"Redis 性能优化（重要）\",\"t\":[\"除了下面介绍的内容之外，再推荐两篇不错的文章：\",\"你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者\",\"Redis 常见阻塞原因总结 - JavaGuide\"]},\"285\":{\"h\":\"使用批量操作减少网络传输\",\"t\":[\"一个 Redis 命令的执行可以简化为以下 4 步：\",\"发送命令\",\"命令排队\",\"命令执行\",\"返回结果\",\"其中，第 1 步和第 4 步耗费时间之和称为 Round Trip Time (RTT,往返时间) ，也就是数据在网络上传输的时间。\",\"使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。\",\"另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在read()和write()系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。\"]},\"286\":{\"h\":\"原生批量操作命令\",\"t\":[\"Redis 中有一些原生支持批量操作的命令，比如：\",\"MGET(获取一个或多个指定 key 的值)、MSET(设置一个或多个指定 key 的值)、\",\"HMGET(获取指定哈希表中一个或者多个指定字段的值)、HMSET(同时将一个或多个 field-value 对设置到指定哈希表中)、\",\"SADD（向指定集合添加一个或多个元素）\",\"……\",\"不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 MGET 无法保证所有的 key 都在同一个 hash slot（哈希槽）上，MGET可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。\",\"整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：\",\"找到 key 对应的所有 hash slot；\",\"分别向对应的 Redis 节点发起 MGET 请求获取数据；\",\"等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。\",\"如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。\",\"Redis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。\",\"我在 Redis 集群详解（付费） 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。\"]},\"287\":{\"h\":\"pipeline\",\"t\":[\"对于不支持批量操作的命令，我们可以利用 pipeline（流水线) 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 元素个数(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。\",\"与MGET、MSET等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 hash slot（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。\",\"原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：\",\"原生批量操作命令是原子操作，pipeline 是非原子操作。\",\"pipeline 可以打包不同的命令，原生批量操作命令不可以。\",\"原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。\",\"顺带补充一下 pipeline 和 Redis 事务的对比：\",\"事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。\",\"Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。\",\"事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。\",\"另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 Lua 脚本 。\"]},\"288\":{\"h\":\"Lua 脚本\",\"t\":[\"Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 原子操作 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。\",\"并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。\",\"不过， Lua 脚本依然存在下面这些缺陷：\",\"如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。\",\"Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。\"]},\"289\":{\"h\":\"大量 key 集中过期问题\",\"t\":[\"我在前面提到过：对于过期 key，Redis 采用的是 定期删除+惰性/懒汉式删除 策略。\",\"定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。\",\"如何解决呢？ 下面是两种常见的方法：\",\"给 key 设置随机过期时间。\",\"开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\",\"个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。\"]},\"290\":{\"h\":\"Redis bigkey（大 Key）\"},\"291\":{\"h\":\"什么是 bigkey？\",\"t\":[\"简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：\",\"string 类型的 value 超过 1MB\",\"复合类型（List、Hash、Set、Sorted Set 等）的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。\"]},\"292\":{\"h\":\"bigkey 是怎么产生的？有什么危害？\",\"t\":[\"bigkey 通常是由于下面这些原因产生的：\",\"程序设计不当，比如直接使用 string 类型存储较大的文件对应的二进制数据。\",\"对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。\",\"未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。\",\"bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。\",\"在 Redis 常见阻塞原因总结这篇文章中我们提到：大 key 还会造成阻塞问题。具体来说，主要体现在下面三个方面：\",\"客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。\",\"网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。\",\"工作线程阻塞：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。\",\"大 key 造成的阻塞问题还会进一步影响到主从同步和集群扩容。\",\"综上，大 key 带来的潜在问题是非常多的，我们应该尽量避免 Redis 中存在 bigkey。\"]},\"293\":{\"h\":\"如何发现 bigkey？\",\"t\":[\"1、使用 Redis 自带的 --bigkeys 参数来查找。\",\"# redis-cli -p 6379 --bigkeys # Scanning the entire keyspace to find biggest keys as well as # average sizes per key type. You can use -i 0.1 to sleep 0.1 sec # per 100 SCAN commands (not usually needed). [00.00%] Biggest string found so far '\\\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\\\"' with 4437 bytes [00.00%] Biggest list found so far '\\\"my-list\\\"' with 17 items -------- summary ------- Sampled 5 keys in the keyspace! Total key length in bytes is 264 (avg len 52.80) Biggest list found '\\\"my-list\\\"' has 17 items Biggest string found '\\\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\\\"' has 4437 bytes 1 lists with 17 items (20.00% of keys, avg size 17.00) 0 hashs with 0 fields (00.00% of keys, avg size 0.00) 4 strings with 4831 bytes (80.00% of keys, avg size 1207.75) 0 streams with 0 entries (00.00% of keys, avg size 0.00) 0 sets with 0 members (00.00% of keys, avg size 0.00) 0 zsets with 0 members (00.00% of keys, avg size 0.00 \",\"从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。\",\"在线上执行该命令时，为了降低对 Redis 的影响，需要指定 -i 参数控制扫描的频率。redis-cli -p 6379 --bigkeys -i 3 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。\",\"2、使用 Redis 自带的 SCAN 命令\",\"SCAN 命令可以按照一定的模式和数量返回匹配的 key。获取了 key 之后，可以利用 STRLEN、HLEN、LLEN等命令返回其长度或成员数量。\",\"数据结构\",\"命令\",\"复杂度\",\"结果（对应 key）\",\"String\",\"STRLEN\",\"O(1)\",\"字符串值的长度\",\"Hash\",\"HLEN\",\"O(1)\",\"哈希表中字段的数量\",\"List\",\"LLEN\",\"O(1)\",\"列表元素数量\",\"Set\",\"SCARD\",\"O(1)\",\"集合元素数量\",\"Sorted Set\",\"ZCARD\",\"O(1)\",\"有序集合的元素数量\",\"对于集合类型还可以使用 MEMORY USAGE 命令（Redis 4.0+），这个命令会返回键值对占用的内存空间。\",\"3、借助开源工具分析 RDB 文件。\",\"通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。\",\"网上有现成的代码/工具可以直接拿来使用：\",\"redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具\",\"rdb_bigkeys : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。\",\"4、借助公有云的 Redis 分析服务。\",\"如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。\",\"这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。\",\"阿里云Key分析\"]},\"294\":{\"h\":\"如何处理 bigkey？\",\"t\":[\"bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\",\"分割 bigkey：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。\",\"手动清理：Redis 4.0+ 可以使用 UNLINK 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 SCAN 命令结合 DEL 命令来分批次删除。\",\"采用合适的数据结构：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）。\",\"开启 lazy-free（惰性删除/延迟释放） ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。\"]},\"295\":{\"h\":\"Redis hotkey（热 Key）\"},\"296\":{\"h\":\"什么是 hotkey？\",\"t\":[\"如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey（热 Key）。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。\",\"hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\"]},\"297\":{\"h\":\"hotkey 有什么危害？\",\"t\":[\"处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\",\"因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\"]},\"298\":{\"h\":\"如何发现 hotkey？\",\"t\":[\"1、使用 Redis 自带的 --hotkeys 参数来查找。\",\"Redis 4.0.3 版本中新增了 hotkeys 参数，该参数能够返回所有 key 的被访问次数。\",\"使用该方案的前提条件是 Redis Server 的 maxmemory-policy 参数设置为 LFU 算法，不然就会出现如下所示的错误。\",\"# redis-cli -p 6379 --hotkeys # Scanning the entire keyspace to find hot keys as well as # average sizes per key type. You can use -i 0.1 to sleep 0.1 sec # per 100 SCAN commands (not usually needed). Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust. \",\"Redis 中有两种 LFU 算法：\",\"volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。\",\"allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。\",\"以下是配置文件 redis.conf 中的示例：\",\"# 使用 volatile-lfu 策略 maxmemory-policy volatile-lfu # 或者使用 allkeys-lfu 策略 maxmemory-policy allkeys-lfu \",\"需要注意的是，hotkeys 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。\",\"2、使用MONITOR 命令。\",\"MONITOR 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。\",\"由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 MONITOR（生产环境中建议谨慎使用该命令）。\",\"# redis-cli 127.0.0.1:6379> MONITOR OK 1683638260.637378 [0 172.17.0.1:61516] \\\"ping\\\" 1683638267.144236 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" 1683638268.941863 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" 1683638269.551671 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" 1683638270.646256 [0 172.17.0.1:61516] \\\"ping\\\" 1683638270.849551 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" 1683638271.926945 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" 1683638274.276599 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet2\\\" 1683638276.327234 [0 172.17.0.1:61518] \\\"smembers\\\" \\\"mySet\\\" \",\"在发生紧急情况时，我们可以选择在合适的时机短暂执行 MONITOR 命令并将输出重定向至文件，在关闭 MONITOR 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。\",\"3、借助开源项目。\",\"京东零售的 hotkey 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。\",\"京东零售开源的 hotkey\",\"4、根据业务情况提前预估。\",\"可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。\",\"5、业务代码中记录分析。\",\"在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。\",\"6、借助公有云的 Redis 分析服务。\",\"如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。\",\"这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。\",\"阿里云Key分析\"]},\"299\":{\"h\":\"如何解决 hotkey？\",\"t\":[\"hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\",\"读写分离：主节点处理写请求，从节点处理读请求。\",\"使用 Redis Cluster：将热点数据分散存储在多个 Redis 节点上。\",\"二级缓存：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。\",\"除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。\",\"这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。\",\"通过阿里云的Proxy Query Cache优化热点Key问题\"]},\"300\":{\"h\":\"慢查询命令\"},\"301\":{\"h\":\"为什么会有慢查询命令？\",\"t\":[\"我们知道一个 Redis 命令的执行可以简化为以下 4 步：\",\"发送命令\",\"命令排队\",\"命令执行\",\"返回结果\",\"Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。\",\"Redis 为什么会有慢查询命令呢？\",\"Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\",\"KEYS *：会返回所有符合规则的 key。\",\"HGETALL：会返回一个 Hash 中所有的键值对。\",\"LRANGE：会返回 List 中指定范围内的元素。\",\"SMEMBERS：返回 Set 中的所有元素。\",\"SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。\",\"……\",\"由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\",\"除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\",\"ZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。\",\"……\"]},\"302\":{\"h\":\"如何找到慢查询命令？\",\"t\":[\"在 redis.conf 文件中，我们可以使用 slowlog-log-slower-than 参数设置耗时命令的阈值，并使用 slowlog-max-len 参数设置耗时命令的最大记录条数。\",\"当 Redis 服务器检测到执行时间超过 slowlog-log-slower-than阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。\",\"⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。\",\"slowlog-log-slower-than和slowlog-max-len的默认配置如下(可以自行修改)：\",\"# The following time is expressed in microseconds, so 1000000 is equivalent # to one second. Note that a negative number disables the slow log, while # a value of zero forces the logging of every command. slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory. # You can reclaim memory used by the slow log with SLOWLOG RESET. slowlog-max-len 128 \",\"除了修改配置文件之外，你也可以直接通过 CONFIG 命令直接设置：\",\"# 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录 CONFIG SET slowlog-log-slower-than 10000 # 只保留最近 128 条耗时命令 CONFIG SET slowlog-max-len 128 \",\"获取慢查询日志的内容很简单，直接使用SLOWLOG GET 命令即可。\",\"127.0.0.1:6379> SLOWLOG GET #慢日志查询 1) 1) (integer) 5 2) (integer) 1684326682 3) (integer) 12000 4) 1) \\\"KEYS\\\" 2) \\\"*\\\" 5) \\\"172.17.0.1:61152\\\" 6) \\\"\\\" // ... \",\"慢查询日志中的每个条目都由以下六个值组成：\",\"唯一渐进的日志标识符。\",\"处理记录命令的 Unix 时间戳。\",\"执行所需的时间量，以微秒为单位。\",\"组成命令参数的数组。\",\"客户端 IP 地址和端口。\",\"客户端名称。\",\"SLOWLOG GET 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 SLOWLOG GET N。\",\"下面是其他比较常用的慢查询相关的命令：\",\"# 返回慢查询命令的数量 127.0.0.1:6379> SLOWLOG LEN (integer) 128 # 清空慢查询命令 127.0.0.1:6379> SLOWLOG RESET OK \"]},\"303\":{\"h\":\"Redis 内存碎片\",\"t\":[\"相关问题：\",\"什么是内存碎片?为什么会有 Redis 内存碎片?\",\"如何清理 Redis 内存碎片？\",\"参考答案：Redis 内存碎片详解。\"]},\"304\":{\"h\":\"Redis 生产问题（重要）\"},\"305\":{\"h\":\"缓存穿透\"},\"306\":{\"h\":\"什么是缓存穿透？\",\"t\":[\"缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\",\"缓存穿透\",\"举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。\"]},\"307\":{\"h\":\"有哪些解决办法？\",\"t\":[\"最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\",\"1）缓存无效 key\",\"如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。\",\"另外，这里多说一嘴，一般情况下我们是这样设计 key 的：表名:列名:主键名:主键值 。\",\"如果用 Java 代码展示的话，差不多是下面这样的：\",\"public Object getObjectInclNullById(Integer id) { // 从缓存中获取数据 Object cacheValue = cache.get(id); // 缓存为空 if (cacheValue == null) { // 从数据库中获取 Object storageValue = storage.get(key); // 缓存空对象 cache.set(key, storageValue); // 如果存储数据为空，需要设置一个过期时间(300秒) if (storageValue == null) { // 必须设置过期时间，否则有被攻击的风险 cache.expire(key, 60 * 5); } return storageValue; } return cacheValue; } \",\"2）布隆过滤器\",\"布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。\",\"具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\",\"加入布隆过滤器之后的缓存处理流程图如下。\",\"加入布隆过滤器之后的缓存处理流程图\",\"但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\",\"为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！\",\"我们先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作：\",\"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\",\"根据得到的哈希值，在位数组中把对应下标的值置为 1。\",\"我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：\",\"对给定元素再次进行相同的哈希计算；\",\"得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"然后，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。 （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\",\"更多关于布隆过滤器的内容可以看我的这篇原创：《不了解布隆过滤器？一文给你整的明明白白！》 ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。\"]},\"308\":{\"h\":\"缓存击穿\"},\"309\":{\"h\":\"什么是缓存击穿？\",\"t\":[\"缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\",\"缓存击穿\",\"举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。\"]},\"310\":{\"h\":\"有哪些解决办法？\",\"t\":[\"设置热点数据永不过期或者过期时间比较长。\",\"针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\",\"请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。\"]},\"311\":{\"h\":\"缓存穿透和缓存击穿有什么区别？\",\"t\":[\"缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。\",\"缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。\"]},\"312\":{\"h\":\"缓存雪崩\"},\"313\":{\"h\":\"什么是缓存雪崩？\",\"t\":[\"我发现缓存雪崩这名字起的有点意思，哈哈。\",\"实际上，缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\",\"另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。\",\"缓存雪崩\",\"举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。\"]},\"314\":{\"h\":\"有哪些解决办法？\",\"t\":[\"针对 Redis 服务不可用的情况：\",\"采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。\",\"限流，避免同时处理大量的请求。\",\"针对热点缓存失效的情况：\",\"设置不同的失效时间比如随机设置缓存的失效时间。\",\"缓存永不失效（不太推荐，实用性太差）。\",\"设置二级缓存。\"]},\"315\":{\"h\":\"缓存雪崩和缓存击穿有什么区别？\",\"t\":[\"缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。\"]},\"316\":{\"h\":\"如何保证缓存和数据库数据的一致性？\",\"t\":[\"细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。\",\"下面单独对 Cache Aside Pattern（旁路缓存模式） 来聊聊。\",\"Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。\",\"如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：\",\"缓存失效时间变短（不推荐，治标不治本）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。\",\"增加 cache 更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。\",\"相关文章推荐：缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹。\"]},\"317\":{\"h\":\"哪些情况可能会导致 Redis 阻塞？\",\"t\":[\"单独抽了一篇文章来总结可能会导致 Redis 阻塞的情况：Redis 常见阻塞原因总结。\"]},\"318\":{\"h\":\"Redis 集群\",\"t\":[\"Redis Sentinel：\",\"什么是 Sentinel？ 有什么用？\",\"Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?\",\"Sentinel 是如何实现故障转移的？\",\"为什么建议部署多个 sentinel 节点（哨兵集群）？\",\"Sentinel 如何选择出新的 master（选举机制）?\",\"如何从 Sentinel 集群中选择出 Leader ？\",\"Sentinel 可以防止脑裂吗？\",\"Redis Cluster：\",\"为什么需要 Redis Cluster？解决了什么问题？有什么优势？\",\"Redis Cluster 是如何分片的？\",\"为什么 Redis Cluster 的哈希槽是 16384 个?\",\"如何确定给定 key 的应该分布到哪个哈希槽中？\",\"Redis Cluster 支持重新分配哈希槽吗？\",\"Redis Cluster 扩容缩容期间可以提供服务吗？\",\"Redis Cluster 中的节点是怎么进行通信的？\",\"参考答案：Redis 集群详解（付费）。\"]},\"319\":{\"h\":\"Redis 使用规范\",\"t\":[\"实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：\",\"使用连接池：避免频繁创建关闭客户端连接。\",\"尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 KEYS *、HGETALL、LRANGE、SMEMBERS、SINTER/SUNION/SDIFF等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\",\"使用批量操作减少网络传输：原生批量操作命令（比如 MGET、MSET等等）、pipeline、Lua 脚本。\",\"尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。\",\"禁止长时间开启 monitor：对性能影响比较大。\",\"控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。\",\"……\",\"相关文章推荐：阿里云 Redis 开发规范 。\"]},\"320\":{\"h\":\"参考\",\"t\":[\"《Redis 开发与运维》\",\"《Redis 设计与实现》\",\"Redis Transactions : https://redis.io/docs/manual/transactions/\",\"What is Redis Pipeline：https://buildatscale.tech/what-is-redis-pipeline/\",\"一文详解 Redis 中 BigKey、HotKey 的发现与处理：https://mp.weixin.qq.com/s/FPYE1B839_8Yk1-YSiW-1Q\",\"Bigkey 问题的解决思路与方式探索:https://mp.weixin.qq.com/s/Sej7D9TpdAobcCmdYdMIyA\",\"Redis 延迟问题全面排障指南：https://mp.weixin.qq.com/s/mIc6a9mfEGdaNDD3MmfFsg\",\"File not found\"]},\"321\":{\"c\":[\"数据库\"]},\"322\":{\"c\":[\"Redis\"]},\"323\":{\"h\":\"类文件结构详解\"},\"324\":{\"h\":\"回顾一下字节码\",\"t\":[\"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。\",\"Clojure（Lisp 语言的一种方言）、Groovy、Scala、JRuby、Kotlin 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成.class文件最终运行在 Java 虚拟机之上。.class文件的二进制格式可以使用 WinHex 查看。\",\"运行在 Java 虚拟机之上的编程语言\",\"可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。\"]},\"325\":{\"h\":\"Class 文件结构总结\",\"t\":[\"根据 Java 虚拟机规范，Class 文件通过 ClassFile 定义，有点类似 C 语言的结构体。\",\"ClassFile 的结构如下：\",\"ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口数量 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//字段数量 field_info fields[fields_count];//一个类可以有多个字段 u2 methods_count;//方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 } \",\"通过分析 ClassFile 的内容，我们便可以知道 class 文件的组成。\",\"ClassFile 内容分析\",\"下面这张图是通过 IDEA 插件 jclasslib 查看的，你可以更直观看到 Class 文件结构。\",\"使用 jclasslib 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。\",\"下面详细介绍一下 Class 文件结构涉及到的一些组件。\"]},\"326\":{\"h\":\"魔数（Magic Number）\",\"t\":[\" u4 magic; //Class 文件的标志 \",\"每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。Java 规范规定魔数为固定值：0xCAFEBABE。如果读取的文件不是以这个魔数开头，Java 虚拟机将拒绝加载它。\"]},\"327\":{\"h\":\"Class 文件版本号（Minor&Major Version）\",\"t\":[\" u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 \",\"紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。\",\"每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 javap -v 命令来快速查看 Class 文件的版本号信息。\",\"高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。\"]},\"328\":{\"h\":\"常量池（Constant Pool）\",\"t\":[\" u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 \",\"紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”）。\",\"常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：\",\"类和接口的全限定名\",\"字段的名称和描述符\",\"方法的名称和描述符\",\"常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．\",\"类型\",\"标志（tag）\",\"描述\",\"CONSTANT_utf8_info\",\"1\",\"UTF-8 编码的字符串\",\"CONSTANT_Integer_info\",\"3\",\"整形字面量\",\"CONSTANT_Float_info\",\"4\",\"浮点型字面量\",\"CONSTANT_Long_info\",\"5\",\"长整型字面量\",\"CONSTANT_Double_info\",\"6\",\"双精度浮点型字面量\",\"CONSTANT_Class_info\",\"7\",\"类或接口的符号引用\",\"CONSTANT_String_info\",\"8\",\"字符串类型字面量\",\"CONSTANT_FieldRef_info\",\"9\",\"字段的符号引用\",\"CONSTANT_MethodRef_info\",\"10\",\"类中方法的符号引用\",\"CONSTANT_InterfaceMethodRef_info\",\"11\",\"接口中方法的符号引用\",\"CONSTANT_NameAndType_info\",\"12\",\"字段或方法的符号引用\",\"CONSTANT_MethodType_info\",\"16\",\"标志方法类型\",\"CONSTANT_MethodHandle_info\",\"15\",\"表示方法句柄\",\"CONSTANT_InvokeDynamic_info\",\"18\",\"表示一个动态方法调用点\",\".class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v class类名-> temp.txt：将结果输出到 temp.txt 文件)。\"]},\"329\":{\"h\":\"访问标志(Access Flags)\",\"t\":[\" u2 access_flags;//Class 的访问标记 \",\"在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。\",\"类访问和属性修饰符:\",\"类访问和属性修饰符\",\"我们定义了一个 Employee 类\",\"package top.snailclimb.bean; public class Employee { ... } \",\"通过javap -v class类名 指令来看一下类的访问标志。\",\"查看类的访问标志\"]},\"330\":{\"h\":\"当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合\",\"t\":[\" u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口数量 u2 interfaces[interfaces_count];//一个类可以实现多个接口 \",\"Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，\",\"类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。\",\"接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。\"]},\"331\":{\"h\":\"字段表集合（Fields）\",\"t\":[\" u2 fields_count;//字段数量 field_info fields[fields_count];//一个类会可以有个字段 \",\"字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。\",\"field info(字段表) 的结构:\",\"字段表的结构 \",\"access_flags: 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。\",\"name_index: 对常量池的引用，表示的字段的名称；\",\"descriptor_index: 对常量池的引用，表示字段和方法的描述符；\",\"attributes_count: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；\",\"attributes[attributes_count]: 存放具体属性具体内容。\",\"上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。\",\"字段的 access_flag 的取值:\",\"字段的 access_flag 的取值\"]},\"332\":{\"h\":\"方法表集合（Methods）\",\"t\":[\" u2 methods_count;//方法数量 method_info methods[methods_count];//一个类可以有个多个方法 \",\"methods_count 表示方法的数量，而 method_info 表示方法表。\",\"Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。\",\"method_info(方法表的) 结构:\",\"方法表的结构\",\"方法表的 access_flag 取值：\",\"方法表的 access_flag 取值\",\"注意：因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了synchronized、native、abstract等关键字修饰方法，所以也就多了这些关键字对应的标志。\"]},\"333\":{\"h\":\"属性表集合（Attributes）\",\"t\":[\" u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合 \",\"在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。\"]},\"334\":{\"h\":\"参考\",\"t\":[\"《实战 Java 虚拟机》\",\"Chapter 4. The class File Format - Java Virtual Machine Specification:https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html\",\"实例分析 JAVA CLASS 的文件结构：https://coolshell.cn/articles/9229.html\",\"《Java 虚拟机原理图解》 1.2.2、Class 文件中的常量池详解（上）：https://blog.csdn.net/luanlouis/article/details/39960815\",\"File not found\"]},\"335\":{\"c\":[\"Java\"]},\"336\":{\"c\":[\"JVM\"]},\"337\":{\"h\":\"类加载过程详解\"},\"338\":{\"h\":\"类的生命周期\",\"t\":[\"类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。\",\"这 7 个阶段的顺序如下图所示：\",\"一个类的完整生命周期\"]},\"339\":{\"h\":\"类加载过程\",\"t\":[\"Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？\",\"系统加载 Class 类型的文件主要三步：加载->连接->初始化。连接过程又可分为三步：验证->准备->解析。\",\"类加载过程\",\"详见 Java Virtual Machine Specification - 5.3. Creation and Loading。\"]},\"340\":{\"h\":\"加载\",\"t\":[\"类加载过程的第一步，主要完成下面 3 件事情：\",\"通过全类名获取定义此类的二进制字节流。\",\"将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\",\"在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。\",\"虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：\\\"通过全类名获取定义此类的二进制字节流\\\" 并没有指明具体从哪里获取（ ZIP、 JAR、EAR、WAR、网络、动态代理技术运行时动态生成、其他文件生成比如 JSP...）、怎样获取。\",\"加载这一步主要是通过我们后面要讲到的 类加载器 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 双亲委派模型 决定（不过，我们也能打破由双亲委派模型）。\",\"类加载器、双亲委派模型也是非常重要的知识点，这部分内容在类加载器详解这篇文章中有详细介绍到。阅读本篇文章的时候，大家知道有这么个东西就可以了。\",\"每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。\",\"一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。\",\"加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。\"]},\"341\":{\"h\":\"验证\",\"t\":[\"验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\",\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。\",\"不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\",\"验证阶段主要由四个检验阶段组成：\",\"文件格式验证（Class 文件格式检查）\",\"元数据验证（字节码语义检查）\",\"字节码验证（程序语义检查）\",\"符号引用验证（类的正确性检查）\",\"验证阶段示意图\",\"文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。\",\"方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\",\"关于方法区的详细介绍，推荐阅读 Java 内存区域详解 这篇文章。\",\"符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。\",\"符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：\",\"java.lang.IllegalAccessError：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。\",\"java.lang.NoSuchFieldError：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。\",\"java.lang.NoSuchMethodError：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。\",\"……\"]},\"342\":{\"h\":\"准备\",\"t\":[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：\",\"这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\",\"从概念上讲，类变量所使用的内存都应当在 方法区 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：《深入理解 Java 虚拟机（第 3 版）》勘误#75\",\"这里所设置的初始值\\\"通常情况\\\"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。\",\"基本数据类型的零值：(图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )\",\"基本数据类型的零值\"]},\"343\":{\"h\":\"解析\",\"t\":[\"解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。\",\"《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：\",\"符号引用和直接引用\",\"举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。\",\"综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。\"]},\"344\":{\"h\":\"初始化\",\"t\":[\"初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\",\"说明：<clinit> ()方法是编译之后自动生成的。\",\"对于<clinit> () 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit> () 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。\",\"对于初始化阶段，虚拟机严格规范了有且只有 6 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：\",\"当遇到 new、 getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 \",\"当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。\",\"当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。\",\"当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。\",\"当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。\",\"使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname(\\\"...\\\"), newInstance() 等等。如果类没初始化，需要触发其初始化。\",\"初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。\",\"当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。\",\"MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。\",\"「补充，来自issue745」 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\"]},\"345\":{\"h\":\"类卸载\",\"t\":[\"卸载这部分内容来自 issue#662由 guang19 补充完善。\",\"卸载类即该类的 Class 对象被 GC。\",\"卸载类需要满足 3 个要求:\",\"该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。\",\"该类没有在其他任何地方被引用\",\"该类的类加载器的实例已被 GC\",\"所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。\",\"只要想通一点就好了，JDK 自带的 BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。\",\"参考\",\"《深入理解 Java 虚拟机》\",\"《实战 Java 虚拟机》\",\"Chapter 5. Loading, Linking, and Initializing - Java Virtual Machine Specification：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4\",\"File not found\"]},\"346\":{\"c\":[\"Java\"]},\"347\":{\"c\":[\"JVM\"]},\"348\":{\"h\":\"类加载器详解（重点）\"},\"349\":{\"h\":\"回顾一下类加载过程\",\"t\":[\"开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。\",\"类加载过程：加载->连接->初始化。\",\"连接过程又可分为三步：验证->准备->解析。\",\"类加载过程\",\"加载是类加载过程的第一步，主要完成下面 3 件事情：\",\"通过全类名获取定义此类的二进制字节流\",\"将字节流所代表的静态存储结构转换为方法区的运行时数据结构\",\"在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口\"]},\"350\":{\"h\":\"类加载器\"},\"351\":{\"h\":\"类加载器介绍\",\"t\":[\"类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。\",\"根据官方 API 文档的介绍：\",\"A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \\\"class file\\\" of that name from a file system.\",\"Every Class object contains a reference to the ClassLoader that defined it.\",\"Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.\",\"翻译过来大概的意思是：\",\"类加载器是一个负责加载类的对象。ClassLoader 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。\",\"每个 Java 类都有一个引用指向加载它的 ClassLoader。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。\",\"从上面的介绍可以看出:\",\"类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。\",\"每个 Java 类都有一个引用指向加载它的 ClassLoader。\",\"数组类不是通过 ClassLoader 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。\",\"class Class<T> { ... private final ClassLoader classLoader; @CallerSensitive public ClassLoader getClassLoader() { //... } ... } \",\"简单来说，类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。 字节码可以是 Java 源程序（.java文件）经过 javac 编译得来，也可以是通过工具动态生成或者通过网络下载得来。\",\"其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。\"]},\"352\":{\"h\":\"类加载器加载规则\",\"t\":[\"JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。\",\"对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。\",\"public abstract class ClassLoader { ... private final ClassLoader parent; // 由这个类加载器加载的类。 private final Vector<Class<?>> classes = new Vector<>(); // 由VM调用，用此类加载器记录每个已加载类。 void addClass(Class<?> c) { classes.addElement(c); } ... } \"]},\"353\":{\"h\":\"类加载器总结\",\"t\":[\"JVM 中内置了三个重要的 ClassLoader：\",\"BootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。\",\"ExtensionClassLoader(扩展类加载器)：主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。\",\"AppClassLoader(应用程序类加载器)：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。\",\"🌈 拓展一下：\",\"rt.jar：rt 代表“RunTime”，rt.jar是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 java.xxx.*都在里面，比如java.util.*、java.io.*、java.nio.*、java.lang.*、java.sql.*、java.math.*。\",\"Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。\",\"除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ .class 文件）进行加密，加载时再利用自定义的类加载器对其解密。\",\"类加载器层次关系图\",\"除了 BootstrapClassLoader 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。\",\"每个 ClassLoader 可以通过getParent()获取其父 ClassLoader，如果获取到 ClassLoader 为null的话，那么该类是通过 BootstrapClassLoader 加载的。\",\"public abstract class ClassLoader { ... // 父加载器 private final ClassLoader parent; @CallerSensitive public final ClassLoader getParent() { //... } ... } \",\"为什么 获取到 ClassLoader 为null就是 BootstrapClassLoader 加载的呢？ 这是因为BootstrapClassLoader 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。\",\"下面我们来看一个获取 ClassLoader 的小案例：\",\"public class PrintClassLoaderTree { public static void main(String[] args) { ClassLoader classLoader = PrintClassLoaderTree.class.getClassLoader(); StringBuilder split = new StringBuilder(\\\"|--\\\"); boolean needContinue = true; while (needContinue){ System.out.println(split.toString() + classLoader); if(classLoader == null){ needContinue = false; }else{ classLoader = classLoader.getParent(); split.insert(0, \\\"\\\\t\\\"); } } } } \",\"输出结果(JDK 8 )：\",\"|--sun.misc.Launcher$AppClassLoader@18b4aac2 |--sun.misc.Launcher$ExtClassLoader@53bd815b |--null \",\"从输出结果可以看出：\",\"我们编写的 Java 类 PrintClassLoaderTree 的 ClassLoader 是AppClassLoader；\",\"AppClassLoader的父 ClassLoader 是ExtClassLoader；\",\"ExtClassLoader的父ClassLoader是Bootstrap ClassLoader，因此输出结果为 null。\"]},\"354\":{\"h\":\"自定义类加载器\",\"t\":[\"我们前面也说说了，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader抽象类。\",\"ClassLoader 类有两个关键的方法：\",\"protected Class loadClass(String name, boolean resolve)：加载指定二进制名称的类，实现了双亲委派机制 。name 为类的二进制名称，resolve 如果为 true，在加载时调用 resolveClass(Class<?> c) 方法解析该类。\",\"protected Class findClass(String name)：根据类的二进制名称来查找类，默认实现是空方法。\",\"官方 API 文档中写到：\",\"Subclasses of ClassLoader are encouraged to override findClass(String name), rather than this method.\",\"建议 ClassLoader的子类重写 findClass(String name)方法而不是loadClass(String name, boolean resolve) 方法。\",\"如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\"]},\"355\":{\"h\":\"双亲委派模型\"},\"356\":{\"h\":\"双亲委派模型介绍\",\"t\":[\"类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。\",\"根据官网介绍：\",\"The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \\\"bootstrap class loader\\\", does not itself have a parent but may serve as the parent of a ClassLoader instance.\",\"翻译过来大概的意思是：\",\"ClassLoader 类使用委托模型来搜索类和资源。每个 ClassLoader 实例都有一个相关的父类加载器。需要查找类或资源时，ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。 虚拟机中被称为 \\\"bootstrap class loader\\\"的内置类加载器本身没有父类加载器，但是可以作为 ClassLoader 实例的父类加载器。\",\"从上面的介绍可以看出：\",\"ClassLoader 类使用委托模型来搜索类和资源。\",\"双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。\",\"ClassLoader 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。\",\"下图展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型(Parents Delegation Model)”。\",\"类加载器层次关系图\",\"注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。\",\"其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 MotherClassLoader 和一个FatherClassLoader 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。\",\"另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。\",\"public abstract class ClassLoader { ... // 组合 private final ClassLoader parent; protected ClassLoader(ClassLoader parent) { this(checkCreateClassLoader(), parent); } ... } \",\"在面向对象编程中，有一条非常经典的设计原则：组合优于继承，多用组合少用继承。\"]},\"357\":{\"h\":\"双亲委派模型的执行流程\",\"t\":[\"双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 java.lang.ClassLoader 的 loadClass() 中，相关代码如下所示。\",\"protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { //首先，检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) { //如果 c 为 null，则说明该类没有被加载过 long t0 = System.nanoTime(); try { if (parent != null) { //当父类的加载器不为空，则通过父类的loadClass来加载该类 c = parent.loadClass(name, false); } else { //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //非空父类的类加载器无法找到相应的类，则抛出异常 } if (c == null) { //当父类加载器无法加载时，则调用findClass方法来加载该类 //用户可通过覆写该方法，来自定义类加载器 long t1 = System.nanoTime(); c = findClass(name); //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { //对类进行link操作 resolveClass(c); } return c; } } \",\"每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。\",\"结合上面的源码，简单总结一下双亲委派模型的执行流程：\",\"在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。\",\"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。\",\"只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。\",\"如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。\",\"🌈 拓展一下：\",\"JVM 判定两个 Java 类是否相同的具体规则：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。\"]},\"358\":{\"h\":\"双亲委派模型的好处\",\"t\":[\"双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。\",\"如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类。\"]},\"359\":{\"h\":\"打破双亲委派模型方法\",\"t\":[\"为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 loadClass() 即可。\",\"🐛 修正（参见：issue871 ）：自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。\",\"为什么是重写 loadClass() 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：\",\"类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。\",\"重写 loadClass()方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。\",\"我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 WebAppClassLoader 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。\",\"Tomcat 的类加载器的层次结构如下：\",\"Tomcat 的类加载器的层次结构\",\"Tomcat 这四个自定义的类加载器对应的目录如下：\",\"CommonClassLoader对应<Tomcat>/common/*\",\"CatalinaClassLoader对应<Tomcat >/server/*\",\"SharedClassLoader对应 <Tomcat >/shared/*\",\"WebAppClassloader对应 <Tomcat >/webapps/<app>/WEB-INF/*\",\"从图中的委派关系中可以看出：\",\"CommonClassLoader作为 CatalinaClassLoader 和 SharedClassLoader 的父加载器。CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用。因此，CommonClassLoader 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。\",\"CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离。CatalinaClassLoader 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。SharedClassLoader 作为 WebAppClassLoader 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。\",\"每个 Web 应用都会创建一个单独的 WebAppClassLoader，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 WebAppClassLoader。各个 WebAppClassLoader 实例之间相互隔离，进而实现 Web 应用之间的类隔。\",\"单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类。\",\"比如，SPI 中，SPI 的接口（如 java.sql.Driver）是由 Java 核心库提供的，由BootstrapClassLoader 加载。而 SPI 的实现（如com.mysql.cj.jdbc.Driver）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（BootstrapClassLoader）也会用来加载 SPI 的实现。按照双亲委派模型，BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。\",\"再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 SharedClassLoader 加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 SharedClassLoader）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在 SharedClassLoader 的加载路径下，所以 SharedClassLoader 无法找到业务类，也就无法加载它们。\",\"如何解决这个问题呢？ 这个时候就需要用到 线程上下文类加载器（ThreadContextClassLoader） 了。\",\"拿 Spring 这个例子来说，当 Spring 需要加载业务类的时候，它不是用自己的类加载器，而是用当前线程的上下文类加载器。还记得我上面说的吗？每个 Web 应用都会创建一个单独的 WebAppClassLoader，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 WebAppClassLoader。这样就可以让高层的类加载器（SharedClassLoader）借助子类加载器（ WebAppClassLoader）来加载业务类，破坏了 Java 的类加载委托机制，让应用逆向使用类加载器。\",\"线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的。\",\"Java.lang.Thread 中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)分别用来获取和设置线程的上下文类加载器。如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。\",\"Spring 获取线程线程上下文类加载器的代码如下：\",\"cl = Thread.currentThread().getContextClassLoader(); \",\"感兴趣的小伙伴可以自行深入研究一下 Tomcat 打破双亲委派模型的原理，推荐资料：《深入拆解 Tomcat & Jetty》。\"]},\"360\":{\"h\":\"推荐阅读\",\"t\":[\"《深入拆解 Java 虚拟机》\",\"深入分析 Java ClassLoader 原理：https://blog.csdn.net/xyang81/article/details/7292380\",\"Java 类加载器(ClassLoader)：http://gityuan.com/2016/01/24/java-classloader/\",\"Class Loaders in Java：https://www.baeldung.com/java-classloaders\",\"Class ClassLoader - Oracle 官方文档：https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html\",\"老大难的 Java ClassLoader 再不理解就老了：https://zhuanlan.zhihu.com/p/51374915\",\"File not found\"]},\"361\":{\"c\":[\"Java\"]},\"362\":{\"c\":[\"JVM\"]},\"363\":{\"h\":\"JDK监控和故障处理工具总结\"},\"364\":{\"h\":\"JDK 命令行工具\",\"t\":[\"这些命令在 JDK 安装目录下的 bin 目录下：\",\"jps (JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\",\"jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;\",\"jinfo (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;\",\"jmap (Memory Map for Java) : 生成堆转储快照;\",\"jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;\",\"jstack (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。\"]},\"365\":{\"h\":\"jps :查看所有 Java 进程\",\"t\":[\"jps(JVM Process Status) 命令类似 UNIX 的 ps 命令。\",\"jps：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。jps -q：只输出进程的本地虚拟机唯一 ID。\",\"C:\\\\Users\\\\SnailClimb>jps 7360 NettyClient2 17396 7972 Launcher 16504 Jps 17340 NettyServer \",\"jps -l:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。\",\"C:\\\\Users\\\\SnailClimb>jps -l 7360 firstNettyDemo.NettyClient2 17396 7972 org.jetbrains.jps.cmdline.Launcher 16492 sun.tools.jps.Jps 17340 firstNettyDemo.NettyServer \",\"jps -v：输出虚拟机进程启动时 JVM 参数。\",\"jps -m：输出传递给 Java 进程 main() 函数的参数。\"]},\"366\":{\"h\":\"jstat : 监视虚拟机各种运行状态信息\",\"t\":[\"jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。\",\"jstat 命令使用格式：\",\"jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]] \",\"比如 jstat -gc -h3 31736 1000 10表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。\",\"常见的 option 如下：\",\"jstat -class vmid：显示 ClassLoader 的相关信息；\",\"jstat -compiler vmid：显示 JIT 编译的相关信息；\",\"jstat -gc vmid：显示与 GC 相关的堆信息；\",\"jstat -gccapacity vmid：显示各个代的容量及使用情况；\",\"jstat -gcnew vmid：显示新生代信息；\",\"jstat -gcnewcapcacity vmid：显示新生代大小与使用情况；\",\"jstat -gcold vmid：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；\",\"jstat -gcoldcapacity vmid：显示老年代的大小；\",\"jstat -gcpermcapacity vmid：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；\",\"jstat -gcutil vmid：显示垃圾收集信息；\",\"另外，加上 -t参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。\"]},\"367\":{\"h\":\"jinfo : 实时地查看和调整虚拟机各项参数\",\"t\":[\"jinfo vmid :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。\",\"jinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。\",\"C:\\\\Users\\\\SnailClimb>jinfo -flag MaxHeapSize 17340 -XX:MaxHeapSize=2124414976 C:\\\\Users\\\\SnailClimb>jinfo -flag PrintGC 17340 -XX:-PrintGC \",\"使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：\",\"jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数。\",\"C:\\\\Users\\\\SnailClimb>jinfo -flag PrintGC 17340 -XX:-PrintGC C:\\\\Users\\\\SnailClimb>jinfo -flag +PrintGC 17340 C:\\\\Users\\\\SnailClimb>jinfo -flag PrintGC 17340 -XX:+PrintGC \"]},\"368\":{\"h\":\"jmap :生成堆转储快照\",\"t\":[\"jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。\",\"jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。\",\"示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。\",\"C:\\\\Users\\\\SnailClimb>jmap -dump:format=b,file=C:\\\\Users\\\\SnailClimb\\\\Desktop\\\\heap.hprof 17340 Dumping heap to C:\\\\Users\\\\SnailClimb\\\\Desktop\\\\heap.hprof ... Heap dump file created \"]},\"369\":{\"h\":\"jhat : 分析 heapdump 文件\",\"t\":[\"jhat 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。\",\"C:\\\\Users\\\\SnailClimb>jhat C:\\\\Users\\\\SnailClimb\\\\Desktop\\\\heap.hprof Reading from C:\\\\Users\\\\SnailClimb\\\\Desktop\\\\heap.hprof... Dump file created Sat May 04 12:30:31 CST 2019 Snapshot read, resolving... Resolving 131419 objects... Chasing references, expect 26 dots.......................... Eliminating duplicate references.......................... Snapshot resolved. Started HTTP server on port 7000 Server is ready. \",\"访问 http://localhost:7000/\"]},\"370\":{\"h\":\"jstack :生成虚拟机当前时刻的线程快照\",\"t\":[\"jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.\",\"生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。\",\"下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。\",\"public class DeadLockDemo { private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) { new Thread(() -> { synchronized (resource1) { System.out.println(Thread.currentThread() + \\\"get resource1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \\\"waiting get resource2\\\"); synchronized (resource2) { System.out.println(Thread.currentThread() + \\\"get resource2\\\"); } } }, \\\"线程 1\\\").start(); new Thread(() -> { synchronized (resource2) { System.out.println(Thread.currentThread() + \\\"get resource2\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \\\"waiting get resource1\\\"); synchronized (resource1) { System.out.println(Thread.currentThread() + \\\"get resource1\\\"); } } }, \\\"线程 2\\\").start(); } } \",\"Output\",\"Thread[线程 1,5,main]get resource1 Thread[线程 2,5,main]get resource2 Thread[线程 1,5,main]waiting get resource2 Thread[线程 2,5,main]waiting get resource1 \",\"线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。\",\"通过 jstack 命令分析：\",\"C:\\\\Users\\\\SnailClimb>jps 13792 KotlinCompileDaemon 7360 NettyClient2 17396 7972 Launcher 8932 Launcher 9256 DeadLockDemo 10764 Jps 17340 NettyServer C:\\\\Users\\\\SnailClimb>jstack 9256 \",\"输出的部分内容如下：\",\"Found one Java-level deadlock: ============================= \\\"线程 2\\\": waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object), which is held by \\\"线程 1\\\" \\\"线程 1\\\": waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object), which is held by \\\"线程 2\\\" Java stack information for the threads listed above: =================================================== \\\"线程 2\\\": at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31) - waiting to lock <0x00000000d5efe1c0> (a java.lang.Object) - locked <0x00000000d5efe1d0> (a java.lang.Object) at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) \\\"线程 1\\\": at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16) - waiting to lock <0x00000000d5efe1d0> (a java.lang.Object) - locked <0x00000000d5efe1c0> (a java.lang.Object) at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source) at java.lang.Thread.run(Thread.java:748) Found 1 deadlock. \",\"可以看到 jstack 命令已经帮我们找到发生死锁的线程的具体信息。\"]},\"371\":{\"h\":\"JDK 可视化分析工具\"},\"372\":{\"h\":\"JConsole:Java 监视与管理控制台\",\"t\":[\"JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输入jconsole命令启动或者在 JDK 目录下的 bin 目录找到jconsole.exe然后双击启动。\"]},\"373\":{\"h\":\"连接 Jconsole\",\"t\":[\"连接 Jconsole\",\"如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:\",\"-Djava.rmi.server.hostname=外网访问 ip 地址 -Dcom.sun.management.jmxremote.port=60001 //监控的端口号 -Dcom.sun.management.jmxremote.authenticate=false //关闭认证 -Dcom.sun.management.jmxremote.ssl=false \",\"在使用 JConsole 连接时，远程进程地址如下：\",\"外网访问 ip 地址:60001 \"]},\"374\":{\"h\":\"查看 Java 程序概况\",\"t\":[\"查看 Java 程序概况 \"]},\"375\":{\"h\":\"内存监控\",\"t\":[\"JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。\",\"点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。\",\"新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\",\"老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\",\"内存监控 \"]},\"376\":{\"h\":\"线程监控\",\"t\":[\"类似我们前面讲的 jstack 命令，不过这个是可视化的。\",\"最下面有一个\\\"检测死锁 (D)\\\"按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。\",\"线程监控 \"]},\"377\":{\"h\":\"Visual VM:多合一故障处理工具\",\"t\":[\"VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：https://visualvm.github.io/ 。Visual VM 中文文档:https://visualvm.github.io/documentation.html。\",\"下面这段话摘自《深入理解 Java 虚拟机》。\",\"VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。\",\"VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：\",\"显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。\",\"监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。\",\"dump 以及分析堆转储快照（jmap、jhat）。\",\"方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。\",\"离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。\",\"其他 plugins 的无限的可能性……\",\"这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:\",\"https://visualvm.github.io/documentation.html\",\"https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html\",\"File not found\"]},\"378\":{\"c\":[\"Java\"]},\"379\":{\"c\":[\"JVM\"]},\"380\":{\"h\":\"JVM垃圾回收详解（重点）\",\"t\":[\"如果没有特殊说明，都是针对的是 HotSpot 虚拟机。\",\"本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。\",\"常见面试题：\",\"如何判断对象是否死亡（两种方法）。\",\"简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。\",\"如何判断一个常量是废弃常量\",\"如何判断一个类是无用的类\",\"垃圾收集有哪些算法，各自的特点？\",\"HotSpot 为什么要分为新生代和老年代？\",\"常见的垃圾回收器有哪些？\",\"介绍一下 CMS,G1 收集器。\",\"Minor Gc 和 Full GC 有什么不同呢？\"]},\"381\":{\"h\":\"前言\",\"t\":[\"当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。\"]},\"382\":{\"h\":\"堆空间的基本结构\",\"t\":[\"Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。\",\"Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。\",\"从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。\",\"在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\",\"新生代内存(Young Generation)\",\"老生代(Old Generation)\",\"永久代(Permanent Generation)\",\"下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。\",\"堆内存结构\",\"JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存 。\",\"关于堆空间结构更详细的介绍，可以回过头看看 Java 内存区域详解 这篇文章。\"]},\"383\":{\"h\":\"内存分配和回收原则\"},\"384\":{\"h\":\"对象优先在 Eden 区分配\",\"t\":[\"大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试一下。\",\"测试代码：\",\"public class GCTest { public static void main(String[] args) { byte[] allocation1, allocation2; allocation1 = new byte[30900*1024]; } } \",\"通过以下方式运行：\",\"添加的参数：-XX:+PrintGCDetails\",\"运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：\",\"从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。\",\"假如我们再为 allocation2 分配内存会出现什么情况呢？\",\"allocation2 = new byte[900*1024]; \",\"给 allocation2 分配内存的时候 Eden 区内存几乎已经被分配完了\",\"当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：\",\"public class GCTest { public static void main(String[] args) { byte[] allocation1, allocation2,allocation3,allocation4,allocation5; allocation1 = new byte[32000*1024]; allocation2 = new byte[1000*1024]; allocation3 = new byte[1000*1024]; allocation4 = new byte[1000*1024]; allocation5 = new byte[1000*1024]; } } \"]},\"385\":{\"h\":\"大对象直接进入老年代\",\"t\":[\"大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\",\"大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。\",\"G1 垃圾回收器会根据 -XX:G1HeapRegionSize 参数设置的堆区域大小和 -XX:G1MixedGCLiveThresholdPercent 参数设置的阈值，来决定哪些对象会直接进入老年代。\",\"Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(XX:ThresholdTolerance是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。\"]},\"386\":{\"h\":\"长期存活的对象将进入老年代\",\"t\":[\"既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。\",\"大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。\",\"对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\",\"修正（issue552）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置，参见 issue1199 ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。\",\"jdk8 官方文档引用：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html。\",\"动态年龄计算的代码如下：\",\"uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) { //survivor_capacity是survivor空间的大小 size_t desired_survivor_size = (size_t)((((double)survivor_capacity)*TargetSurvivorRatio)/100); size_t total = 0; uint age = 1; while (age < table_size) { //sizes数组是每个年龄段对象大小 total += sizes[age]; if (total > desired_survivor_size) { break; } age++; } uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold; ... } \",\"额外补充说明(issue672)：关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。 如果你去 Oracle 的官网阅读相关的虚拟机参数，你会发现-XX:MaxTenuringThreshold=threshold这里有个说明\",\"Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.\"]},\"387\":{\"h\":\"主要进行 gc 的区域\",\"t\":[\"周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：\",\"“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”\",\"上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：\",\"R 大的回答\",\"总结：\",\"针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：\",\"部分收集 (Partial GC)：\",\"新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；\",\"老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\",\"混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。\",\"整堆收集 (Full GC)：收集整个 Java 堆和方法区。\"]},\"388\":{\"h\":\"空间分配担保\",\"t\":[\"空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。\",\"《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：\",\"JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full GC。\",\"JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。\"]},\"389\":{\"h\":\"死亡对象判断方法\",\"t\":[\"堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。\"]},\"390\":{\"h\":\"引用计数法\",\"t\":[\"给对象中添加一个引用计数器：\",\"每当有一个地方引用它，计数器就加 1；\",\"当引用失效，计数器就减 1；\",\"任何时候计数器为 0 的对象就是不可能再被使用的。\",\"这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。\",\"对象之间循环引用\",\"所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\",\"public class ReferenceCountingGc { Object instance = null; public static void main(String[] args) { ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; } } \"]},\"391\":{\"h\":\"可达性分析算法\",\"t\":[\"这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\",\"下图中的 Object 6 ~ Object 10 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。\",\"可达性分析算法\",\"哪些对象可以作为 GC Roots 呢？\",\"虚拟机栈(栈帧中的局部变量表)中引用的对象\",\"本地方法栈(Native 方法)中引用的对象\",\"方法区中类静态属性引用的对象\",\"方法区中常量引用的对象\",\"所有被同步锁持有的对象\",\"JNI（Java Native Interface）引用的对象\",\"对象可以被回收，就代表一定会被回收吗？\",\"即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\",\"被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\",\"Object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。忘掉它的存在吧！\",\"参考：\",\"JEP 421: Deprecate Finalization for Removal\",\"是时候忘掉 finalize 方法了\"]},\"392\":{\"h\":\"引用类型总结\",\"t\":[\"无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\",\"JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\",\"JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\",\"Java 引用类型总结\",\"1．强引用（StrongReference）\",\"以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\",\"2．软引用（SoftReference）\",\"如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\",\"软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\",\"3．弱引用（WeakReference）\",\"如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\",\"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\",\"4．虚引用（PhantomReference）\",\"\\\"虚引用\\\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\",\"虚引用主要用来跟踪对象被垃圾回收的活动。\",\"虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\",\"特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。\"]},\"393\":{\"h\":\"如何判断一个常量是废弃常量？\",\"t\":[\"运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\",\"JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。\",\"🐛 修正（参见：issue747，reference）：\",\"JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代\",\"JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。\",\"JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)\",\"假如在字符串常量池中存在字符串 \\\"abc\\\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \\\"abc\\\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\\\"abc\\\" 就会被系统清理出常量池了。\"]},\"394\":{\"h\":\"如何判断一个类是无用的类？\",\"t\":[\"方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\",\"判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类”：\",\"该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\",\"加载该类的 ClassLoader 已经被回收。\",\"该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\",\"虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\"]},\"395\":{\"h\":\"垃圾收集算法\"},\"396\":{\"h\":\"标记-清除算法\",\"t\":[\"标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。\",\"它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\",\"效率问题：标记和清除两个过程效率都不高。\",\"空间问题：标记清除后会产生大量不连续的内存碎片。\",\"标记-清除算法\",\"关于具体是标记可回收对象还是不可回收对象，众说纷纭，两种说法其实都没问题，我个人更倾向于是前者。\",\"如果按照前者的理解，整个标记-清除过程大致是这样的：\",\"当一个对象被创建时，给一个标记位，假设为 0 (false)；\",\"在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；\",\"扫描阶段清除的就是标记位为 0 (false)的对象。\"]},\"397\":{\"h\":\"复制算法\",\"t\":[\"为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\",\"复制算法\",\"虽然改进了标记-清除算法，但依然存在下面这些问题：\",\"可用内存变小：可用内存缩小为原来的一半。\",\"不适合老年代：如果存活对象数量比较大，复制性能会变得很差。\"]},\"398\":{\"h\":\"标记-整理算法\",\"t\":[\"标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\",\"标记-整理算法\",\"由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。\"]},\"399\":{\"h\":\"分代收集算法\",\"t\":[\"当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\",\"比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\",\"延伸面试问题： HotSpot 为什么要分为新生代和老年代？\",\"根据上面的对分代收集算法的介绍回答。\"]},\"400\":{\"h\":\"垃圾收集器\",\"t\":[\"如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\",\"虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。\",\"JDK 默认垃圾收集器（使用 java -XX:+PrintCommandLineFlags -version 命令查看）：\",\"JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）\",\"JDK 9 ~ JDK20: G1\"]},\"401\":{\"h\":\"Serial 收集器\",\"t\":[\"Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ \\\"Stop The World\\\" ），直到它收集结束。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"Serial 收集器\",\"虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\",\"但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。\"]},\"402\":{\"h\":\"ParNew 收集器\",\"t\":[\"ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"ParNew 收集器 \",\"它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\",\"并行和并发概念补充：\",\"并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\",\"并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\"]},\"403\":{\"h\":\"Parallel Scavenge 收集器\",\"t\":[\"Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？\",\"-XX:+UseParallelGC 使用 Parallel 收集器+ 老年代串行 -XX:+UseParallelOldGC 使用 Parallel 收集器+ 老年代并行 \",\"Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。\",\"新生代采用标记-复制算法，老年代采用标记-整理算法。\",\"Parallel Old收集器运行示意图\",\"这是 JDK1.8 默认收集器\",\"使用 java -XX:+PrintCommandLineFlags -version 命令查看\",\"-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version \\\"1.8.0_211\\\" Java(TM) SE Runtime Environment (build 1.8.0_211-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) \",\"JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能\"]},\"404\":{\"h\":\"Serial Old 收集器\",\"t\":[\"Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\",\"Serial 收集器\"]},\"405\":{\"h\":\"Parallel Old 收集器\",\"t\":[\"Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\",\"Parallel Old收集器运行示意图\"]},\"406\":{\"h\":\"CMS 收集器\",\"t\":[\"CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。\",\"CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\",\"从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\",\"初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\",\"并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\",\"重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\",\"并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\",\"CMS 收集器\",\"从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\",\"对 CPU 资源敏感；\",\"无法处理浮动垃圾；\",\"它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。\"]},\"407\":{\"h\":\"G1 收集器\",\"t\":[\"G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.\",\"被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\",\"并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\",\"分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\",\"空间整合：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\",\"可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。\",\"G1 收集器的运作大致分为以下几个步骤：\",\"初始标记\",\"并发标记\",\"最终标记\",\"筛选回收\",\"G1 收集器\",\"G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\",\"从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。\"]},\"408\":{\"h\":\"ZGC 收集器\",\"t\":[\"与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。\",\"在 ZGC 中出现 Stop The World 的情况会更少！\",\"Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！\",\"不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：\",\"$ java -XX:+UseZGC className \",\"关于 ZGC 收集器的详细介绍推荐阅读美团技术团队的 新一代垃圾回收器 ZGC 的探索与实践 这篇文章。\"]},\"409\":{\"h\":\"参考\",\"t\":[\"《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\",\"https://my.oschina.net/hosee/blog/644618\",\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\",\"File not found\"]},\"410\":{\"c\":[\"Java\"]},\"411\":{\"c\":[\"JVM\"]},\"412\":{\"h\":\"JVM线上问题排查和性能调优案例\",\"t\":[\"JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。\",\"这篇文章，我会分享一些我看到的相关的案例。\",\"下面是正文。\",\"一次线上 OOM 问题分析 - 艾小仙 - 2023\",\"现象：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。\",\"分析：使用 JDK 自带的jvisualvm分析 dump 文件(MAT 也能分析)。\",\"建议：对于 SQL 语句，如果监测到没有where条件的全表查询应该默认增加一个合适的limit作为限制，防止这种问题拖垮整个系统\",\"资料：实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022。\",\"生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023\",\"现象：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。\",\"临时解决办法：紧急回滚至上一稳定版本。\",\"分析：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。\",\"建议：正常情况下，-Xmn参数（控制 Young 区的大小）总是应当小于-Xmx参数（控制堆内存的最大大小），否则就会触发 OOM 错误。\",\"资料：最重要的 JVM 参数总结 - JavaGuide - 2023\",\"一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022\",\"现象：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。\",\"分析：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。\",\"建议：远离 Hibernate。\",\"资料：Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）\",\"YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021\",\"现象：广告服务在新版本上线后，收到了大量的服务超时告警。\",\"分析：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。\",\"建议：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。\",\"听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021\",\"通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。\",\"你们要的线上 GC 问题案例来啦 - 编了个程 - 2021\",\"案例 1：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC\",\"案例 2： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。\",\"Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020\",\"这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。\",\"File not found\"]},\"413\":{\"c\":[\"Java\"]},\"414\":{\"c\":[\"JVM\"]},\"415\":{\"h\":\"大白话带你认识 JVM\",\"t\":[\"来自说出你的愿望吧丷投稿，原文地址：https://juejin.im/post/5e1505d0f265da5d5d744050。\"]},\"416\":{\"h\":\"前言\",\"t\":[\"如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来\"]},\"417\":{\"h\":\"一、JVM 的基本介绍\",\"t\":[\"JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···\",\"好，其实抛开这么专业的句子不说，就知道 JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。\"]},\"418\":{\"h\":\"1.1 Java 文件是如何被运行的\",\"t\":[\"比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。\",\"那我们的 JVM 是不认识文本文件的，所以它需要一个 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class\"]},\"419\":{\"h\":\"① 类加载器\",\"t\":[\"如果 JVM 想要执行这个 .class 文件，我们需要将其装进一个 类加载器 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进 JVM 里面来。\"]},\"420\":{\"h\":\"② 方法区\",\"t\":[\"方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等\",\"类加载器将 .class 文件搬过来就是先丢到这一块上\"]},\"421\":{\"h\":\"③ 堆\",\"t\":[\"堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 线程不安全 的\"]},\"422\":{\"h\":\"④ 栈\",\"t\":[\"栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。\",\"我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。\"]},\"423\":{\"h\":\"⑤ 程序计数器\",\"t\":[\"主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 线程独享 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。\"]},\"424\":{\"h\":\"小总结\",\"t\":[\"Java 文件经过编译后变成 .class 字节码文件\",\"字节码文件通过类加载器被搬运到 JVM 虚拟机中\",\"虚拟机主要的 5 大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行\"]},\"425\":{\"h\":\"1.2 简单的代码例子\",\"t\":[\"一个简单的学生类\",\"一个 main 方法\",\"执行 main 方法的步骤如下:\",\"编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载\",\"JVM 找到 App 的主程序入口，执行 main 方法\",\"这个 main 中的第一条语句为 Student student = new Student(\\\"tellUrDream\\\") ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中\",\"加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 指向方法区中的 Student 类的类型信息 的引用\",\"执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。\",\"执行 sayName()\",\"其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。\"]},\"426\":{\"h\":\"二、类加载器的介绍\",\"t\":[\"之前也提到了它是负责加载.class 文件的，它们在文件开头会有特定的文件标示，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定\"]},\"427\":{\"h\":\"2.1 类加载器的流程\",\"t\":[\"从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分统称为连接\"]},\"428\":{\"h\":\"2.1.1 加载\",\"t\":[\"将 class 文件加载到内存\",\"将静态数据结构转化成方法区中运行时的数据结构\",\"在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口\"]},\"429\":{\"h\":\"2.1.2 链接\",\"t\":[\"验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查\",\"准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）\",\"解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）\"]},\"430\":{\"h\":\"2.1.3 初始化\",\"t\":[\"初始化其实就是执行类构造器方法的<clinit>()的过程，而且要保证执行前父类的<clinit>()方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 static int a 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。\",\"注意：字节码文件中初始化方法有两种，非静态资源初始化的<init>和静态资源初始化的<clinit>，类构造器方法<clinit>()不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。\"]},\"431\":{\"h\":\"2.1.4 卸载\",\"t\":[\"GC 将无用对象从内存中卸载\"]},\"432\":{\"h\":\"2.2 类加载器的加载顺序\",\"t\":[\"加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的\",\"BootStrap ClassLoader：rt.jar\",\"Extension ClassLoader: 加载扩展的 jar 包\",\"App ClassLoader：指定的 classpath 下面的 jar 包\",\"Custom ClassLoader：自定义的类加载器\"]},\"433\":{\"h\":\"2.3 双亲委派机制\",\"t\":[\"当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。\",\"这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。\",\"其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 java.lang.String：\",\"package java.lang; public class String { public static void main(String[] args) { System.out.println(); } } \",\"尝试运行当前类的 main 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的java.lang.String，然而发现这个里面并没有 main 方法。\"]},\"434\":{\"h\":\"三、运行时数据区\"},\"435\":{\"h\":\"3.1 本地方法栈和程序计数器\",\"t\":[\"比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，这种用 native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。\",\"程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。\",\"如果执行的是 native 方法，那这个指针就不工作了。\"]},\"436\":{\"h\":\"3.2 方法区\",\"t\":[\"方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。\"]},\"437\":{\"h\":\"3.3 虚拟机栈和虚拟机堆\",\"t\":[\"一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。\"]},\"438\":{\"h\":\"3.3.1 虚拟机栈的概念\",\"t\":[\"它是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈\",\"public class Person{ int a = 1; public void doSomething(){ int b = 2; } } \"]},\"439\":{\"h\":\"3.3.2 虚拟机栈存在的异常\",\"t\":[\"如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 StackOverflowError （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 OutOfMemoryError。\"]},\"440\":{\"h\":\"3.3.3 虚拟机栈的生命周期\",\"t\":[\"对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。\",\"这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。\"]},\"441\":{\"h\":\"3.3.4 虚拟机栈的执行\",\"t\":[\"我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。\",\"栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。\"]},\"442\":{\"h\":\"3.3.5 局部变量的复用\",\"t\":[\"局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以 Slot 为最小单位，一个 slot 可以存放 32 位以内的数据类型。\",\"虚拟机通过索引定位的方式使用局部变量表，范围为 [0,局部变量表的 slot 的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些 slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。\"]},\"443\":{\"h\":\"3.3.6 虚拟机堆的概念\",\"t\":[\"JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为年轻代和老年代，而非堆内存则为永久代。年轻代又会分为Eden和Survivor区。Survivor 也会分为FromPlace和ToPlace，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 8:1:1。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整\",\"堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数\",\"MetaspaceSize：初始化元空间大小，控制发生GC MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。 \",\"移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。\"]},\"444\":{\"h\":\"3.3.7 Eden 年轻代的介绍\",\"t\":[\"当我们 new 一个对象后，会先放到 Eden 划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里 JVM 的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，有兴趣可以了解一下。\",\"当 Eden 空间满了之后，会触发一个叫做 Minor GC（就是一个发生在年轻代的 GC）的操作，存活下来的对象移动到 Survivor0 区。Survivor0 区满后触发 Minor GC，就会将存活对象移动到 Survivor1 区，此时还会把 from 和 to 两个指针交换，这样保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为空。经过多次的 Minor GC 后仍然存活的对象（这里的存活判断是 15 次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是 15，因为 HotSpot 会在对象头中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15）会移动到老年代。\",\"🐛 修正：当 Eden 区内存空间满了的时候，就会触发 Minor GC，Survivor0 区满不会触发 Minor GC 。\",\"那 Survivor0 区 的对象什么时候垃圾回收呢？\",\"假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换。\",\"老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC，期间会停止所有线程等待 GC 的完成。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。\",\"而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。\",\"补充说明：关于-XX:TargetSurvivorRatio 参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold 才移动到老年代。可以举个例子：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段（如例子中的年龄 6）后，总占用超过 Survivor 空间*TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代），这时候无需等到 MaxTenuringThreshold 中要求的 15\"]},\"445\":{\"h\":\"3.3.8 如何判断一个对象需要被干掉\",\"t\":[\"图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。\",\"在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法\",\"1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。\",\"2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java，C#等都是靠这招去判定对象是否存活的。\",\"（了解一下即可）在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：\",\"虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）\",\"方法区中静态变量所引用的对象（静态变量）\",\"方法区中常量引用的对象\",\"本地方法栈（即 native 修饰的方法）中 JNI 引用的对象（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）\",\"已启动的且未终止的 Java 线程\",\"这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）\"]},\"446\":{\"h\":\"3.3.9 如何宣告一个对象的真正死亡\",\"t\":[\"首先必须要提到的是一个名叫 finalize() 的方法\",\"finalize()是 Object 类的一个方法、一个对象的 finalize()方法只会被系统自动调用一次，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。\",\"补充一句：并不提倡在程序中调用 finalize()来进行自救。建议忘掉 Java 程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 deprecated ，且 java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 finalize 来的更加的轻量及可靠。\",\"判断一个对象的死亡至少需要两次标记\",\"如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。\",\"GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。\",\"如果确定对象已经死亡，我们又该如何回收这些垃圾呢\"]},\"447\":{\"h\":\"3.4 垃圾回收算法\",\"t\":[\"关于常见垃圾回收算法的详细介绍，建议阅读这篇：JVM 垃圾回收详解（重点）。\"]},\"448\":{\"h\":\"3.5 （了解）各种各样的垃圾回收器\",\"t\":[\"HotSpot VM 中的垃圾回收器，以及适用场景\",\"到 jdk8 为止，默认的垃圾收集器是 Parallel Scavenge 和 Parallel Old\",\"从 jdk9 开始，G1 收集器成为默认的垃圾收集器 目前来看，G1 回收器停顿时间最短而且没有明显缺点，非常适合 Web 应用。在 jdk8 中测试 Web 应用，堆内存 6G，新生代 4.5G 的情况下，Parallel Scavenge 回收新生代停顿长达 1.5 秒。G1 回收器回收同样大小的新生代只停顿 0.2 秒。\"]},\"449\":{\"h\":\"3.6 （了解）JVM 的常用参数\",\"t\":[\"JVM 的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。\",\"参数名称\",\"含义\",\"默认值\",\"说明\",\"-Xms\",\"初始堆大小\",\"物理内存的 1/64(<1GB)\",\"默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.\",\"-Xmx\",\"最大堆大小\",\"物理内存的 1/4(<1GB)\",\"默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制\",\"-Xmn\",\"年轻代大小(1.4or later)\",\"注意：此处的大小是（eden+ 2 survivor space).与 jmap -heap 中显示的 New gen 是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun 官方推荐配置为整个堆的 3/8\",\"-XX:NewSize\",\"设置年轻代大小(for 1.3/1.4)\",\"-XX:MaxNewSize\",\"年轻代最大值(for 1.3/1.4)\",\"-XX:PermSize\",\"设置持久代(perm gen)初始值\",\"物理内存的 1/64\",\"-XX:MaxPermSize\",\"设置持久代最大值\",\"物理内存的 1/4\",\"-Xss\",\"每个线程的堆栈大小\",\"JDK5.0 以后每个线程堆栈大小为 1M,以前每个线程堆栈大小为 256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在 3000~5000 左右一般小的应用， 如果栈不是很深， 应该是 128k 够用的 大的应用建议使用 256k。这个选项对性能影响比较大，需要严格的测试。（校长）和 threadstacksize 选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了\",\"-XX:NewRatio\",\"年轻代(包括 Eden 和两个 Survivor 区)与年老代的比值(除去持久代)\",\"-XX:NewRatio=4 表示年轻代与年老代所占比值为 1:4,年轻代占整个堆栈的 1/5Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。\",\"-XX:SurvivorRatio\",\"Eden 区与 Survivor 区的大小比值\",\"设置为 8,则两个 Survivor 区与一个 Eden 区的比值为 2:8,一个 Survivor 区占整个年轻代的 1/10\",\"-XX:+DisableExplicitGC\",\"关闭 System.gc()\",\"这个参数需要严格的测试\",\"-XX:PretenureSizeThreshold\",\"对象超过多大是直接在旧生代分配\",\"0\",\"单位字节 新生代采用 Parallel ScavengeGC 时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.\",\"-XX:ParallelGCThreads\",\"并行收集器的线程数\",\"此值最好配置与处理器数目相等 同样适用于 CMS\",\"-XX:MaxGCPauseMillis\",\"每次年轻代垃圾回收的最长时间(最大暂停时间)\",\"如果无法满足此时间,JVM 会自动调整年轻代大小,以满足此值.\",\"其实还有一些打印及 CMS 方面的参数，这里就不以一一列举了\"]},\"450\":{\"h\":\"四、关于 JVM 调优的一些方面\",\"t\":[\"根据刚刚涉及的 jvm 的知识点，我们可以尝试对 JVM 进行调优，主要就是堆内存那块\",\"所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为 64m。所以 java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 fullgc，所以老年代过小的话反而是会增多 fullgc 的）。此值对系统性能影响较大，Sun 官方推荐配置为 java 堆的 3/8。\"]},\"451\":{\"h\":\"4.1 调整最大堆内存和最小堆内存\",\"t\":[\"-Xmx –Xms：指定 java 堆最大值（默认值是物理内存的 1/4(<1GB)）和初始 java 堆最小值（默认值是物理内存的 1/64(<1GB)）\",\"默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.，默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于 40%了，JVM 就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于 70%，又会动态缩小不过不会小于–Xms。就这么简单\",\"开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。\",\"我们执行下面的代码\",\"System.out.println(\\\"Xmx=\\\" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的最大空间 System.out.println(\\\"free mem=\\\" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的空闲空间 System.out.println(\\\"total mem=\\\" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + \\\"M\\\"); //当前可用的总空间 \",\"注意：此处设置的是 Java 堆大小，也就是新生代大小 + 老年代大小\",\"设置一个 VM options 的参数\",\"-Xmx20m -Xms5m -XX:+PrintGCDetails \",\"再次启动 main 方法\",\"这里 GC 弹出了一个 Allocation Failure 分配失败，这个事情发生在 PSYoungGen，也就是年轻代中\",\"这时候申请到的内存为 18M，空闲内存为 4.214195251464844M\",\"我们此时创建一个字节数组看看，执行下面的代码\",\"byte[] b = new byte[1 * 1024 * 1024]; System.out.println(\\\"分配了1M空间给数组\\\"); System.out.println(\\\"Xmx=\\\" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的最大空间 System.out.println(\\\"free mem=\\\" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的空闲空间 System.out.println(\\\"total mem=\\\" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + \\\"M\\\"); \",\"此时 free memory 就又缩水了，不过 total memory 是没有变化的。Java 会尽可能将 total mem 的值维持在最小堆内存大小\",\"byte[] b = new byte[10 * 1024 * 1024]; System.out.println(\\\"分配了10M空间给数组\\\"); System.out.println(\\\"Xmx=\\\" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的最大空间 System.out.println(\\\"free mem=\\\" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的空闲空间 System.out.println(\\\"total mem=\\\" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + \\\"M\\\"); //当前可用的总空间 \",\"这时候我们创建了一个 10M 的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的 total memory 已经变成了 15M，这就是已经申请了一次内存的结果。\",\"此时我们再跑一下这个代码\",\"System.gc(); System.out.println(\\\"Xmx=\\\" + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的最大空间 System.out.println(\\\"free mem=\\\" + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + \\\"M\\\"); //系统的空闲空间 System.out.println(\\\"total mem=\\\" + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + \\\"M\\\"); //当前可用的总空间 \",\"此时我们手动执行了一次 fullgc，此时 total memory 的内存空间又变回 5.5M 了，此时又是把申请的内存释放掉的结果。\"]},\"452\":{\"h\":\"4.2 调整新生代和老年代的比值\",\"t\":[\"-XX:NewRatio --- 新生代（eden+2\\\\*Survivor）和老年代（不包含永久区）的比值 例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的 1/5。在 Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。 \"]},\"453\":{\"h\":\"4.3 调整 Survivor 区和 Eden 区的比值\",\"t\":[\"-XX:SurvivorRatio（幸存代）--- 设置两个 Survivor 区和 eden 的比值 例如：8，表示两个 Survivor:eden=2:8，即一个 Survivor 占年轻代的 1/10 \"]},\"454\":{\"h\":\"4.4 设置年轻代和老年代的大小\",\"t\":[\"-XX:NewSize --- 设置年轻代大小 -XX:MaxNewSize --- 设置年轻代最大值 \",\"可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的 gc，需要注意。\"]},\"455\":{\"h\":\"4.5 小总结\",\"t\":[\"根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 java 堆的 3/8，幸存代占新生代的 1/10\",\"在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具。\",\"-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径 \",\"一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。\"]},\"456\":{\"h\":\"4.6 永久区的设置\",\"t\":[\"-XX:PermSize -XX:MaxPermSize \",\"初始空间（默认为物理内存的 1/64）和最大空间（默认为物理内存的 1/4）。也就是说，jvm 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会 OOM。\",\"tips：如果堆空间没有用完也抛出了 OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM。\"]},\"457\":{\"h\":\"4.7 JVM 的栈参数调优\"},\"458\":{\"h\":\"4.7.1 调整每个线程栈空间的大小\",\"t\":[\"可以通过-Xss：调整每个线程栈空间的大小\",\"JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右\"]},\"459\":{\"h\":\"4.7.2 设置线程栈的大小\",\"t\":[\"-XXThreadStackSize： 设置线程栈的大小(0 means use default stack size) \",\"这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供 demo 了\"]},\"460\":{\"h\":\"4.8 (可以直接跳过了)JVM 其他参数介绍\",\"t\":[\"形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。\"]},\"461\":{\"h\":\"4.8.1 设置内存页的大小\",\"t\":[\"-XXThreadStackSize： 设置内存页的大小，不可设置过大，会影响Perm的大小 \"]},\"462\":{\"h\":\"4.8.2 设置原始类型的快速优化\",\"t\":[\"-XX:+UseFastAccessorMethods： 设置原始类型的快速优化 \"]},\"463\":{\"h\":\"4.8.3 设置关闭手动 GC\",\"t\":[\"-XX:+DisableExplicitGC： 设置关闭System.gc()(这个参数需要严格的测试) \"]},\"464\":{\"h\":\"4.8.4 设置垃圾最大年龄\",\"t\":[\"-XX:MaxTenuringThreshold 设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,加在年轻代即被回收的概率。该参数只有在串行GC时才有效. \"]},\"465\":{\"h\":\"4.8.5 加快编译速度\",\"t\":[\"-XX:+AggressiveOpts 加快编译速度 \"]},\"466\":{\"h\":\"4.8.6 改善锁机制性能\",\"t\":[\"-XX:+UseBiasedLocking \"]},\"467\":{\"h\":\"4.8.7 禁用垃圾回收\",\"t\":[\"-Xnoclassgc \"]},\"468\":{\"h\":\"4.8.8 设置堆空间存活时间\",\"t\":[\"-XX:SoftRefLRUPolicyMSPerMB 设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。 \"]},\"469\":{\"h\":\"4.8.9 设置对象直接分配在老年代\",\"t\":[\"-XX:PretenureSizeThreshold 设置对象超过多大时直接在老年代分配，默认值是0。 \"]},\"470\":{\"h\":\"4.8.10 设置 TLAB 占 eden 区的比例\",\"t\":[\"-XX:TLABWasteTargetPercent 设置TLAB占eden区的百分比，默认值是1% 。 \"]},\"471\":{\"h\":\"4.8.11 设置是否优先 YGC\",\"t\":[\"-XX:+CollectGen0First 设置FullGC时是否先YGC，默认值是false。 \"]},\"472\":{\"h\":\"finally\",\"t\":[\"真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java 核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。\",\"File not found\"]},\"473\":{\"c\":[\"Java\"]},\"474\":{\"c\":[\"JVM\"]},\"475\":{\"h\":\"最重要的JVM参数总结\",\"t\":[\"本文由 JavaGuide 翻译自 https://www.baeldung.com/jvm-parameters，并对文章进行了大量的完善补充。\",\"JDK 版本：1.8\"]},\"476\":{\"h\":\"1.概述\",\"t\":[\"在本篇文章中，你将掌握最常用的 JVM 参数配置。\"]},\"477\":{\"h\":\"2.堆内存相关\",\"t\":[\"Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\",\"内存区域常见配置参数\"]},\"478\":{\"h\":\"2.1.显式指定堆内存 –Xms 和 -Xmx\",\"t\":[\"与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：\",\"-Xms<heap size>[unit] -Xmx<heap size>[unit] \",\"heap size 表示要初始化内存的具体大小。\",\"unit 表示要初始化内存的单位。单位为 “ g” (GB)、“ m”（MB）、“ k”（KB）。\",\"举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：\",\"-Xms2G -Xmx5G \"]},\"479\":{\"h\":\"2.2.显式新生代内存(Young Generation)\",\"t\":[\"根据Oracle 官方文档，在堆总可用内存配置完成之后，第二大影响因素是为 Young Generation 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 MB，最大大小为无限制。\",\"一共有两种指定 新生代内存(Young Generation)大小的方法：\",\"1.通过-XX:NewSize和-XX:MaxNewSize指定\",\"-XX:NewSize=<young size>[unit] -XX:MaxNewSize=<young size>[unit] \",\"举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：\",\"-XX:NewSize=256m -XX:MaxNewSize=1024m \",\"2.通过-Xmn<young size>[unit]指定\",\"举个栗子 🌰，如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：\",\"-Xmn256m \",\"GC 调优策略中很重要的一条经验总结是这样说的：\",\"将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。\",\"另外，你还可以通过 -XX:NewRatio=<int> 来设置老年代与新生代内存的比值。\",\"比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。\",\"-XX:NewRatio=1 \"]},\"480\":{\"h\":\"2.3.显式指定永久代/元空间的大小\",\"t\":[\"从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。\",\"JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\",\"-XX:PermSize=N #方法区 (永久代) 初始大小 -XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen \",\"相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。\",\"JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。\",\"下面是一些常用参数：\",\"-XX:MetaspaceSize=N #设置 Metaspace 的初始大小（是一个常见的误区，后面会解释） -XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小 \",\"🐛 修正（参见：issue#1947）：\",\"1、Metaspace 的初始容量并不是 -XX:MetaspaceSize 设置，无论 -XX:MetaspaceSize 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。\",\"可以参考 Oracle 官方文档 Other Considerations 中提到的：\",\"Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.\",\"MetaspaceSize 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。\",\"另外，还可以看一下这个试验：JVM 参数 MetaspaceSize 的误解。\",\"2、Metaspace 由于使用不断扩容到-XX:MetaspaceSize参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。\",\"也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。\",\"垃圾搜集器内部是根据变量 _capacity_until_GC来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：\",\"void MetaspaceGC::initialize() { // Set the high-water mark to MaxMetapaceSize during VM initializaton since // we can't do a GC during initialization. _capacity_until_GC = MaxMetaspaceSize; } \",\"相关阅读：issue 更正：MaxMetaspaceSize 如果不指定大小的话，不会耗尽内存 #1204 。\"]},\"481\":{\"h\":\"3.垃圾收集相关\"},\"482\":{\"h\":\"3.1.垃圾回收器\",\"t\":[\"为了提高应用程序的稳定性，选择正确的垃圾收集算法至关重要。\",\"JVM 具有四种类型的 GC 实现：\",\"串行垃圾收集器\",\"并行垃圾收集器\",\"CMS 垃圾收集器\",\"G1 垃圾收集器\",\"可以使用以下参数声明这些实现：\",\"-XX:+UseSerialGC -XX:+UseParallelGC -XX:+UseParNewGC -XX:+UseG1GC \",\"有关垃圾回收实施的更多详细信息，请参见此处。\"]},\"483\":{\"h\":\"3.2.GC 日志记录\",\"t\":[\"生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。\",\"# 必选 # 打印基本 GC 信息 -XX:+PrintGCDetails -XX:+PrintGCDateStamps # 打印对象分布 -XX:+PrintTenuringDistribution # 打印堆数据 -XX:+PrintHeapAtGC # 打印Reference处理信息 # 强引用/弱引用/软引用/虚引用/finalize 相关的方法 -XX:+PrintReferenceGC # 打印STW时间 -XX:+PrintGCApplicationStoppedTime # 可选 # 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 # GC日志输出的文件路径 -Xloggc:/path/to/gc-%t.log # 开启日志文件分割 -XX:+UseGCLogFileRotation # 最多分割几个文件，超过之后从头文件开始写 -XX:NumberOfGCLogFiles=14 # 每个文件上限大小，超过就触发分割 -XX:GCLogFileSize=50M \"]},\"484\":{\"h\":\"4.处理 OOM\",\"t\":[\"对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。\",\"这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:\",\"-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_pid<pid>.hprof -XX:OnOutOfMemoryError=\\\"< cmd args >;< cmd args >\\\" -XX:+UseGCOverheadLimit \",\"这里有几点需要注意:\",\"HeapDumpOnOutOfMemoryError 指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中。\",\"HeapDumpPath 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <pid> 标记，则当前进程的进程 id 将附加到文件名中，并使用.hprof格式\",\"OnOutOfMemoryError 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: -XX:OnOutOfMemoryError=\\\"shutdown -r\\\" 。\",\"UseGCOverheadLimit 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例\"]},\"485\":{\"h\":\"5.其他\",\"t\":[\"-server : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM\",\"-XX:+UseStringDeduplication : Java 8u20 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 char [] 数组来优化堆内存。\",\"-XX:+UseLWPSynchronization: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。\",\"-XX:LargePageSizeInBytes: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。\",\"-XX:MaxHeapFreeRatio : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。\",\"-XX:SurvivorRatio : eden/survivor 空间的比例, 例如-XX:SurvivorRatio=6 设置每个 survivor 和 eden 之间的比例为 1:6。\",\"-XX:+UseLargePages : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。\",\"-XX:+UseStringCache : 启用 String 池中可用的常用分配字符串的缓存。\",\"-XX:+UseCompressedStrings : 对 String 对象使用 byte [] 类型，该类型可以用纯 ASCII 格式表示。\",\"-XX:+OptimizeStringConcat : 它尽可能优化字符串串联操作。\"]},\"486\":{\"h\":\"文章推荐\",\"t\":[\"这里推荐了非常多优质的 JVM 实践相关的文章，推荐阅读，尤其是 JVM 性能优化和问题排查相关的文章。\",\"JVM 参数配置说明 - 阿里云官方文档 - 2022\",\"JVM 内存配置最佳实践 - 阿里云官方文档 - 2022\",\"求你了，GC 日志打印别再瞎配置了 - 思否 - 2022\",\"一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022\",\"一次线上 JVM 调优实践，FullGC40 次/天到 10 天一次的优化过程 - HeapDump - 2021\",\"听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021\",\"你们要的线上 GC 问题案例来啦 - 编了个程 - 2021\",\"Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团队 - 2020\",\"从实际案例聊聊 Java 应用的 GC 优化-美团技术团队 - 美团技术团队 - 2017\",\"File not found\"]},\"487\":{\"c\":[\"Java\"]},\"488\":{\"c\":[\"JVM\"]},\"489\":{\"h\":\"Java内存区域详解（重点）\",\"t\":[\"File not found\",\"如果没有特殊说明，都是针对的是 HotSpot 虚拟机。\",\"本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。\",\"常见面试题：\",\"介绍下 Java 内存区域（运行时数据区）\",\"Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）\",\"对象的访问定位的两种方式（句柄和直接指针两种方式）\"]},\"490\":{\"h\":\"前言\",\"t\":[\"对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\"]},\"491\":{\"h\":\"运行时数据区域\",\"t\":[\"Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。\",\"JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。\",\"JDK 1.7：\",\"Java 运行时数据区域（JDK1.7）\",\"JDK 1.8：\",\"Java 运行时数据区域（JDK1.8 ）\",\"线程私有的：\",\"程序计数器\",\"虚拟机栈\",\"本地方法栈\",\"线程共享的：\",\"堆\",\"方法区\",\"直接内存 (非运行时数据区的一部分)\",\"Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。\"]},\"492\":{\"h\":\"程序计数器\",\"t\":[\"程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\",\"另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\",\"从上面的介绍中我们知道了程序计数器主要有两个作用：\",\"字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\",\"在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\",\"⚠️ 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。\"]},\"493\":{\"h\":\"Java 虚拟机栈\",\"t\":[\"与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。\",\"栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。\",\"方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\",\"栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。\",\"Java 虚拟机栈\",\"局部变量表 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\",\"局部变量表\",\"操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。\",\"动态链接 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接 。\",\"栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\",\"Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。\",\"除了 StackOverFlowError 错误之外，栈还可能会出现OutOfMemoryError错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\",\"简单总结一下程序运行中栈可能会出现两种错误：\",\"StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\",\"OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\"]},\"494\":{\"h\":\"本地方法栈\",\"t\":[\"和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\",\"本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\",\"方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\"]},\"495\":{\"h\":\"堆\",\"t\":[\"Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\",\"Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\",\"Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。\",\"在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\",\"新生代内存(Young Generation)\",\"老生代(Old Generation)\",\"永久代(Permanent Generation)\",\"下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。\",\"堆内存结构\",\"JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。 （我会在方法区这部分内容详细介绍到）。\",\"大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。\",\"🐛 修正（参见：issue552）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。\",\"动态年龄计算的代码如下\",\"uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) { //survivor_capacity是survivor空间的大小 size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100); size_t total = 0; uint age = 1; while (age < table_size) { total += sizes[age];//sizes数组是每个年龄段对象大小 if (total > desired_survivor_size) break; age++; } uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold; ... } \",\"堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\",\"java.lang.OutOfMemoryError: GC Overhead Limit Exceeded：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\",\"java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值，详见：Default Java 8 max heap size)\",\"……\"]},\"496\":{\"h\":\"方法区\",\"t\":[\"方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。\",\"《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。\",\"当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\",\"方法区和永久代以及元空间是什么关系呢？ 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。\",\"HotSpot 虚拟机方法区的两种实现\",\"为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?\",\"下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5\",\"1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。\",\"当元空间溢出时会得到如下错误：java.lang.OutOfMemoryError: MetaSpace\",\"你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。\",\"2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。\",\"3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。\",\"方法区常用参数有哪些？\",\"JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。\",\"-XX:PermSize=N //方法区 (永久代) 初始大小 -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen \",\"相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。\",\"JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：\",\"-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 \",\"与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\"]},\"497\":{\"h\":\"运行时常量池\",\"t\":[\"Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。\",\"字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。\",\"《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：\",\"符号引用和直接引用\",\"常量池表会在类加载后存放到方法区的运行时常量池中。\",\"运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。\",\"既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\"]},\"498\":{\"h\":\"字符串常量池\",\"t\":[\"字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。\",\"// 在堆中创建字符串对象”ab“ // 将字符串对象”ab“的引用保存在字符串常量池中 String aa = \\\"ab\\\"; // 直接返回字符串常量池中字符串对象”ab“的引用 String bb = \\\"ab\\\"; System.out.println(aa==bb);// true \",\"HotSpot 虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 可以简单理解为一个固定大小的HashTable ，容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。\",\"JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。\",\"method-area-jdk1.6\",\"method-area-jdk1.7\",\"JDK 1.7 为什么要将字符串常量池移动到堆中？\",\"主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。\",\"相关问题：JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎\",\"最后再来分享一段周志明老师在《深入理解 Java 虚拟机（第 3 版）》样例代码&勘误 GitHub 仓库的 issue#112 中说过的话：\",\"运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。\"]},\"499\":{\"h\":\"直接内存\",\"t\":[\"直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。\",\"直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。\",\"JDK1.4 中新加入的 NIO（Non-Blocking I/O，也被称为 New I/O），引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。\",\"直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\",\"类似的概念还有 堆外内存 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。\",\"堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。\"]},\"500\":{\"h\":\"HotSpot 虚拟机对象探秘\",\"t\":[\"通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\"]},\"501\":{\"h\":\"对象的创建\",\"t\":[\"Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。\"]},\"502\":{\"h\":\"Step1:类加载检查\",\"t\":[\"虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\"]},\"503\":{\"h\":\"Step2:分配内存\",\"t\":[\"在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\",\"内存分配的两种方式 （补充内容，需要掌握）：\",\"指针碰撞： \",\"适用场合：堆内存规整（即没有内存碎片）的情况下。\",\"原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。\",\"使用该分配方式的 GC 收集器：Serial, ParNew\",\"空闲列表： \",\"适用场合：堆内存不规整的情况下。\",\"原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。\",\"使用该分配方式的 GC 收集器：CMS\",\"选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\\\"标记-清除\\\"，还是\\\"标记-整理\\\"（也称作\\\"标记-压缩\\\"），值得注意的是，复制算法内存也是规整的。\",\"内存分配并发问题（补充内容，需要掌握）\",\"在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：\",\"CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。\",\"TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配\"]},\"504\":{\"h\":\"Step3:初始化零值\",\"t\":[\"内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\"]},\"505\":{\"h\":\"Step4:设置对象头\",\"t\":[\"初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\"]},\"506\":{\"h\":\"Step5:执行 init 方法\",\"t\":[\"在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\"]},\"507\":{\"h\":\"对象的内存布局\",\"t\":[\"在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\",\"Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\",\"实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。\",\"对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\"]},\"508\":{\"h\":\"对象的访问定位\",\"t\":[\"建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。\"]},\"509\":{\"h\":\"句柄\",\"t\":[\"如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\",\"对象的访问定位-使用句柄\"]},\"510\":{\"h\":\"直接指针\",\"t\":[\"如果使用直接指针访问，reference 中存储的直接就是对象的地址。\",\"对象的访问定位-直接指针\",\"这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。\",\"HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。\"]},\"511\":{\"h\":\"参考\",\"t\":[\"《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\",\"《自己动手写 Java 虚拟机》\",\"Chapter 2. The Structure of the Java Virtual Machine：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html\",\"JVM 栈帧内部结构-动态链接：https://chenxitag.com/archives/368\",\"Java 中 new String(\\\"字面量\\\") 中 \\\"字面量\\\" 是何时进入字符串常量池的? - 木女孩的回答 - 知乎：https://www.zhihu.com/question/55994121/answer/147296098\",\"JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎：https://www.zhihu.com/question/57109429/answer/151717241\",\"http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/\",\"https://dzone.com/articles/jvm-permgen-–-where-art-thou\",\"https://stackoverflow.com/questions/9095748/method-area-and-permgen\",\"File not found\"]},\"512\":{\"c\":[\"Java\"]},\"513\":{\"c\":[\"JVM\"]},\"514\":{\"h\":\"基础概念\"},\"515\":{\"h\":\"Java特点\",\"t\":[\"1.面向对象（封装，继承，多态）\",\"2.平台无关性 （一次编写，随处运行）\",\"3.可靠性（内存管理机制不用自己去处理指针、内存, 异常处理机制）\",\"4.安全性（Java存储分配模型是防御恶意代码的主要方法之一。Java没有指针，所以程序员不能得到隐蔽起来的内存和伪造指针去指向存储器；再例如限制访问权限修饰符）\",\"5.丰富的资源库、强大的生态\"]},\"516\":{\"h\":\"JDK 和 JRE\",\"t\":[\"JRE：全称Java Runtime Environment，提供Java运行时环境，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）\",\"JDK：全称Java Development Kit，提供Java的开发和运行环境，提供给开发者使用，JDK包含JRE，JAVA源码的编译器javac，监控工具jconsole，分析工具jvisualvm等\",\"总结，如果你需要运行Java程序，只需要安装JRE；如果你需要程序开发，那么需要安装JDK就行了，不需要再重复安装JRE。\"]},\"517\":{\"h\":\"Java 和 C++ 区别\",\"t\":[\"不同点：\",\"Java 不提供指针来直接访问内存，程序内存更加安全，C++有指针概念\",\"Java有JVM⾃动内存管理垃圾回收机制(GC)，不需要程序员⼿动释放⽆⽤内存\",\"Java是单继承，可以用接口实现多继承， C++支持多继承\",\"c++是多继承，并且有指针的概念，需要由程序员自己管理内存；\",\"Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存\"]},\"518\":{\"h\":\"面向对象\",\"t\":[\"三大特性: 封装、继承、多态\",\"封装: 对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；可以理解为类的隔离\",\"继承： 子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；可以理解为类的复用\",\"多态： 通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）；可以理解为类的扩展\"]},\"519\":{\"h\":\"多态实现原理\",\"t\":[\"多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。\",\"静态绑定与动态绑定：\",\"​ 一种是在编译期确定，被称为静态分派，比如方法的重载；\",\"​ 一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。\",\"多态的实现\",\"​ 虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。\"]},\"520\":{\"h\":\"抽象类和接口\",\"t\":[\"抽象类： 包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，\",\"**接口： **接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法\",\"相同点:\",\"​ ① 抽象类和接口都不能被实例化\",\"​ ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法\",\"不同点：\",\"​ ① 抽象类有构造方法，接口没有构造方法\",\"​ ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）\",\"​ ③ 抽象类只能单继承，接口可以多继承\",\"​ ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量\",\"抽象类的使用场景：\",\"​ 既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量\",\"接口的应用场景：\",\"​ 约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系\"]},\"521\":{\"h\":\"static和final关键字\",\"t\":[\"static： 可以修饰属性、方法\",\"​ static修饰属性：\",\"​ 类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。\",\"​ static修饰方法：\",\"​ 随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；\",\"final： 关键字主要⽤在三个地⽅：变量、⽅法、类。\",\"​ final修饰变量：\",\"​ 如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；\",\"​ 如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。\",\"​ final修饰方法：\",\"​ 把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。\",\"​ final修饰类：\",\"​ final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。\",\"一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）\"]},\"522\":{\"h\":\"泛型以及泛型擦除\",\"t\":[\"参考：https://blog.csdn.net/baoyinwang/article/details/107341997\",\"泛型：\",\"​ 泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。\",\"泛型擦除：\",\"​ Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。\",\"​ 如List等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。\",\"可以通过反射添加其它类型元素\"]},\"523\":{\"h\":\"反射原理以及使用场景\",\"t\":[\"Java反射：\",\"​ 是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；\",\"反射原理：\",\"​ 反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类\",\"​ 如何得到Class的实例:\",\" 1.类名.class(就是一份字节码) 2.Class.forName(String className);根据一个类的全限定名来构建Class对象 3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型 \",\"使用场景：\",\"开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。\",\"动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。\",\"JDK：spring默认动态代理，需要实现接口\",\"CGLIB：通过asm框架序列化字节流，可配置，性能差\",\"自定义注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。\"]},\"524\":{\"h\":\"Java异常体系\",\"t\":[\"​ \",\"Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception\",\"Error ：\",\"​ 是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。\",\"Exception 包含：RuntimeException 、CheckedException\",\"编程错误可以分成三类：语法错误、逻辑错误和运行错误。\",\"语法错误（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误\",\"逻辑错误指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因\",\"运行错误是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误\",\"RuntimeException： 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。\",\"​ 如 NullPointerException 、 ClassCastException ；\",\"**CheckedException：**受检异常，程序使用trycatch进行捕捉处理\",\"​\\t\\t如IOException、SQLException、NotFoundException；\"]},\"525\":{\"c\":[\"java\"]},\"526\":{\"c\":[\"java\"]},\"527\":{\"h\":\"ArrayBlockingQueue 源码分析\"},\"528\":{\"h\":\"阻塞队列简介\"},\"529\":{\"h\":\"阻塞队列的历史\",\"t\":[\"Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 java.util.concurrent，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。\",\"为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 ArrayBlockingQueue 和 LinkedBlockingQueue，它们是带有生产者-消费者模式实现的并发容器。其中，ArrayBlockingQueue 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 LinkedBlockingQueue 则由链表构成的队列，正是因为链表的特性，所以 LinkedBlockingQueue 在添加元素上并不会向 ArrayBlockingQueue 那样有着较多的约束，所以 LinkedBlockingQueue 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 Integer.MAX_VALUE，近乎于无限大)。\",\"随着 Java 的不断发展，JDK 后续的几个版本又对阻塞队列进行了不少的更新和完善:\",\"JDK1.6 版本:增加 SynchronousQueue，一个不存储元素的阻塞队列。\",\"JDK1.7 版本:增加 TransferQueue，一个支持更多操作的阻塞队列。\",\"JDK1.8 版本:增加 DelayQueue，一个支持延迟获取元素的阻塞队列。\"]},\"530\":{\"h\":\"阻塞队列的思想\",\"t\":[\"阻塞队列就是典型的生产者-消费者模型，它可以做到以下几点:\",\"当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。\",\"当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。\",\"当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。\",\"当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。\",\"总结一下：阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 put、take、offfer、poll 等 API 即可实现多线程之间的生产和消费。\",\"这也使得阻塞队列在多线程开发中有着广泛的运用，最常见的例子无非是我们的线程池,从源码中我们就能看出当核心线程无法及时处理任务时，这些任务都会扔到 workQueue 中。\",\"public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {// ...} \"]},\"531\":{\"h\":\"ArrayBlockingQueue 常见方法及测试\",\"t\":[\"简单了解了阻塞队列的历史之后，我们就开始重点讨论本篇文章所要介绍的并发容器——ArrayBlockingQueue。为了后续更加深入的了解 ArrayBlockingQueue，我们不妨基于下面几个实例了解以下 ArrayBlockingQueue 的使用。\",\"先看看第一个例子，我们这里会用两个线程分别模拟生产者和消费者，生产者生产完会使用 put 方法生产 10 个元素给消费者进行消费，当队列元素达到我们设置的上限 5 时，put 方法就会阻塞。 同理消费者也会通过 take 方法消费元素，当队列为空时，take 方法就会阻塞消费者线程。这里笔者为了保证消费者能够在消费完 10 个元素后及时退出。便通过倒计时门闩，来控制消费者结束，生产者在这里只会生产 10 个元素。当消费者将 10 个元素消费完成之后，按下倒计时门闩，所有线程都会停止。\",\"public class ProducerConsumerExample { public static void main(String[] args) throws InterruptedException { // 创建一个大小为 5 的 ArrayBlockingQueue ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5); // 创建生产者线程 Thread producer = new Thread(() -> { try { for (int i = 1; i <= 10; i++) { // 向队列中添加元素，如果队列已满则阻塞等待 queue.put(i); System.out.println(\\\"生产者添加元素：\\\" + i); } } catch (InterruptedException e) { e.printStackTrace(); } }); CountDownLatch countDownLatch = new CountDownLatch(1); // 创建消费者线程 Thread consumer = new Thread(() -> { try { int count = 0; while (true) { // 从队列中取出元素，如果队列为空则阻塞等待 int element = queue.take(); System.out.println(\\\"消费者取出元素：\\\" + element); ++count; if (count == 10) { break; } } countDownLatch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } }); // 启动线程 producer.start(); consumer.start(); // 等待线程结束 producer.join(); consumer.join(); countDownLatch.await(); producer.interrupt(); consumer.interrupt(); } } \",\"代码输出结果如下，可以看到只有生产者往队列中投放元素之后消费者才能消费，这也就意味着当队列中没有数据的时消费者就会阻塞，等待队列非空再继续消费。\",\"生产者添加元素：1 生产者添加元素：2 消费者取出元素：1 消费者取出元素：2 消费者取出元素：3 生产者添加元素：3 生产者添加元素：4 生产者添加元素：5 消费者取出元素：4 生产者添加元素：6 消费者取出元素：5 生产者添加元素：7 生产者添加元素：8 生产者添加元素：9 生产者添加元素：10 消费者取出元素：6 消费者取出元素：7 消费者取出元素：8 消费者取出元素：9 消费者取出元素：10 \",\"了解了 put、take 这两个会阻塞的存和取方法之后，我我们再来看看阻塞队列中非阻塞的入队和出队方法 offer 和 poll。\",\"如下所示，我们设置了一个大小为 3 的阻塞队列，我们会尝试在队列用 offer 方法存放 4 个元素，然后再从队列中用 poll 尝试取 4 次。\",\"public class OfferPollExample { public static void main(String[] args) { // 创建一个大小为 3 的 ArrayBlockingQueue ArrayBlockingQueue<String> queue = new ArrayBlockingQueue<>(3); // 向队列中添加元素 System.out.println(queue.offer(\\\"A\\\")); System.out.println(queue.offer(\\\"B\\\")); System.out.println(queue.offer(\\\"C\\\")); // 尝试向队列中添加元素，但队列已满，返回 false System.out.println(queue.offer(\\\"D\\\")); // 从队列中取出元素 System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); // 尝试从队列中取出元素，但队列已空，返回 null System.out.println(queue.poll()); } } \",\"最终代码的输出结果如下，可以看到因为队列的大小为 3 的缘故，我们前 3 次存放到队列的结果为 true，第 4 次存放时，由于队列已满，所以存放结果返回 false。这也是为什么我们后续的 poll 方法只得到了 3 个元素的值。\",\"true true true false A B C null \",\"了解了阻塞存取和非阻塞存取，我们再来看看阻塞队列的一个比较特殊的操作，某些场景下，我们希望能够一次性将阻塞队列的结果存到列表中再进行批量操作，我们就可以使用阻塞队列的 drainTo 方法，这个方法会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 drainTo 会返回本次转移到 list 中的元素数，反之若队列为空，drainTo 则直接返回 0。\",\"public class DrainToExample { public static void main(String[] args) { // 创建一个大小为 5 的 ArrayBlockingQueue ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5); // 向队列中添加元素 queue.add(1); queue.add(2); queue.add(3); queue.add(4); queue.add(5); // 创建一个 List，用于存储从队列中取出的元素 List<Integer> list = new ArrayList<>(); // 从队列中取出所有元素，并添加到 List 中 queue.drainTo(list); // 输出 List 中的元素 System.out.println(list); } } \",\"代码输出结果如下\",\"[1, 2, 3, 4, 5] \"]},\"532\":{\"h\":\"ArrayBlockingQueue 源码分析\",\"t\":[\"自此我们对阻塞队列的使用有了基本的印象，接下来我们就可以进一步了解一下 ArrayBlockingQueue 的工作机制了。\"]},\"533\":{\"h\":\"整体设计\",\"t\":[\"在了解 ArrayBlockingQueue 的具体细节之前，我们先来看看 ArrayBlockingQueue 的类图。\",\"ArrayBlockingQueue 类图\",\"从图中我们可以看出，ArrayBlockingQueue 继承了阻塞队列 BlockingQueue 这个接口，不难猜出通过继承 BlockingQueue 这个接口之后，ArrayBlockingQueue 就拥有了阻塞队列那些常见的操作行为。\",\"同时， ArrayBlockingQueue 还继承了 AbstractQueue 这个抽象类，这个继承了 AbstractCollection 和 Queue 的抽象类，从抽象类的特定和语义我们也可以猜出，这个继承关系使得 ArrayBlockingQueue 拥有了队列的常见操作。\",\"所以我们是否可以得出这样一个结论，通过继承 AbstractQueue 获得队列所有的操作模板，其实现的入队和出队操作的整体框架。然后 ArrayBlockingQueue 通过继承 BlockingQueue 获取到阻塞队列的常见操作并将这些操作实现，填充到 AbstractQueue 模板方法的细节中，由此 ArrayBlockingQueue 成为一个完整的阻塞队列。\",\"为了印证这一点，我们到源码中一探究竟。首先我们先来看看 AbstractQueue，从类的继承关系我们可以大致得出，它通过 AbstractCollection 获得了集合的常见操作方法，然后通过 Queue 接口获得了队列的特性。\",\"public abstract class AbstractQueue<E> extends AbstractCollection<E> implements Queue<E> { //... } \",\"对于集合的操作无非是增删改查，所以我们不妨从添加方法入手，从源码中我们可以看到，它实现了 AbstractCollection 的 add 方法，其内部逻辑如下:\",\"调用继承 Queue 接口的来的 offer 方法，如果 offer 成功则返回 true。\",\"如果 offer 失败，即代表当前元素入队失败直接抛异常。\",\"public boolean add(E e) { if (offer(e)) return true; else throw new IllegalStateException(\\\"Queue full\\\"); } \",\"而 AbstractQueue 中并没有对 Queue 的 offer 的实现，很明显这样做的目的是定义好了 add 的核心逻辑，将 offer 的细节交由其子类即我们的 ArrayBlockingQueue 实现。\",\"到此，我们对于抽象类 AbstractQueue 的分析就结束了，我们继续看看 ArrayBlockingQueue 中另一个重要的继承接口 BlockingQueue。\",\"点开 BlockingQueue 之后，我们可以看到这个接口同样继承了 Queue 接口，这就意味着它也具备了队列所拥有的所有行为。同时，它还定义了自己所需要实现的方法。\",\"public interface BlockingQueue<E> extends Queue<E> { //元素入队成功返回true，反之则会抛出异常IllegalStateException boolean add(E e); //元素入队成功返回true，反之返回false boolean offer(E e); //元素入队成功则直接返回，如果队列已满元素不可入队则将线程阻塞，因为阻塞期间可能会被打断，所以这里方法签名抛出了InterruptedException void put(E e) throws InterruptedException; //和上一个方法一样,只不过队列满时只会阻塞单位为unit，时间为timeout的时长，如果在等待时长内没有入队成功则直接返回false。 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //从队头取出一个元素，如果队列为空则阻塞等待，因为会阻塞线程的缘故，所以该方法可能会被打断，所以签名定义了InterruptedException E take() throws InterruptedException; //取出队头的元素并返回，如果当前队列为空则阻塞等待timeout且单位为unit的时长，如果这个时间段没有元素则直接返回null。 E poll(long timeout, TimeUnit unit) throws InterruptedException; //获取队列剩余元素个数 int remainingCapacity(); //删除我们指定的对象，如果成功返回true，反之返回false。 boolean remove(Object o); //判断队列中是否包含指定元素 public boolean contains(Object o); //将队列中的元素全部存到指定的集合中 int drainTo(Collection<? super E> c); //转移maxElements个元素到集合中 int drainTo(Collection<? super E> c, int maxElements); } \",\"了解了 BlockingQueue 的常见操作后，我们就知道了 ArrayBlockingQueue 通过继承 BlockingQueue 的方法并实现后，填充到 AbstractQueue 的方法上，由此我们便知道了上文中 AbstractQueue 的 add 方法的 offer 方法是哪里是实现的了。\",\"public boolean add(E e) { //AbstractQueue的offer来自下层的ArrayBlockingQueue从BlockingQueue继承并实现的offer方法 if (offer(e)) return true; else throw new IllegalStateException(\\\"Queue full\\\"); } \"]},\"534\":{\"h\":\"初始化\",\"t\":[\"了解 ArrayBlockingQueue 的细节前，我们不妨先看看其构造函数，了解一下其初始化过程。从源码中我们可以看出 ArrayBlockingQueue 有 3 个构造方法，而最核心的构造方法就是下方这一个。\",\"// capacity 表示队列初始容量，fair 表示 锁的公平性 public ArrayBlockingQueue(int capacity, boolean fair) { //如果设置的队列大小小于0，则直接抛出IllegalArgumentException if (capacity <= 0) throw new IllegalArgumentException(); //初始化一个数组用于存放队列的元素 this.items = new Object[capacity]; //创建阻塞队列流程控制的锁 lock = new ReentrantLock(fair); //用lock锁创建两个条件控制队列生产和消费 notEmpty = lock.newCondition(); notFull = lock.newCondition(); } \",\"这个构造方法里面有两个比较核心的成员变量 notEmpty(非空) 和 notFull （非满） ，需要我们格外留意，它们是实现生产者和消费者有序工作的关键所在，这一点笔者会在后续的源码解析中详细说明，这里我们只需初步了解一下阻塞队列的构造即可。\",\"另外两个构造方法都是基于上述的构造方法，默认情况下，我们会使用下面这个构造方法，该构造方法就意味着 ArrayBlockingQueue 用的是非公平锁，即各个生产者或者消费者线程收到通知后，对于锁的争抢是随机的。\",\" public ArrayBlockingQueue(int capacity) { this(capacity, false); } \",\"还有一个不怎么常用的构造方法，在初始化容量和锁的非公平性之后，它还提供了一个 Collection 参数，从源码中不难看出这个构造方法是将外部传入的集合的元素在初始化时直接存放到阻塞队列中。\",\"public ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) { //初始化容量和锁的公平性 this(capacity, fair); final ReentrantLock lock = this.lock; //上锁并将c中的元素存放到ArrayBlockingQueue底层的数组中 lock.lock(); try { int i = 0; try { //遍历并添加元素到数组中 for (E e : c) { checkNotNull(e); items[i++] = e; } } catch (ArrayIndexOutOfBoundsException ex) { throw new IllegalArgumentException(); } //记录当前队列容量 count = i; //更新下一次put或者offer或用add方法添加到队列底层数组的位置 putIndex = (i == capacity) ? 0 : i; } finally { //完成遍历后释放锁 lock.unlock(); } } \"]},\"535\":{\"h\":\"阻塞式获取和新增元素\",\"t\":[\"ArrayBlockingQueue 阻塞式获取和新增元素对应的就是生产者-消费者模型，虽然它也支持非阻塞式获取和新增元素（例如 poll() 和 offer(E e) 方法，后文会介绍到），但一般不会使用。\",\"ArrayBlockingQueue 阻塞式获取和新增元素的方法为：\",\"put(E e)：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。\",\"take() ：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。\",\"这两个方法实现的关键就是在于两个条件对象 notEmpty(非空) 和 notFull （非满），这个我们在上文的构造方法中有提到。\",\"接下来笔者就通过两张图让大家了解一下这两个条件是如何在阻塞队列中运用的。\",\"ArrayBlockingQueue 非空条件\",\"假设我们的代码消费者先启动，当它发现队列中没有数据，那么非空条件就会将这个线程挂起，即等待条件非空时挂起。然后 CPU 执行权到达生产者，生产者发现队列中可以存放数据，于是将数据存放进去，通知此时条件非空，此时消费者就会被唤醒到队列中使用 take 等方法获取值了。\",\"ArrayBlockingQueue 非满条件\",\"随后的执行中，生产者生产速度远远大于消费者消费速度，于是生产者将队列塞满后再次尝试将数据存入队列，发现队列已满，于是阻塞队列就将当前线程挂起，等待非满。然后消费者拿着 CPU 执行权进行消费，于是队列可以存放新数据了，发出一个非满的通知，此时挂起的生产者就会等待 CPU 执行权到来时再次尝试将数据存到队列中。\",\"简单了解阻塞队列的基于两个条件的交互流程之后，我们不妨看看 put 和 take 方法的源码。\",\"public void put(E e) throws InterruptedException { //确保插入的元素不为null checkNotNull(e); //加锁 final ReentrantLock lock = this.lock; //这里使用lockInterruptibly()方法而不是lock()方法是为了能够响应中断操作，如果在等待获取锁的过程中被打断则该方法会抛出InterruptedException异常。 lock.lockInterruptibly(); try { //如果count等数组长度则说明队列已满，当前线程将被挂起放到AQS队列中，等待队列非满时插入（非满条件）。 //在等待期间，锁会被释放，其他线程可以继续对队列进行操作。 while (count == items.length) notFull.await(); //如果队列可以存放元素，则调用enqueue将元素入队 enqueue(e); } finally { //释放锁 lock.unlock(); } } \",\"put方法内部调用了 enqueue 方法来实现元素入队，我们继续深入查看一下 enqueue 方法的实现细节：\",\"private void enqueue(E x) { //获取队列底层的数组 final Object[] items = this.items; //将putindex位置的值设置为我们传入的x items[putIndex] = x; //更新putindex，如果putindex等于数组长度，则更新为0 if (++putIndex == items.length) putIndex = 0; //队列长度+1 count++; //通知队列非空，那些因为获取元素而阻塞的线程可以继续工作了 notEmpty.signal(); } \",\"从源码中可以看到入队操作的逻辑就是在数组中追加一个新元素，整体执行步骤为:\",\"获取 ArrayBlockingQueue 底层的数组 items。\",\"将元素存到 putIndex 位置。\",\"更新 putIndex 到下一个位置，如果 putIndex 等于队列长度，则说明 putIndex 已经到达数组末尾了，下一次插入则需要 0 开始。(ArrayBlockingQueue 用到了循环队列的思想，即从头到尾循环复用一个数组)\",\"更新 count 的值，表示当前队列长度+1。\",\"调用 notEmpty.signal() 通知队列非空，消费者可以从队列中获取值了。\",\"自此我们了解了 put 方法的流程，为了更加完整的了解 ArrayBlockingQueue 关于生产者-消费者模型的设计，我们继续看看阻塞获取队列元素的 take 方法。\",\"public E take() throws InterruptedException { //获取锁 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { //如果队列中元素个数为0，则将当前线程打断并存入AQS队列中，等待队列非空时获取并移除元素（非空条件） while (count == 0) notEmpty.await(); //如果队列不为空则调用dequeue获取元素 return dequeue(); } finally { //释放锁 lock.unlock(); } } \",\"理解了 put 方法再看take 方法就很简单了，其核心逻辑和put 方法正好是相反的，比如put 方法在队列满的时候等待队列非满时插入元素（非满条件），而take 方法等待队列非空时获取并移除元素（非空条件）。\",\"take方法内部调用了 dequeue 方法来实现元素出队，其核心逻辑和 enqueue 方法也是相反的。\",\"private E dequeue() { //获取阻塞队列底层的数组 final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") //从队列中获取takeIndex位置的元素 E x = (E) items[takeIndex]; //将takeIndex置空 items[takeIndex] = null; //takeIndex向后挪动，如果等于数组长度则更新为0 if (++takeIndex == items.length) takeIndex = 0; //队列长度减1 count--; if (itrs != null) itrs.elementDequeued(); //通知那些被打断的线程当前队列状态非满，可以继续存放元素 notFull.signal(); return x; } \",\"由于dequeue 方法（出队）和上面介绍的 enqueue 方法（入队）的步骤大致类似，这里就不重复介绍了。\",\"为了帮助理解，我专门画了一张图来展示 notEmpty(非空) 和 notFull （非满）这两个条件对象是如何控制 ArrayBlockingQueue 的存和取的。\",\"ArrayBlockingQueue 非空非满\",\"消费者：当消费者从队列中 take 或者 poll 等操作取出一个元素之后，就会通知队列非满，此时那些等待非满的生产者就会被唤醒等待获取 CPU 时间片进行入队操作。\",\"生产者：当生产者将元素存到队列中后，就会触发通知队列非空，此时消费者就会被唤醒等待 CPU 时间片尝试获取元素。如此往复，两个条件对象就构成一个环路，控制着多线程之间的存和取。\"]},\"536\":{\"h\":\"非阻塞式获取和新增元素\",\"t\":[\"ArrayBlockingQueue 非阻塞式获取和新增元素的方法为：\",\"offer(E e)：将元素插入队列尾部。如果队列已满，则该方法会直接返回 false，不会等待并阻塞线程。\",\"poll()：获取并移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。\",\"add(E e)：将元素插入队列尾部。如果队列已满则会抛出 IllegalStateException 异常，底层基于 offer(E e) 方法。\",\"remove()：移除队列头部的元素，如果队列为空则会抛出 NoSuchElementException 异常，底层基于 poll()。\",\"peek()：获取但不移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。\",\"先来看看 offer 方法，逻辑和 put 差不多，唯一的区别就是入队失败时不会阻塞当前线程，而是直接返回 false。\",\"public boolean offer(E e) { //确保插入的元素不为null checkNotNull(e); //获取锁 final ReentrantLock lock = this.lock; lock.lock(); try { //队列已满直接返回false if (count == items.length) return false; else { //反之将元素入队并直接返回true enqueue(e); return true; } } finally { //释放锁 lock.unlock(); } } \",\"poll 方法同理，获取元素失败也是直接返回空，并不会阻塞获取元素的线程。\",\"public E poll() { final ReentrantLock lock = this.lock; //上锁 lock.lock(); try { //如果队列为空直接返回null，反之出队返回元素值 return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } \",\"add 方法其实就是对于 offer 做了一层封装，如下代码所示，可以看到 add 会调用没有规定时间的 offer，如果入队失败则直接抛异常。\",\"public boolean add(E e) { //调用下方的add return super.add(e); } public boolean add(E e) { //调用offer如果失败直接抛出异常 if (offer(e)) return true; else throw new IllegalStateException(\\\"Queue full\\\"); } \",\"remove 方法同理，调用 poll，如果返回 null 则说明队列没有元素，直接抛出异常。\",\"public E remove() { E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); } \",\"peek() 方法的逻辑也很简单，内部调用了 itemAt 方法。\",\"public E peek() { //加锁 final ReentrantLock lock = this.lock; lock.lock(); try { //当队列为空时返回 null return itemAt(takeIndex); } finally { //释放锁 lock.unlock(); } } //返回队列中指定位置的元素 @SuppressWarnings(\\\"unchecked\\\") final E itemAt(int i) { return (E) items[i]; } \"]},\"537\":{\"h\":\"指定超时时间内阻塞式获取和新增元素\",\"t\":[\"在 offer(E e) 和 poll() 非阻塞获取和新增元素的基础上，设计者提供了带有等待时间的 offer(E e, long timeout, TimeUnit unit) 和 poll(long timeout, TimeUnit unit) ，用于在指定的超时时间内阻塞式地添加和获取元素。\",\" public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException { checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { //队列已满，进入循环 while (count == items.length) { //时间到了队列还是满的，则直接返回false if (nanos <= 0) return false; //阻塞nanos时间，等待非满 nanos = notFull.awaitNanos(nanos); } enqueue(e); return true; } finally { lock.unlock(); } } \",\"可以看到，带有超时时间的 offer 方法在队列已满的情况下，会等待用户所传的时间段，如果规定时间内还不能存放元素则直接返回 false。\",\"public E poll(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { //队列为空，循环等待，若时间到还是空的，则直接返回null while (count == 0) { if (nanos <= 0) return null; nanos = notEmpty.awaitNanos(nanos); } return dequeue(); } finally { lock.unlock(); } } \",\"同理，带有超时时间的 poll 也一样，队列为空则在规定时间内等待，若时间到了还是空的，则直接返回 null。\"]},\"538\":{\"h\":\"判断元素是否存在\",\"t\":[\"ArrayBlockingQueue 提供了 contains(Object o) 来判断指定元素是否存在于队列中。\",\"public boolean contains(Object o) { //若目标元素为空，则直接返回 false if (o == null) return false; //获取当前队列的元素数组 final Object[] items = this.items; //加锁 final ReentrantLock lock = this.lock; lock.lock(); try { // 如果队列非空 if (count > 0) { final int putIndex = this.putIndex; //从队列头部开始遍历 int i = takeIndex; do { if (o.equals(items[i])) return true; if (++i == items.length) i = 0; } while (i != putIndex); } return false; } finally { //释放锁 lock.unlock(); } } \"]},\"539\":{\"h\":\"ArrayBlockingQueue 获取和新增元素的方法对比\",\"t\":[\"为了帮助理解 ArrayBlockingQueue ，我们再来对比一下上面提到的这些获取和新增元素的方法。\",\"新增元素：\",\"方法\",\"队列满时处理方式\",\"方法返回值\",\"put(E e)\",\"线程阻塞，直到中断或被唤醒\",\"void\",\"offer(E e)\",\"直接返回 false\",\"boolean\",\"offer(E e, long timeout, TimeUnit unit)\",\"指定超时时间内阻塞，超过规定时间还未添加成功则返回 false\",\"boolean\",\"add(E e)\",\"直接抛出 IllegalStateException 异常\",\"boolean\",\"获取/移除元素：\",\"方法\",\"队列空时处理方式\",\"方法返回值\",\"take()\",\"线程阻塞，直到中断或被唤醒\",\"E\",\"poll()\",\"返回 null\",\"E\",\"poll(long timeout, TimeUnit unit)\",\"指定超时时间内阻塞，超过规定时间还是空的则返回 null\",\"E\",\"peek()\",\"返回 null\",\"E\",\"remove()\",\"直接抛出 NoSuchElementException 异常\",\"boolean\"]},\"540\":{\"h\":\"ArrayBlockingQueue 相关面试题\"},\"541\":{\"h\":\"ArrayBlockingQueue 是什么？它的特点是什么？\",\"t\":[\"ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现，从其名字就能看出来了。\",\"ArrayBlockingQueue 的容量有限，一旦创建，容量不能改变。\",\"为了保证线程安全，ArrayBlockingQueue 的并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。并且，它还支持公平和非公平两种方式的锁访问机制，默认是非公平锁。\",\"ArrayBlockingQueue 虽名为阻塞队列，但也支持非阻塞获取和新增元素（例如 poll() 和 offer(E e) 方法），只是队列满时添加元素会抛出异常，队列为空时获取的元素为 null，一般不会使用。\"]},\"542\":{\"h\":\"ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？\",\"t\":[\"ArrayBlockingQueue 和 LinkedBlockingQueue 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：\",\"底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。\",\"是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。\",\"锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。\",\"内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。\"]},\"543\":{\"h\":\"ArrayBlockingQueue 和 ConcurrentLinkedQueue 有什么区别？\",\"t\":[\"ArrayBlockingQueue 和 ConcurrentLinkedQueue 是 Java 并发包中常用的两种队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：\",\"底层实现：ArrayBlockingQueue 基于数组实现，而 ConcurrentLinkedQueue 基于链表实现。\",\"是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小，而 ConcurrentLinkedQueue 是无界队列，可以动态地增加容量。\",\"是否阻塞：ArrayBlockingQueue 支持阻塞和非阻塞两种获取和新增元素的方式（一般只会使用前者）， ConcurrentLinkedQueue 是无界的，仅支持非阻塞式获取和新增元素。\"]},\"544\":{\"h\":\"ArrayBlockingQueue 的实现原理是什么？\",\"t\":[\"ArrayBlockingQueue 的实现原理主要分为以下几点（这里以阻塞式获取和新增元素为例介绍）：\",\"ArrayBlockingQueue 内部维护一个定长的数组用于存储元素。\",\"通过使用 ReentrantLock 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。\",\"通过 Condition 实现线程间的等待和唤醒操作。\",\"这里再详细介绍一下线程间的等待和唤醒具体的实现（不需要记具体的方法，面试中回答要点即可）：\",\"当队列已满时，生产者线程会调用 notFull.await() 方法让生产者进行等待，等待队列非满时插入（非满条件）。\",\"当队列为空时，消费者线程会调用 notEmpty.await()方法让消费者进行等待，等待队列非空时消费（非空条件）。\",\"当有新的元素被添加时，生产者线程会调用 notEmpty.signal()方法唤醒正在等待消费的消费者线程。\",\"当队列中有元素被取出时，消费者线程会调用 notFull.signal()方法唤醒正在等待插入元素的生产者线程。\",\"关于 Condition接口的补充：\",\"Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程。\"]},\"545\":{\"h\":\"参考文献\",\"t\":[\"深入理解 Java 系列 | BlockingQueue 用法详解：https://juejin.cn/post/6999798721269465102\",\"深入浅出阻塞队列 BlockingQueue 及其典型实现 ArrayBlockingQueue：https://zhuanlan.zhihu.com/p/539619957\",\"并发编程大扫盲：ArrayBlockingQueue 底层原理和实战：https://zhuanlan.zhihu.com/p/339662987\",\"File not found\"]},\"546\":{\"c\":[\"Java\"]},\"547\":{\"c\":[\"Java集合\"]},\"548\":{\"h\":\"ArrayList 源码分析\",\"t\":[\"File not found\"]},\"549\":{\"h\":\"ArrayList 简介\",\"t\":[\"ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。\",\"ArrayList 继承于 AbstractList ，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。\",\" public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{ } \",\"List : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\",\"RandomAccess ：这是一个标志接口，表明实现这个接口的 List 集合是支持 快速随机访问 的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\",\"Cloneable ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\",\"Serializable : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\",\"ArrayList 类图\"]},\"550\":{\"h\":\"ArrayList 和 Vector 的区别?（了解即可）\",\"t\":[\"ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 。\",\"Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全。\"]},\"551\":{\"h\":\"ArrayList 可以添加 null 值吗？\",\"t\":[\"ArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\",\"示例代码：\",\"ArrayList<String> listOfStrings = new ArrayList<>(); listOfStrings.add(null); listOfStrings.add(\\\"java\\\"); System.out.println(listOfStrings); \",\"输出：\",\"[null, java] \"]},\"552\":{\"h\":\"Arraylist 与 LinkedList 区别?\",\"t\":[\"是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\",\"底层数据结构：ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\",\"插入和删除是否受元素位置的影响：\",\"ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\",\"LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。\",\"是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\",\"内存空间占用：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\"]},\"553\":{\"h\":\"ArrayList 核心源码解读\",\"t\":[\"这里以 JDK1.8 为例，分析一下 ArrayList 的底层源码。\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = {}; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小） */ public ArrayList(int initialCapacity) { if (initialCapacity > 0) { //如果传入的参数大于0，创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { //如果传入的参数等于0，创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else { //其他情况，抛出异常 throw new IllegalArgumentException(\\\"Illegal Capacity: \\\" + initialCapacity); } } /** * 默认无参构造函数 * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection<? extends E> c) { //将指定集合转换为数组 elementData = c.toArray(); //如果elementData数组的长度不为0 if ((size = elementData.length) != 0) { // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断） if (elementData.getClass() != Object[].class) //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组 elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // 其他情况，用空数组代替 this.elementData = EMPTY_ELEMENTDATA; } } /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() { modCount++; if (size < elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } //下面是ArrayList的扩容机制 //ArrayList的扩容机制提高了性能，如果每次只扩充一个， //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { //如果是true，minExpand的值为0，如果是false,minExpand的值为10 int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; //如果最小容量大于已有的最大容量 if (minCapacity > minExpand) { ensureExplicitCapacity(minCapacity); } } // 根据给定的最小容量和当前数组元素来计算所需容量。 private static int calculateCapacity(Object[] elementData, int minCapacity) { // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } // 否则直接返回最小容量 return minCapacity; } // 确保内部容量达到指定的最小容量。 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); } /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity >> 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity < 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } //比较minCapacity和 MAX_ARRAY_SIZE private static int hugeCapacity(int minCapacity) { if (minCapacity < 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } /** * 返回此列表中的元素数。 */ public int size() { return size; } /** * 如果此列表不包含元素，则返回 true 。 */ public boolean isEmpty() { //注意=和==的区别 return size == 0; } /** * 如果此列表包含指定的元素，则返回true 。 */ public boolean contains(Object o) { //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 return indexOf(o) >= 0; } /** * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 */ public int indexOf(Object o) { if (o == null) { for (int i = 0; i < size; i++) if (elementData[i] == null) return i; } else { for (int i = 0; i < size; i++) //equals()方法比较 if (o.equals(elementData[i])) return i; } return -1; } /** * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。. */ public int lastIndexOf(Object o) { if (o == null) { for (int i = size - 1; i >= 0; i--) if (elementData[i] == null) return i; } else { for (int i = size - 1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } /** * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） */ public Object clone() { try { ArrayList<?> v = (ArrayList<?>) super.clone(); //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { // 这不应该发生，因为我们是可以克隆的 throw new InternalError(e); } } /** * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */ public Object[] toArray() { return Arrays.copyOf(elementData, size); } /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。 * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） */ @SuppressWarnings(\\\"unchecked\\\") public <T> T[] toArray(T[] a) { if (a.length < size) // 新建一个运行时类型的数组，但是ArrayList数组的内容 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //调用System提供的arraycopy()方法实现数组之间的复制 System.arraycopy(elementData, 0, a, 0, size); if (a.length > size) a[size] = null; return a; } // Positional Access Operations @SuppressWarnings(\\\"unchecked\\\") E elementData(int index) { return (E) elementData[index]; } /** * 返回此列表中指定位置的元素。 */ public E get(int index) { rangeCheck(index); return elementData(index); } /** * 用指定的元素替换此列表中指定位置的元素。 */ public E set(int index, E element) { //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //返回原来在这个位置的元素 return oldValue; } /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; } /** * 在此列表中的指定位置插入指定的元素。 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 */ public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work //从列表中删除的元素 return oldValue; } /** * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。 * 返回true，如果此列表包含指定的元素 */ public boolean remove(Object o) { if (o == null) { for (int index = 0; index < size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index < size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } /** * 从列表中删除所有元素。 */ public void clear() { modCount++; // 把数组中所有的元素的值设为null for (int i = 0; i < size; i++) elementData[i] = null; size = 0; } /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection<? extends E> c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection<? extends E> c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 * 将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) { modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex - fromIndex); for (int i = newSize; i < size; i++) { elementData[i] = null; } size = newSize; } /** * 检查给定的索引是否在范围内。 */ private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) { if (index > size || index < 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) { return \\\"Index: \\\" + index + \\\", Size: \\\" + size; } /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection<?> c) { Objects.requireNonNull(c); //如果此列表被修改则返回true return batchRemove(c, false); } /** * 仅保留此列表中包含在指定集合中的元素。 * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 */ public boolean retainAll(Collection<?> c) { Objects.requireNonNull(c); return batchRemove(c, true); } /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 * 返回的列表迭代器是fail-fast 。 */ public ListIterator<E> listIterator(int index) { if (index < 0 || index > size) throw new IndexOutOfBoundsException(\\\"Index: \\\" + index); return new ListItr(index); } /** * 返回列表中的列表迭代器（按适当的顺序）。 * 返回的列表迭代器是fail-fast 。 */ public ListIterator<E> listIterator() { return new ListItr(0); } /** * 以正确的顺序返回该列表中的元素的迭代器。 * 返回的迭代器是fail-fast 。 */ public Iterator<E> iterator() { return new Itr(); } \"]},\"554\":{\"h\":\"ArrayList 扩容机制分析\"},\"555\":{\"h\":\"先从 ArrayList 的构造函数说起\",\"t\":[\"ArrayList 有三种方式来初始化，构造方法源码如下（JDK8）：\",\"/** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 默认构造函数，使用初始容量10构造一个空列表(无参数构造) */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) { if (initialCapacity > 0) {//初始容量大于0 //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) {//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else {//初始容量小于0，抛出异常 throw new IllegalArgumentException(\\\"Illegal Capacity: \\\" + initialCapacity); } } /** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */ public ArrayList(Collection<? extends E> c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } \",\"细心的同学一定会发现：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 下面在我们分析 ArrayList 扩容时会讲到这一点内容！\",\"补充：JDK6 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。\"]},\"556\":{\"h\":\"一步一步分析 ArrayList 扩容机制\",\"t\":[\"这里以无参构造函数创建的 ArrayList 为例分析。\"]},\"557\":{\"h\":\"add 方法\",\"t\":[\"/** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) { // 加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! // 这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; } \",\"注意：JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法\",\"ensureCapacityInternal 方法的源码如下：\",\"// 根据给定的最小容量和当前数组元素来计算所需容量。 private static int calculateCapacity(Object[] elementData, int minCapacity) { // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } // 否则直接返回最小容量 return minCapacity; } // 确保内部容量达到指定的最小容量。 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } \",\"ensureCapacityInternal 方法非常简单，内部直接调用了 ensureExplicitCapacity 方法：\",\"//判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) { modCount++; //判断当前数组容量是否足以存储minCapacity个元素 if (minCapacity - elementData.length > 0) //调用grow方法进行扩容 grow(minCapacity); } \",\"我们来仔细分析一下：\",\"当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length > 0成立，所以会进入 grow(minCapacity) 方法。\",\"当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length > 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。\",\"添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\",\"直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\"]},\"558\":{\"h\":\"grow 方法\",\"t\":[\"/** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; // 将oldCapacity 右移一位，其效果相当于oldCapacity /2， // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity >> 1); // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity < 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } \",\"int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.\",\"\\\">>\\\"（移位运算符）：>>1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity /2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源\",\"我们再来通过例子探究一下grow() 方法：\",\"当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 hugeCapacity 方法。数组容量为 10，add 方法中 return true,size 增为 1。\",\"当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\",\"以此类推······\",\"这里补充一点比较重要，但是容易被忽视掉的知识点：\",\"Java 中的 length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\",\"Java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.\",\"Java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\"]},\"559\":{\"h\":\"hugeCapacity() 方法\",\"t\":[\"从上面 grow() 方法源码我们知道：如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。\",\"private static int hugeCapacity(int minCapacity) { if (minCapacity < 0) // overflow throw new OutOfMemoryError(); // 对minCapacity和MAX_ARRAY_SIZE进行比较 // 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小 // 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小 // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } \"]},\"560\":{\"h\":\"System.arraycopy() 和 Arrays.copyOf() 方法\",\"t\":[\"阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！\"]},\"561\":{\"h\":\"System.arraycopy() 方法\",\"t\":[\"源码：\",\" // 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义 /** * 复制数组 * @param src 源数组 * @param srcPos 源数组中的起始位置 * @param dest 目标数组 * @param destPos 目标数组中的起始位置 * @param length 要复制的数组元素的数量 */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); \",\"场景：\",\" /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } \",\"我们写一个简单的方法测试以下：\",\"public class ArraycopyTest { public static void main(String[] args) { // TODO Auto-generated method stub int[] a = new int[10]; a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3; System.arraycopy(a, 2, a, 3, 3); a[2]=99; for (int i = 0; i < a.length; i++) { System.out.print(a[i] + \\\" \\\"); } } } \",\"结果：\",\"0 1 99 2 3 0 0 0 0 0 \"]},\"562\":{\"h\":\"Arrays.copyOf() 方法\",\"t\":[\"源码：\",\" public static int[] copyOf(int[] original, int newLength) { // 申请一个新的数组 int[] copy = new int[newLength]; // 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } \",\"场景：\",\" /** 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); } \",\"个人觉得使用 Arrays.copyOf()方法主要是为了给原有数组扩容，测试代码如下：\",\"public class ArrayscopyOfTest { public static void main(String[] args) { int[] a = new int[3]; a[0] = 0; a[1] = 1; a[2] = 2; int[] b = Arrays.copyOf(a, 10); System.out.println(\\\"b.length\\\"+b.length); } } \",\"结果：\",\"10 \"]},\"563\":{\"h\":\"两者联系和区别\",\"t\":[\"联系：\",\"看两者源代码可以发现 copyOf()内部实际调用了 System.arraycopy() 方法\",\"区别：\",\"arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。\"]},\"564\":{\"h\":\"ensureCapacity 方法\",\"t\":[\"ArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？\",\" /** 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity > minExpand) { ensureExplicitCapacity(minCapacity); } } \",\"理论上来说，最好在向 ArrayList 添加大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数\",\"我们通过下面的代码实际测试以下这个方法的效果：\",\"public class EnsureCapacityTest { public static void main(String[] args) { ArrayList<Object> list = new ArrayList<Object>(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i < N; i++) { list.add(i); } long endTime = System.currentTimeMillis(); System.out.println(\\\"使用ensureCapacity方法前：\\\"+(endTime - startTime)); } } \",\"运行结果：\",\"使用ensureCapacity方法前：2158 \",\"public class EnsureCapacityTest { public static void main(String[] args) { ArrayList<Object> list = new ArrayList<Object>(); final int N = 10000000; long startTime1 = System.currentTimeMillis(); list.ensureCapacity(N); for (int i = 0; i < N; i++) { list.add(i); } long endTime1 = System.currentTimeMillis(); System.out.println(\\\"使用ensureCapacity方法后：\\\"+(endTime1 - startTime1)); } } \",\"运行结果：\",\"使用ensureCapacity方法后：1773 \",\"通过运行结果，我们可以看出向 ArrayList 添加大量元素之前使用ensureCapacity 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 ArrayList 里面添加这么多元素。\",\"File not found\"]},\"565\":{\"c\":[\"Java\"]},\"566\":{\"c\":[\"Java集合\"]},\"567\":{\"h\":\"ConcurrentHashMap 源码分析\",\"t\":[\"本文来自公众号：末读代码的投稿，原文地址：https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw 。\",\"上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 ConcurrentHashMap 了，作为线程安全的 HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？\"]},\"568\":{\"h\":\"1. ConcurrentHashMap 1.7\"},\"569\":{\"h\":\"1. 存储结构\",\"t\":[\"Java 7 ConcurrentHashMap 存储结构\",\"Java 7 中 ConcurrentHashMap 的存储结构如上图，ConcurrnetHashMap 由很多个 Segment 组合，而每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发。\"]},\"570\":{\"h\":\"2. 初始化\",\"t\":[\"通过 ConcurrentHashMap 的无参构造探寻 ConcurrentHashMap 的初始化流程。\",\" /** * Creates a new, empty map with a default initial capacity (16), * load factor (0.75) and concurrencyLevel (16). */ public ConcurrentHashMap() { this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); } \",\"无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。\",\" /** * 默认初始化容量 */ static final int DEFAULT_INITIAL_CAPACITY = 16; /** * 默认负载因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 默认并发级别 */ static final int DEFAULT_CONCURRENCY_LEVEL = 16; \",\"接着看下这个有参构造函数的内部实现逻辑。\",\"@SuppressWarnings(\\\"unchecked\\\") public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) { // 参数校验 if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0) throw new IllegalArgumentException(); // 校验并发级别大小，大于 1<<16，重置为 65536 if (concurrencyLevel > MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments // 2的多少次方 int sshift = 0; int ssize = 1; // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值 while (ssize < concurrencyLevel) { ++sshift; ssize <<= 1; } // 记录段偏移量 this.segmentShift = 32 - sshift; // 记录段掩码 this.segmentMask = ssize - 1; // 设置容量 if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量 int c = initialCapacity / ssize; if (c * ssize < initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数 while (cap < c) cap <<= 1; // create segments and segments[0] // 创建 Segment 数组，设置 segments[0] Segment<K,V> s0 = new Segment<K,V>(loadFactor, (int)(cap * loadFactor), (HashEntry<K,V>[])new HashEntry[cap]); Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; } \",\"总结一下在 Java 7 中 ConcurrentHashMap 的初始化逻辑。\",\"必要参数校验。\",\"校验并发级别 concurrencyLevel 大小，如果大于最大值，重置为最大值。无参构造默认值是 16.\",\"寻找并发级别 concurrencyLevel 之上最近的 2 的幂次方值，作为初始化容量大小，默认是 16。\",\"记录 segmentShift 偏移量，这个值为【容量 = 2 的 N 次方】中的 N，在后面 Put 时计算位置时会用到。默认是 32 - sshift = 28.\",\"记录 segmentMask，默认是 ssize - 1 = 16 -1 = 15.\",\"初始化 segments[0]，默认大小为 2，负载因子 0.75，扩容阀值是 2*0.75=1.5，插入第二个值时才会进行扩容。\"]},\"571\":{\"h\":\"3. put\",\"t\":[\"接着上面的初始化参数继续查看 put 方法源码。\",\"/** * Maps the specified key to the specified value in this table. * Neither the key nor the value can be null. * * <p> The value can be retrieved by calling the <tt>get</tt> method * with a key that is equal to the original key. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with <tt>key</tt>, or * <tt>null</tt> if there was no mapping for <tt>key</tt> * @throws NullPointerException if the specified key or value is null */ public V put(K key, V value) { Segment<K,V> s; if (value == null) throw new NullPointerException(); int hash = hash(key); // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算 // 其实也就是把高4位与segmentMask（1111）做与运算 int j = (hash >>> segmentShift) & segmentMask; if ((s = (Segment<K,V>)UNSAFE.getObject // nonvolatile; recheck (segments, (j << SSHIFT) + SBASE)) == null) // in ensureSegment // 如果查找到的 Segment 为空，初始化 s = ensureSegment(j); return s.put(key, hash, value, false); } /** * Returns the segment for the given index, creating it and * recording in segment table (via CAS) if not already present. * * @param k the index * @return the segment */ @SuppressWarnings(\\\"unchecked\\\") private Segment<K,V> ensureSegment(int k) { final Segment<K,V>[] ss = this.segments; long u = (k << SSHIFT) + SBASE; // raw offset Segment<K,V> seg; // 判断 u 位置的 Segment 是否为null if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { Segment<K,V> proto = ss[0]; // use segment 0 as prototype // 获取0号 segment 里的 HashEntry<K,V> 初始化长度 int cap = proto.table.length; // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的 float lf = proto.loadFactor; // 计算扩容阀值 int threshold = (int)(cap * lf); // 创建一个 cap 容量的 HashEntry 数组 HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap]; if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // recheck // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作 Segment<K,V> s = new Segment<K,V>(lf, threshold, tab); // 自旋检查 u 位置的 Segment 是否为null while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) { // 使用CAS 赋值，只会成功一次 if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) break; } } } return seg; } \",\"上面的源码分析了 ConcurrentHashMap 在 put 一个数据时的处理流程，下面梳理下具体流程。\",\"计算要 put 的 key 的位置，获取指定位置的 Segment。\",\"如果指定位置的 Segment 为空，则初始化这个 Segment.\",\"初始化 Segment 流程：\",\"检查计算得到的位置的 Segment 是否为 null.\",\"为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。\",\"再次检查计算得到的指定位置的 Segment 是否为 null.\",\"使用创建的 HashEntry 数组初始化这个 Segment.\",\"自旋判断计算得到的指定位置的 Segment 是否为 null，使用 CAS 在这个位置赋值为 Segment.\",\"Segment.put 插入 key,value 值。\",\"上面探究了获取 Segment 段和初始化 Segment 段的操作。最后一行的 Segment 的 put 方法还没有查看，继续分析。\",\"final V put(K key, int hash, V value, boolean onlyIfAbsent) { // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。 HashEntry<K,V> node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try { HashEntry<K,V>[] tab = table; // 计算要put的数据位置 int index = (tab.length - 1) & hash; // CAS 获取 index 坐标的值 HashEntry<K,V> first = entryAt(tab, index); for (HashEntry<K,V> e = first;;) { if (e != null) { // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value K k; if ((k = e.key) == key || (e.hash == hash && key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。 if (node != null) node.setNext(first); else node = new HashEntry<K,V>(hash, key, value, first); int c = count + 1; // 容量大于扩容阀值，小于最大容量，进行扩容 if (c > threshold && tab.length < MAXIMUM_CAPACITY) rehash(node); else // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; } \",\"由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能。\",\"tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。\",\"计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 。\",\"遍历 put 新元素，为什么要遍历？因为这里获取的 HashEntry 可能是一个空元素，也可能是链表已存在，所以要区别对待。\",\"如果这个位置上的 HashEntry 不存在：\",\"如果当前容量大于扩容阀值，小于最大容量，进行扩容。\",\"直接头插法插入。\",\"如果这个位置上的 HashEntry 存在：\",\"判断链表当前元素 key 和 hash 值是否和要 put 的 key 和 hash 值一致。一致则替换值\",\"不一致，获取链表下一个节点，直到发现相同进行值替换，或者链表表里完毕没有相同的。 \",\"如果当前容量大于扩容阀值，小于最大容量，进行扩容。\",\"直接链表头插法插入。\",\"如果要插入的位置之前已经存在，替换后返回旧值，否则返回 null.\",\"这里面的第一步中的 scanAndLockForPut 操作这里没有介绍，这个方法做的操作就是不断的自旋 tryLock() 获取锁。当自旋次数大于指定次数时，使用 lock() 阻塞获取锁。在自旋时顺表获取下 hash 位置的 HashEntry。\",\"private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) { HashEntry<K,V> first = entryForHash(this, hash); HashEntry<K,V> e = first; HashEntry<K,V> node = null; int retries = -1; // negative while locating node // 自旋获取锁 while (!tryLock()) { HashEntry<K,V> f; // to recheck first below if (retries < 0) { if (e == null) { if (node == null) // speculatively create node node = new HashEntry<K,V>(hash, key, value, null); retries = 0; } else if (key.equals(e.key)) retries = 0; else e = e.next; } else if (++retries > MAX_SCAN_RETRIES) { // 自旋达到指定次数后，阻塞等到只到获取到锁 lock(); break; } else if ((retries & 1) == 0 && (f = entryForHash(this, hash)) != first) { e = first = f; // re-traverse if entry changed retries = -1; } } return node; } \"]},\"572\":{\"h\":\"4. 扩容 rehash\",\"t\":[\"ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表头插法插入到指定位置。\",\"private void rehash(HashEntry<K,V> node) { HashEntry<K,V>[] oldTable = table; // 老容量 int oldCapacity = oldTable.length; // 新容量，扩大两倍 int newCapacity = oldCapacity << 1; // 新的扩容阀值 threshold = (int)(newCapacity * loadFactor); // 创建新的数组 HashEntry<K,V>[] newTable = (HashEntry<K,V>[]) new HashEntry[newCapacity]; // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。 int sizeMask = newCapacity - 1; for (int i = 0; i < oldCapacity ; i++) { // 遍历老数组 HashEntry<K,V> e = oldTable[i]; if (e != null) { HashEntry<K,V> next = e.next; // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。 int idx = e.hash & sizeMask; if (next == null) // Single node on list // 如果当前位置还不是链表，只是一个元素，直接赋值 newTable[idx] = e; else { // Reuse consecutive sequence at same slot // 如果是链表了 HashEntry<K,V> lastRun = e; int lastIdx = idx; // 新的位置只可能是不便或者是老的位置+老的容量。 // 遍历结束后，lastRun 后面的元素位置都是相同的 for (HashEntry<K,V> last = next; last != null; last = last.next) { int k = last.hash & sizeMask; if (k != lastIdx) { lastIdx = k; lastRun = last; } } // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。 newTable[lastIdx] = lastRun; // Clone remaining nodes for (HashEntry<K,V> p = e; p != lastRun; p = p.next) { // 遍历剩余元素，头插法到指定 k 位置。 V v = p.value; int h = p.hash; int k = h & sizeMask; HashEntry<K,V> n = newTable[k]; newTable[k] = new HashEntry<K,V>(h, p.key, v, n); } } } } // 头插法插入新的节点 int nodeIndex = node.hash & sizeMask; // add the new node node.setNext(newTable[nodeIndex]); newTable[nodeIndex] = node; table = newTable; } \",\"有些同学可能会对最后的两个 for 循环有疑惑，这里第一个 for 是为了寻找这样一个节点，这个节点后面的所有 next 节点的新位置都是相同的。然后把这个作为一个链表赋值到新位置。第二个 for 循环是为了把剩余的元素通过头插法插入到指定位置链表。这样实现的原因可能是基于概率统计，有深入研究的同学可以发表下意见。\"]},\"573\":{\"h\":\"5. get\",\"t\":[\"到这里就很简单了，get 方法只需要两步即可。\",\"计算得到 key 的存放位置。\",\"遍历指定位置查找相同 key 的 value 值。\",\"public V get(Object key) { Segment<K,V> s; // manually integrate access methods to reduce overhead HashEntry<K,V>[] tab; int h = hash(key); long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE; // 计算得到 key 的存放位置 if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null && (tab = s.table) != null) { for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE); e != null; e = e.next) { // 如果是链表，遍历查找到相同 key 的 value。 K k; if ((k = e.key) == key || (e.hash == h && key.equals(k))) return e.value; } } return null; } \"]},\"574\":{\"h\":\"2. ConcurrentHashMap 1.8\"},\"575\":{\"h\":\"1. 存储结构\",\"t\":[\"Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）\",\"可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。当冲突链表达到一定长度时，链表会转换成红黑树。\"]},\"576\":{\"h\":\"2. 初始化 initTable\",\"t\":[\"/** * Initializes table, using the size recorded in sizeCtl. */ private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 如果 sizeCtl < 0 ,说明另外的线程执行CAS 成功，正在进行初始化。 if ((sc = sizeCtl) < 0) // 让出 CPU 使用权 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if ((tab = table) == null || tab.length == 0) { int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; table = tab = nt; sc = n - (n >>> 2); } } finally { sizeCtl = sc; } break; } } return tab; } \",\"从源码中可以发现 ConcurrentHashMap 的初始化是通过自旋和 CAS 操作完成的。里面需要注意的是变量 sizeCtl ，它的值决定着当前的初始化状态。\",\"-1 说明正在初始化\",\"-N 说明有 N-1 个线程正在进行扩容\",\"0 表示 table 初始化大小，如果 table 没有初始化\",\">0 表示 table 扩容的阈值，如果 table 已经初始化。\"]},\"577\":{\"h\":\"3. put\",\"t\":[\"直接过一遍 put 源码。\",\"public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { // key 和 value 不能为空 if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { // f = 目标位置元素 Node<K,V> f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值 if (tab == null || (n = tab.length) == 0) // 数组桶为空，初始化数组桶（自旋+CAS) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出 if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 使用 synchronized 加锁加入节点 synchronized (f) { if (tabAt(tab, i) == f) { // 说明是链表 if (fh >= 0) { binCount = 1; // 循环加入新的或者覆盖节点 for (Node<K,V> e = f;; ++binCount) { K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; if ((e = e.next) == null) { pred.next = new Node<K,V>(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { // 红黑树 Node<K,V> p; binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); return null; } \",\"根据 key 计算出 hashcode 。\",\"判断是否需要进行初始化。\",\"即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。\",\"如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。\",\"如果都不满足，则利用 synchronized 锁写入数据。\",\"如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度 ≥64 时才会将链表转换为红黑树。\"]},\"578\":{\"h\":\"4. get\",\"t\":[\"get 流程比较简单，直接过一遍源码。\",\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // key 所在的 hash 位置 int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 如果指定位置元素存在，头结点hash值相同 if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) // key hash 值相等，key值相同，直接返回元素 value return e.val; } else if (eh < 0) // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) { // 是链表，遍历查找 if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; } \",\"总结一下 get 过程：\",\"根据 hash 值计算位置。\",\"查找到指定位置，如果头节点就是要找的，直接返回它的 value.\",\"如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。\",\"如果是链表，遍历查找之。\",\"总结：\",\"总的来说 ConcurrentHashMap 在 Java8 中相对于 Java7 来说变化还是挺大的，\"]},\"579\":{\"h\":\"3. 总结\",\"t\":[\"Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。\",\"Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。\",\"有些同学可能对 Synchronized 的性能存在疑问，其实 Synchronized 锁自从引入锁升级策略后，性能不再是问题，有兴趣的同学可以自己了解下 Synchronized 的锁升级。\",\"File not found\"]},\"580\":{\"c\":[\"Java\"]},\"581\":{\"c\":[\"Java集合\"]},\"582\":{\"h\":\"CopyOnWriteArrayList 源码分析\"},\"583\":{\"h\":\"CopyOnWriteArrayList 简介\",\"t\":[\"在 JDK1.5 之前，如果想要使用并发安全的 List 只能选择 Vector。而 Vector 是一种老旧的集合，已经被淘汰。Vector 对于增删改查等方法基本都加了 synchronized，这种方式虽然能够保证同步，但这相当于对整个 Vector 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。\",\"JDK1.5 引入了 Java.util.concurrent（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 List 实现就是 CopyOnWriteArrayList 。关于java.util.concurrent 包下常见并发容器的总结，可以看我写的这篇文章：Java 常见并发容器总结 。\"]},\"584\":{\"h\":\"CopyOnWriteArrayList 到底有什么厉害之处？\",\"t\":[\"对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 List 的内部数据，毕竟对于读取操作来说是安全的。\",\"这种思路与 ReentrantReadWriteLock 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。CopyOnWriteArrayList 更进一步地实现了这一思想。为了将读操作性能发挥到极致，CopyOnWriteArrayList 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。\",\"CopyOnWriteArrayList 线程安全的核心在于其采用了 写时复制（Copy-On-Write） 的策略，从 CopyOnWriteArrayList 的名字就能看出了。\"]},\"585\":{\"h\":\"Copy-On-Write 的思想是什么？\",\"t\":[\"CopyOnWriteArrayList名字中的“Copy-On-Write”即写时复制，简称 COW。\",\"下面是维基百科对 Copy-On-Write 的介绍，介绍的挺不错：\",\"写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。\",\"这里再以 CopyOnWriteArrayList为例介绍：当需要修改（ add，set、remove 等操作） CopyOnWriteArrayList 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。\",\"可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。\",\"不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：\",\"内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。\",\"写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。\",\"数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。\",\"……\"]},\"586\":{\"h\":\"CopyOnWriteArrayList 源码分析\",\"t\":[\"这里以 JDK1.8 为例，分析一下 CopyOnWriteArrayList 的底层核心源码。\",\"CopyOnWriteArrayList 的类定义如下：\",\"public class CopyOnWriteArrayList<E> extends Object implements List<E>, RandomAccess, Cloneable, Serializable { //... } \",\"CopyOnWriteArrayList 实现了以下接口：\",\"List : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\",\"RandomAccess ：这是一个标志接口，表明实现这个接口的 List 集合是支持 快速随机访问 的。\",\"Cloneable ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\",\"Serializable : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\",\"CopyOnWriteArrayList 类图\"]},\"587\":{\"h\":\"初始化\",\"t\":[\"CopyOnWriteArrayList 中有一个无参构造函数和两个有参构造函数。\",\"// 创建一个空的 CopyOnWriteArrayList public CopyOnWriteArrayList() { setArray(new Object[0]); } // 按照集合的迭代器返回的顺序创建一个包含指定集合元素的 CopyOnWriteArrayList public CopyOnWriteArrayList(Collection<? extends E> c) { Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList<?>)c).getArray(); else { elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); } setArray(elements); } // 创建一个包含指定数组的副本的列表 public CopyOnWriteArrayList(E[] toCopyIn) { setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } \"]},\"588\":{\"h\":\"插入元素\",\"t\":[\"CopyOnWriteArrayList 的 add()方法有三个版本：\",\"add(E e)：在 CopyOnWriteArrayList 的尾部插入元素。\",\"add(int index, E element)：在 CopyOnWriteArrayList 的指定位置插入元素。\",\"addIfAbsent(E e)：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。\",\"这里以add(E e)为例进行介绍：\",\"// 插入元素到 CopyOnWriteArrayList 的尾部 public boolean add(E e) { final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try { // 获取原来的数组 Object[] elements = getArray(); // 原来数组的长度 int len = elements.length; // 创建一个长度+1的新数组，并将原来数组的元素复制给新数组 Object[] newElements = Arrays.copyOf(elements, len + 1); // 元素放在新数组末尾 newElements[len] = e; // array指向新数组 setArray(newElements); return true; } finally { // 解锁 lock.unlock(); } } \",\"从上面的源码可以看出：\",\"add方法内部用到了 ReentrantLock 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 finally 中，可以保证锁能被释放。\",\"CopyOnWriteArrayList 通过复制底层数组的方式实现写操作，即先创建一个新的数组来容纳新添加的元素，然后在新数组中进行写操作，最后将新数组赋值给底层数组的引用，替换掉旧的数组。这也就证明了我们前面说的：CopyOnWriteArrayList 线程安全的核心在于其采用了 写时复制（Copy-On-Write） 的策略。\",\"每次写操作都需要通过 Arrays.copyOf 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，CopyOnWriteArrayList 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。\",\"CopyOnWriteArrayList 中并没有类似于 ArrayList 的 grow() 方法扩容的操作。\",\"Arrays.copyOf 方法的时间复杂度是 O(n)，其中 n 表示需要复制的数组长度。因为这个方法的实现原理是先创建一个新的数组，然后将源数组中的数据复制到新数组中，最后返回新数组。这个方法会复制整个数组，因此其时间复杂度与数组长度成正比，即 O(n)。值得注意的是，由于底层调用了系统级别的拷贝指令，因此在实际应用中这个方法的性能表现比较优秀，但是也需要注意控制复制的数据量，避免出现内存占用过高的情况。\"]},\"589\":{\"h\":\"读取元素\",\"t\":[\"CopyOnWriteArrayList 的读取操作是基于内部数组 array 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。\",\"// 底层数组，只能通过getArray和setArray方法访问 private transient volatile Object[] array; public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } private E get(Object[] a, int index) { return (E) a[index]; } \",\"不过，get方法是弱一致性的，在某些情况下可能读到旧的元素值。\",\"get(int index)方法是分两步进行的：\",\"通过getArray()获取当前数组的引用；\",\"直接从数组中获取下标为 index 的元素。\",\"这个过程并没有加锁，所以在并发环境下可能出现如下情况：\",\"线程 1 调用get(int index)方法获取值，内部通过getArray()方法获取到了 array 属性值；\",\"线程 2 调用CopyOnWriteArrayList的add、set、remove 等修改方法时，内部通过setArray方法修改了array属性的值；\",\"线程 1 还是从旧的 array 数组中取值。\"]},\"590\":{\"h\":\"获取列表中元素的个数\",\"t\":[\"public int size() { return getArray().length; } \",\"CopyOnWriteArrayList中的array数组每次复制都刚好能够容纳下所有元素，并不像ArrayList那样会预留一定的空间。因此，CopyOnWriteArrayList中并没有size属性CopyOnWriteArrayList的底层数组的长度就是元素个数，因此size()方法只要返回数组长度就可以了。\"]},\"591\":{\"h\":\"删除元素\",\"t\":[\"CopyOnWriteArrayList删除元素相关的方法一共有 4 个：\",\"remove(int index)：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。\",\"boolean remove(Object o)：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。\",\"boolean removeAll(Collection<?> c)：从此列表中删除指定集合中包含的所有元素。\",\"void clear()：移除此列表中的所有元素。\",\"这里以remove(int index)为例进行介绍：\",\"public E remove(int index) { // 获取可重入锁 final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try { //获取当前array数组 Object[] elements = getArray(); // 获取当前array长度 int len = elements.length; //获取指定索引的元素(旧值) E oldValue = get(elements, index); int numMoved = len - index - 1; // 判断删除的是否是最后一个元素 if (numMoved == 0) // 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组 setArray(Arrays.copyOf(elements, len - 1)); else { // 分段复制，将index前的元素和index+1后的元素复制到新数组 // 新数组长度为旧数组长度-1 Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); //将新数组赋值给array引用 setArray(newElements); } return oldValue; } finally { // 解锁 lock.unlock(); } } \"]},\"592\":{\"h\":\"判断元素是否存在\",\"t\":[\"CopyOnWriteArrayList提供了两个用于判断指定元素是否在列表中的方法：\",\"contains(Object o)：判断是否包含指定元素。\",\"containsAll(Collection<?> c)：判断是否保证指定集合的全部元素。\",\"// 判断是否包含指定元素 public boolean contains(Object o) { //获取当前array数组 Object[] elements = getArray(); //调用index尝试查找指定元素，如果返回值大于等于0，则返回true，否则返回false return indexOf(o, elements, 0, elements.length) >= 0; } // 判断是否保证指定集合的全部元素 public boolean containsAll(Collection<?> c) { //获取当前array数组 Object[] elements = getArray(); //获取数组长度 int len = elements.length; //遍历指定集合 for (Object e : c) { //循环调用indexOf方法判断，只要有一个没有包含就直接返回false if (indexOf(e, elements, 0, len) < 0) return false; } //最后表示全部包含或者制定集合为空集合，那么返回true return true; } \"]},\"593\":{\"h\":\"CopyOnWriteArrayList 常用方法测试\",\"t\":[\"代码：\",\"// 创建一个 CopyOnWriteArrayList 对象 CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(); // 向列表中添加元素 list.add(\\\"Java\\\"); list.add(\\\"Python\\\"); list.add(\\\"C++\\\"); System.out.println(\\\"初始列表：\\\" + list); // 使用 get 方法获取指定位置的元素 System.out.println(\\\"列表第二个元素为：\\\" + list.get(1)); // 使用 remove 方法删除指定元素 boolean result = list.remove(\\\"C++\\\"); System.out.println(\\\"删除结果：\\\" + result); System.out.println(\\\"列表删除元素后为：\\\" + list); // 使用 set 方法更新指定位置的元素 list.set(1, \\\"Golang\\\"); System.out.println(\\\"列表更新后为：\\\" + list); // 使用 add 方法在指定位置插入元素 list.add(0, \\\"PHP\\\"); System.out.println(\\\"列表插入元素后为：\\\" + list); // 使用 size 方法获取列表大小 System.out.println(\\\"列表大小为：\\\" + list.size()); // 使用 removeAll 方法删除指定集合中所有出现的元素 result = list.removeAll(List.of(\\\"Java\\\", \\\"Golang\\\")); System.out.println(\\\"批量删除结果：\\\" + result); System.out.println(\\\"列表批量删除元素后为：\\\" + list); // 使用 clear 方法清空列表中所有元素 list.clear(); System.out.println(\\\"列表清空后为：\\\" + list); \",\"输出：\",\"列表更新后为：[Java, Golang] 列表插入元素后为：[PHP, Java, Golang] 列表大小为：3 批量删除结果：true 列表批量删除元素后为：[PHP] 列表清空后为：[] \",\"File not found\"]},\"594\":{\"c\":[\"Java\"]},\"595\":{\"c\":[\"Java集合\"]},\"596\":{\"h\":\"DelayQueue 源码分析\"},\"597\":{\"h\":\"DelayQueue 简介\",\"t\":[\"DelayQueue 是 JUC 包(java.util.concurrent)为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 BlockingQueue 的一种，底层是一个基于 PriorityQueue 实现的一个无界队列，是线程安全的。关于PriorityQueue可以参考笔者编写的这篇文章：PriorityQueue 源码分析 。\",\"BlockingQueue 的实现类\",\"DelayQueue 中存放的元素必须实现 Delayed 接口，并且需要重写 getDelay()方法（计算是否到期）。\",\"public interface Delayed extends Comparable<Delayed> { long getDelay(TimeUnit unit); } \",\"默认情况下, DelayQueue 会按照到期时间升序编排任务。只有当元素过期时（getDelay()方法返回值小于等于 0），才能从队列中取出。\"]},\"598\":{\"h\":\"DelayQueue 发展史\",\"t\":[\"DelayQueue 最早是在 Java 5 中引入的，作为 java.util.concurrent 包中的一部分，用于支持基于时间的任务调度和缓存过期删除等场景，该版本仅仅支持延迟功能的实现，还未解决线程安全问题。\",\"在 Java 6 中，DelayQueue 的实现进行了优化，通过使用 ReentrantLock 和 Condition 解决线程安全及线程间交互的效率，提高了其性能和可靠性。\",\"在 Java 7 中，DelayQueue 的实现进行了进一步的优化，通过使用 CAS 操作实现元素的添加和移除操作，提高了其并发操作性能。\",\"在 Java 8 中，DelayQueue 的实现没有进行重大变化，但是在 java.time 包中引入了新的时间类，如 Duration 和 Instant，使得使用 DelayQueue 进行基于时间的调度更加方便和灵活。\",\"在 Java 9 中，DelayQueue 的实现进行了一些微小的改进，主要是对代码进行了一些优化和精简。\",\"总的来说，DelayQueue 的发展史主要是通过优化其实现方式和提高其性能和可靠性，使其更加适用于基于时间的调度和缓存过期删除等场景。\"]},\"599\":{\"h\":\"DelayQueue 常见使用场景示例\",\"t\":[\"我们这里希望任务可以按照我们预期的时间执行，例如提交 3 个任务，分别要求 1s、2s、3s 后执行，即使是乱序添加，1s 后要求 1s 执行的任务会准时执行。\",\"延迟任务\",\"对此我们可以使用 DelayQueue 来实现,所以我们首先需要继承 Delayed 实现 DelayedTask，实现 getDelay 方法以及优先级比较 compareTo。\",\"/** * 延迟任务 */ public class DelayedTask implements Delayed { /** * 任务到期时间 */ private long executeTime; /** * 任务 */ private Runnable task; public DelayedTask(long delay, Runnable task) { this.executeTime = System.currentTimeMillis() + delay; this.task = task; } /** * 查看当前任务还有多久到期 * @param unit * @return */ @Override public long getDelay(TimeUnit unit) { return unit.convert(executeTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS); } /** * 延迟队列需要到期时间升序入队，所以我们需要实现compareTo进行到期时间比较 * @param o * @return */ @Override public int compareTo(Delayed o) { return Long.compare(this.executeTime, ((DelayedTask) o).executeTime); } public void execute() { task.run(); } } \",\"完成任务的封装之后，使用就很简单了，设置好多久到期然后将任务提交到延迟队列中即可。\",\"// 创建延迟队列，并添加任务 DelayQueue < DelayedTask > delayQueue = new DelayQueue < > (); //分别添加1s、2s、3s到期的任务 delayQueue.add(new DelayedTask(2000, () -> System.out.println(\\\"Task 2\\\"))); delayQueue.add(new DelayedTask(1000, () -> System.out.println(\\\"Task 1\\\"))); delayQueue.add(new DelayedTask(3000, () -> System.out.println(\\\"Task 3\\\"))); // 取出任务并执行 while (!delayQueue.isEmpty()) { //阻塞获取最先到期的任务 DelayedTask task = delayQueue.take(); if (task != null) { task.execute(); } } \",\"从输出结果可以看出，即使笔者先提到 2s 到期的任务，1s 到期的任务 Task1 还是优先执行的。\",\"Task 1 Task 2 Task 3 \"]},\"600\":{\"h\":\"DelayQueue 源码解析\",\"t\":[\"这里以 JDK1.8 为例，分析一下 DelayQueue 的底层核心源码。\",\"DelayQueue 的类定义如下：\",\"public class DelayQueue<E extends Delayed> extends AbstractQueue<E> implements BlockingQueue<E> { //... } \",\"DelayQueue 继承了 AbstractQueue 类，实现了 BlockingQueue 接口。\",\"DelayQueue类图\"]},\"601\":{\"h\":\"核心成员变量\",\"t\":[\"DelayQueue 的 4 个核心成员变量如下：\",\"//可重入锁，实现线程安全的关键 private final transient ReentrantLock lock = new ReentrantLock(); //延迟队列底层存储数据的集合,确保元素按照到期时间升序排列 private final PriorityQueue<E> q = new PriorityQueue<E>(); //指向准备执行优先级最高的线程 private Thread leader = null; //实现多线程之间等待唤醒的交互 private final Condition available = lock.newCondition(); \",\"lock : 我们都知道 DelayQueue 存取是线程安全的，所以为了保证存取元素时线程安全，我们就需要在存取时上锁，而 DelayQueue 就是基于 ReentrantLock 独占锁确保存取操作的线程安全。\",\"q : 延迟队列要求元素按照到期时间进行升序排列，所以元素添加时势必需要进行优先级排序,所以 DelayQueue 底层元素的存取都是通过这个优先队列 PriorityQueue 的成员变量 q 来管理的。\",\"leader : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,设计者就用 leader 来管理延迟任务，只有 leader 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 leader 线程执行完手头的延迟任务后唤醒它。\",\"available : 上文讲述 leader 线程时提到的等待唤醒操作的交互就是通过 available 实现的，假如线程 1 尝试在空的 DelayQueue 获取任务时，available 就会将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 available 的 signal 方法将其唤醒。\"]},\"602\":{\"h\":\"构造方法\",\"t\":[\"相较于其他的并发容器，延迟队列的构造方法比较简单，它只有两个构造方法，因为所有成员变量在类加载时都已经初始完成了，所以默认构造方法什么也没做。还有一个传入 Collection 对象的构造方法，它会将调用 addAll()方法将集合元素存到优先队列 q 中。\",\"public DelayQueue() {} public DelayQueue(Collection<? extends E> c) { this.addAll(c); } \"]},\"603\":{\"h\":\"添加元素\",\"t\":[\"DelayQueue 添加元素的方法无论是 add、put 还是 offer,本质上就是调用一下 offer ,所以了解延迟队列的添加逻辑我们只需阅读 offer 方法即可。\",\"offer 方法的整体逻辑为:\",\"尝试获取 lock 。\",\"如果上锁成功,则调 q 的 offer 方法将元素存放到优先队列中。\",\"调用 peek 方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)，于是将 leader 设置为空,通知因为队列为空时调用 take 等方法导致阻塞的线程来争抢元素。\",\"上述步骤执行完成，释放 lock。\",\"返回 true。\",\"源码如下，笔者已详细注释，读者可自行参阅:\",\"public boolean offer(E e) { //尝试获取lock final ReentrantLock lock = this.lock; lock.lock(); try { //如果上锁成功,则调q的offer方法将元素存放到优先队列中 q.offer(e); //调用peek方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素) if (q.peek() == e) { //将leader设置为空,通知调用取元素方法而阻塞的线程来争抢这个任务 leader = null; available.signal(); } return true; } finally { //上述步骤执行完成，释放lock lock.unlock(); } } \"]},\"604\":{\"h\":\"获取元素\",\"t\":[\"DelayQueue 中获取元素的方式分为阻塞式和非阻塞式，先来看看逻辑比较复杂的阻塞式获取元素方法 take,为了让读者可以更直观的了解阻塞式获取元素的全流程，笔者将以 3 个线程并发获取元素为例讲述 take 的工作流程。\",\"想要理解下面的内容，需要用到 AQS 相关的知识，推荐阅读下面这两篇文章：\",\"图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)\",\"AQS 都看完了，Condition 原理可不能少！\",\"1、首先， 3 个线程会尝试获取可重入锁 lock,假设我们现在有 3 个线程分别是 t1、t2、t3,随后 t1 得到了锁，而 t2、t3 没有抢到锁，故将这两个线程存入等待队列中。\",\"2、紧接着 t1 开始进行元素获取的逻辑。\",\"3、线程 t1 首先会查看 DelayQueue 队列首元素是否为空。\",\"4、如果元素为空，则说明当前队列没有任何元素，故 t1 就会被阻塞存到 conditionWaiter 这个队列中。\",\"注意，调用 await 之后 t1 就会释放 lcok 锁，假如 DelayQueue 持续为空，那么 t2、t3 也会像 t1 一样执行相同的逻辑并进入 conditionWaiter 队列中。\",\"如果元素不为空，则判断当前任务是否到期，如果元素到期，则直接返回出去。如果元素未到期，则判断当前 leader 线程(DelayQueue 中唯一一个可以等待并获取元素的线程引用)是否为空，若不为空，则说明当前 leader 正在等待执行一个优先级比当前元素还高的元素到期，故当前线程 t1 只能调用 await 进入无限期等待，等到 leader 取得元素后唤醒。反之，若 leader 线程为空，则将当前线程设置为 leader 并进入有限期等待,到期后取出元素并返回。\",\"自此我们阻塞式获取元素的逻辑都已完成后,源码如下，读者可自行参阅:\",\"public E take() throws InterruptedException { // 尝试获取可重入锁,将底层AQS的state设置为1,并设置为独占锁 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { //查看队列第一个元素 E first = q.peek(); //若为空,则将当前线程放入ConditionObject的等待队列中，并将底层AQS的state设置为0，表示释放锁并进入无限期等待 if (first == null) available.await(); else { //若元素不为空，则查看当前元素多久到期 long delay = first.getDelay(NANOSECONDS); //如果小于0则说明已到期直接返回出去 if (delay <= 0) return q.poll(); //如果大于0则说明任务还没到期，首先需要释放对这个元素的引用 first = null; // don't retain ref while waiting //判断leader是否为空，如果不为空，则说明正有线程作为leader并等待一个任务到期，则当前线程进入无限期等待 if (leader != null) available.await(); else { //反之将我们的线程成为leader Thread thisThread = Thread.currentThread(); leader = thisThread; try { //并进入有限期等待 available.awaitNanos(delay); } finally { //等待任务到期时，释放leader引用，进入下一次循环将任务return出去 if (leader == thisThread) leader = null; } } } } } finally { //收尾逻辑:如果leader不为空且q有元素，则说明有任务没人认领，直接发起通知唤醒因为锁被当前消费者持有而导致阻塞的生产者(即调用put、add、offer的线程) if (leader == null && q.peek() != null) available.signal(); //释放锁 lock.unlock(); } } \",\"我们再来看看非阻塞的获取元素方法 poll ，逻辑比较简单，整体步骤如下:\",\"尝试获取可重入锁。\",\"查看队列第一个元素,判断元素是否为空。\",\"若元素为空，或者元素未到期，则直接返回空。\",\"若元素不为空且到期了，直接调用 poll 返回出去。\",\"释放可重入锁 lock 。\",\"源码如下,读者可自行参阅源码及注释:\",\"public E poll() { //尝试获取可重入锁 final ReentrantLock lock = this.lock; lock.lock(); try { //查看队列第一个元素,判断元素是否为空 E first = q.peek(); //若元素为空，或者元素未到期，则直接返回空 if (first == null || first.getDelay(NANOSECONDS) > 0) return null; else //若元素不为空且到期了，直接调用poll返回出去 return q.poll(); } finally { //释放可重入锁lock lock.unlock(); } } \"]},\"605\":{\"h\":\"查看元素\",\"t\":[\"上文获取元素时都会调用到 peek 方法，peek 顾名思义仅仅窥探一下队列中的元素，它的步骤就 4 步:\",\"上锁。\",\"调用优先队列 q 的 peek 方法查看索引 0 位置的元素。\",\"释放锁。\",\"将元素返回出去。\",\"public E peek() { final ReentrantLock lock = this.lock; lock.lock(); try { return q.peek(); } finally { lock.unlock(); } } \"]},\"606\":{\"h\":\"DelayQueue 常见面试题\"},\"607\":{\"h\":\"DelayQueue 的实现原理是什么？\",\"t\":[\"DelayQueue 底层是使用优先队列 PriorityQueue 来存储元素，而 PriorityQueue 采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得 DelayQueue 对于延迟任务优先级的管理就变得十分方便了。同时 DelayQueue 为了保证线程安全还用到了可重入锁 ReentrantLock,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，DelayQueue 还用到了 Condition，通过 Condition 的 await 和 signal 方法完成多线程之间的等待唤醒。\"]},\"608\":{\"h\":\"DelayQueue 的实现是否线程安全？\",\"t\":[\"DelayQueue 的实现是线程安全的，它通过 ReentrantLock 实现了互斥访问和 Condition 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。\"]},\"609\":{\"h\":\"DelayQueue 的使用场景有哪些？\",\"t\":[\"DelayQueue 通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 DelayQueue 中，DelayQueue 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的 key 封装成一个延迟的删除任务，并将其添加到 DelayQueue 中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。\"]},\"610\":{\"h\":\"DelayQueue 中 Delayed 接口的作用是什么？\",\"t\":[\"Delayed 接口定义了元素的剩余延迟时间(getDelay)和元素之间的比较规则(该接口继承了 Comparable 接口)。若希望元素能够存放到 DelayQueue 中，就必须实现 Delayed 接口的 getDelay() 方法和 compareTo() 方法，否则 DelayQueue 无法得知当前任务剩余时长和任务优先级的比较。\"]},\"611\":{\"h\":\"DelayQueue 和 Timer/TimerTask 的区别是什么？\",\"t\":[\"DelayQueue 和 Timer/TimerTask 都可以用于实现定时任务调度，但是它们的实现方式不同。DelayQueue 是基于优先级队列和堆排序算法实现的，可以实现多个任务按照时间先后顺序执行；而 Timer/TimerTask 是基于单线程实现的，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。另外，DelayQueue 还支持动态添加和移除任务，而 Timer/TimerTask 只能在创建时指定任务。\"]},\"612\":{\"h\":\"参考文献\",\"t\":[\"《深入理解高并发编程：JDK 核心技术》:\",\"一口气说出 Java 6 种延时队列的实现方法(面试官也得服):https://www.jb51.net/article/186192.htm\",\"图解 DelayQueue 源码（java 8）——延时队列的小九九: https://blog.csdn.net/every__day/article/details/113810985\",\"File not found\"]},\"613\":{\"c\":[\"Java\"]},\"614\":{\"c\":[\"Java集合\"]},\"615\":{\"h\":\"HashMap 源码分析\",\"t\":[\"File not found\",\"感谢 changfubai 对本文的改进做出的贡献！\"]},\"616\":{\"h\":\"HashMap 简介\",\"t\":[\"HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。\",\"HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个\",\"JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小。\"]},\"617\":{\"h\":\"底层数据结构分析\"},\"618\":{\"h\":\"JDK1.8 之前\",\"t\":[\"JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。\",\"HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\",\"所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\",\"JDK 1.8 HashMap 的 hash 方法源码:\",\"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\",\" static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"对比一下 JDK1.7 的 HashMap 的 hash 方法源码.\",\"static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } \",\"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\",\"所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\",\"jdk1.8 之前的内部结构-HashMap\"]},\"619\":{\"h\":\"JDK1.8 之后\",\"t\":[\"相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。\",\"当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。相关源码这里就不贴了，重点关注 treeifyBin()方法即可！\",\"jdk1.8之后的内部结构-HashMap\",\"类的属性：\",\"public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable { // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 << 30; // 默认的负载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于等于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于等于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小容量 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node<k,v>[] table; // 存放具体元素的集 transient Set<map.entry<k,v>> entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容 int threshold; // 负载因子 final float loadFactor; } \",\"loadFactor 负载因子\",\"loadFactor 负载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\",\"loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。\",\"给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。\",\"threshold\",\"threshold = capacity * loadFactor，当 Size>threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。\",\"Node 节点类源码:\",\"// 继承自 Map.Entry<K,V> static class Node<K,V> implements Map.Entry<K,V> { final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node<K,V> next; Node(int hash, K key, V value, Node<K,V> next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \\\"=\\\" + value; } // 重写hashCode()方法 public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 重写 equals() 方法 public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry<?,?> e = (Map.Entry<?,?>)o; if (Objects.equals(key, e.getKey()) && Objects.equals(value, e.getValue())) return true; } return false; } } \",\"树节点类源码:\",\"static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> { TreeNode<K,V> parent; // 父 TreeNode<K,V> left; // 左 TreeNode<K,V> right; // 右 TreeNode<K,V> prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node<K,V> next) { super(hash, key, val, next); } // 返回根节点 final TreeNode<K,V> root() { for (TreeNode<K,V> r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } \"]},\"620\":{\"h\":\"HashMap 源码分析\"},\"621\":{\"h\":\"构造方法\",\"t\":[\"HashMap 中有四个构造方法，它们分别如下：\",\" // 默认构造函数。 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } // 包含另一个“Map”的构造函数 public HashMap(Map<? extends K, ? extends V> m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 指定“容量大小”和“负载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; // 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化 this.threshold = tableSizeFor(initialCapacity); } \",\"值得注意的是上述四个构造方法中，都初始化了负载因子 loadFactor，由于 HashMap 中没有 capacity 这样的字段，即使指定了初始化容量 initialCapacity ，也只是通过 tableSizeFor 将其扩容到与 initialCapacity 最接近的 2 的幂次方大小，然后暂时赋值给 threshold ，后续通过 resize 方法将 threshold 赋值给 newCap 进行 table 的初始化。\",\"putMapEntries 方法：\",\"final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) { int s = m.size(); if (s > 0) { // 判断table是否已经初始化 if (table == null) { // pre-size /* * 未初始化，s为m的实际元素个数，ft=s/loadFactor => s=ft*loadFactor, 跟我们前面提到的 * 阈值=容量*负载因子 是不是很像，是的，ft指的是要添加s个元素所需的最小的容量 */ float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft < (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); /* * 根据构造函数可知，table未初始化，threshold实际上是存放的初始化容量，如果添加s个元素所 * 需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。 * 注意这里不是初始化阈值 */ if (t > threshold) threshold = tableSizeFor(t); } // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s > threshold) resize(); // 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容 for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } \"]},\"622\":{\"h\":\"put 方法\",\"t\":[\"HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。\",\"对 putVal 方法添加元素的分析如下：\",\"如果定位到的数组位置没有元素 就直接插入。\",\"如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。\",\"public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node<K,V>[] tab; Node<K,V> p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素（处理hash冲突） else { Node<K,V> e; K k; //快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; // 判断插入的是否是红黑树节点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 不是红黑树节点则说明为链表结点 else { // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) { // 到达链表的尾部 if ((e = p.next) == null) { // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法 // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。 // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; } // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; } } // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) { // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; } } // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size > threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null; } \",\"我们再来对比一下 JDK1.7 put 方法的代码\",\"对于 put 方法的分析如下：\",\"① 如果定位到的数组位置没有元素 就直接插入。\",\"② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。\",\"public V put(K key, V value) if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry<K,V> e = table[i]; e != null; e = e.next) { // 先遍历 Object k; if (e.hash == hash && ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); // 再插入 return null; } \"]},\"623\":{\"h\":\"get 方法\",\"t\":[\"public V get(Object key) { Node<K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K,V> getNode(int hash, Object key) { Node<K,V>[] tab; Node<K,V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { // 数组元素相等 if (first.hash == hash && // always check first node ((k = first.key) == key || (key != null && key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) { // 在树中get if (first instanceof TreeNode) return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 在链表中get do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \"]},\"624\":{\"h\":\"resize 方法\",\"t\":[\"进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。\",\"final Node<K,V>[] resize() { Node<K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } else if (oldThr > 0) // initial capacity was placed in threshold // 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量 newCap = oldThr; else { // signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { // 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化， // 或者扩容前的旧容量小于16，在这里计算新的resize上限 float ft = (float)newCap * loadFactor; newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\\\"rawtypes\\\",\\\"unchecked\\\"}) Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) // 只有一个节点，直接计算元素新的位置即可 newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) // 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。 // 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。 ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; // 原索引 if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } \"]},\"625\":{\"h\":\"HashMap 常用方法测试\",\"t\":[\"package map; import java.util.Collection; import java.util.HashMap; import java.util.Set; public class HashMapDemo { public static void main(String[] args) { HashMap<String, String> map = new HashMap<String, String>(); // 键不能重复，值可以重复 map.put(\\\"san\\\", \\\"张三\\\"); map.put(\\\"si\\\", \\\"李四\\\"); map.put(\\\"wu\\\", \\\"王五\\\"); map.put(\\\"wang\\\", \\\"老王\\\"); map.put(\\\"wang\\\", \\\"老王2\\\");// 老王被覆盖 map.put(\\\"lao\\\", \\\"老王\\\"); System.out.println(\\\"-------直接输出hashmap:-------\\\"); System.out.println(map); /** * 遍历HashMap */ // 1.获取Map中的所有键 System.out.println(\\\"-------foreach获取Map中所有的键:------\\\"); Set<String> keys = map.keySet(); for (String key : keys) { System.out.print(key+\\\" \\\"); } System.out.println();//换行 // 2.获取Map中所有值 System.out.println(\\\"-------foreach获取Map中所有的值:------\\\"); Collection<String> values = map.values(); for (String value : values) { System.out.print(value+\\\" \\\"); } System.out.println();//换行 // 3.得到key的值的同时得到key所对应的值 System.out.println(\\\"-------得到key的值的同时得到key所对应的值:-------\\\"); Set<String> keys2 = map.keySet(); for (String key : keys2) { System.out.print(key + \\\"：\\\" + map.get(key)+\\\" \\\"); } /** * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。 * 一次是在获取keySet的时候，一次是在遍历所有key的时候。 */ // 当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set<java.util.Map.Entry<String, String>> entrys = map.entrySet(); for (java.util.Map.Entry<String, String> entry : entrys) { System.out.println(entry.getKey() + \\\"--\\\" + entry.getValue()); } /** * HashMap其他常用方法 */ System.out.println(\\\"after map.size()：\\\"+map.size()); System.out.println(\\\"after map.isEmpty()：\\\"+map.isEmpty()); System.out.println(map.remove(\\\"san\\\")); System.out.println(\\\"after map.remove()：\\\"+map); System.out.println(\\\"after map.get(si)：\\\"+map.get(\\\"si\\\")); System.out.println(\\\"after map.containsKey(si)：\\\"+map.containsKey(\\\"si\\\")); System.out.println(\\\"after containsValue(李四)：\\\"+map.containsValue(\\\"李四\\\")); System.out.println(map.replace(\\\"si\\\", \\\"李四2\\\")); System.out.println(\\\"after map.replace(si, 李四2):\\\"+map); } } \",\"File not found\"]},\"626\":{\"c\":[\"Java\"]},\"627\":{\"c\":[\"Java集合\"]},\"628\":{\"h\":\"Java集合使用注意事项总结\",\"t\":[\"这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。\",\"强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。\"]},\"629\":{\"h\":\"集合判空\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size()==0 的方式。\",\"这是因为 isEmpty() 方法的可读性更好，并且时间复杂度为 O(1)。\",\"绝大部分我们使用的集合的 size() 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 java.util.concurrent 包下的某些集合（ConcurrentLinkedQueue、ConcurrentHashMap...）。\",\"下面是 ConcurrentHashMap 的 size() 方法和 isEmpty() 方法的源码。\",\"public int size() { long n = sumCount(); return ((n < 0L) ? 0 : (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i < as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum; } public boolean isEmpty() { return sumCount() <= 0L; // ignore transient negative values } \"]},\"630\":{\"h\":\"集合转 Map\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。\",\"class Person { private String name; private String phoneNumber; // getters and setters } List<Person> bookList = new ArrayList<>(); bookList.add(new Person(\\\"jack\\\",\\\"18163138123\\\")); bookList.add(new Person(\\\"martin\\\",null)); // 空指针异常 bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber)); \",\"下面我们来解释一下原因。\",\"首先，我们来看 java.util.stream.Collectors 类的 toMap() 方法 ，可以看到其内部调用了 Map 接口的 merge() 方法。\",\"public static <T, K, U, M extends Map<K, U>> Collector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper, BinaryOperator<U> mergeFunction, Supplier<M> mapSupplier) { BiConsumer<M, T> accumulator = (map, element) -> map.merge(keyMapper.apply(element), valueMapper.apply(element), mergeFunction); return new CollectorImpl<>(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID); } \",\"Map 接口的 merge() 方法如下，这个方法是接口中的默认实现。\",\"如果你还不了解 Java 8 新特性的话，请看这篇文章：《Java8 新特性总结》 。\",\"default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) { Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) { remove(key); } else { put(key, newValue); } return newValue; } \",\"merge() 方法会先调用 Objects.requireNonNull() 方法判断 value 是否为空。\",\"public static <T> T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } \"]},\"631\":{\"h\":\"集合遍历\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。\",\"通过反编译你会发现 foreach 语法底层其实还是依赖 Iterator 。不过， remove/add 操作直接调用的是集合自己的方法，而不是 Iterator 的 remove/add方法\",\"这就导致 Iterator 莫名其妙地发现自己有元素被 remove/add ，然后，它就会抛出一个 ConcurrentModificationException 来提示用户发生了并发修改异常。这就是单线程状态下产生的 fail-fast 机制。\",\"fail-fast 机制：多个线程对 fail-fast 集合进行修改的时候，可能会抛出ConcurrentModificationException。 即使是单线程下也有可能会出现这种情况，上面已经提到过。\",\"相关阅读：什么是 fail-fast 。\",\"Java8 开始，可以使用 Collection#removeIf()方法删除满足特定条件的元素,如\",\"List<Integer> list = new ArrayList<>(); for (int i = 1; i <= 10; ++i) { list.add(i); } list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */ System.out.println(list); /* [1, 3, 5, 7, 9] */ \",\"除了上面介绍的直接使用 Iterator 进行遍历操作之外，你还可以：\",\"使用普通的 for 循环\",\"使用 fail-safe 的集合类。java.util包下面的所有的集合类都是 fail-fast 的，而java.util.concurrent包下面的所有的类都是 fail-safe 的。\",\"……\"]},\"632\":{\"h\":\"集合去重\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"可以利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains() 进行遍历去重或者判断包含操作。\",\"这里我们以 HashSet 和 ArrayList 为例说明。\",\"// Set 去重代码示例 public static <T> Set<T> removeDuplicateBySet(List<T> data) { if (CollectionUtils.isEmpty(data)) { return new HashSet<>(); } return new HashSet<>(data); } // List 去重代码示例 public static <T> List<T> removeDuplicateByList(List<T> data) { if (CollectionUtils.isEmpty(data)) { return new ArrayList<>(); } List<T> result = new ArrayList<>(data.size()); for (T current : data) { if (!result.contains(current)) { result.add(current); } } return result; } \",\"两者的核心差别在于 contains() 方法的实现。\",\"HashSet 的 contains() 方法底部依赖的 HashMap 的 containsKey() 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。\",\"private transient HashMap<E,Object> map; public boolean contains(Object o) { return map.containsKey(o); } \",\"我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。\",\"ArrayList 的 contains() 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。\",\"public boolean contains(Object o) { return indexOf(o) >= 0; } public int indexOf(Object o) { if (o == null) { for (int i = 0; i < size; i++) if (elementData[i]==null) return i; } else { for (int i = 0; i < size; i++) if (o.equals(elementData[i])) return i; } return -1; } \"]},\"633\":{\"h\":\"集合转数组\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组。\",\"toArray(T[] array) 方法的参数是一个泛型数组，如果 toArray 方法中没有传递任何参数的话返回的是 Object类 型数组。\",\"String [] s= new String[]{ \\\"dog\\\", \\\"lazy\\\", \\\"a\\\", \\\"over\\\", \\\"jumps\\\", \\\"fox\\\", \\\"brown\\\", \\\"quick\\\", \\\"A\\\" }; List<String> list = Arrays.asList(s); Collections.reverse(list); //没有指定类型的话会报错 s=list.toArray(new String[0]); \",\"由于 JVM 优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：https://shipilev.net/blog/2016/arrays-wisdom-ancients/\"]},\"634\":{\"h\":\"数组转集合\",\"t\":[\"《阿里巴巴 Java 开发手册》的描述如下：\",\"使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\",\"我在之前的一个项目中就遇到一个类似的坑。\",\"Arrays.asList()在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 List 集合。\",\"String[] myArray = {\\\"Apple\\\", \\\"Banana\\\", \\\"Orange\\\"}; List<String> myList = Arrays.asList(myArray); //上面两个语句等价于下面一条语句 List<String> myList = Arrays.asList(\\\"Apple\\\",\\\"Banana\\\", \\\"Orange\\\"); \",\"JDK 源码对于这个方法的说明：\",\"/** *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁， * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。 */ public static <T> List<T> asList(T... a) { return new ArrayList<>(a); } \",\"下面我们来总结一下使用注意事项。\",\"1、Arrays.asList()是泛型方法，传递的数组必须是对象数组，而不是基本类型。\",\"int[] myArray = {1, 2, 3}; List myList = Arrays.asList(myArray); System.out.println(myList.size());//1 System.out.println(myList.get(0));//数组地址值 System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException int[] array = (int[]) myList.get(0); System.out.println(array[0]);//1 \",\"当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。\",\"我们使用包装类型数组就可以解决这个问题。\",\"Integer[] myArray = {1, 2, 3}; \",\"2、使用集合的修改方法: add()、remove()、clear()会抛出异常。\",\"List myList = Arrays.asList(1, 2, 3); myList.add(4);//运行时报错：UnsupportedOperationException myList.remove(1);//运行时报错：UnsupportedOperationException myList.clear();//运行时报错：UnsupportedOperationException \",\"Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。\",\"List myList = Arrays.asList(1, 2, 3); System.out.println(myList.getClass());//class java.util.Arrays$ArrayList \",\"下图是 java.util.Arrays$ArrayList 的简易源码，我们可以看到这个类重写的方法有哪些。\",\" private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java.io.Serializable { ... @Override public E get(int index) { ... } @Override public E set(int index, E element) { ... } @Override public int indexOf(Object o) { ... } @Override public boolean contains(Object o) { ... } @Override public void forEach(Consumer<? super E> action) { ... } @Override public void replaceAll(UnaryOperator<E> operator) { ... } @Override public void sort(Comparator<? super E> c) { ... } } \",\"我们再看一下java.util.AbstractList的 add/remove/clear 方法就知道为什么会抛出 UnsupportedOperationException 了。\",\"public E remove(int index) { throw new UnsupportedOperationException(); } public boolean add(E e) { add(size(), e); return true; } public void add(int index, E element) { throw new UnsupportedOperationException(); } public void clear() { removeRange(0, size()); } protected void removeRange(int fromIndex, int toIndex) { ListIterator<E> it = listIterator(fromIndex); for (int i=0, n=toIndex-fromIndex; i<n; i++) { it.next(); it.remove(); } } \",\"那我们如何正确的将数组转换为 ArrayList ?\",\"1、手动实现工具类\",\"//JDK1.5+ static <T> List<T> arrayToList(final T[] array) { final List<T> l = new ArrayList<T>(array.length); for (final T s : array) { l.add(s); } return l; } Integer [] myArray = { 1, 2, 3 }; System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList \",\"2、最简便的方法\",\"List list = new ArrayList<>(Arrays.asList(\\\"a\\\", \\\"b\\\", \\\"c\\\")) \",\"3、使用 Java8 的 Stream(推荐)\",\"Integer [] myArray = { 1, 2, 3 }; List myList = Arrays.stream(myArray).collect(Collectors.toList()); //基本类型也可以实现转换（依赖boxed的装箱操作） int [] myArray2 = { 1, 2, 3 }; List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); \",\"4、使用 Guava\",\"对于不可变集合，你可以使用ImmutableList类及其of()与copyOf()工厂方法：（参数不能为空）\",\"List<String> il = ImmutableList.of(\\\"string\\\", \\\"elements\\\"); // from varargs List<String> il = ImmutableList.copyOf(aStringArray); // from array \",\"对于可变集合，你可以使用Lists类及其newArrayList()工厂方法：\",\"List<String> l1 = Lists.newArrayList(anotherListOrCollection); // from collection List<String> l2 = Lists.newArrayList(aStringArray); // from array List<String> l3 = Lists.newArrayList(\\\"or\\\", \\\"string\\\", \\\"elements\\\"); // from varargs \",\"5、使用 Apache Commons Collections\",\"List<String> list = new ArrayList<String>(); CollectionUtils.addAll(list, str); \",\"6、 使用 Java9 的 List.of()方法\",\"Integer[] array = {1, 2, 3}; List<Integer> list = List.of(array); \",\"File not found\"]},\"635\":{\"c\":[\"Java\"]},\"636\":{\"c\":[\"Java集合\"]},\"637\":{\"h\":\"Java集合常见面试题总结(上)\",\"t\":[\"File not found\"]},\"638\":{\"h\":\"集合概述\"},\"639\":{\"h\":\"Java 集合概览\",\"t\":[\"Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。\",\"Java 集合框架如下图所示：\",\"Java 集合框架概览\",\"注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了AbstractList, NavigableSet等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。\"]},\"640\":{\"h\":\"说说 List, Set, Queue, Map 四者的区别？\",\"t\":[\"List(对付顺序的好帮手): 存储的元素是有序的、可重复的。\",\"Set(注重独一无二的性质): 存储的元素不可重复的。\",\"Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。\",\"Map(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，\\\"x\\\" 代表 key，\\\"y\\\" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\"]},\"641\":{\"h\":\"集合框架底层数据结构总结\",\"t\":[\"先来看一下 Collection 接口下面的集合。\"]},\"642\":{\"h\":\"List\",\"t\":[\"ArrayList：Object[] 数组。详细可以查看：ArrayList 源码分析。\",\"Vector：Object[] 数组。\",\"LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：LinkedList 源码分析。\"]},\"643\":{\"h\":\"Set\",\"t\":[\"HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。\",\"LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。\",\"TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。\"]},\"644\":{\"h\":\"Queue\",\"t\":[\"PriorityQueue: Object[] 数组来实现小顶堆。详细可以查看：PriorityQueue 源码分析。\",\"DelayQueue:PriorityQueue。详细可以查看：DelayQueue 源码分析。\",\"ArrayDeque: 可扩容动态双向数组。\",\"再来看看 Map 接口下面的集合。\"]},\"645\":{\"h\":\"Map\",\"t\":[\"HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：HashMap 源码分析。\",\"LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：LinkedHashMap 源码分析\",\"Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。\",\"TreeMap：红黑树（自平衡的排序二叉树）。\"]},\"646\":{\"h\":\"如何选用集合?\",\"t\":[\"我们主要根据集合的特点来选择合适的集合。比如：\",\"我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。\",\"我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。\"]},\"647\":{\"h\":\"为什么要使用集合？\",\"t\":[\"当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的大小可变、支持泛型、具有内建算法等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。\"]},\"648\":{\"h\":\"List\"},\"649\":{\"h\":\"ArrayList 和 Array（数组）的区别？\",\"t\":[\"ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活：\",\"ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。\",\"ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。\",\"ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。Array 可以直接存储基本类型数据，也可以存储对象。\",\"ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。\",\"ArrayList创建时不需要指定大小，而Array创建时必须指定大小。\",\"下面是二者使用的简单对比：\",\"Array：\",\" // 初始化一个 String 类型的数组 String[] stringArr = new String[]{\\\"hello\\\", \\\"world\\\", \\\"!\\\"}; // 修改数组元素的值 stringArr[0] = \\\"goodbye\\\"; System.out.println(Arrays.toString(stringArr));// [goodbye, world, !] // 删除数组中的元素，需要手动移动后面的元素 for (int i = 0; i < stringArr.length - 1; i++) { stringArr[i] = stringArr[i + 1]; } stringArr[stringArr.length - 1] = null; System.out.println(Arrays.toString(stringArr));// [world, !, null] \",\"ArrayList ：\",\"// 初始化一个 String 类型的 ArrayList ArrayList<String> stringList = new ArrayList<>(Arrays.asList(\\\"hello\\\", \\\"world\\\", \\\"!\\\")); // 添加元素到 ArrayList 中 stringList.add(\\\"goodbye\\\"); System.out.println(stringList);// [hello, world, !, goodbye] // 修改 ArrayList 中的元素 stringList.set(0, \\\"hi\\\"); System.out.println(stringList);// [hi, world, !, goodbye] // 删除 ArrayList 中的元素 stringList.remove(0); System.out.println(stringList); // [world, !, goodbye] \"]},\"650\":{\"h\":\"ArrayList 和 Vector 的区别?（了解即可）\",\"t\":[\"ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 。\",\"Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全。\"]},\"651\":{\"h\":\"Vector 和 Stack 的区别?（了解即可）\",\"t\":[\"Vector 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。\",\"Stack 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。\",\"随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap、CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。\"]},\"652\":{\"h\":\"ArrayList 可以添加 null 值吗？\",\"t\":[\"ArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\",\"示例代码：\",\"ArrayList<String> listOfStrings = new ArrayList<>(); listOfStrings.add(null); listOfStrings.add(\\\"java\\\"); System.out.println(listOfStrings); \",\"输出：\",\"[null, java] \"]},\"653\":{\"h\":\"ArrayList 插入和删除元素的时间复杂度？\",\"t\":[\"对于插入：\",\"头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。\",\"尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。\",\"指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。\",\"对于删除：\",\"头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。\",\"尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。\",\"指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\",\"这里简单列举一个例子：\",\"// ArrayList的底层数组大小为10，此时存储了7个元素 +---+---+---+---+---+---+---+---+---+---+ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | | | +---+---+---+---+---+---+---+---+---+---+ 0 1 2 3 4 5 6 7 8 9 // 在索引为1的位置插入一个元素8，该元素后面的所有元素都要向右移动一位 +---+---+---+---+---+---+---+---+---+---+ | 1 | 8 | 2 | 3 | 4 | 5 | 6 | 7 | | | +---+---+---+---+---+---+---+---+---+---+ 0 1 2 3 4 5 6 7 8 9 // 删除索引为1的位置的元素，该元素后面的所有元素都要向左移动一位 +---+---+---+---+---+---+---+---+---+---+ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | | | +---+---+---+---+---+---+---+---+---+---+ 0 1 2 3 4 5 6 7 8 9 \"]},\"654\":{\"h\":\"LinkedList 插入和删除元素的时间复杂度？\",\"t\":[\"头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\",\"尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\",\"指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\",\"这里简单列举一个例子：假如我们要删除节点 9 的话，需要先遍历链表找到该节点。然后，再执行相应节点指针指向的更改，具体的源码可以参考：LinkedList 源码分析 。\",\"unlink 方法逻辑\"]},\"655\":{\"h\":\"LinkedList 为什么不能实现 RandomAccess 接口？\",\"t\":[\"RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。\"]},\"656\":{\"h\":\"ArrayList 与 LinkedList 区别?\",\"t\":[\"是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\",\"底层数据结构：ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）\",\"插入和删除是否受元素位置的影响：\",\"ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。\",\"LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。\",\"是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。\",\"内存空间占用：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。\",\"我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！就连 LinkedList 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 LinkedList 。\",\"另外，不要下意识地认为 LinkedList 作为链表就最适合元素增删的场景。我在上面也说了，LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。\"]},\"657\":{\"h\":\"补充内容: 双向链表和双向循环链表\",\"t\":[\"双向链表： 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。\",\"双向链表\",\"双向循环链表： 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。\",\"双向循环链表\"]},\"658\":{\"h\":\"补充内容:RandomAccess 接口\",\"t\":[\"public interface RandomAccess { } \",\"查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。\",\"在 binarySearch（) 方法中，它要判断传入的 list 是否 RandomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法\",\" public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) { if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } \",\"ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！\"]},\"659\":{\"h\":\"说一说 ArrayList 的扩容机制吧\",\"t\":[\"详见笔主的这篇文章: ArrayList 扩容机制分析。\"]},\"660\":{\"h\":\"Set\"},\"661\":{\"h\":\"Comparable 和 Comparator 的区别\",\"t\":[\"Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：\",\"Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序\",\"Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序\",\"一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().\"]},\"662\":{\"h\":\"Comparator 定制排序\",\"t\":[\"ArrayList<Integer> arrayList = new ArrayList<Integer>(); arrayList.add(-1); arrayList.add(3); arrayList.add(3); arrayList.add(-5); arrayList.add(7); arrayList.add(4); arrayList.add(-9); arrayList.add(-7); System.out.println(\\\"原始数组:\\\"); System.out.println(arrayList); // void reverse(List list)：反转 Collections.reverse(arrayList); System.out.println(\\\"Collections.reverse(arrayList):\\\"); System.out.println(arrayList); // void sort(List list),按自然排序的升序排序 Collections.sort(arrayList); System.out.println(\\\"Collections.sort(arrayList):\\\"); System.out.println(arrayList); // 定制排序的用法 Collections.sort(arrayList, new Comparator<Integer>() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); System.out.println(\\\"定制排序后：\\\"); System.out.println(arrayList); \",\"Output:\",\"原始数组: [-1, 3, 3, -5, 7, 4, -9, -7] Collections.reverse(arrayList): [-7, -9, 4, 7, -5, 3, 3, -1] Collections.sort(arrayList): [-9, -7, -5, -1, 3, 3, 4, 7] 定制排序后： [7, 4, 3, 3, -1, -5, -7, -9] \"]},\"663\":{\"h\":\"重写 compareTo 方法实现按年龄来排序\",\"t\":[\"// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列 // 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他 // 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了 public class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } /** * T重写compareTo方法实现按年龄来排序 */ @Override public int compareTo(Person o) { if (this.age > o.getAge()) { return 1; } if (this.age < o.getAge()) { return -1; } return 0; } } \",\" public static void main(String[] args) { TreeMap<Person, String> pdata = new TreeMap<Person, String>(); pdata.put(new Person(\\\"张三\\\", 30), \\\"zhangsan\\\"); pdata.put(new Person(\\\"李四\\\", 20), \\\"lisi\\\"); pdata.put(new Person(\\\"王五\\\", 10), \\\"wangwu\\\"); pdata.put(new Person(\\\"小红\\\", 5), \\\"xiaohong\\\"); // 得到key的值的同时得到key所对应的值 Set<Person> keys = pdata.keySet(); for (Person key : keys) { System.out.println(key.getAge() + \\\"-\\\" + key.getName()); } } \",\"Output：\",\"5-小红 10-王五 20-李四 30-张三 \"]},\"664\":{\"h\":\"无序性和不可重复性的含义是什么\",\"t\":[\"无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。\",\"不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 hashCode() 方法。\"]},\"665\":{\"h\":\"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同\",\"t\":[\"HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。\",\"HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。\",\"底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。\"]},\"666\":{\"h\":\"Queue\"},\"667\":{\"h\":\"Queue 与 Deque 的区别\",\"t\":[\"Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。\",\"Queue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。\",\"Queue 接口\",\"抛出异常\",\"返回特殊值\",\"插入队尾\",\"add(E e)\",\"offer(E e)\",\"删除队首\",\"remove()\",\"poll()\",\"查询队首元素\",\"element()\",\"peek()\",\"Deque 是双端队列，在队列的两端均可以插入或删除元素。\",\"Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：\",\"Deque 接口\",\"抛出异常\",\"返回特殊值\",\"插入队首\",\"addFirst(E e)\",\"offerFirst(E e)\",\"插入队尾\",\"addLast(E e)\",\"offerLast(E e)\",\"删除队首\",\"removeFirst()\",\"pollFirst()\",\"删除队尾\",\"removeLast()\",\"pollLast()\",\"查询队首元素\",\"getFirst()\",\"peekFirst()\",\"查询队尾元素\",\"getLast()\",\"peekLast()\",\"事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。\"]},\"668\":{\"h\":\"ArrayDeque 与 LinkedList 的区别\",\"t\":[\"ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？\",\"ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。\",\"ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。\",\"ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。\",\"ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。\",\"从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。\"]},\"669\":{\"h\":\"说一说 PriorityQueue\",\"t\":[\"PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\",\"这里列举其相关的一些要点：\",\"PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据\",\"PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。\",\"PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。\",\"PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。\",\"PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。\"]},\"670\":{\"h\":\"什么是 BlockingQueue？\",\"t\":[\"BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。\",\"public interface BlockingQueue<E> extends Queue<E> { // ... } \",\"BlockingQueue 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。\",\"BlockingQueue\"]},\"671\":{\"h\":\"BlockingQueue 的实现类有哪些？\",\"t\":[\"BlockingQueue 的实现类\",\"Java 中常用的阻塞队列实现类有以下几种：\",\"ArrayBlockingQueue：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。\",\"LinkedBlockingQueue：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue类似， 它也支持公平和非公平的锁访问机制。\",\"PriorityBlockingQueue：支持优先级排序的无界阻塞队列。元素必须实现Comparable接口或者在构造函数中传入Comparator对象，并且不能插入 null 元素。\",\"SynchronousQueue：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，SynchronousQueue通常用于线程之间的直接传递数据。\",\"DelayQueue：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。\",\"……\",\"日常开发中，这些队列使用的其实都不多，了解即可。\"]},\"672\":{\"h\":\"ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？\",\"t\":[\"ArrayBlockingQueue 和 LinkedBlockingQueue 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：\",\"底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。\",\"是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。\",\"锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。\",\"内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。\",\"File not found\"]},\"673\":{\"c\":[\"Java\"]},\"674\":{\"c\":[\"Java集合\"]},\"675\":{\"h\":\"Java集合常见面试题总结(下)\",\"t\":[\"File not found\"]},\"676\":{\"h\":\"Map（重要）\"},\"677\":{\"h\":\"HashMap 和 Hashtable 的区别\",\"t\":[\"线程是否安全：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；\",\"效率： 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；\",\"对 Null key 和 Null value 的支持：HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。\",\"初始容量大小和每次扩充容量大小的不同： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。\",\"底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。\",\"HashMap 中带有初始容量的构造函数：\",\" public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } \",\"下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。\",\" /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } \"]},\"678\":{\"h\":\"HashMap 和 HashSet 区别\",\"t\":[\"如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。\",\"HashMap\",\"HashSet\",\"实现了 Map 接口\",\"实现 Set 接口\",\"存储键值对\",\"仅存储对象\",\"调用 put()向 map 中添加元素\",\"调用 add()方法向 Set 中添加元素\",\"HashMap 使用键（Key）计算 hashcode\",\"HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性\"]},\"679\":{\"h\":\"HashMap 和 TreeMap 区别\",\"t\":[\"TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。\",\"TreeMap 继承关系图\",\"实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。\",\"实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：\",\"/** * @author shuang.kou * @createTime 2020年06月15日 17:02:00 */ public class Person { private Integer age; public Person(Integer age) { this.age = age; } public Integer getAge() { return age; } public static void main(String[] args) { TreeMap<Person, String> treeMap = new TreeMap<>(new Comparator<Person>() { @Override public int compare(Person person1, Person person2) { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); } }); treeMap.put(new Person(3), \\\"person1\\\"); treeMap.put(new Person(18), \\\"person2\\\"); treeMap.put(new Person(35), \\\"person3\\\"); treeMap.put(new Person(16), \\\"person4\\\"); treeMap.entrySet().stream().forEach(personStringEntry -> { System.out.println(personStringEntry.getValue()); }); } } \",\"输出:\",\"person1 person4 person2 person3 \",\"可以看出，TreeMap 中的元素已经是按照 Person 的 age 字段的升序来排列了。\",\"上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：\",\"TreeMap<Person, String> treeMap = new TreeMap<>((person1, person2) -> { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); }); \",\"综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。\"]},\"680\":{\"h\":\"HashSet 如何检查重复?\",\"t\":[\"以下内容摘自我的 Java 启蒙书《Head first java》第二版：\",\"当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。\",\"在 JDK1.8 中，HashSet的add()方法只是简单的调用了HashMap的put()方法，并且判断了一下返回值以确保是否有重复元素。直接看一下HashSet中的源码：\",\"// Returns: true if this set did not already contain the specified element // 返回值：当 set 中没有包含 add 的元素时返回真 public boolean add(E e) { return map.put(e, PRESENT)==null; } \",\"而在HashMap的putVal()方法中也能看到如下说明：\",\"// Returns : previous value, or null if none // 返回值：如果插入位置没有元素返回null，否则返回上一个元素 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { ... } \",\"也就是说，在 JDK1.8 中，实际上无论HashSet中是否已经存在了某元素，HashSet都会直接插入，只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。\"]},\"681\":{\"h\":\"HashMap 的底层实现\"},\"682\":{\"h\":\"JDK1.8 之前\",\"t\":[\"JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\",\"所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\",\"JDK 1.8 HashMap 的 hash 方法源码:\",\"JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。\",\" static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"对比一下 JDK1.7 的 HashMap 的 hash 方法源码.\",\"static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20) ^ (h >>> 12); return h ^ (h >>> 7) ^ (h >>> 4); } \",\"相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。\",\"所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\",\"jdk1.8 之前的内部结构-HashMap\"]},\"683\":{\"h\":\"JDK1.8 之后\",\"t\":[\"相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"jdk1.8之后的内部结构-HashMap\",\"TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\",\"我们来结合源码分析一下 HashMap 链表到红黑树的转换。\",\"1、 putVal 方法中执行链表转红黑树的判断逻辑。\",\"链表的长度大于 8 的时候，就执行 treeifyBin （转换红黑树）的逻辑。\",\"// 遍历链表 for (int binCount = 0; ; ++binCount) { // 遍历到链表最后一个节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果链表元素个数大于等于TREEIFY_THRESHOLD（8） if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st // 红黑树转换（并不会直接转换成红黑树） treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } \",\"2、treeifyBin 方法中判断是否真的转换为红黑树。\",\"final void treeifyBin(Node<K,V>[] tab, int hash) { int n, index; Node<K,V> e; // 判断当前数组的长度是否小于 64 if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY) // 如果当前数组的长度小于 64，那么会选择先进行数组扩容 resize(); else if ((e = tab[index = (n - 1) & hash]) != null) { // 否则才将列表转换为红黑树 TreeNode<K,V> hd = null, tl = null; do { TreeNode<K,V> p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } \",\"将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。\"]},\"684\":{\"h\":\"HashMap 的长度为什么是 2 的幂次方\",\"t\":[\"为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。\",\"这个算法应该如何设计呢？\",\"我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。\"]},\"685\":{\"h\":\"HashMap 多线程操作导致死循环问题\",\"t\":[\"JDK1.7 及之前版本的 HashMap 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。\",\"为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在数据覆盖的问题。并发环境下，推荐使用 ConcurrentHashMap 。\",\"一般面试中这样介绍就差不多，不需要记各种细节，个人觉得也没必要记。如果想要详细了解 HashMap 扩容导致死循环问题，可以看看耗子叔的这篇文章：Java HashMap 的死循环。\"]},\"686\":{\"h\":\"HashMap 为什么线程不安全？\",\"t\":[\"JDK1.7 及之前版本，在多线程环境下，HashMap 扩容时会造成死循环和数据丢失的问题。\",\"数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。\",\"JDK 1.8 后，在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。\",\"举个例子：\",\"两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。\",\"不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。\",\"随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。\",\"public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // ... // 判断是否出现 hash 碰撞 // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素（处理hash冲突） else { // ... } \",\"还有一种情况是这两个线程同时 put 操作导致 size 的值不正确，进而导致数据覆盖的问题：\",\"线程 1 执行 if(++size > threshold) 判断时，假设获得 size 的值为 10，由于时间片耗尽挂起。\",\"线程 2 也执行 if(++size > threshold) 判断，获得 size 的值也为 10，并将元素插入到该桶位中，并将 size 的值更新为 11。\",\"随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。\",\"线程 1、2 都执行了一次 put 操作，但是 size 的值只增加了 1，也就导致实际上只有一个元素被添加到了 HashMap 中。\",\"public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // ... // 实际大小大于阈值则扩容 if (++size > threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null; } \"]},\"687\":{\"h\":\"HashMap 常见的遍历方式?\",\"t\":[\"HashMap 的 7 种遍历方式与性能分析！\",\"🐛 修正（参见：issue#1411）：\",\"这篇文章对于 parallelStream 遍历方式的性能分析有误，先说结论：存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低 。\",\"当遍历不存在阻塞时, parallelStream 的性能是最低的：\",\"Benchmark Mode Cnt Score Error Units Test.entrySet avgt 5 288.651 ± 10.536 ns/op Test.keySet avgt 5 584.594 ± 21.431 ns/op Test.lambda avgt 5 221.791 ± 10.198 ns/op Test.parallelStream avgt 5 6919.163 ± 1116.139 ns/op \",\"加入阻塞代码Thread.sleep(10)后, parallelStream 的性能才是最高的:\",\"Benchmark Mode Cnt Score Error Units Test.entrySet avgt 5 1554828440.000 ± 23657748.653 ns/op Test.keySet avgt 5 1550612500.000 ± 6474562.858 ns/op Test.lambda avgt 5 1551065180.000 ± 19164407.426 ns/op Test.parallelStream avgt 5 186345456.667 ± 3210435.590 ns/op \"]},\"688\":{\"h\":\"ConcurrentHashMap 和 Hashtable 的区别\",\"t\":[\"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\",\"底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\",\"实现线程安全的方式（重要）：\",\"在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。\",\"到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\",\"Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\",\"下面，我们再来看看两者底层数据结构的对比图。\",\"Hashtable :\",\"Hashtable 的内部结构\",\"https://www.cnblogs.com/chengxiao/p/6842045.html>\",\"JDK1.7 的 ConcurrentHashMap：\",\"Java7 ConcurrentHashMap 存储结构\",\"ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。\",\"Segment 数组中的每个元素包含一个 HashEntry 数组，每个 HashEntry 数组属于链表结构。\",\"JDK1.8 的 ConcurrentHashMap：\",\"Java8 ConcurrentHashMap 存储结构\",\"JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。\",\"TreeNode是存储红黑树节点，被TreeBin包装。TreeBin通过root属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 ConcurrentHashMap 中TreeBin通过waiter属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。\",\"static final class TreeBin<K,V> extends Node<K,V> { TreeNode<K,V> root; volatile TreeNode<K,V> first; volatile Thread waiter; volatile int lockState; // values for lockState static final int WRITER = 1; // set while holding write lock static final int WAITER = 2; // set when waiting for write lock static final int READER = 4; // increment value for setting read lock ... } \"]},\"689\":{\"h\":\"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现\"},\"690\":{\"h\":\"JDK1.8 之前\",\"t\":[\"Java7 ConcurrentHashMap 存储结构\",\"首先将数据分为一段一段（这个“段”就是 Segment）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\",\"ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。\",\"Segment 继承了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。\",\"static class Segment<K,V> extends ReentrantLock implements Serializable { } \",\"一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的个数一旦初始化就不能改变。 Segment 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。\",\"Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。也就是说，对同一 Segment 的并发写入会被阻塞，不同 Segment 的写入是可以并发执行的。\"]},\"691\":{\"h\":\"JDK1.8 之后\",\"t\":[\"Java8 ConcurrentHashMap 存储结构\",\"Java 8 几乎完全重写了 ConcurrentHashMap，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。\",\"ConcurrentHashMap 取消了 Segment 分段锁，采用 Node + CAS + synchronized 来保证并发安全。数据结构跟 HashMap 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。\",\"Java 8 中，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。\"]},\"692\":{\"h\":\"JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？\",\"t\":[\"线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。\",\"Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。\",\"并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。\"]},\"693\":{\"h\":\"ConcurrentHashMap 为什么 key 和 value 不能为 null？\",\"t\":[\"ConcurrentHashMap 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。\",\"拿 get 方法取值来说，返回的结果为 null 存在两种情况：\",\"值没有在集合中 ；\",\"值本身就是 null。\",\"这也就是二义性的由来。\",\"具体可以参考 ConcurrentHashMap 源码分析 。\",\"多线程环境下，存在一个线程操作该 ConcurrentHashMap 时，其他的线程将该 ConcurrentHashMap 修改的情况，所以无法通过 containsKey(key) 来判断否存在这个键值对，也就没办法解决二义性问题了。\",\"与此形成对比的是，HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 HashMap 修改的情况，所以可以通过 contains(key)来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。\",\"也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。\",\"如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。\",\"public static final Object NULL = new Object(); \",\"最后，再分享一下 ConcurrentHashMap 作者本人 (Doug Lea)对于这个问题的回答：\",\"The main reason that nulls aren't allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) is that ambiguities that may be just barely tolerable in non-concurrent maps can't be accommodated. The main one is that if map.get(key) returns null, you can't detect whether the key explicitly maps to null vs the key isn't mapped. In a non-concurrent map, you can check this via map.contains(key), but in a concurrent one, the map might have changed between calls.\",\"翻译过来之后的，大致意思还是单线程下可以容忍歧义，而多线程下无法容忍。\"]},\"694\":{\"h\":\"ConcurrentHashMap 能保证复合操作的原子性吗？\",\"t\":[\"ConcurrentHashMap 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 HashMap 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！\",\"复合操作是指由多个基本操作(如put、get、remove、containsKey等)组成的操作，例如先判断某个键是否存在containsKey(key)，然后根据结果进行插入或更新put(key, value)。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。\",\"例如，有两个线程 A 和 B 同时对 ConcurrentHashMap 进行复合操作，如下：\",\"// 线程 A if (!map.containsKey(key)) { map.put(key, value); } // 线程 B if (!map.containsKey(key)) { map.put(key, anotherValue); } \",\"如果线程 A 和 B 的执行顺序是这样：\",\"线程 A 判断 map 中不存在 key\",\"线程 B 判断 map 中不存在 key\",\"线程 B 将 (key, anotherValue) 插入 map\",\"线程 A 将 (key, value) 插入 map\",\"那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。\",\"那如何保证 ConcurrentHashMap 复合操作的原子性呢？\",\"ConcurrentHashMap 提供了一些原子性的复合操作，如 putIfAbsent、compute、computeIfAbsent 、computeIfPresent、merge等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。\",\"上面的代码可以改写为：\",\"// 线程 A map.putIfAbsent(key, value); // 线程 B map.putIfAbsent(key, anotherValue); \",\"或者：\",\"// 线程 A map.computeIfAbsent(key, k -> value); // 线程 B map.computeIfAbsent(key, k -> anotherValue); \",\"很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 ConcurrentHashMap 的初衷。在使用 ConcurrentHashMap 的时候，尽量使用这些原子性的复合操作方法来保证原子性。\"]},\"695\":{\"h\":\"Collections 工具类（不重要）\",\"t\":[\"Collections 工具类常用方法:\",\"排序\",\"查找,替换操作\",\"同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)\"]},\"696\":{\"h\":\"排序操作\",\"t\":[\"void reverse(List list)//反转 void shuffle(List list)//随机排序 void sort(List list)//按自然排序的升序排序 void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑 void swap(List list, int i , int j)//交换两个索引位置的元素 void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 \"]},\"697\":{\"h\":\"查找,替换操作\",\"t\":[\"int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll) int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素 int frequency(Collection c, Object o)//统计元素出现次数 int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target) boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 \"]},\"698\":{\"h\":\"同步控制\",\"t\":[\"Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。\",\"我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。\",\"最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。\",\"方法如下：\",\"synchronizedCollection(Collection<T> c) //返回指定 collection 支持的同步（线程安全的）collection。 synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。 synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。 synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。 \",\"File not found\"]},\"699\":{\"c\":[\"Java\"]},\"700\":{\"c\":[\"Java集合\"]},\"701\":{\"h\":\"LinkedHashMap 源码分析\"},\"702\":{\"h\":\"LinkedHashMap 简介\",\"t\":[\"LinkedHashMap 是 Java 提供的一个集合类，它继承自 HashMap，并在 HashMap 基础上维护一条双向链表，使得具备如下特性:\",\"支持遍历时会按照插入顺序有序进行迭代。\",\"支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。\",\"因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。\",\"LinkedHashMap 逻辑结构如下图所示，它是在 HashMap 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。\",\"LinkedHashMap 逻辑结构\"]},\"703\":{\"h\":\"LinkedHashMap 使用示例\"},\"704\":{\"h\":\"插入顺序遍历\",\"t\":[\"如下所示，我们按照顺序往 LinkedHashMap 添加元素然后进行遍历。\",\"HashMap < String, String > map = new LinkedHashMap < > (); map.put(\\\"a\\\", \\\"2\\\"); map.put(\\\"g\\\", \\\"3\\\"); map.put(\\\"r\\\", \\\"1\\\"); map.put(\\\"e\\\", \\\"23\\\"); for (Map.Entry < String, String > entry: map.entrySet()) { System.out.println(entry.getKey() + \\\":\\\" + entry.getValue()); } \",\"输出：\",\"a:2 g:3 r:1 e:23 \",\"可以看出，LinkedHashMap 的迭代顺序是和插入顺序一致的,这一点是 HashMap 所不具备的。\"]},\"705\":{\"h\":\"访问顺序遍历\",\"t\":[\"LinkedHashMap 定义了排序模式 accessOrder(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。\",\"为了实现访问顺序遍历，我们可以使用传入 accessOrder 属性的 LinkedHashMap 构造方法，并将 accessOrder 设置为 true，表示其具备访问有序性。\",\"LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true); map.put(1, \\\"one\\\"); map.put(2, \\\"two\\\"); map.put(3, \\\"three\\\"); map.put(4, \\\"four\\\"); map.put(5, \\\"five\\\"); //访问元素2,该元素会被移动至链表末端 map.get(2); //访问元素3,该元素会被移动至链表末端 map.get(3); for (Map.Entry<Integer, String> entry : map.entrySet()) { System.out.println(entry.getKey() + \\\" : \\\" + entry.getValue()); } \",\"输出：\",\"1 : one 4 : four 5 : five 2 : two 3 : three \",\"可以看出，LinkedHashMap 的迭代顺序是和访问顺序一致的。\"]},\"706\":{\"h\":\"LRU 缓存\",\"t\":[\"从上一个我们可以了解到通过 LinkedHashMap 我们可以封装一个简易版的 LRU（Least Recently Used，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。\",\"具体实现思路如下：\",\"继承 LinkedHashMap;\",\"构造方法中指定 accessOrder 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；\",\"重写removeEldestEntry 方法，该方法会返回一个 boolean 值，告知 LinkedHashMap 是否需要移除链表首元素（缓存容量有限）。\",\"public class LRUCache<K, V> extends LinkedHashMap<K, V> { private final int capacity; public LRUCache(int capacity) { super(capacity, 0.75f, true); this.capacity = capacity; } /** * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素) */ @Override protected boolean removeEldestEntry(Map.Entry<K, V> eldest) { return size() > capacity; } } \",\"测试代码如下，笔者初始化缓存容量为 2，然后按照次序先后添加 4 个元素。\",\"LRUCache < Integer, String > cache = new LRUCache < > (2); cache.put(1, \\\"one\\\"); cache.put(2, \\\"two\\\"); cache.put(3, \\\"three\\\"); cache.put(4, \\\"four\\\"); for (int i = 0; i < 4; i++) { System.out.println(cache.get(i)); } \",\"输出：\",\"null null three four \",\"从输出结果来看，由于缓存容量为 2 ，因此，添加第 3 个元素时，第 1 个元素会被删除。添加第 4 个元素时，第 2 个元素会被删除。\"]},\"707\":{\"h\":\"LinkedHashMap 源码解析\"},\"708\":{\"h\":\"Node 的设计\",\"t\":[\"在正式讨论 LinkedHashMap 前，我们先来聊聊 LinkedHashMap 节点 Entry 的设计,我们都知道 HashMap 的 bucket 上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树:\",\"链表上的节点个数达到树化的阈值 7，即TREEIFY_THRESHOLD - 1。\",\"bucket 的容量达到最小的树化容量即MIN_TREEIFY_CAPACITY。\",\"🐛 修正（参见：issue#2147）：\",\"链表上的节点个数达到树化的阈值是 8 而非 7。因为源码的判断是从链表初始元素开始遍历，下标是从 0 开始的，所以判断条件设置为 8-1=7，其实是迭代到尾部元素时再判断整个链表长度大于等于 8 才进行树化操作。\",\"而 LinkedHashMap 是在 HashMap 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 TreeNode 的设计就是一个比较棘手的问题。\",\"对此我们不妨来看看两者之间节点类的类图，可以看到:\",\"LinkedHashMap 的节点内部类 Entry 基于 HashMap 的基础上，增加 before 和 after 指针使节点具备双向链表的特性。\",\"HashMap 的树节点 TreeNode 继承了具备双向链表特性的 LinkedHashMap 的 Entry。\",\"LinkedHashMap 和 HashMap 之间的关系\",\"很多读者此时就会有这样一个疑问，为什么 HashMap 的树节点 TreeNode 要通过 LinkedHashMap 获取双向链表的特性呢?为什么不直接在 Node 上实现前驱和后继指针呢?\",\"先来回答第一个问题，我们都知道 LinkedHashMap 是在 HashMap 基础上对节点增加双向指针实现双向链表的特性,所以 LinkedHashMap 内部链表转红黑树时，对应的节点会转为树节点 TreeNode,为了保证使用 LinkedHashMap 时树节点具备双向链表的特性，所以树节点 TreeNode 需要继承 LinkedHashMap 的 Entry。\",\"再来说说第二个问题，我们直接在 HashMap 的节点 Node 上直接实现前驱和后继指针,然后 TreeNode 直接继承 Node 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 HashMap 时存储键值对的节点类 Node 多了两个没有必要的引用，占用没必要的内存空间。\",\"所以，为了保证 HashMap 底层的节点类 Node 没有多余的引用，又要保证 LinkedHashMap 的节点类 Entry 拥有存储链表的引用，设计者就让 LinkedHashMap 的节点 Entry 去继承 Node 并增加存储前驱后继节点的引用 before、after，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 TreeNode 再通过继承 Entry 获取 before、after 两个指针。\",\"static class Entry<K,V> extends HashMap.Node<K,V> { Entry<K,V> before, after; Entry(int hash, K key, V value, Node<K,V> next) { super(hash, key, value, next); } } \",\"但是这样做，不也使得使用 HashMap 时的 TreeNode 多了两个没有必要的引用吗?这不也是一种空间的浪费吗？\",\"static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> { //略 } \",\"对于这个问题,引用作者的一段注释，作者们认为在良好的 hashCode 算法时，HashMap 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 TreeNode 变为 Node，所以 TreeNode 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。\",\"Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution \"]},\"709\":{\"h\":\"构造方法\",\"t\":[\"LinkedHashMap 构造方法有 4 个实现也比较简单，直接调用父类即 HashMap 的构造方法完成初始化。\",\"public LinkedHashMap() { super(); accessOrder = false; } public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } \",\"我们上面也提到了，默认情况下 accessOrder 为 false，如果我们要让 LinkedHashMap 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 accessOrder 设置为 true。\"]},\"710\":{\"h\":\"get 方法\",\"t\":[\"get 方法是 LinkedHashMap 增删改查操作中唯一一个重写的方法， accessOrder 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。\",\"public V get(Object key) { Node < K, V > e; //获取key的键值对,若为空直接返回 if ((e = getNode(hash(key), key)) == null) return null; //若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾 if (accessOrder) afterNodeAccess(e); //返回键值对的值 return e.value; } \",\"从源码可以看出，get 的执行步骤非常简单:\",\"调用父类即 HashMap 的 getNode 获取键值对，若为空则直接返回。\",\"判断 accessOrder 是否为 true，若为 true 则说明需要保证 LinkedHashMap 的链表访问有序性，执行步骤 3。\",\"调用 LinkedHashMap 重写的 afterNodeAccess 将当前元素添加到链表末尾。\",\"关键点在于 afterNodeAccess 方法的实现，这个方法负责将元素移动到链表末尾。\",\"void afterNodeAccess(Node < K, V > e) { // move node to last LinkedHashMap.Entry < K, V > last; //如果accessOrder 且当前节点不未链表尾节点 if (accessOrder && (last = tail) != e) { //获取当前节点、以及前驱节点和后继节点 LinkedHashMap.Entry < K, V > p = (LinkedHashMap.Entry < K, V > ) e, b = p.before, a = p.after; //将当前节点的后继节点指针指向空，使其和后继节点断开联系 p.after = null; //如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点 if (b == null) head = a; else //如果后继节点不为空，则让前驱节点指向后继节点 b.after = a; //如果后继节点不为空，则让后继节点指向前驱节点 if (a != null) a.before = b; else //如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null last = b; //如果last为空，则说明当前链表只有一个节点p，则将head指向p if (last == null) head = p; else { //反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p p.before = last; last.after = p; } //tail指向p，自此将节点p移动到链表末尾 tail = p; ++modCount; } } \",\"从源码可以看出， afterNodeAccess 方法完成了下面这些操作:\",\"如果 accessOrder 为 true 且链表尾部不为当前节点 p，我们则需要将当前节点移到链表尾部。\",\"获取当前节点 p、以及它的前驱节点 b 和后继节点 a。\",\"将当前节点 p 的后继指针设置为 null，使其和后继节点 p 断开联系。\",\"尝试将前驱节点指向后继节点，若前驱节点为空，则说明当前节点 p 就是链表首节点，故直接将后继节点 a 设置为首节点，随后我们再将 p 追加到 a 的末尾。\",\"再尝试让后继节点 a 指向前驱节点 b。\",\"上述操作让前驱节点和后继节点完成关联，并将当前节点 p 独立出来，这一步则是将当前节点 p 追加到链表末端，如果链表末端为空，则说明当前链表只有一个节点 p，所以直接让 head 指向 p 即可。\",\"上述操作已经将 p 成功到达链表末端，最后我们将 tail 指针即指向链表末端的指针指向 p 即可。\",\"可以结合这张图理解，展示了 key 为 13 的元素被移动到了链表尾部。\",\"LinkedHashMap 移动元素 13 到链表尾部\",\"看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。\"]},\"711\":{\"h\":\"remove 方法后置操作——afterNodeRemoval\",\"t\":[\"LinkedHashMap 并没有对 remove 方法进行重写，而是直接继承 HashMap 的 remove 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，LinkedHashMap 重写了 HashMap 的空实现方法 afterNodeRemoval。\",\"final Node<K,V> removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { //略 if (node != null && (!matchValue || (v = node.value) == value || (value != null && value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; //HashMap的removeNode完成元素移除后会调用afterNodeRemoval进行移除后置操作 afterNodeRemoval(node); return node; } } return null; } //空实现 void afterNodeRemoval(Node<K,V> p) { } \",\"我们可以看到从 HashMap 继承来的 remove 方法内部调用的 removeNode 方法将节点从 bucket 删除后，调用了 afterNodeRemoval。\",\"void afterNodeRemoval(Node<K,V> e) { // unlink //获取当前节点p、以及e的前驱节点b和后继节点a LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after; //将p的前驱和后继指针都设置为null，使其和前驱、后继节点断开联系 p.before = p.after = null; //如果前驱节点为空，则说明当前节点p是链表首节点，让head指针指向后继节点a即可 if (b == null) head = a; else //如果前驱节点b不为空，则让b直接指向后继节点a b.after = a; //如果后继节点为空，则说明当前节点p在链表末端，所以直接让tail指针指向前驱节点a即可 if (a == null) tail = b; else //反之后继节点的前驱指针直接指向前驱节点 a.before = b; } \",\"从源码可以看出， afterNodeRemoval 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收，整体步骤为:\",\"获取当前节点 p、以及 e 的前驱节点 b 和后继节点 a。\",\"让当前节点 p 和其前驱、后继节点断开联系。\",\"尝试让前驱节点 b 指向后继节点 a，若 b 为空则说明当前节点 p 在链表首部，我们直接将 head 指向后继节点 a 即可。\",\"尝试让后继节点 a 指向前驱节点 b，若 a 为空则说明当前节点 p 在链表末端，所以直接让 tail 指针指向前驱节点 a 即可。\",\"可以结合这张图理解，展示了 key 为 13 的元素被删除，也就是从链表中移除了这个元素。\",\"LinkedHashMap 删除元素 13\",\"看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。\"]},\"712\":{\"h\":\"put 方法后置操作——afterNodeInsertion\",\"t\":[\"同样的 LinkedHashMap 并没有实现插入方法，而是直接继承 HashMap 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:\",\"重写 afterNodeAccess(上文提到过),如果当前被插入的 key 已存在与 map 中，因为 LinkedHashMap 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 afterNodeAccess 将其放到链表末端。\",\"重写了 HashMap 的 afterNodeInsertion 方法，当 removeEldestEntry 返回 true 时，会将链表首节点移除。\",\"这一点我们可以在 HashMap 的插入操作核心方法 putVal 中看到。\",\"final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { //略 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //如果当前的key在map中存在，则调用afterNodeAccess afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) resize(); //调用插入后置方法，该方法被LinkedHashMap重写 afterNodeInsertion(evict); return null; } \",\"上述步骤的源码上文已经解释过了，所以这里我们着重了解一下 afterNodeInsertion 的工作流程，假设我们的重写了 removeEldestEntry，当链表 size 超过 capacity 时，就返回 true。\",\"/** * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素) */ protected boolean removeEldestEntry(Map.Entry < K, V > eldest) { return size() > capacity; } \",\"以下图为例，假设笔者最后新插入了一个不存在的节点 19,假设 capacity 为 4，所以 removeEldestEntry 返回 true，我们要将链表首节点移除。\",\"LinkedHashMap 中插入新元素 19\",\"移除的步骤很简单，查看链表首节点是否存在，若存在则断开首节点和后继节点的关系，并让首节点指针指向下一节点，所以 head 指针指向了 12，节点 10 成为没有任何引用指向的空对象，等待 GC。\",\"LinkedHashMap 中插入新元素 19\",\"void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry<K,V> first; //如果evict为true且队首元素不为空以及removeEldestEntry返回true，则说明我们需要最老的元素(即在链表首部的元素)移除。 if (evict && (first = head) != null && removeEldestEntry(first)) { //获取链表首部的键值对的key K key = first.key; //调用removeNode将元素从HashMap的bucket中移除，并和LinkedHashMap的双向链表断开，等待gc回收 removeNode(hash(key), key, null, false, true); } } \",\"从源码可以看出， afterNodeInsertion 方法完成了下面这些操作:\",\"判断 eldest 是否为 true，只有为 true 才能说明可能需要将最年长的键值对(即链表首部的元素)进行移除，具体是否具体要进行移除，还得确定链表是否为空((first = head) != null)，以及 removeEldestEntry 方法是否返回 true，只有这两个方法返回 true 才能确定当前链表不为空，且链表需要进行移除操作了。\",\"获取链表第一个元素的 key。\",\"调用 HashMap 的 removeNode 方法，该方法我们上文提到过，它会将节点从 HashMap 的 bucket 中移除，并且 LinkedHashMap 还重写了 removeNode 中的 afterNodeRemoval 方法，所以这一步将通过调用 removeNode 将元素从 HashMap 的 bucket 中移除，并和 LinkedHashMap 的双向链表断开，等待 gc 回收。\"]},\"713\":{\"h\":\"LinkedHashMap 和 HashMap 遍历性能比较\",\"t\":[\"LinkedHashMap 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 HashMap 那种遍历整个 bucket 的方式来说，高效需多。\",\"这一点我们可以从两者的迭代器中得以印证，先来看看 HashMap 的迭代器，可以看到 HashMap 迭代键值对时会用到一个 nextNode 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。\",\" final class EntryIterator extends HashIterator implements Iterator < Map.Entry < K, V >> { public final Map.Entry < K, V > next() { return nextNode(); } } //获取下一个Node final Node < K, V > nextNode() { Node < K, V > [] t; //获取下一个元素next Node < K, V > e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); //将next指向bucket中下一个不为空的Node if ((next = (current = e).next) == null && (t = table) != null) { do {} while (index < t.length && (next = t[index++]) == null); } return e; } \",\"相比之下 LinkedHashMap 的迭代器则是直接使用通过 after 指针快速定位到当前节点的后继节点，简洁高效需多。\",\" final class LinkedEntryIterator extends LinkedHashIterator implements Iterator < Map.Entry < K, V >> { public final Map.Entry < K, V > next() { return nextNode(); } } //获取下一个Node final LinkedHashMap.Entry < K, V > nextNode() { //获取下一个节点next LinkedHashMap.Entry < K, V > e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); //current 指针指向当前节点 current = e; //next直接当前节点的after指针快速定位到下一个节点 next = e.after; return e; } \",\"为了验证笔者所说的观点，笔者对这两个容器进行了压测，测试插入 1000w 和迭代 1000w 条数据的耗时，代码如下:\",\"int count = 1000_0000; Map<Integer, Integer> hashMap = new HashMap<>(); Map<Integer, Integer> linkedHashMap = new LinkedHashMap<>(); long start, end; start = System.currentTimeMillis(); for (int i = 0; i < count; i++) { hashMap.put(ThreadLocalRandom.current().nextInt(1, count), ThreadLocalRandom.current().nextInt(0, count)); } end = System.currentTimeMillis(); System.out.println(\\\"map time putVal: \\\" + (end - start)); start = System.currentTimeMillis(); for (int i = 0; i < count; i++) { linkedHashMap.put(ThreadLocalRandom.current().nextInt(1, count), ThreadLocalRandom.current().nextInt(0, count)); } end = System.currentTimeMillis(); System.out.println(\\\"linkedHashMap putVal time: \\\" + (end - start)); start = System.currentTimeMillis(); long num = 0; for (Integer v : hashMap.values()) { num = num + v; } end = System.currentTimeMillis(); System.out.println(\\\"map get time: \\\" + (end - start)); start = System.currentTimeMillis(); for (Integer v : linkedHashMap.values()) { num = num + v; } end = System.currentTimeMillis(); System.out.println(\\\"linkedHashMap get time: \\\" + (end - start)); System.out.println(num); \",\"从输出结果来看，因为 LinkedHashMap 需要维护双向链表的缘故，插入元素相较于 HashMap 会更耗时，但是有了双向链表明确的前后节点关系，迭代效率相对于前者高效了需多。不过，总体来说却别不大，毕竟数据量这么庞大。\",\"map time putVal: 5880 linkedHashMap putVal time: 7567 map get time: 143 linkedHashMap get time: 67 63208969074998 \"]},\"714\":{\"h\":\"LinkedHashMap 常见面试题\"},\"715\":{\"h\":\"什么是 LinkedHashMap？\",\"t\":[\"LinkedHashMap 是 Java 集合框架中 HashMap 的一个子类，它继承了 HashMap 的所有属性和方法，并且在 HashMap 的基础重写了 afterNodeRemoval、afterNodeInsertion、afterNodeAccess 方法。使之拥有顺序插入和访问有序的特性。\"]},\"716\":{\"h\":\"LinkedHashMap 如何按照插入顺序迭代元素？\",\"t\":[\"LinkedHashMap 按照插入顺序迭代元素是它的默认行为。LinkedHashMap 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。\"]},\"717\":{\"h\":\"LinkedHashMap 如何按照访问顺序迭代元素？\",\"t\":[\"LinkedHashMap 可以通过构造函数中的 accessOrder 参数指定按照访问顺序迭代元素。当 accessOrder 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。\"]},\"718\":{\"h\":\"LinkedHashMap 如何实现 LRU 缓存？\",\"t\":[\"将 accessOrder 设置为 true 并重写 removeEldestEntry 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 removeEldestEntry 返回 true 时，视为缓存已满，LinkedHashMap 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。\"]},\"719\":{\"h\":\"LinkedHashMap 和 HashMap 有什么区别？\",\"t\":[\"LinkedHashMap 和 HashMap 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于迭代元素的顺序。HashMap 迭代元素的顺序是不确定的，而 LinkedHashMap 提供了按照插入顺序或访问顺序迭代元素的功能。此外，LinkedHashMap 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 HashMap 则没有这个链表。因此，LinkedHashMap 的插入性能可能会比 HashMap 略低，但它提供了更多的功能并且迭代效率相较于 HashMap 更加高效。\"]},\"720\":{\"h\":\"参考文献\",\"t\":[\"LinkedHashMap 源码详细分析（JDK1.8）:https://www.imooc.com/article/22931\",\"HashMap 与 LinkedHashMap:https://www.cnblogs.com/Spground/p/8536148.html\",\"源于 LinkedHashMap 源码: https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/\",\"File not found\"]},\"721\":{\"c\":[\"Java\"]},\"722\":{\"c\":[\"Java集合\"]},\"723\":{\"h\":\"LinkedList 源码分析\",\"t\":[\"File not found\"]},\"724\":{\"h\":\"LinkedList 简介\",\"t\":[\"LinkedList 是一个基于双向链表实现的集合类，经常被拿来和 ArrayList 做比较。关于 LinkedList 和ArrayList的详细对比，我们 Java 集合常见面试题总结(上)有详细介绍到。\",\"双向链表\",\"不过，我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！就连 LinkedList 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 LinkedList 。\",\"另外，不要下意识地认为 LinkedList 作为链表就最适合元素增删的场景。我在上面也说了，LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。\"]},\"725\":{\"h\":\"LinkedList 插入和删除元素的时间复杂度？\",\"t\":[\"头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\",\"尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。\",\"指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\"]},\"726\":{\"h\":\"LinkedList 为什么不能实现 RandomAccess 接口？\",\"t\":[\"RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。\"]},\"727\":{\"h\":\"LinkedList 源码分析\",\"t\":[\"这里以 JDK1.8 为例，分析一下 LinkedList 的底层核心源码。\",\"LinkedList 的类定义如下：\",\"public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable { //... } \",\"LinkedList 继承了 AbstractSequentialList ，而 AbstractSequentialList 又继承于 AbstractList 。\",\"阅读过 ArrayList 的源码我们就知道，ArrayList 同样继承了 AbstractList ， 所以 LinkedList 会有大部分方法和 ArrayList 相似。\",\"LinkedList 实现了以下接口：\",\"List : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\",\"Deque ：继承自 Queue 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，Deque 的发音为 \\\"deck\\\" [dɛk]，这个大部分人都会读错。\",\"Cloneable ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\",\"Serializable : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\",\"LinkedList 类图\",\"LinkedList 中的元素是通过 Node 定义的：\",\"private static class Node<E> { E item;// 节点值 Node<E> next; // 指向的下一个节点（后继节点） Node<E> prev; // 指向的前一个节点（前驱结点） // 初始化参数顺序分别是：前驱结点、本身节点值、后继节点 Node(Node<E> prev, E element, Node<E> next) { this.item = element; this.next = next; this.prev = prev; } } \"]},\"728\":{\"h\":\"初始化\",\"t\":[\"LinkedList 中有一个无参构造函数和一个有参构造函数。\",\"// 创建一个空的链表对象 public LinkedList() { } // 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象 public LinkedList(Collection<? extends E> c) { this(); addAll(c); } \"]},\"729\":{\"h\":\"插入元素\",\"t\":[\"LinkedList 除了实现了 List 接口相关方法，还实现了 Deque 接口的很多方法，所以我们有很多种方式插入元素。\",\"我们这里以 List 接口中相关的插入方法为例进行源码讲解，对应的是add() 方法。\",\"add() 方法有两个版本：\",\"add(E e)：用于在 LinkedList 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。\",\"add(int index, E element):用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。\",\"// 在链表尾部插入元素 public boolean add(E e) { linkLast(e); return true; } // 在链表指定位置插入元素 public void add(int index, E element) { // 下标越界检查 checkPositionIndex(index); // 判断 index 是不是链表尾部位置 if (index == size) // 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可 linkLast(element); else // 如果不是则调用 linkBefore 方法将其插入指定元素之前 linkBefore(element, node(index)); } // 将元素节点插入到链表尾部 void linkLast(E e) { // 将最后一个元素赋值（引用传递）给节点 l final Node<E> l = last; // 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空 final Node<E> newNode = new Node<>(l, e, null); // 将 last 引用指向新节点 last = newNode; // 判断尾节点是否为空 // 如果 l 是null 意味着这是第一次添加元素 if (l == null) // 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素 first = newNode; else // 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next l.next = newNode; size++; modCount++; } // 在指定元素之前插入元素 void linkBefore(E e, Node<E> succ) { // assert succ != null;断言 succ不为 null // 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息 final Node<E> pred = succ.prev; // 初始化节点，并指明前驱和后继节点 final Node<E> newNode = new Node<>(pred, e, succ); // 将 succ 节点前驱引用 prev 指向新节点 succ.prev = newNode; // 判断尾节点是否为空，为空表示当前链表还没有节点 if (pred == null) first = newNode; else // succ 节点前驱的后继引用指向新节点 pred.next = newNode; size++; modCount++; } \"]},\"730\":{\"h\":\"获取元素\",\"t\":[\"LinkedList获取元素相关的方法一共有 3 个：\",\"getFirst()：获取链表的第一个元素。\",\"getLast()：获取链表的最后一个元素。\",\"get(int index)：获取链表指定位置的元素。\",\"// 获取链表的第一个元素 public E getFirst() { final Node<E> f = first; if (f == null) throw new NoSuchElementException(); return f.item; } // 获取链表的最后一个元素 public E getLast() { final Node<E> l = last; if (l == null) throw new NoSuchElementException(); return l.item; } // 获取链表指定位置的元素 public E get(int index) { // 下标越界检查，如果越界就抛异常 checkElementIndex(index); // 返回链表中对应下标的元素 return node(index).item; } \",\"这里的核心在于 node(int index) 这个方法：\",\"// 返回指定下标的非空节点 Node<E> node(int index) { // 断言下标未越界 // assert isElementIndex(index); // 如果index小于size的二分之一 从前开始查找（向后查找） 反之向前查找 if (index < (size >> 1)) { Node<E> x = first; // 遍历，循环向后查找，直至 i == index for (int i = 0; i < index; i++) x = x.next; return x; } else { Node<E> x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } \",\"get(int index) 或 remove(int index) 等方法内部都调用了该方法来获取对应的节点。\",\"从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。\"]},\"731\":{\"h\":\"删除元素\",\"t\":[\"LinkedList删除元素相关的方法一共有 5 个：\",\"removeFirst()：删除并返回链表的第一个元素。\",\"removeLast()：删除并返回链表的最后一个元素。\",\"remove(E e)：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。\",\"remove(int index)：删除指定索引处的元素，并返回该元素的值。\",\"void clear()：移除此链表中的所有元素。\",\"// 删除并返回链表的第一个元素 public E removeFirst() { final Node<E> f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } // 删除并返回链表的最后一个元素 public E removeLast() { final Node<E> l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } // 删除链表中首次出现的指定元素，如果不存在该元素则返回 fals public boolean remove(Object o) { // 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除 if (o == null) { for (Node<E> x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 如果不为 null ,遍历链表找到要删除的节点 for (Node<E> x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } // 删除链表指定位置的元素 public E remove(int index) { // 下标越界检查，如果越界就抛异常 checkElementIndex(index); return unlink(node(index)); } \",\"这里的核心在于 unlink(Node<E> x) 这个方法：\",\"E unlink(Node<E> x) { // 断言 x 不为 null // assert x != null; // 获取当前节点（也就是待删除节点）的元素 final E element = x.item; // 获取当前节点的下一个节点 final Node<E> next = x.next; // 获取当前节点的前一个节点 final Node<E> prev = x.prev; // 如果前一个节点为空，则说明当前节点是头节点 if (prev == null) { // 直接让链表头指向当前节点的下一个节点 first = next; } else { // 如果前一个节点不为空 // 将前一个节点的 next 指针指向当前节点的下一个节点 prev.next = next; // 将当前节点的 prev 指针置为 null，，方便 GC 回收 x.prev = null; } // 如果下一个节点为空，则说明当前节点是尾节点 if (next == null) { // 直接让链表尾指向当前节点的前一个节点 last = prev; } else { // 如果下一个节点不为空 // 将下一个节点的 prev 指针指向当前节点的前一个节点 next.prev = prev; // 将当前节点的 next 指针置为 null，方便 GC 回收 x.next = null; } // 将当前节点元素置为 null，方便 GC 回收 x.item = null; size--; modCount++; return element; } \",\"unlink() 方法的逻辑如下：\",\"首先获取待删除节点 x 的前驱和后继节点；\",\"判断待删除节点是否为头节点或尾节点： \",\"如果 x 是头节点，则将 first 指向 x 的后继节点 next\",\"如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev\",\"如果 x 不是头节点也不是尾节点，执行下一步操作\",\"将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；\",\"将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；\",\"将待删除节点 x 的元素置空，修改链表长度。\",\"可以参考下图理解（图源：LinkedList 源码分析(JDK 1.8)）：\",\"unlink 方法逻辑\"]},\"732\":{\"h\":\"遍历链表\",\"t\":[\"推荐使用for-each 循环来遍历 LinkedList 中的元素， for-each 循环最终会转换成迭代器形式。\",\"LinkedList<String> list = new LinkedList<>(); list.add(\\\"apple\\\"); list.add(\\\"banana\\\"); list.add(\\\"pear\\\"); for (String fruit : list) { System.out.println(fruit); } \",\"LinkedList 的遍历的核心就是它的迭代器的实现。\",\"// 双向迭代器 private class ListItr implements ListIterator<E> { // 表示上一次调用 next() 或 previous() 方法时经过的节点； private Node<E> lastReturned; // 表示下一个要遍历的节点； private Node<E> next; // 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标； private int nextIndex; // 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。 private int expectedModCount = modCount; ………… } \",\"下面我们对迭代器 ListItr 中的核心方法进行详细介绍。\",\"我们先来看下从头到尾方向的迭代：\",\"// 判断还有没有下一个节点 public boolean hasNext() { // 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历 return nextIndex < size; } // 获取下一个节点 public E next() { // 检查在迭代过程中链表是否被修改过 checkForComodification(); // 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常 if (!hasNext()) throw new NoSuchElementException(); // 将 lastReturned 指向当前节点 lastReturned = next; // 将 next 指向下一个节点 next = next.next; nextIndex++; return lastReturned.item; } \",\"再来看一下从尾到头方向的迭代：\",\"// 判断是否还有前一个节点 public boolean hasPrevious() { return nextIndex > 0; } // 获取前一个节点 public E previous() { // 检查是否在迭代过程中链表被修改 checkForComodification(); // 如果没有前一个节点，则抛出异常 if (!hasPrevious()) throw new NoSuchElementException(); // 将 lastReturned 和 next 指针指向上一个节点 lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; } \",\"如果需要删除或插入元素，也可以使用迭代器进行操作。\",\"LinkedList<String> list = new LinkedList<>(); list.add(\\\"apple\\\"); list.add(null); list.add(\\\"banana\\\"); // Collection 接口的 removeIf 方法底层依然是基于迭代器 list.removeIf(Objects::isNull); for (String fruit : list) { System.out.println(fruit); } \",\"迭代器对应的移除元素的方法如下：\",\"// 从列表中删除上次被返回的元素 public void remove() { // 检查是否在迭代过程中链表被修改 checkForComodification(); // 如果上次返回的节点为空，则抛出异常 if (lastReturned == null) throw new IllegalStateException(); // 获取当前节点的下一个节点 Node<E> lastNext = lastReturned.next; // 从链表中删除上次返回的节点 unlink(lastReturned); // 修改指针 if (next == lastReturned) next = lastNext; else nextIndex--; // 将上次返回的节点引用置为 null，方便 GC 回收 lastReturned = null; expectedModCount++; } \"]},\"733\":{\"h\":\"LinkedList 常用方法测试\",\"t\":[\"代码：\",\"// 创建 LinkedList 对象 LinkedList<String> list = new LinkedList<>(); // 添加元素到链表末尾 list.add(\\\"apple\\\"); list.add(\\\"banana\\\"); list.add(\\\"pear\\\"); System.out.println(\\\"链表内容：\\\" + list); // 在指定位置插入元素 list.add(1, \\\"orange\\\"); System.out.println(\\\"链表内容：\\\" + list); // 获取指定位置的元素 String fruit = list.get(2); System.out.println(\\\"索引为 2 的元素：\\\" + fruit); // 修改指定位置的元素 list.set(3, \\\"grape\\\"); System.out.println(\\\"链表内容：\\\" + list); // 删除指定位置的元素 list.remove(0); System.out.println(\\\"链表内容：\\\" + list); // 删除第一个出现的指定元素 list.remove(\\\"banana\\\"); System.out.println(\\\"链表内容：\\\" + list); // 获取链表的长度 int size = list.size(); System.out.println(\\\"链表长度：\\\" + size); // 清空链表 list.clear(); System.out.println(\\\"清空后的链表：\\\" + list); \",\"输出：\",\"索引为 2 的元素：banana 链表内容：[apple, orange, banana, grape] 链表内容：[orange, banana, grape] 链表内容：[orange, grape] 链表长度：2 清空后的链表：[] \",\"File not found\"]},\"734\":{\"c\":[\"Java\"]},\"735\":{\"c\":[\"Java集合\"]},\"736\":{\"h\":\"PriorityQueue 源码分析（付费）\",\"t\":[\"PriorityQueue 源码分析 为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 必读源码系列》中。\",\"PriorityQueue 源码分析\",\"File not found\",\"File not found\"]},\"737\":{\"c\":[\"Java\"]},\"738\":{\"c\":[\"Java集合\"]},\"739\":{\"h\":\"AQS 详解\"},\"740\":{\"h\":\"AQS 介绍\",\"t\":[\"AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\",\"AQS 就是一个抽象类，主要用来构建锁和同步器。\",\"public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { } \",\"AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。\"]},\"741\":{\"h\":\"AQS 原理\",\"t\":[\"在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。\"]},\"742\":{\"h\":\"AQS 核心思想\",\"t\":[\"AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。\",\"CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。\",\"CLH 队列结构如下图所示：\",\"CLH 队列结构\",\"关于 AQS 核心数据结构-CLH 锁的详细解读，强烈推荐阅读 Java AQS 核心数据结构-CLH 锁 - Qunar 技术沙龙 这篇文章。\",\"AQS(AbstractQueuedSynchronizer)的核心原理图：\",\"CLH 队列\",\"AQS 使用 int 成员变量 state 表示同步状态，通过内置的 FIFO 线程等待/等待队列 来完成获取资源线程的排队工作。\",\"state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。\",\"// 共享变量，使用volatile修饰保证线程可见性 private volatile int state; \",\"另外，状态信息 state 可以通过 protected 类型的getState()、setState()和compareAndSetState() 进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。\",\"//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值） protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } \",\"以可重入的互斥锁 ReentrantLock 为例，它的内部维护了一个 state 变量，用来表示锁的占用状态。state 的初始值为 0，表示锁处于未锁定状态。当线程 A 调用 lock() 方法时，会尝试通过 tryAcquire() 方法独占该锁，并让 state 的值加 1。如果成功了，那么线程 A 就获取到了锁。如果失败了，那么线程 A 就会被加入到一个等待队列（CLH 队列）中，直到其他线程释放该锁。假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。但是，这也意味着，一个线程必须释放与获取的次数相同的锁，才能让 state 的值回到 0，也就是让锁恢复到未锁定状态。只有这样，其他等待的线程才能有机会获取该锁。\",\"线程 A 尝试获取锁的过程如下图所示（图源从 ReentrantLock 的实现看 AQS 的原理及应用 - 美团技术团队）：\",\"AQS 独占模式获取锁\",\"再以倒计时器 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程开始执行任务，每执行完一个子线程，就调用一次 countDown() 方法。该方法会尝试使用 CAS(Compare and Swap) 操作，让 state 的值减少 1。当所有的子线程都执行完毕后（即 state 的值变为 0），CountDownLatch 会调用 unpark() 方法，唤醒主线程。这时，主线程就可以从 await() 方法（CountDownLatch 中的await() 方法而非 AQS 中的）返回，继续执行后续的操作。\"]},\"743\":{\"h\":\"AQS 资源共享方式\",\"t\":[\"AQS 定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。\",\"一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\"]},\"744\":{\"h\":\"自定义同步器\",\"t\":[\"同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\",\"使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。\",\"将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\",\"这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。\",\"AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：\",\"//独占方式。尝试获取资源，成功则返回true，失败则返回false。 protected boolean tryAcquire(int) //独占方式。尝试释放资源，成功则返回true，失败则返回false。 protected boolean tryRelease(int) //共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 protected int tryAcquireShared(int) //共享方式。尝试释放资源，成功则返回true，失败则返回false。 protected boolean tryReleaseShared(int) //该线程是否正在独占资源。只有用到condition才需要去实现它。 protected boolean isHeldExclusively() \",\"什么是钩子方法呢？ 钩子方法是一种被声明在抽象类中的方法，一般使用 protected 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。\",\"篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：用 Java8 改造后的模板方法模式真的是 yyds!。\",\"除了上面提到的钩子方法之外，AQS 类中的其他方法都是 final ，所以无法被其他类重写。\"]},\"745\":{\"h\":\"常见同步工具类\",\"t\":[\"下面介绍几个基于 AQS 的常见同步工具类。\"]},\"746\":{\"h\":\"Semaphore(信号量)\"},\"747\":{\"h\":\"介绍\",\"t\":[\"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。\",\"Semaphore 的使用简单，我们这里假设有 N(N>5) 个线程来获取 Semaphore 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。\",\"// 初始共享资源数量 final Semaphore semaphore = new Semaphore(5); // 获取1个许可 semaphore.acquire(); // 释放1个许可 semaphore.release(); \",\"当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。\",\"Semaphore 有两种模式：。\",\"公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；\",\"非公平模式： 抢占式的。\",\"Semaphore 对应的两个构造方法如下：\",\"public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits); } \",\"这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。\",\"Semaphore 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。\"]},\"748\":{\"h\":\"原理\",\"t\":[\"Semaphore 是共享锁的一种实现，它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。\",\"以无参 acquire 方法为例，调用semaphore.acquire() ，线程尝试获取许可证，如果 state > 0 的话，则表示可以获取成功，如果 state <= 0 的话，则表示许可证数量不足，获取失败。\",\"如果可以获取成功的话(state > 0 )，会尝试使用 CAS 操作去修改 state 的值 state=state-1。如果获取失败则会创建一个 Node 节点加入等待队列，挂起当前线程。\",\"// 获取1个许可证 public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } // 获取一个或者多个许可证 public void acquire(int permits) throws InterruptedException { if (permits < 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits); } \",\"acquireSharedInterruptibly方法是 AbstractQueuedSynchronizer 中的默认实现。\",\"// 共享模式下获取许可证，获取成功则返回，失败则加入等待队列，挂起线程 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 尝试获取许可证，arg为获取许可证个数，当获取失败时,则创建一个节点加入等待队列，挂起当前线程。 if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); } \",\"这里再以非公平模式（NonfairSync）的为例，看看 tryAcquireShared 方法的实现。\",\"// 共享模式下尝试获取资源(在Semaphore中的资源即许可证): protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } // 非公平的共享模式获取许可证 final int nonfairTryAcquireShared(int acquires) { for (;;) { // 当前可用许可证数量 int available = getState(); /* * 尝试获取许可证，当前可用许可证数量小于等于0时，返回负值，表示获取失败， * 当前可用许可证大于0时才可能获取成功，CAS失败了会循环重新获取最新的值尝试获取 */ int remaining = available - acquires; if (remaining < 0 || compareAndSetState(available, remaining)) return remaining; } } \",\"以无参 release 方法为例，调用semaphore.release(); ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒等待队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state > 0 则获取令牌成功，否则重新进入等待队列，挂起线程。\",\"// 释放一个许可证 public void release() { sync.releaseShared(1); } // 释放一个或者多个许可证 public void release(int permits) { if (permits < 0) throw new IllegalArgumentException(); sync.releaseShared(permits); } \",\"releaseShared方法是 AbstractQueuedSynchronizer 中的默认实现。\",\"// 释放共享锁 // 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。 public final boolean releaseShared(int arg) { //释放共享锁 if (tryReleaseShared(arg)) { //释放当前节点的后置等待节点 doReleaseShared(); return true; } return false; } \",\"tryReleaseShared 方法是Semaphore 的内部类 Sync 重写的一个方法， AbstractQueuedSynchronizer中的默认实现仅仅抛出 UnsupportedOperationException 异常。\",\"// 内部类 Sync 中重写的一个方法 // 尝试释放资源 protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); // 可用许可证+1 int next = current + releases; if (next < current) // overflow throw new Error(\\\"Maximum permit count exceeded\\\"); // CAS修改state的值 if (compareAndSetState(current, next)) return true; } } \",\"可以看到，上面提到的几个方法底层基本都是通过同步器 sync 实现的。Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer ，重写了其中的某些方法。并且，Sync 对应的还有两个子类 NonfairSync（对应非公平模式） 和 FairSync（对应公平模式）。\",\"private static final class Sync extends AbstractQueuedSynchronizer { // ... } static final class NonfairSync extends Sync { // ... } static final class FairSync extends Sync { // ... } \"]},\"749\":{\"h\":\"实战\",\"t\":[\"public class SemaphoreExample { // 请求的数量 private static final int threadCount = 550; public static void main(String[] args) throws InterruptedException { // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢） ExecutorService threadPool = Executors.newFixedThreadPool(300); // 初始许可证数量 final Semaphore semaphore = new Semaphore(20); for (int i = 0; i < threadCount; i++) { final int threadnum = i; threadPool.execute(() -> {// Lambda 表达式的运用 try { semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20 test(threadnum); semaphore.release();// 释放一个许可 } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } }); } threadPool.shutdown(); System.out.println(\\\"finish\\\"); } public static void test(int threadnum) throws InterruptedException { Thread.sleep(1000);// 模拟请求的耗时操作 System.out.println(\\\"threadnum:\\\" + threadnum); Thread.sleep(1000);// 模拟请求的耗时操作 } } \",\"执行 acquire() 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire() 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。\",\"当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：\",\"semaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4 test(threadnum); semaphore.release(5);// 释放5个许可 \",\"除了 acquire() 方法之外，另一个比较常用的与之对应的方法是 tryAcquire() 方法，该方法如果获取不到许可就立即返回 false。\",\"issue645 补充内容：\",\"Semaphore 与 CountDownLatch 一样，也是共享锁的一种实现。它默认构造 AQS 的 state 为 permits。当执行任务的线程数量超出 permits，那么多余的线程将会被放入等待队列 Park,并自旋判断 state 是否大于 0。只有当 state 大于 0 的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行 release() 方法，release() 方法使得 state 的变量会加 1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过 permits 数量的线程能自旋成功，便限制了执行任务线程的数量。\"]},\"750\":{\"h\":\"CountDownLatch （倒计时器）\"},\"751\":{\"h\":\"介绍\",\"t\":[\"CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\",\"CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\"]},\"752\":{\"h\":\"原理\",\"t\":[\"CountDownLatch 是共享锁的一种实现，它默认构造 AQS 的 state 值为 count。这个我们通过 CountDownLatch 的构造方法即可看出。\",\"public CountDownLatch(int count) { if (count < 0) throw new IllegalArgumentException(\\\"count < 0\\\"); this.sync = new Sync(count); } private static final class Sync extends AbstractQueuedSynchronizer { Sync(int count) { setState(count); } //... } \",\"当线程调用 countDown() 时，其实使用了tryReleaseShared方法以 CAS 的操作来减少 state，直至 state 为 0 。当 state 为 0 时，表示所有的线程都调用了 countDown 方法，那么在 CountDownLatch 上等待的线程就会被唤醒并继续执行。\",\"public void countDown() { // Sync 是 CountDownLatch 的内部类 , 继承了 AbstractQueuedSynchronizer sync.releaseShared(1); } \",\"releaseShared方法是 AbstractQueuedSynchronizer 中的默认实现。\",\"// 释放共享锁 // 如果 tryReleaseShared 返回 true，就唤醒等待队列中的一个或多个线程。 public final boolean releaseShared(int arg) { //释放共享锁 if (tryReleaseShared(arg)) { //释放当前节点的后置等待节点 doReleaseShared(); return true; } return false; } \",\"tryReleaseShared 方法是CountDownLatch 的内部类 Sync 重写的一个方法， AbstractQueuedSynchronizer中的默认实现仅仅抛出 UnsupportedOperationException 异常。\",\"// 对 state 进行递减，直到 state 变成 0； // 只有 count 递减到 0 时，countDown 才会返回 true protected boolean tryReleaseShared(int releases) { // 自选检查 state 是否为 0 for (;;) { int c = getState(); // 如果 state 已经是 0 了，直接返回 false if (c == 0) return false; // 对 state 进行递减 int nextc = c-1; // CAS 操作更新 state 的值 if (compareAndSetState(c, nextc)) return nextc == 0; } } \",\"以无参 await方法为例，当调用 await() 的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 就会一直阻塞，也就是说 await() 之后的语句不会被执行（main 线程被加入到等待队列也就是 CLH 队列中了）。然后，CountDownLatch 会自旋 CAS 判断 state == 0，如果 state == 0 的话，就会释放所有等待的线程，await() 方法之后的语句得到执行。\",\"// 等待（也可以叫做加锁） public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } // 带有超时时间的等待 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); } \",\"acquireSharedInterruptibly方法是 AbstractQueuedSynchronizer 中的默认实现。\",\"// 尝试获取锁，获取成功则返回，失败则加入等待队列，挂起线程 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 尝试获得锁，获取成功则返回 if (tryAcquireShared(arg) < 0) // 获取失败加入等待队列，挂起线程 doAcquireSharedInterruptibly(arg); } \",\"tryAcquireShared 方法是CountDownLatch 的内部类 Sync 重写的一个方法，其作用就是判断 state 的值是否为 0，是的话就返回 1，否则返回 -1。\",\"protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } \"]},\"753\":{\"h\":\"实战\",\"t\":[\"CountDownLatch 的两种典型用法：\",\"某一线程在开始运行前等待 n 个线程执行完毕 : 将 CountDownLatch 的计数器初始化为 n （new CountDownLatch(n)），每当一个任务线程执行完毕，就将计数器减 1 （countdownlatch.countDown()），当计数器的值变为 0 时，在 CountDownLatch 上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。\",\"实现多个线程开始执行任务的最大并行性：注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 （new CountDownLatch(1)），多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。\",\"CountDownLatch 代码示例：\",\"public class CountDownLatchExample { // 请求的数量 private static final int THREAD_COUNT = 550; public static void main(String[] args) throws InterruptedException { // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢） // 只是测试使用，实际场景请手动赋值线程池参数 ExecutorService threadPool = Executors.newFixedThreadPool(300); final CountDownLatch countDownLatch = new CountDownLatch(THREAD_COUNT); for (int i = 0; i < THREAD_COUNT; i++) { final int threadNum = i; threadPool.execute(() -> { try { test(threadNum); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 表示一个请求已经被完成 countDownLatch.countDown(); } }); } countDownLatch.await(); threadPool.shutdown(); System.out.println(\\\"finish\\\"); } public static void test(int threadnum) throws InterruptedException { Thread.sleep(1000); System.out.println(\\\"threadNum:\\\" + threadnum); Thread.sleep(1000); } } \",\"上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行System.out.println(\\\"finish\\\");。\",\"与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。\",\"其他 N 个线程必须引用闭锁对象，因为他们需要通知 CountDownLatch 对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 await()方法，恢复执行自己的任务。\",\"再插一嘴：CountDownLatch 的 await() 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：\",\"for (int i = 0; i < threadCount-1; i++) { ....... } \",\"这样就导致 count 的值没办法等于 0，然后就会导致一直等待。\"]},\"754\":{\"h\":\"CyclicBarrier(循环栅栏)\"},\"755\":{\"h\":\"介绍\",\"t\":[\"CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\",\"CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。\",\"CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。\"]},\"756\":{\"h\":\"原理\",\"t\":[\"CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。\",\"//每次拦截的线程数 private final int parties; //计数器 private int count; \",\"下面我们结合源码来简单看看。\",\"1、CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\",\"public CyclicBarrier(int parties) { this(parties, null); } public CyclicBarrier(int parties, Runnable barrierAction) { if (parties <= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; } \",\"其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。\",\"2、当调用 CyclicBarrier 对象调用 await() 方法时，实际上调用的是 dowait(false, 0L)方法。 await() 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。\",\"public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } \",\"dowait(false, 0L)方法源码分析如下：\",\" // 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。 private int count; /** * Main barrier code, covering the various policies. */ private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; // 锁住 lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); // 如果线程中断了，抛出异常 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } // count 减1 int index = --count; // 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件 if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 将 count 重置为 parties 属性的初始化值 // 唤醒之前等待的线程 // 下一波执行开始 nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // loop until tripped, broken, interrupted, or timed out for (;;) { try { if (!timed) trip.await(); else if (nanos > 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation && ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \\\"belong\\\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed && nanos <= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } \"]},\"757\":{\"h\":\"实战\",\"t\":[\"示例 1：\",\"public class CyclicBarrierExample1 { // 请求的数量 private static final int threadCount = 550; // 需要同步的线程数量 private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5); public static void main(String[] args) throws InterruptedException { // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); for (int i = 0; i < threadCount; i++) { final int threadNum = i; Thread.sleep(1000); threadPool.execute(() -> { try { test(threadNum); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } }); } threadPool.shutdown(); } public static void test(int threadnum) throws InterruptedException, BrokenBarrierException { System.out.println(\\\"threadnum:\\\" + threadnum + \\\"is ready\\\"); try { /**等待60秒，保证子线程完全执行结束*/ cyclicBarrier.await(60, TimeUnit.SECONDS); } catch (Exception e) { System.out.println(\\\"-----CyclicBarrierException------\\\"); } System.out.println(\\\"threadnum:\\\" + threadnum + \\\"is finish\\\"); } } \",\"运行结果，如下：\",\"threadnum:0is ready threadnum:1is ready threadnum:2is ready threadnum:3is ready threadnum:4is ready threadnum:4is finish threadnum:0is finish threadnum:1is finish threadnum:2is finish threadnum:3is finish threadnum:5is ready threadnum:6is ready threadnum:7is ready threadnum:8is ready threadnum:9is ready threadnum:9is finish threadnum:5is finish threadnum:8is finish threadnum:7is finish threadnum:6is finish ...... \",\"可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， await() 方法之后的方法才被执行。\",\"另外，CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。\",\"示例 2：\",\"public class CyclicBarrierExample2 { // 请求的数量 private static final int threadCount = 550; // 需要同步的线程数量 private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> { System.out.println(\\\"------当线程数达到之后，优先执行------\\\"); }); public static void main(String[] args) throws InterruptedException { // 创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); for (int i = 0; i < threadCount; i++) { final int threadNum = i; Thread.sleep(1000); threadPool.execute(() -> { try { test(threadNum); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } }); } threadPool.shutdown(); } public static void test(int threadnum) throws InterruptedException, BrokenBarrierException { System.out.println(\\\"threadnum:\\\" + threadnum + \\\"is ready\\\"); cyclicBarrier.await(); System.out.println(\\\"threadnum:\\\" + threadnum + \\\"is finish\\\"); } } \",\"运行结果，如下：\",\"threadnum:0is ready threadnum:1is ready threadnum:2is ready threadnum:3is ready threadnum:4is ready ------当线程数达到之后，优先执行------ threadnum:4is finish threadnum:0is finish threadnum:2is finish threadnum:1is finish threadnum:3is finish threadnum:5is ready threadnum:6is ready threadnum:7is ready threadnum:8is ready threadnum:9is ready ------当线程数达到之后，优先执行------ threadnum:9is finish threadnum:5is finish threadnum:6is finish threadnum:8is finish threadnum:7is finish ...... \"]},\"758\":{\"h\":\"参考\",\"t\":[\"Java 并发之 AQS 详解：https://www.cnblogs.com/waterystone/p/4920797.html\",\"从 ReentrantLock 的实现看 AQS 的原理及应用：https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\",\"File not found\"]},\"759\":{\"c\":[\"Java\"]},\"760\":{\"c\":[\"Java并发\"]},\"761\":{\"h\":\"Atomic 原子类总结\"},\"762\":{\"h\":\"Atomic 原子类介绍\",\"t\":[\"Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。\",\"所以，所谓原子类说简单点就是具有原子/原子操作特征的类。\",\"并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。\",\"JUC原子类概览\",\"根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类\",\"基本类型\",\"使用原子的方式更新基本类型\",\"AtomicInteger：整型原子类\",\"AtomicLong：长整型原子类\",\"AtomicBoolean：布尔型原子类\",\"数组类型\",\"使用原子的方式更新数组里的某个元素\",\"AtomicIntegerArray：整型数组原子类\",\"AtomicLongArray：长整型数组原子类\",\"AtomicReferenceArray：引用类型数组原子类\",\"引用类型\",\"AtomicReference：引用类型原子类\",\"AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"🐛 修正（参见：issue#626） : AtomicMarkableReference 不能解决 ABA 问题。\",\"对象的属性修改类型\",\"AtomicIntegerFieldUpdater:原子更新整型字段的更新器\",\"AtomicLongFieldUpdater：原子更新长整型字段的更新器\",\"AtomicReferenceFieldUpdater：原子更新引用类型里的字段\"]},\"763\":{\"h\":\"基本类型原子类\",\"t\":[\"使用原子的方式更新基本类型\",\"AtomicInteger：整型原子类\",\"AtomicLong：长整型原子类\",\"AtomicBoolean：布尔型原子类\",\"上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。\",\"AtomicInteger 类常用方法\",\"public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 \",\"AtomicInteger 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicInteger; public class AtomicIntegerTest { public static void main(String[] args) { int temvalue = 0; AtomicInteger i = new AtomicInteger(0); temvalue = i.getAndSet(3); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); //temvalue:0; i:3 temvalue = i.getAndIncrement(); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); //temvalue:3; i:4 temvalue = i.getAndAdd(5); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); //temvalue:4; i:9 } } \"]},\"764\":{\"h\":\"基本数据类型原子类的优势\",\"t\":[\"通过一个简单例子带大家看一下基本数据类型原子类的优势\",\"1、多线程环境不使用原子类保证线程安全（基本数据类型）\",\"class Test { private volatile int count = 0; //若要线程安全执行执行count++，需要加锁 public synchronized void increment() { count++; } public int getCount() { return count; } } \",\"2、多线程环境使用原子类保证线程安全（基本数据类型）\",\"class Test2 { private AtomicInteger count = new AtomicInteger(); public void increment() { count.incrementAndGet(); } //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() { return count.get(); } } \"]},\"765\":{\"h\":\"AtomicInteger 线程安全原理简单分析\",\"t\":[\"AtomicInteger 类的部分源码：\",\" // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用） private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\\\"value\\\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; \",\"AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。\",\"CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。\"]},\"766\":{\"h\":\"数组类型原子类\",\"t\":[\"使用原子的方式更新数组里的某个元素\",\"AtomicIntegerArray：整形数组原子类\",\"AtomicLongArray：长整形数组原子类\",\"AtomicReferenceArray：引用类型数组原子类\",\"上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。\",\"AtomicIntegerArray 类常用方法：\",\"public final int get(int i) //获取 index=i 位置元素的值 public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增 public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减 public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值 boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update） public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 \",\"AtomicIntegerArray 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicIntegerArray; public class AtomicIntegerArrayTest { public static void main(String[] args) { int temvalue = 0; int[] nums = { 1, 2, 3, 4, 5, 6 }; AtomicIntegerArray i = new AtomicIntegerArray(nums); for (int j = 0; j < nums.length; j++) { System.out.println(i.get(j)); } temvalue = i.getAndSet(0, 2); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); temvalue = i.getAndIncrement(0); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); temvalue = i.getAndAdd(0, 5); System.out.println(\\\"temvalue:\\\" + temvalue + \\\"; i:\\\" + i); } } \"]},\"767\":{\"h\":\"引用类型原子类\",\"t\":[\"基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。\",\"AtomicReference：引用类型原子类\",\"AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。\",\"上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。\",\"AtomicReference 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicReference; public class AtomicReferenceTest { public static void main(String[] args) { AtomicReference < Person > ar = new AtomicReference < Person > (); Person person = new Person(\\\"SnailClimb\\\", 22); ar.set(person); Person updatePerson = new Person(\\\"Daisy\\\", 20); ar.compareAndSet(person, updatePerson); System.out.println(ar.get().getName()); System.out.println(ar.get().getAge()); } } class Person { private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } \",\"上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：\",\"Daisy 20 \",\"AtomicStampedReference 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicStampedReference; public class AtomicStampedReferenceDemo { public static void main(String[] args) { // 实例化、取当前值和 stamp 值 final Integer initialRef = 0, initialStamp = 0; final AtomicStampedReference<Integer> asr = new AtomicStampedReference<>(initialRef, initialStamp); System.out.println(\\\"currentValue=\\\" + asr.getReference() + \\\", currentStamp=\\\" + asr.getStamp()); // compare and set final Integer newReference = 666, newStamp = 999; final boolean casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp); System.out.println(\\\"currentValue=\\\" + asr.getReference() + \\\", currentStamp=\\\" + asr.getStamp() + \\\", casResult=\\\" + casResult); // 获取当前的值和当前的 stamp 值 int[] arr = new int[1]; final Integer currentValue = asr.get(arr); final int currentStamp = arr[0]; System.out.println(\\\"currentValue=\\\" + currentValue + \\\", currentStamp=\\\" + currentStamp); // 单独设置 stamp 值 final boolean attemptStampResult = asr.attemptStamp(newReference, 88); System.out.println(\\\"currentValue=\\\" + asr.getReference() + \\\", currentStamp=\\\" + asr.getStamp() + \\\", attemptStampResult=\\\" + attemptStampResult); // 重新设置当前值和 stamp 值 asr.set(initialRef, initialStamp); System.out.println(\\\"currentValue=\\\" + asr.getReference() + \\\", currentStamp=\\\" + asr.getStamp()); // [不推荐使用，除非搞清楚注释的意思了] weak compare and set // 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191] // 但是注释上写着 \\\"May fail spuriously and does not provide ordering guarantees, // so is only rarely an appropriate alternative to compareAndSet.\\\" // todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发 final boolean wCasResult = asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp); System.out.println(\\\"currentValue=\\\" + asr.getReference() + \\\", currentStamp=\\\" + asr.getStamp() + \\\", wCasResult=\\\" + wCasResult); } } \",\"输出结果如下：\",\"currentValue=0, currentStamp=0 currentValue=666, currentStamp=999, casResult=true currentValue=666, currentStamp=999 currentValue=666, currentStamp=88, attemptStampResult=true currentValue=0, currentStamp=0 currentValue=666, currentStamp=999, wCasResult=true \",\"AtomicMarkableReference 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicMarkableReference; public class AtomicMarkableReferenceDemo { public static void main(String[] args) { // 实例化、取当前值和 mark 值 final Boolean initialRef = null, initialMark = false; final AtomicMarkableReference<Boolean> amr = new AtomicMarkableReference<>(initialRef, initialMark); System.out.println(\\\"currentValue=\\\" + amr.getReference() + \\\", currentMark=\\\" + amr.isMarked()); // compare and set final Boolean newReference1 = true, newMark1 = true; final boolean casResult = amr.compareAndSet(initialRef, newReference1, initialMark, newMark1); System.out.println(\\\"currentValue=\\\" + amr.getReference() + \\\", currentMark=\\\" + amr.isMarked() + \\\", casResult=\\\" + casResult); // 获取当前的值和当前的 mark 值 boolean[] arr = new boolean[1]; final Boolean currentValue = amr.get(arr); final boolean currentMark = arr[0]; System.out.println(\\\"currentValue=\\\" + currentValue + \\\", currentMark=\\\" + currentMark); // 单独设置 mark 值 final boolean attemptMarkResult = amr.attemptMark(newReference1, false); System.out.println(\\\"currentValue=\\\" + amr.getReference() + \\\", currentMark=\\\" + amr.isMarked() + \\\", attemptMarkResult=\\\" + attemptMarkResult); // 重新设置当前值和 mark 值 amr.set(initialRef, initialMark); System.out.println(\\\"currentValue=\\\" + amr.getReference() + \\\", currentMark=\\\" + amr.isMarked()); // [不推荐使用，除非搞清楚注释的意思了] weak compare and set // 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191] // 但是注释上写着 \\\"May fail spuriously and does not provide ordering guarantees, // so is only rarely an appropriate alternative to compareAndSet.\\\" // todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发 final boolean wCasResult = amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1); System.out.println(\\\"currentValue=\\\" + amr.getReference() + \\\", currentMark=\\\" + amr.isMarked() + \\\", wCasResult=\\\" + wCasResult); } } \",\"输出结果如下：\",\"currentValue=null, currentMark=false currentValue=true, currentMark=true, casResult=true currentValue=true, currentMark=true currentValue=true, currentMark=false, attemptMarkResult=true currentValue=null, currentMark=false currentValue=true, currentMark=true, wCasResult=true \"]},\"768\":{\"h\":\"对象的属性修改类型原子类\",\"t\":[\"如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。\",\"AtomicIntegerFieldUpdater:原子更新整形字段的更新器\",\"AtomicLongFieldUpdater：原子更新长整形字段的更新器\",\"AtomicReferenceFieldUpdater：原子更新引用类型里的字段的更新器\",\"要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。\",\"上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerFieldUpdater为例子来介绍。\",\"AtomicIntegerFieldUpdater 类使用示例 :\",\"import java.util.concurrent.atomic.AtomicIntegerFieldUpdater; public class AtomicIntegerFieldUpdaterTest { public static void main(String[] args) { AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, \\\"age\\\"); User user = new User(\\\"Java\\\", 22); System.out.println(a.getAndIncrement(user));// 22 System.out.println(a.get(user));// 23 } } class User { private String name; public volatile int age; public User(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } \",\"输出结果：\",\"22 23 \"]},\"769\":{\"h\":\"参考\",\"t\":[\"《Java 并发编程的艺术》\",\"File not found\"]},\"770\":{\"c\":[\"Java\"]},\"771\":{\"c\":[\"Java并发\"]},\"772\":{\"h\":\"CompletableFuture 详解\",\"t\":[\"一个接口可能需要调用 N 个其他服务的接口，这在项目开发中还是挺常见的。举个例子：用户请求获取订单信息，可能需要调用用户信息、商品详情、物流信息、商品推荐等接口，最后再汇总数据统一返回。\",\"如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些接口之间有大部分都是 无前后顺序关联 的，可以 并行执行 ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。\",\"serial-to-parallel\",\"对于存在前后顺序关系的接口调用，可以进行编排，如下图所示。\",\"获取用户信息之后，才能调用商品详情和物流信息接口。\",\"成功获取商品详情和物流信息之后，才能调用商品推荐接口。\",\"对于 Java 程序来说，Java 8 才被引入的 CompletableFuture 可以帮助我们来做多个任务的编排，功能非常强大。\",\"这篇文章是 CompletableFuture 的简单入门，带大家看看 CompletableFuture 常用的 API。\"]},\"773\":{\"h\":\"Future 介绍\",\"t\":[\"Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\",\"这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。\",\"在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：\",\"取消任务；\",\"判断任务是否被取消;\",\"判断任务是否已经执行完成;\",\"获取任务执行结果。\",\"// V 代表了Future执行的任务返回值的类型 public interface Future<V> { // 取消任务执行 // 成功取消返回 true，否则返回 false boolean cancel(boolean mayInterruptIfRunning); // 判断任务是否被取消 boolean isCancelled(); // 判断任务是否已经执行完成 boolean isDone(); // 获取任务执行结果 V get() throws InterruptedException, ExecutionException; // 指定时间内没有返回计算结果就抛出 TimeOutException 异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptio } \",\"简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。\"]},\"774\":{\"h\":\"CompletableFuture 介绍\",\"t\":[\"Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\",\"Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\",\"下面我们来简单看看 CompletableFuture 类的定义。\",\"public class CompletableFuture<T> implements Future<T>, CompletionStage<T> { } \",\"可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。\",\"CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\",\"CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程的能力。\",\"Future 接口有 5 个方法：\",\"boolean cancel(boolean mayInterruptIfRunning)：尝试取消执行任务。\",\"boolean isCancelled()：判断任务是否被取消。\",\"boolean isDone()：判断任务是否已经被执行完成。\",\"get()：等待任务执行完成并获取运算结果。\",\"get(long timeout, TimeUnit unit)：多了一个超时时间。\",\"CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\",\"CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。\",\"由于方法众多，所以这里不能一一讲解，下文中我会介绍大部分常见方法的使用。\"]},\"775\":{\"h\":\"CompletableFuture 常见操作\"},\"776\":{\"h\":\"创建 CompletableFuture\",\"t\":[\"常见的创建 CompletableFuture 对象的方法如下：\",\"通过 new 关键字。\",\"基于 CompletableFuture 自带的静态工厂方法：runAsync()、supplyAsync() 。\"]},\"777\":{\"h\":\"new 关键字\",\"t\":[\"通过 new 关键字创建 CompletableFuture 对象这种使用方式可以看作是将 CompletableFuture 当做 Future 来使用。\",\"我在我的开源项目 guide-rpc-framework 中就是这种方式创建的 CompletableFuture 对象。\",\"下面咱们来看一个简单的案例。\",\"我们通过创建了一个结果值类型为 RpcResponse<Object> 的 CompletableFuture，你可以把 resultFuture 看作是异步运算结果的载体。\",\"CompletableFuture<RpcResponse<Object>> resultFuture = new CompletableFuture<>(); \",\"假设在未来的某个时刻，我们得到了最终的结果。这时，我们可以调用 complete() 方法为其传入结果，这表示 resultFuture 已经被完成了。\",\"// complete() 方法只能调用一次，后续调用将被忽略。 resultFuture.complete(rpcResponse); \",\"你可以通过 isDone() 方法来检查是否已经完成。\",\"public boolean isDone() { return result != null; } \",\"获取异步计算的结果也非常简单，直接调用 get() 方法即可。调用 get() 方法的线程会阻塞直到 CompletableFuture 完成运算。\",\"rpcResponse = completableFuture.get(); \",\"如果你已经知道计算的结果的话，可以使用静态方法 completedFuture() 来创建 CompletableFuture 。\",\"CompletableFuture<String> future = CompletableFuture.completedFuture(\\\"hello!\\\"); assertEquals(\\\"hello!\\\", future.get()); \",\"completedFuture() 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。\",\"public static <U> CompletableFuture<U> completedFuture(U value) { return new CompletableFuture<U>((value == null) ? NIL : value); } \"]},\"778\":{\"h\":\"静态工厂方法\",\"t\":[\"这两个方法可以帮助我们封装计算逻辑。\",\"static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier); // 使用自定义线程池(推荐) static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor); static CompletableFuture<Void> runAsync(Runnable runnable); // 使用自定义线程池(推荐) static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor); \",\"runAsync() 方法接受的参数是 Runnable ，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用 runAsync() 方法。\",\"@FunctionalInterface public interface Runnable { public abstract void run(); } \",\"supplyAsync() 方法接受的参数是 Supplier<U> ，这也是一个函数式接口，U 是返回结果值的类型。\",\"@FunctionalInterface public interface Supplier<T> { /** * Gets a result. * * @return a result */ T get(); } \",\"当你需要异步操作且关心返回结果的时候,可以使用 supplyAsync() 方法。\",\"CompletableFuture<Void> future = CompletableFuture.runAsync(() -> System.out.println(\\\"hello!\\\")); future.get();// 输出 \\\"hello!\\\" CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> \\\"hello!\\\"); assertEquals(\\\"hello!\\\", future2.get()); \"]},\"779\":{\"h\":\"处理异步结算的结果\",\"t\":[\"当我们获取到异步计算的结果之后，还可以对其进行进一步的处理，比较常用的方法有下面几个：\",\"thenApply()\",\"thenAccept()\",\"thenRun()\",\"whenComplete()\",\"thenApply() 方法接受一个 Function 实例，用它来处理结果。\",\"// 沿用上一个任务的线程池 public <U> CompletableFuture<U> thenApply( Function<? super T,? extends U> fn) { return uniApplyStage(null, fn); } //使用默认的 ForkJoinPool 线程池（不推荐） public <U> CompletableFuture<U> thenApplyAsync( Function<? super T,? extends U> fn) { return uniApplyStage(defaultExecutor(), fn); } // 使用自定义线程池(推荐) public <U> CompletableFuture<U> thenApplyAsync( Function<? super T,? extends U> fn, Executor executor) { return uniApplyStage(screenExecutor(executor), fn); } \",\"thenApply() 方法使用示例如下：\",\"CompletableFuture<String> future = CompletableFuture.completedFuture(\\\"hello!\\\") .thenApply(s -> s + \\\"world!\\\"); assertEquals(\\\"hello!world!\\\", future.get()); // 这次调用将被忽略。 future.thenApply(s -> s + \\\"nice!\\\"); assertEquals(\\\"hello!world!\\\", future.get()); \",\"你还可以进行 流式调用：\",\"CompletableFuture<String> future = CompletableFuture.completedFuture(\\\"hello!\\\") .thenApply(s -> s + \\\"world!\\\").thenApply(s -> s + \\\"nice!\\\"); assertEquals(\\\"hello!world!nice!\\\", future.get()); \",\"如果你不需要从回调函数中获取返回结果，可以使用 thenAccept() 或者 thenRun()。这两个方法的区别在于 thenRun() 不能访问异步计算的结果。\",\"thenAccept() 方法的参数是 Consumer<? super T> 。\",\"public CompletableFuture<Void> thenAccept(Consumer<? super T> action) { return uniAcceptStage(null, action); } public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action) { return uniAcceptStage(defaultExecutor(), action); } public CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor) { return uniAcceptStage(screenExecutor(executor), action); } \",\"顾名思义，Consumer 属于消费型接口，它可以接收 1 个输入对象然后进行“消费”。\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"thenRun() 的方法是的参数是 Runnable 。\",\"public CompletableFuture<Void> thenRun(Runnable action) { return uniRunStage(null, action); } public CompletableFuture<Void> thenRunAsync(Runnable action) { return uniRunStage(defaultExecutor(), action); } public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor) { return uniRunStage(screenExecutor(executor), action); } \",\"thenAccept() 和 thenRun() 使用示例如下：\",\"CompletableFuture.completedFuture(\\\"hello!\\\") .thenApply(s -> s + \\\"world!\\\").thenApply(s -> s + \\\"nice!\\\").thenAccept(System.out::println);//hello!world!nice! CompletableFuture.completedFuture(\\\"hello!\\\") .thenApply(s -> s + \\\"world!\\\").thenApply(s -> s + \\\"nice!\\\").thenRun(() -> System.out.println(\\\"hello!\\\"));//hello! \",\"whenComplete() 的方法的参数是 BiConsumer<? super T, ? super Throwable> 。\",\"public CompletableFuture<T> whenComplete( BiConsumer<? super T, ? super Throwable> action) { return uniWhenCompleteStage(null, action); } public CompletableFuture<T> whenCompleteAsync( BiConsumer<? super T, ? super Throwable> action) { return uniWhenCompleteStage(defaultExecutor(), action); } // 使用自定义线程池(推荐) public CompletableFuture<T> whenCompleteAsync( BiConsumer<? super T, ? super Throwable> action, Executor executor) { return uniWhenCompleteStage(screenExecutor(executor), action); } \",\"相对于 Consumer ， BiConsumer 可以接收 2 个输入对象然后进行“消费”。\",\"@FunctionalInterface public interface BiConsumer<T, U> { void accept(T t, U u); default BiConsumer<T, U> andThen(BiConsumer<? super T, ? super U> after) { Objects.requireNonNull(after); return (l, r) -> { accept(l, r); after.accept(l, r); }; } } \",\"whenComplete() 使用示例如下：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"hello!\\\") .whenComplete((res, ex) -> { // res 代表返回的结果 // ex 的类型为 Throwable ，代表抛出的异常 System.out.println(res); // 这里没有抛出异常所有为 null assertNull(ex); }); assertEquals(\\\"hello!\\\", future.get()); \"]},\"780\":{\"h\":\"异常处理\",\"t\":[\"你可以通过 handle() 方法来处理任务执行过程中可能出现的抛出异常的情况。\",\"public <U> CompletableFuture<U> handle( BiFunction<? super T, Throwable, ? extends U> fn) { return uniHandleStage(null, fn); } public <U> CompletableFuture<U> handleAsync( BiFunction<? super T, Throwable, ? extends U> fn) { return uniHandleStage(defaultExecutor(), fn); } public <U> CompletableFuture<U> handleAsync( BiFunction<? super T, Throwable, ? extends U> fn, Executor executor) { return uniHandleStage(screenExecutor(executor), fn); } \",\"示例代码如下：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (true) { throw new RuntimeException(\\\"Computation error!\\\"); } return \\\"hello!\\\"; }).handle((res, ex) -> { // res 代表返回的结果 // ex 的类型为 Throwable ，代表抛出的异常 return res != null ? res : \\\"world!\\\"; }); assertEquals(\\\"world!\\\", future.get()); \",\"你还可以通过 exceptionally() 方法来处理异常情况。\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { if (true) { throw new RuntimeException(\\\"Computation error!\\\"); } return \\\"hello!\\\"; }).exceptionally(ex -> { System.out.println(ex.toString());// CompletionException return \\\"world!\\\"; }); assertEquals(\\\"world!\\\", future.get()); \",\"如果你想让 CompletableFuture 的结果就是异常的话，可以使用 completeExceptionally() 方法为其赋值。\",\"CompletableFuture<String> completableFuture = new CompletableFuture<>(); // ... completableFuture.completeExceptionally( new RuntimeException(\\\"Calculation failed!\\\")); // ... completableFuture.get(); // ExecutionException \"]},\"781\":{\"h\":\"组合 CompletableFuture\",\"t\":[\"你可以使用 thenCompose() 按顺序链接两个 CompletableFuture 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系。\",\"public <U> CompletableFuture<U> thenCompose( Function<? super T, ? extends CompletionStage<U>> fn) { return uniComposeStage(null, fn); } public <U> CompletableFuture<U> thenComposeAsync( Function<? super T, ? extends CompletionStage<U>> fn) { return uniComposeStage(defaultExecutor(), fn); } public <U> CompletableFuture<U> thenComposeAsync( Function<? super T, ? extends CompletionStage<U>> fn, Executor executor) { return uniComposeStage(screenExecutor(executor), fn); } \",\"thenCompose() 方法会使用示例如下：\",\"CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> \\\"hello!\\\") .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + \\\"world!\\\")); assertEquals(\\\"hello!world!\\\", future.get()); \",\"在实际开发中，这个方法还是非常有用的。比如说，task1 和 task2 都是异步执行的，但 task1 必须执行完成后才能开始执行 task2（task2 依赖 task1 的执行结果）。\",\"和 thenCompose() 方法类似的还有 thenCombine() 方法， 它同样可以组合两个 CompletableFuture 对象。\",\"CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> \\\"hello!\\\") .thenCombine(CompletableFuture.supplyAsync( () -> \\\"world!\\\"), (s1, s2) -> s1 + s2) .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + \\\"nice!\\\")); assertEquals(\\\"hello!world!nice!\\\", completableFuture.get()); \",\"那 thenCompose() 和 thenCombine() 有什么区别呢？\",\"thenCompose() 可以链接两个 CompletableFuture 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。\",\"thenCombine() 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。\",\"除了 thenCompose() 和 thenCombine() 之外， 还有一些其他的组合 CompletableFuture 的方法用于实现不同的效果，满足不同的业务需求。\",\"例如，如果我们想要实现 task1 和 task2 中的任意一个任务执行完后就执行 task3 的话，可以使用 acceptEither()。\",\"public CompletableFuture<Void> acceptEither( CompletionStage<? extends T> other, Consumer<? super T> action) { return orAcceptStage(null, other, action); } public CompletableFuture<Void> acceptEitherAsync( CompletionStage<? extends T> other, Consumer<? super T> action) { return orAcceptStage(asyncPool, other, action); } \",\"简单举一个例子：\",\"CompletableFuture<String> task = CompletableFuture.supplyAsync(() -> { System.out.println(\\\"任务1开始执行，当前时间：\\\" + System.currentTimeMillis()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"任务1执行完毕，当前时间：\\\" + System.currentTimeMillis()); return \\\"task1\\\"; }); CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> { System.out.println(\\\"任务2开始执行，当前时间：\\\" + System.currentTimeMillis()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"任务2执行完毕，当前时间：\\\" + System.currentTimeMillis()); return \\\"task2\\\"; }); task.acceptEitherAsync(task2, (res) -> { System.out.println(\\\"任务3开始执行，当前时间：\\\" + System.currentTimeMillis()); System.out.println(\\\"上一个任务的结果为：\\\" + res); }); // 增加一些延迟时间，确保异步任务有足够的时间完成 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } \",\"输出：\",\"任务1开始执行，当前时间：1695088058520 任务2开始执行，当前时间：1695088058521 任务1执行完毕，当前时间：1695088059023 任务3开始执行，当前时间：1695088059023 上一个任务的结果为：task1 任务2执行完毕，当前时间：1695088059523 \",\"任务组合操作acceptEitherAsync()会在异步任务 1 和异步任务 2 中的任意一个完成时触发执行任务 3，但是需要注意，这个触发时机是不确定的。如果任务 1 和任务 2 都还未完成，那么任务 3 就不能被执行。\"]},\"782\":{\"h\":\"并行运行多个 CompletableFuture\",\"t\":[\"你可以通过 CompletableFuture 的 allOf()这个静态方法来并行运行多个 CompletableFuture 。\",\"实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务之间没有依赖关系，可以互相独立地运行。\",\"比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 CompletableFuture 来处理。\",\"示例代码如下：\",\"CompletableFuture<Void> task1 = CompletableFuture.supplyAsync(()->{ //自定义业务操作 }); ...... CompletableFuture<Void> task6 = CompletableFuture.supplyAsync(()->{ //自定义业务操作 }); ...... CompletableFuture<Void> headerFuture=CompletableFuture.allOf(task1,.....,task6); try { headerFuture.join(); } catch (Exception ex) { ...... } System.out.println(\\\"all done. \\\"); \",\"经常和 allOf() 方法拿来对比的是 anyOf() 方法。\",\"allOf() 方法会等到所有的 CompletableFuture 都运行完成之后再返回\",\"Random rand = new Random(); CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000 + rand.nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\\\"future1 done...\\\"); } return \\\"abc\\\"; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(1000 + rand.nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\\\"future2 done...\\\"); } return \\\"efg\\\"; }); \",\"调用 join() 可以让程序等future1 和 future2 都运行完了之后再继续执行。\",\"CompletableFuture<Void> completableFuture = CompletableFuture.allOf(future1, future2); completableFuture.join(); assertTrue(completableFuture.isDone()); System.out.println(\\\"all futures done...\\\"); \",\"输出：\",\"future1 done... future2 done... all futures done... \",\"anyOf() 方法不会等待所有的 CompletableFuture 都运行完成之后再返回，只要有一个执行完成即可！\",\"CompletableFuture<Object> f = CompletableFuture.anyOf(future1, future2); System.out.println(f.get()); \",\"输出结果可能是：\",\"future2 done... efg \",\"也可能是：\",\"future1 done... abc \"]},\"783\":{\"h\":\"CompletableFuture 使用建议\"},\"784\":{\"h\":\"使用自定义线程池\",\"t\":[\"我们上面的代码示例中，为了方便，都没有选择自定义线程池。实际项目中，这是不可取的。\",\"CompletableFuture 默认使用ForkJoinPool.commonPool() 作为执行器，这个线程池是全局共享的，可能会被其他任务占用，导致性能下降或者饥饿。因此，建议使用自定义的线程池来执行 CompletableFuture 的异步任务，可以提高并发度和灵活性。\",\"private ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); CompletableFuture.runAsync(() -> { //... }, executor); \"]},\"785\":{\"h\":\"尽量避免使用 get()\",\"t\":[\"CompletableFuture的get()方法是阻塞的，尽量避免使用。如果必须要使用的话，需要添加超时时间，否则可能会导致主线程一直等待，无法执行其他任务。\",\" CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> { try { Thread.sleep(10_000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"Hello, world!\\\"; }); // 获取异步任务的返回值，设置超时时间为 5 秒 try { String result = future.get(5, TimeUnit.SECONDS); System.out.println(result); } catch (InterruptedException | ExecutionException | TimeoutException e) { // 处理异常 e.printStackTrace(); } } \",\"上面这段代码在调用 get() 时抛出了 TimeoutException 异常。这样我们就可以在异常处理中进行相应的操作，比如取消任务、重试任务、记录日志等。\"]},\"786\":{\"h\":\"正确进行异常处理\",\"t\":[\"使用 CompletableFuture的时候一定要以正确的方式进行异常处理，避免异常丢失或者出现不可控问题。\",\"下面是一些建议：\",\"使用 whenComplete 方法可以在任务完成时触发回调函数，并正确地处理异常，而不是让异常被吞噬或丢失。\",\"使用 exceptionally 方法可以处理异常并重新抛出，以便异常能够传播到后续阶段，而不是让异常被忽略或终止。\",\"使用 handle 方法可以处理正常的返回结果和异常，并返回一个新的结果，而不是让异常影响正常的业务逻辑。\",\"使用 CompletableFuture.allOf 方法可以组合多个 CompletableFuture，并统一处理所有任务的异常，而不是让异常处理过于冗长或重复。\",\"……\"]},\"787\":{\"h\":\"合理组合多个异步任务\",\"t\":[\"正确使用 thenCompose() 、 thenCombine() 、acceptEither()、allOf()、anyOf()等方法来组合多个异步任务，以满足实际业务的需求，提高程序执行效率。\",\"实际使用中，我们还可以利用或者参考现成的异步任务编排框架，比如京东的 asyncTool 。\",\"asyncTool README 文档\"]},\"788\":{\"h\":\"后记\",\"t\":[\"这篇文章只是简单介绍了 CompletableFuture 的核心概念和比较常用的一些 API 。如果想要深入学习的话，还可以多找一些书籍和博客看，比如下面几篇文章就挺不错：\",\"CompletableFuture 原理与实践-外卖商家端 API 的异步化 - 美团技术团队：这篇文章详细介绍了 CompletableFuture 在实际项目中的运用。参考这篇文章，可以对项目中类似的场景进行优化，也算是一个小亮点了。这种性能优化方式比较简单且效果还不错！\",\"读 RocketMQ 源码，学习并发编程三大神器 - 勇哥 java 实战分享：这篇文章介绍了 RocketMQ 对CompletableFuture的应用。具体来说，从 RocketMQ 4.7 开始，RocketMQ 引入了 CompletableFuture来实现异步消息处理 。\",\"另外，建议 G 友们可以看看京东的 asyncTool 这个并发框架，里面大量使用到了 CompletableFuture 。\",\"File not found\"]},\"789\":{\"c\":[\"Java\"]},\"790\":{\"c\":[\"Java并发\"]},\"791\":{\"h\":\"Java 常见并发容器总结\",\"t\":[\"JDK 提供的这些容器大部分在 java.util.concurrent 包中。\",\"ConcurrentHashMap : 线程安全的 HashMap\",\"CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。\",\"ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。\",\"BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。\",\"ConcurrentSkipListMap : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。\"]},\"792\":{\"h\":\"ConcurrentHashMap\",\"t\":[\"我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 Collections.synchronizedMap() 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。\",\"所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。\",\"在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。\",\"到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。\",\"关于 ConcurrentHashMap 的详细介绍，请看我写的这篇文章：ConcurrentHashMap 源码分析。\"]},\"793\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"在 JDK1.5 之前，如果想要使用并发安全的 List 只能选择 Vector。而 Vector 是一种老旧的集合，已经被淘汰。Vector 对于增删改查等方法基本都加了 synchronized，这种方式虽然能够保证同步，但这相当于对整个 Vector 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。\",\"JDK1.5 引入了 Java.util.concurrent（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 List 实现就是 CopyOnWriteArrayList 。\",\"对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 List 的内部数据，毕竟对于读取操作来说是安全的。\",\"这种思路与 ReentrantReadWriteLock 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。CopyOnWriteArrayList 更进一步地实现了这一思想。为了将读操作性能发挥到极致，CopyOnWriteArrayList 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。\",\"CopyOnWriteArrayList 线程安全的核心在于其采用了 写时复制（Copy-On-Write） 的策略，从 CopyOnWriteArrayList 的名字就能看出了。\",\"当需要修改（ add，set、remove 等操作） CopyOnWriteArrayList 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。\",\"关于 CopyOnWriteArrayList 的详细介绍，请看我写的这篇文章：CopyOnWriteArrayList 源码分析。\"]},\"794\":{\"h\":\"ConcurrentLinkedQueue\",\"t\":[\"Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\",\"从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\",\"ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。\",\"ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\"]},\"795\":{\"h\":\"BlockingQueue\"},\"796\":{\"h\":\"BlockingQueue 简介\",\"t\":[\"上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\",\"BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：\",\"BlockingQueue 的实现类\",\"下面主要介绍一下 3 个常见的 BlockingQueue 的实现类：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue 。\"]},\"797\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。\",\"public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable{} \",\"ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。\",\"ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：\",\"private static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true); \"]},\"798\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE 。\",\"相关构造方法:\",\" /** *某种意义上的无界队列 * Creates a {@code LinkedBlockingQueue} with a capacity of * {@link Integer#MAX_VALUE}. */ public LinkedBlockingQueue() { this(Integer.MAX_VALUE); } /** *有界队列 * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if {@code capacity} is not greater * than zero */ public LinkedBlockingQueue(int capacity) { if (capacity <= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node<E>(null); } \"]},\"799\":{\"h\":\"PriorityBlockingQueue\",\"t\":[\"PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\",\"PriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。\",\"简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。\",\"推荐文章：《解读 Java 并发队列 BlockingQueue》\"]},\"800\":{\"h\":\"ConcurrentSkipListMap\",\"t\":[\"下面这部分内容参考了极客时间专栏《数据结构与算法之美》以及《实战 Java 高并发程序设计》。\",\"为了引出 ConcurrentSkipListMap，先带着大家简单理解一下跳表。\",\"对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。\",\"跳表的本质是同时维护了多个链表，并且链表是分层的，\",\"2级索引跳表\",\"最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。\",\"跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。\",\"在跳表中查找元素18\",\"查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。\",\"从上面很容易看出，跳表是一种利用空间换时间的算法。\",\"使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。\"]},\"801\":{\"h\":\"参考\",\"t\":[\"《实战 Java 高并发程序设计》\",\"https://javadoop.com/post/java-concurrent-queue\",\"https://juejin.im/post/5aeebd02518825672f19c546\",\"File not found\"]},\"802\":{\"c\":[\"Java\"]},\"803\":{\"c\":[\"Java并发\"]},\"804\":{\"h\":\"Java并发常见面试题总结（上）\",\"t\":[\"File not found\"]},\"805\":{\"h\":\"什么是线程和进程?\"},\"806\":{\"h\":\"何为进程?\",\"t\":[\"进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。\",\"在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。\",\"如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（.exe 文件的运行）。\",\"进程示例图片-Windows\"]},\"807\":{\"h\":\"何为线程?\",\"t\":[\"线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\",\"Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。\",\"public class MultiThread { public static void main(String[] args) { // 获取 Java 线程管理 MXBean ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean(); // 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息 ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false); // 遍历线程信息，仅打印线程 ID 和线程名称信息 for (ThreadInfo threadInfo : threadInfos) { System.out.println(\\\"[\\\" + threadInfo.getThreadId() + \\\"] \\\" + threadInfo.getThreadName()); } } } \",\"上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：\",\"[5] Attach Listener //添加事件 [4] Signal Dispatcher // 分发处理给 JVM 信号的线程 [3] Finalizer //调用对象 finalize 方法的线程 [2] Reference Handler //清除 reference 线程 [1] main //main 线程,程序入口 \",\"从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。\"]},\"808\":{\"h\":\"Java 线程和操作系统的线程有啥区别？\",\"t\":[\"JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。由于绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核），在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。\",\"我们上面提到了用户线程和内核线程，考虑到很多读者不太了解二者的区别，这里简单介绍一下：\",\"用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。\",\"内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。\",\"顺便简单总结一下用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。\",\"一句话概括 Java 线程和操作系统线程的关系：现在的 Java 线程的本质其实就是操作系统的线程。\",\"线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：\",\"一对一（一个用户线程对应一个内核线程）\",\"多对一（多个用户线程映射到一个内核线程）\",\"多对多（多个用户线程映射到多个内核线程）\",\"常见的三种线程模型\",\"在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个 Java 线程对应一个系统内核线程。Solaris 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: JVM 中的线程模型是用户级的么？。\",\"虚拟线程在 JDK 21 顺利转正，关于虚拟线程、平台线程（也就是我们上面提到的 Java 线程）和内核线程三者的关系可以阅读我写的这篇文章：Java 20 新特性概览。\"]},\"809\":{\"h\":\"请简要描述线程与进程的关系,区别及优缺点？\",\"t\":[\"从 JVM 角度说进程和线程之间的关系。\"]},\"810\":{\"h\":\"图解进程和线程的关系\",\"t\":[\"下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。\",\"Java 运行时数据区域（JDK1.8 之后）\",\"从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。\",\"总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。\",\"下面是该知识点的扩展内容！\",\"下面来思考这样一个问题：为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？\"]},\"811\":{\"h\":\"程序计数器为什么是私有的?\",\"t\":[\"程序计数器主要有下面两个作用：\",\"字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\",\"在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\",\"需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。\",\"所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\"]},\"812\":{\"h\":\"虚拟机栈和本地方法栈为什么是私有的?\",\"t\":[\"虚拟机栈： 每个 Java 方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\",\"本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\",\"所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。\"]},\"813\":{\"h\":\"一句话简单了解堆和方法区\",\"t\":[\"堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\"]},\"814\":{\"h\":\"并发与并行的区别\",\"t\":[\"并发：两个及两个以上的作业在同一 时间段 内执行。\",\"并行：两个及两个以上的作业在同一 时刻 执行。\",\"最关键的点是：是否是 同时 执行。\"]},\"815\":{\"h\":\"同步和异步的区别\",\"t\":[\"同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。\",\"异步：调用在发出之后，不用等待返回结果，该调用直接返回。\"]},\"816\":{\"h\":\"为什么要使用多线程?\",\"t\":[\"先从总体上来说：\",\"从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\",\"从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\",\"再深入到计算机底层来探讨：\",\"单核时代：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。\",\"多核时代: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。\"]},\"817\":{\"h\":\"使用多线程可能带来什么问题?\",\"t\":[\"并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。\"]},\"818\":{\"h\":\"如何理解线程安全和不安全？\",\"t\":[\"线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。\",\"线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。\",\"线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。\"]},\"819\":{\"h\":\"单核 CPU 上运行多个线程效率一定会高吗？\",\"t\":[\"单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。\",\"在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。\",\"因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。\"]},\"820\":{\"h\":\"说说线程的生命周期和状态?\",\"t\":[\"Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：\",\"NEW: 初始状态，线程被创建出来但没有被调用 start() 。\",\"RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。\",\"BLOCKED：阻塞状态，需要等待锁释放。\",\"WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。\",\"TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。\",\"TERMINATED：终止状态，表示该线程已经运行完毕。\",\"线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。\",\"Java 线程状态变迁图(图源：挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误)：\",\"Java 线程状态变迁图\",\"由上图可以看出：线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。\",\"在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。\",\"为什么 JVM 没有区分这两种状态呢？ （摘自：Java 线程运行怎么有第六种状态？ - Dawell 的回答 ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。\",\"RUNNABLE-VS-RUNNING\",\"当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。\",\"TIMED_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。\",\"当线程进入 synchronized 方法/块或者调用 wait 后（被 notify）重新进入 synchronized 方法/块，但是锁被其它线程占有，这个时候线程就会进入 BLOCKED（阻塞） 状态。\",\"线程在执行完了 run()方法之后将会进入到 TERMINATED（终止） 状态。\",\"相关阅读：线程的几种状态你真的了解么？ 。\"]},\"821\":{\"h\":\"什么是线程上下文切换?\",\"t\":[\"线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。\",\"主动让出 CPU，比如调用了 sleep(), wait() 等。\",\"时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。\",\"调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。\",\"被终止或结束运行\",\"这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 上下文切换。\",\"上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。\"]},\"822\":{\"h\":\"什么是线程死锁?如何避免死锁?\"},\"823\":{\"h\":\"认识线程死锁\",\"t\":[\"线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。\",\"如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\",\"线程死锁示意图 \",\"下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：\",\"public class DeadLockDemo { private static Object resource1 = new Object();//资源 1 private static Object resource2 = new Object();//资源 2 public static void main(String[] args) { new Thread(() -> { synchronized (resource1) { System.out.println(Thread.currentThread() + \\\"get resource1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \\\"waiting get resource2\\\"); synchronized (resource2) { System.out.println(Thread.currentThread() + \\\"get resource2\\\"); } } }, \\\"线程 1\\\").start(); new Thread(() -> { synchronized (resource2) { System.out.println(Thread.currentThread() + \\\"get resource2\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \\\"waiting get resource1\\\"); synchronized (resource1) { System.out.println(Thread.currentThread() + \\\"get resource1\\\"); } } }, \\\"线程 2\\\").start(); } } \",\"Output\",\"Thread[线程 1,5,main]get resource1 Thread[线程 2,5,main]get resource2 Thread[线程 1,5,main]waiting get resource2 Thread[线程 2,5,main]waiting get resource1 \",\"线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。\",\"上面的例子符合产生死锁的四个必要条件：\",\"互斥条件：该资源任意一个时刻只由一个线程占用。\",\"请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\",\"不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。\",\"循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。\"]},\"824\":{\"h\":\"如何预防和避免线程死锁?\",\"t\":[\"如何预防死锁？ 破坏死锁的产生的必要条件即可：\",\"破坏请求与保持条件：一次性申请所有的资源。\",\"破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\",\"破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\",\"如何避免死锁？\",\"避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。\",\"安全状态 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <P1、P2、P3.....Pn> 序列为安全序列。\",\"我们对线程 2 的代码修改成下面这样就不会产生死锁了。\",\"new Thread(() -> { synchronized (resource1) { System.out.println(Thread.currentThread() + \\\"get resource1\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \\\"waiting get resource2\\\"); synchronized (resource2) { System.out.println(Thread.currentThread() + \\\"get resource2\\\"); } } }, \\\"线程 2\\\").start(); \",\"输出：\",\"Thread[线程 1,5,main]get resource1 Thread[线程 1,5,main]waiting get resource2 Thread[线程 1,5,main]get resource2 Thread[线程 2,5,main]get resource1 Thread[线程 2,5,main]waiting get resource2 Thread[线程 2,5,main]get resource2 Process finished with exit code 0 \",\"我们分析一下上面的代码为什么避免了死锁的发生?\",\"线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。\"]},\"825\":{\"h\":\"sleep() 方法和 wait() 方法对比\",\"t\":[\"共同点：两者都可以暂停线程的执行。\",\"区别：\",\"sleep() 方法没有释放锁，而 wait() 方法释放了锁 。\",\"wait() 通常被用于线程间交互/通信，sleep()通常被用于暂停执行。\",\"wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。\",\"sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。为什么这样设计呢？下一个问题就会聊到。\"]},\"826\":{\"h\":\"为什么 wait() 方法不定义在 Thread 中？\",\"t\":[\"wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）。\",\"类似的问题：为什么 sleep() 方法定义在 Thread 中？\",\"因为 sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。\"]},\"827\":{\"h\":\"可以直接调用 Thread 类的 run 方法吗？\",\"t\":[\"这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！\",\"new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\",\"总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。\",\"File not found\"]},\"828\":{\"c\":[\"Java\"]},\"829\":{\"c\":[\"Java并发\"]},\"830\":{\"h\":\"Java并发常见面试题总结（中）\",\"t\":[\"File not found\"]},\"831\":{\"h\":\"JMM(Java 内存模型)\",\"t\":[\"JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题：JMM（Java 内存模型）详解 。\"]},\"832\":{\"h\":\"volatile 关键字\"},\"833\":{\"h\":\"如何保证变量的可见性？\",\"t\":[\"在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\",\"JMM(Java 内存模型)\",\"JMM(Java 内存模型)强制在主存中进行读取\",\"volatile 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 volatile 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\"]},\"834\":{\"h\":\"如何禁止指令重排序？\",\"t\":[\"在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。\",\"在 Java 中，Unsafe 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：\",\"public native void loadFence(); public native void storeFence(); public native void fullFence(); \",\"理论上来说，你通过这个三个方法也可以实现和volatile禁止重排序一样的效果，只是会麻烦一些。\",\"下面我以一个常见的面试题为例讲解一下 volatile 关键字禁止指令重排序的效果。\",\"面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”\",\"双重校验锁实现对象单例（线程安全）：\",\"public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) { //类对象加锁 synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } \",\"uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\",\"为 uniqueInstance 分配内存空间\",\"初始化 uniqueInstance\",\"将 uniqueInstance 指向分配的内存地址\",\"但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\"]},\"835\":{\"h\":\"volatile 可以保证原子性么？\",\"t\":[\"volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。\",\"我们通过下面的代码即可证明：\",\"/** * 微信搜 JavaGuide 回复\\\"面试突击\\\"即可免费领取个人原创的 Java 面试手册 * * @author Guide哥 * @date 2022/08/03 13:40 **/ public class VolatoleAtomicityDemo { public volatile static int inc = 0; public void increase() { inc++; } public static void main(String[] args) throws InterruptedException { ExecutorService threadPool = Executors.newFixedThreadPool(5); VolatoleAtomicityDemo volatoleAtomicityDemo = new VolatoleAtomicityDemo(); for (int i = 0; i < 5; i++) { threadPool.execute(() -> { for (int j = 0; j < 500; j++) { volatoleAtomicityDemo.increase(); } }); } // 等待1.5秒，保证上面程序执行完成 Thread.sleep(1500); System.out.println(inc); threadPool.shutdown(); } } \",\"正常情况下，运行上面的代码理应输出 2500。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 2500。\",\"为什么会出现这种情况呢？不是说好了，volatile 可以保证变量的可见性嘛！\",\"也就是说，如果 volatile 能保证 inc++ 操作的原子性的话。每个线程中对 inc 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500=2500。\",\"很多人会误认为自增操作 inc++ 是原子性的，实际上，inc++ 其实是一个复合操作，包括三步：\",\"读取 inc 的值。\",\"对 inc 加 1。\",\"将 inc 的值写回内存。\",\"volatile 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：\",\"线程 1 对 inc 进行读取操作之后，还未对其进行修改。线程 2 又读取了 inc的值并对其进行修改（+1），再将inc 的值写回内存。\",\"线程 2 操作完毕后，线程 1 对 inc的值进行修改（+1），再将inc 的值写回内存。\",\"这也就导致两个线程分别对 inc 进行了一次自增操作后，inc 实际上只增加了 1。\",\"其实，如果想要保证上面的代码运行正确也非常简单，利用 synchronized、Lock或者AtomicInteger都可以。\",\"使用 synchronized 改进：\",\"public synchronized void increase() { inc++; } \",\"使用 AtomicInteger 改进：\",\"public AtomicInteger inc = new AtomicInteger(); public void increase() { inc.getAndIncrement(); } \",\"使用 ReentrantLock 改进：\",\"Lock lock = new ReentrantLock(); public void increase() { lock.lock(); try { inc++; } finally { lock.unlock(); } } \"]},\"836\":{\"h\":\"乐观锁和悲观锁\"},\"837\":{\"h\":\"什么是悲观锁？\",\"t\":[\"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\",\"像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\",\"public void performSynchronisedTask() { synchronized (this) { // 需要同步的操作 } } private Lock lock = new ReentrantLock(); lock.lock(); try { // 需要同步的操作 } finally { lock.unlock(); } \",\"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\"]},\"838\":{\"h\":\"什么是乐观锁？\",\"t\":[\"乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。\",\"在 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。\",\"// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好 // 代价就是会消耗更多的内存空间（空间换时间） LongAdder sum = new LongAdder(); sum.increment(); \",\"高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\",\"不过，大量失败重试的问题也是可以解决的，像我们前面提到的 LongAdder以空间换时间的方式就解决了这个问题。\",\"理论上来说：\",\"悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。\",\"乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。\"]},\"839\":{\"h\":\"如何实现乐观锁？\",\"t\":[\"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\"]},\"840\":{\"h\":\"版本号机制\",\"t\":[\"一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\",\"举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\",\"操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。\",\"在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。\",\"操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。\",\"操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。\",\"这样就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。\"]},\"841\":{\"h\":\"CAS 算法\",\"t\":[\"CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\",\"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\",\"原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。\",\"CAS 涉及到三个操作数：\",\"V：要更新的变量值(Var)\",\"E：预期值(Expected)\",\"N：拟写入的新值(New)\",\"当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\",\"举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。\",\"i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\",\"i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。\",\"当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\",\"Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\",\"sun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作\",\"/** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update); public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update); \",\"关于 Unsafe 类的详细介绍可以看这篇文章：Java 魔法类 Unsafe 详解 - JavaGuide - 2022 。\"]},\"842\":{\"h\":\"乐观锁存在哪些问题？\",\"t\":[\"ABA 问题是乐观锁最常见的问题。\"]},\"843\":{\"h\":\"ABA 问题\",\"t\":[\"如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \\\"ABA\\\"问题。\",\"ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\",\"public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair<V> current = pair; return expectedReference == current.reference && expectedStamp == current.stamp && ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } \"]},\"844\":{\"h\":\"循环时间长开销大\",\"t\":[\"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\",\"如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\",\"可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\",\"可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。\"]},\"845\":{\"h\":\"只能保证一个共享变量的原子操作\",\"t\":[\"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。\"]},\"846\":{\"h\":\"synchronized 关键字\"},\"847\":{\"h\":\"synchronized 是什么？有什么用？\",\"t\":[\"synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\",\"在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。\",\"不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。\"]},\"848\":{\"h\":\"如何使用 synchronized？\",\"t\":[\"synchronized 关键字的使用方式主要有下面 3 种：\",\"修饰实例方法\",\"修饰静态方法\",\"修饰代码块\",\"1、修饰实例方法 （锁当前对象实例）\",\"给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。\",\"synchronized void method() { //业务代码 } \",\"2、修饰静态方法 （锁当前类）\",\"给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。\",\"这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。\",\"synchronized static void method() { //业务代码 } \",\"静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。\",\"3、修饰代码块 （锁指定对象/类）\",\"对括号里指定的对象/类加锁：\",\"synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。\",\"synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁\",\"synchronized(this) { //业务代码 } \",\"总结：\",\"synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；\",\"synchronized 关键字加到实例方法上是给对象实例上锁；\",\"尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能。\"]},\"849\":{\"h\":\"构造方法可以用 synchronized 修饰么？\",\"t\":[\"先说结论：构造方法不能使用 synchronized 关键字修饰。\",\"构造方法本身就属于线程安全的，不存在同步的构造方法一说。\"]},\"850\":{\"h\":\"synchronized 底层原理了解吗？\",\"t\":[\"synchronized 关键字底层原理属于 JVM 层面的东西。\"]},\"851\":{\"h\":\"synchronized 同步语句块的情况\",\"t\":[\"public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(\\\"synchronized 代码块\\\"); } } } \",\"通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class。\",\"synchronized关键字原理\",\"从上面我们可以看出：synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"上面的字节码中包含一个 monitorenter 指令以及两个 monitorexit 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。\",\"当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。\",\"在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 ObjectMonitor对象。\",\"另外，wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。\",\"在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。\",\"执行 monitorenter 获取锁\",\"对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。\",\"执行 monitorexit 释放锁\",\"如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\"]},\"852\":{\"h\":\"synchronized 修饰方法的的情况\",\"t\":[\"public class SynchronizedDemo2 { public synchronized void method() { System.out.println(\\\"synchronized 方法\\\"); } } \",\"synchronized关键字原理\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\",\"如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。\"]},\"853\":{\"h\":\"总结\",\"t\":[\"synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。\",\"synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。\",\"不过两者的本质都是对对象监视器 monitor 的获取。\",\"相关推荐：Java 锁与线程的那些事 - 有赞技术团队 。\",\"🧗🏻 进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 monitor。\"]},\"854\":{\"h\":\"JDK1.6 之后的 synchronized 底层做了哪些优化？\",\"t\":[\"JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。\",\"锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\",\"关于这几种优化的详细信息可以查看下面这篇文章：Java6 及以上版本对 synchronized 的优化 。\"]},\"855\":{\"h\":\"synchronized 和 volatile 有什么区别？\",\"t\":[\"synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！\",\"volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。\",\"volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。\"]},\"856\":{\"h\":\"ReentrantLock\"},\"857\":{\"h\":\"ReentrantLock 是什么？\",\"t\":[\"ReentrantLock 实现了 Lock 接口，是一个可重入且独占式的锁，和 synchronized 关键字类似。不过，ReentrantLock 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。\",\"public class ReentrantLock implements Lock, java.io.Serializable {} \",\"ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。\",\"ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。\",\"// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \",\"从上面的内容可以看出， ReentrantLock 的底层就是由 AQS 来实现的。关于 AQS 的相关内容推荐阅读 AQS 详解 这篇文章。\"]},\"858\":{\"h\":\"公平锁和非公平锁有什么区别？\",\"t\":[\"公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\",\"非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\"]},\"859\":{\"h\":\"synchronized 和 ReentrantLock 有什么区别？\"},\"860\":{\"h\":\"两者都是可重入锁\",\"t\":[\"可重入锁 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。\",\"JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。\",\"在下面的代码中，method1() 和 method2()都被 synchronized 关键字修饰，method1()调用了method2()。\",\"public class SynchronizedDemo { public synchronized void method1() { System.out.println(\\\"方法1\\\"); method2(); } public synchronized void method2() { System.out.println(\\\"方法2\\\"); } } \",\"由于 synchronized锁是可重入的，同一个线程在调用method1() 时可以直接获得当前对象的锁，执行 method2() 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如synchronized是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 method2()时获取锁失败，会出现死锁问题。\"]},\"861\":{\"h\":\"synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API\",\"t\":[\"synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。\",\"ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。\"]},\"862\":{\"h\":\"ReentrantLock 比 synchronized 增加了一些高级功能\",\"t\":[\"相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：\",\"等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。\",\"可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来指定是否是公平的。\",\"可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。\",\"如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。\",\"关于 Condition接口的补充：\",\"Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程。\"]},\"863\":{\"h\":\"可中断锁和不可中断锁有什么区别？\",\"t\":[\"可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。ReentrantLock 就属于是可中断锁。\",\"不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 synchronized 就属于是不可中断锁。\"]},\"864\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"ReentrantReadWriteLock 在实际项目中使用的并不多，面试中也问的比较少，简单了解即可。JDK 1.8 引入了性能更好的读写锁 StampedLock 。\"]},\"865\":{\"h\":\"ReentrantReadWriteLock 是什么？\",\"t\":[\"ReentrantReadWriteLock 实现了 ReadWriteLock ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\",\"public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable{ } public interface ReadWriteLock { Lock readLock(); Lock writeLock(); } \",\"一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。\",\"读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。\",\"ReentrantReadWriteLock 其实是两把锁，一把是 WriteLock (写锁)，一把是 ReadLock（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\",\"和 ReentrantLock 一样，ReentrantReadWriteLock 底层也是基于 AQS 实现的。\",\"ReentrantReadWriteLock 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。\",\"// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁 public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } \"]},\"866\":{\"h\":\"ReentrantReadWriteLock 适合什么场景？\",\"t\":[\"由于 ReentrantReadWriteLock 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 ReentrantReadWriteLock 能够明显提升系统性能。\"]},\"867\":{\"h\":\"共享锁和独占锁有什么区别？\",\"t\":[\"共享锁：一把锁可以被多个线程同时获得。\",\"独占锁：一把锁只能被一个线程获得。\"]},\"868\":{\"h\":\"线程持有读锁还能获取写锁吗？\",\"t\":[\"在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\",\"在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。\",\"读写锁的源码分析，推荐阅读 聊聊 Java 的几把 JVM 级锁 - 阿里巴巴中间件 这篇文章，写的很不错。\"]},\"869\":{\"h\":\"读锁为什么不能升级为写锁？\",\"t\":[\"写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。\",\"另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。\"]},\"870\":{\"h\":\"StampedLock\",\"t\":[\"StampedLock 面试中问的比较少，不是很重要，简单了解即可。\"]},\"871\":{\"h\":\"StampedLock 是什么？\",\"t\":[\"StampedLock 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 Conditon。\",\"不同于一般的 Lock 类，StampedLock 并不是直接实现 Lock或 ReadWriteLock接口，而是基于 CLH 锁 独立实现的（AQS 也是基于这玩意）。\",\"public class StampedLock implements java.io.Serializable { } \",\"StampedLock 提供了三种模式的读写控制模式：读锁、写锁和乐观读。\",\"写锁：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 ReentrantReadWriteLock 的写锁，不过这里的写锁是不可重入的。\",\"读锁 （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 ReentrantReadWriteLock 的读锁，不过这里的读锁是不可重入的。\",\"乐观读：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。\",\"另外，StampedLock 还支持这三种锁在一定条件下进行相互转换 。\",\"long tryConvertToWriteLock(long stamp){} long tryConvertToReadLock(long stamp){} long tryConvertToOptimisticRead(long stamp){} \",\"StampedLock 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是StampedLock不可重入的原因。\",\"// 写锁 public long writeLock() { long s, next; // bypass acquireWrite in fully unlocked case only return ((((s = state) & ABITS) == 0L && U.compareAndSwapLong(this, STATE, s, next = s + WBIT)) ? next : acquireWrite(false, 0L)); } // 读锁 public long readLock() { long s = state, next; // bypass acquireRead on common uncontended case return ((whead == wtail && (s & ABITS) < RFULL && U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ? next : acquireRead(false, 0L)); } // 乐观读 public long tryOptimisticRead() { long s; return (((s = state) & WBIT) == 0L) ? (s & SBITS) : 0L; } \"]},\"872\":{\"h\":\"StampedLock 的性能为什么更好？\",\"t\":[\"相比于传统读写锁多出来的乐观读是StampedLock比 ReadWriteLock 性能更好的关键原因。StampedLock 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。\"]},\"873\":{\"h\":\"StampedLock 适合什么场景？\",\"t\":[\"和 ReentrantReadWriteLock 一样，StampedLock 同样适合读多写少的业务场景，可以作为 ReentrantReadWriteLock的替代品，性能更好。\",\"不过，需要注意的是StampedLock不可重入，不支持条件变量 Conditon，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 ReentrantLock 的一些高级性能，就不太建议使用 StampedLock 了。\",\"另外，StampedLock 性能虽好，但使用起来相对比较麻烦，一旦使用不当，就会出现生产问题。强烈建议你在使用StampedLock 之前，看看 StampedLock 官方文档中的案例。\"]},\"874\":{\"h\":\"StampedLock 的底层原理了解吗？\",\"t\":[\"StampedLock 不是直接实现 Lock或 ReadWriteLock接口，而是基于 CLH 锁 实现的（AQS 也是基于这玩意），CLH 锁是对自旋锁的一种改良，是一种隐式的链表队列。StampedLock 通过 CLH 队列进行线程的管理，通过同步状态值 state 来表示锁的状态和类型。\",\"StampedLock 的原理和 AQS 原理比较类似，这里就不详细介绍了，感兴趣的可以看看下面这两篇文章：\",\"AQS 详解\",\"StampedLock 底层原理分析\",\"如果你只是准备面试的话，建议多花点精力搞懂 AQS 原理即可，StampedLock 底层原理在面试中遇到的概率非常小。\"]},\"875\":{\"h\":\"Atomic 原子类\",\"t\":[\"Atomic 原子类部分的内容我单独写了一篇文章来总结：Atomic 原子类总结 。\"]},\"876\":{\"h\":\"参考\",\"t\":[\"《深入理解 Java 虚拟机》\",\"《实战 Java 高并发程序设计》\",\"Guide to the Volatile Keyword in Java - Baeldung：https://www.baeldung.com/java-volatile\",\"不可不说的 Java“锁”事 - 美团技术团队：https://tech.meituan.com/2018/11/15/java-lock.html\",\"在 ReadWriteLock 类中读锁为什么不能升级为写锁？：https://cloud.tencent.com/developer/article/1176230\",\"高性能解决线程饥饿的利器 StampedLock：https://mp.weixin.qq.com/s/2Acujjr4BHIhlFsCLGwYSg\",\"理解 Java 中的 ThreadLocal - 技术小黑屋：https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/\",\"ThreadLocal (Java Platform SE 8 ) - Oracle Help Center：https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html\",\"File not found\"]},\"877\":{\"c\":[\"Java\"]},\"878\":{\"c\":[\"Java并发\"]},\"879\":{\"h\":\"Java并发常见面试题总结（下）\",\"t\":[\"File not found\"]},\"880\":{\"h\":\"ThreadLocal\"},\"881\":{\"h\":\"ThreadLocal 有什么用？\",\"t\":[\"通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？\",\"JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\",\"如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\",\"再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。\"]},\"882\":{\"h\":\"如何使用 ThreadLocal？\",\"t\":[\"相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。下面简单演示一下如何在项目中实际使用 ThreadLocal 。\",\"import java.text.SimpleDateFormat; import java.util.Random; public class ThreadLocalExample implements Runnable{ // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本 private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat(\\\"yyyyMMdd HHmm\\\")); public static void main(String[] args) throws InterruptedException { ThreadLocalExample obj = new ThreadLocalExample(); for(int i=0 ; i<10; i++){ Thread t = new Thread(obj, \\\"\\\"+i); Thread.sleep(new Random().nextInt(1000)); t.start(); } } @Override public void run() { System.out.println(\\\"Thread Name= \\\"+Thread.currentThread().getName()+\\\" default Formatter = \\\"+formatter.get().toPattern()); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } //formatter pattern is changed here by thread, but it won't reflect to other threads formatter.set(new SimpleDateFormat()); System.out.println(\\\"Thread Name= \\\"+Thread.currentThread().getName()+\\\" formatter = \\\"+formatter.get().toPattern()); } } \",\"输出结果 :\",\"Thread Name= 0 default Formatter = yyyyMMdd HHmm Thread Name= 0 formatter = yy-M-d ah:mm Thread Name= 1 default Formatter = yyyyMMdd HHmm Thread Name= 2 default Formatter = yyyyMMdd HHmm Thread Name= 1 formatter = yy-M-d ah:mm Thread Name= 3 default Formatter = yyyyMMdd HHmm Thread Name= 2 formatter = yy-M-d ah:mm Thread Name= 4 default Formatter = yyyyMMdd HHmm Thread Name= 3 formatter = yy-M-d ah:mm Thread Name= 4 formatter = yy-M-d ah:mm Thread Name= 5 default Formatter = yyyyMMdd HHmm Thread Name= 5 formatter = yy-M-d ah:mm Thread Name= 6 default Formatter = yyyyMMdd HHmm Thread Name= 6 formatter = yy-M-d ah:mm Thread Name= 7 default Formatter = yyyyMMdd HHmm Thread Name= 7 formatter = yy-M-d ah:mm Thread Name= 8 default Formatter = yyyyMMdd HHmm Thread Name= 9 default Formatter = yyyyMMdd HHmm Thread Name= 8 formatter = yy-M-d ah:mm Thread Name= 9 formatter = yy-M-d ah:mm \",\"从输出中可以看出，虽然 Thread-0 已经改变了 formatter 的值，但 Thread-1 默认格式化值与初始化值相同，其他线程也一样。\",\"上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法withInitial()，将 Supplier 功能接口作为参数。\",\"private static final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){ @Override protected SimpleDateFormat initialValue(){ return new SimpleDateFormat(\\\"yyyyMMdd HHmm\\\"); } }; \"]},\"883\":{\"h\":\"ThreadLocal 原理了解吗？\",\"t\":[\"从 Thread类源代码入手。\",\"public class Thread implements Runnable { //...... //与此线程有关的ThreadLocal值。由ThreadLocal类维护 ThreadLocal.ThreadLocalMap threadLocals = null; //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护 ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; //...... } \",\"从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。\",\"ThreadLocal类的set()方法\",\"public void set(T value) { //获取当前请求的线程 Thread t = Thread.currentThread(); //取出 Thread 类内部的 threadLocals 变量(哈希表结构) ThreadLocalMap map = getMap(t); if (map != null) // 将需要存储的值放入到这个哈希表中 map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } \",\"通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。\",\"每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。\",\"ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) { //...... } \",\"比如我们在同一个线程中声明了两个 ThreadLocal 对象的话， Thread内部都是使用仅有的那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。\",\"ThreadLocal 数据结构如下图所示：\",\"ThreadLocal 数据结构\",\"ThreadLocalMap是ThreadLocal的静态内部类。\",\"ThreadLocal内部类\"]},\"884\":{\"h\":\"ThreadLocal 内存泄露问题是怎么导致的？\",\"t\":[\"ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。\",\"这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法\",\"static class Entry extends WeakReference<ThreadLocal<?>> { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal<?> k, Object v) { super(k); value = v; } } \",\"弱引用介绍：\",\"如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\",\"弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\"]},\"885\":{\"h\":\"线程池\"},\"886\":{\"h\":\"什么是线程池?\",\"t\":[\"顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。\"]},\"887\":{\"h\":\"为什么要用线程池？\",\"t\":[\"池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\",\"线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。\",\"这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：\",\"降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\",\"提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\"]},\"888\":{\"h\":\"如何创建线程池？\",\"t\":[\"方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。\",\"通过构造方法实现\",\"方式二：通过 Executor 框架的工具类 Executors 来创建。\",\"我们可以创建多种类型的 ThreadPoolExecutor：\",\"FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\",\"SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\",\"CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。\",\"ScheduledThreadPool：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\",\"对应 Executors 工具类中的方法如图所示：\"]},\"889\":{\"h\":\"为什么不推荐使用内置线程池？\",\"t\":[\"在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\",\"为什么呢？\",\"使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\",\"另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险\",\"Executors 返回线程池对象的弊端如下(后文会详细介绍到)：\",\"FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。\",\"ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"// 无界队列 LinkedBlockingQueue public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()); } // 无界队列 LinkedBlockingQueue public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>())); } // 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE` public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>()); } // DelayedWorkQueue（延迟阻塞队列） public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } \"]},\"890\":{\"h\":\"线程池常见参数有哪些？如何解释？\",\"t\":[\" /** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */ public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 ) { if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } \",\"ThreadPoolExecutor 3 个最重要的参数：\",\"corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\",\"maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"ThreadPoolExecutor其他常见参数 :\",\"keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁，线程池回收线程时，会对核心线程和非核心线程一视同仁，直到线程池中线程的数量等于 corePoolSize ，回收过程才会停止。\",\"unit : keepAliveTime 参数的时间单位。\",\"threadFactory :executor 创建新线程的时候会用到。\",\"handler :饱和策略。关于饱和策略下面单独介绍一下。\",\"下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：\",\"线程池各个参数的关系\"]},\"891\":{\"h\":\"线程池的饱和策略有哪些？\",\"t\":[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:\",\"ThreadPoolExecutor.AbortPolicy： 抛出 RejectedExecutionException来拒绝新任务的处理。\",\"ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\",\"ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。\",\"ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。\",\"举个例子：Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略来配置线程池的时候，默认使用的是 AbortPolicy。在这种饱和策略下，如果队列满了，ThreadPoolExecutor 将抛出 RejectedExecutionException 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用CallerRunsPolicy。CallerRunsPolicy 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务\",\"public static class CallerRunsPolicy implements RejectedExecutionHandler { public CallerRunsPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { // 直接主线程执行，而不是线程池中的线程执行 r.run(); } } } \"]},\"892\":{\"h\":\"线程池常用的阻塞队列有哪些？\",\"t\":[\"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。\",\"容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。FixedThreadPool最多只能创建核心线程数的线程（核心线程数和最大线程数相等），SingleThreadExector只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。\",\"SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\",\"DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。\"]},\"893\":{\"h\":\"线程池处理任务的流程了解吗？\",\"t\":[\"图解线程池实现原理\",\"如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\",\"如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\",\"如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\",\"如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。\"]},\"894\":{\"h\":\"如何给线程池命名？\",\"t\":[\"初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。\",\"默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。\",\"给线程池里的线程命名通常有下面两种方式：\",\"1、利用 guava 的 ThreadFactoryBuilder\",\"ThreadFactory threadFactory = new ThreadFactoryBuilder() .setNameFormat(threadNamePrefix + \\\"-%d\\\") .setDaemon(true).build(); ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory); \",\"2、自己实现 ThreadFactory。\",\"import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.atomic.AtomicInteger; /** * 线程工厂，它设置线程名称，有利于我们定位问题。 */ public final class NamingThreadFactory implements ThreadFactory { private final AtomicInteger threadNum = new AtomicInteger(); private final ThreadFactory delegate; private final String name; /** * 创建一个带名字的线程池生产工厂 */ public NamingThreadFactory(ThreadFactory delegate, String name) { this.delegate = delegate; this.name = name; // TODO consider uniquifying this } @Override public Thread newThread(Runnable r) { Thread t = delegate.newThread(r); t.setName(name + \\\" [#\\\" + threadNum.incrementAndGet() + \\\"]\\\"); return t; } } \"]},\"895\":{\"h\":\"如何设定线程池的大小？\",\"t\":[\"很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了上下文切换成本。不清楚什么是上下文切换的话，可以看我下面的介绍。\",\"上下文切换：\",\"多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。\",\"上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\",\"Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\",\"类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。\",\"如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。\",\"如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。\",\"有一个简单并且适用面比较广的公式：\",\"CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\",\"I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。\",\"如何判断是 CPU 密集任务还是 IO 密集任务？\",\"CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。\",\"🌈 拓展一下（参见：issue#1737）：\",\"线程数更严谨的计算的方法应该是：最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间）），其中 WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）。\",\"线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。\",\"我们可以通过 JDK 自带的工具 VisualVM 来查看 WT/ST 比例。\",\"CPU 密集型任务的 WT/ST 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。\",\"IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。\",\"公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！\"]},\"896\":{\"h\":\"如何动态修改线程池的参数？\",\"t\":[\"美团技术团队在《Java 线程池实现原理及其在美团业务中的实践》这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。\",\"美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：\",\"corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。\",\"maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"为什么是这三个参数？\",\"我在Java 线程池详解 这篇文章中就说过这三个参数是 ThreadPoolExecutor 最重要的参数，它们基本决定了线程池对于任务的处理策略。\",\"如何支持参数动态配置？ 且看 ThreadPoolExecutor 提供的下面这些方法。\",\"格外需要注意的是corePoolSize， 程序运行期间的时候，我们调用 setCorePoolSize（）这个方法的话，线程池会首先判断当前工作线程数是否大于corePoolSize，如果大于的话就会回收工作线程。\",\"另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 ResizableCapacityLinkedBlockIngQueue 的队列（主要就是把LinkedBlockingQueue的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。\",\"最终实现的可动态修改线程池参数效果如下。👏👏👏\",\"动态配置线程池参数最终效果\",\"还没看够？推荐 why 神的如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。这篇文章，深度剖析，很不错哦！\",\"如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：\",\"Hippo4j：异步线程池框架，支持线程池动态变更&监控&报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。\",\"Dynamic TP：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。\"]},\"897\":{\"h\":\"如何设计一个能够根据任务的优先级来执行的线程池？\",\"t\":[\"这是一个常见的面试问题，本质其实还是在考察求职者对于线程池以及阻塞队列的掌握。\",\"我们上面也提到了，不同的线程池会选用不同的阻塞队列作为任务队列，比如FixedThreadPool 使用的是LinkedBlockingQueue（无界队列），由于队列永远不会被放满，因此FixedThreadPool最多只能创建核心线程数的线程。\",\"假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 PriorityBlockingQueue （优先级阻塞队列）作为任务队列（ThreadPoolExecutor 的构造函数有一个 workQueue 参数可以传入任务队列）。\",\"ThreadPoolExecutor构造函数\",\"PriorityBlockingQueue 是一个支持优先级的无界阻塞队列，可以看作是线程安全的 PriorityQueue，两者底层都是使用小顶堆形式的二叉堆，即值最小的元素优先出队。不过，PriorityQueue 不支持阻塞操作。\",\"要想让 PriorityBlockingQueue 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：\",\"提交到线程池的任务实现 Comparable 接口，并重写 compareTo 方法来指定任务之间的优先级比较规则。\",\"创建 PriorityBlockingQueue 时传入一个 Comparator 对象来指定任务之间的排序规则(推荐)。\",\"不过，这存在一些风险和问题，比如：\",\"PriorityBlockingQueue 是无界的，可能堆积大量的请求，从而导致 OOM。\",\"可能会导致饥饿问题，即低优先级的任务长时间得不到执行。\",\"由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 ReentrantLock），因此会降低性能。\",\"对于 OOM 这个问题的解决比较简单粗暴，就是继承PriorityBlockingQueue 并重写一下 offer 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。\",\"饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。\",\"对于性能方面的影响，是没办法避免的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的。\"]},\"898\":{\"h\":\"Future\"},\"899\":{\"h\":\"Future 类有什么用？\",\"t\":[\"Future 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\",\"这其实就是多线程中经典的 Future 模式，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。\",\"在 Java 中，Future 类只是一个泛型接口，位于 java.util.concurrent 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：\",\"取消任务；\",\"判断任务是否被取消;\",\"判断任务是否已经执行完成;\",\"获取任务执行结果。\",\"// V 代表了Future执行的任务返回值的类型 public interface Future<V> { // 取消任务执行 // 成功取消返回 true，否则返回 false boolean cancel(boolean mayInterruptIfRunning); // 判断任务是否被取消 boolean isCancelled(); // 判断任务是否已经执行完成 boolean isDone(); // 获取任务执行结果 V get() throws InterruptedException, ExecutionException; // 指定时间内没有返回计算结果就抛出 TimeOutException 异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptio } \",\"简单理解就是：我有一个任务，提交给了 Future 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 Future 那里直接取出任务执行结果。\"]},\"900\":{\"h\":\"Callable 和 Future 有什么关系？\",\"t\":[\"我们可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。\",\"FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask 。\",\"<T> Future<T> submit(Callable<T> task); Future<?> submit(Runnable task); \",\"FutureTask 不光实现了 Future接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行。\",\"FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象。\",\"public FutureTask(Callable<V> callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; } public FutureTask(Runnable runnable, V result) { // 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象 this.callable = Executors.callable(runnable, result); this.state = NEW; } \",\"FutureTask相当于对Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。\"]},\"901\":{\"h\":\"CompletableFuture 类有什么用？\",\"t\":[\"Future 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。\",\"Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。\",\"下面我们来简单看看 CompletableFuture 类的定义。\",\"public class CompletableFuture<T> implements Future<T>, CompletionStage<T> { } \",\"可以看到，CompletableFuture 同时实现了 Future 和 CompletionStage 接口。\",\"CompletionStage 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。\",\"CompletionStage 接口中的方法比较多，CompletableFuture 的函数式能力就是这个接口赋予的。从这个接口的方法参数你就可以发现其大量使用了 Java8 引入的函数式编程。\"]},\"902\":{\"h\":\"AQS\"},\"903\":{\"h\":\"AQS 是什么？\",\"t\":[\"AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。\",\"AQS 就是一个抽象类，主要用来构建锁和同步器。\",\"public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { } \",\"AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue等等皆是基于 AQS 的。\"]},\"904\":{\"h\":\"AQS 的原理是什么？\",\"t\":[\"AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。\",\"CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。\",\"CLH 队列结构如下图所示：\",\"AQS(AbstractQueuedSynchronizer)的核心原理图（图源Java 并发之 AQS 详解）如下：\",\"AQS 使用 int 成员变量 state 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。\",\"state 变量由 volatile 修饰，用于展示当前临界资源的获锁情况。\",\"// 共享变量，使用volatile修饰保证线程可见性 private volatile int state; \",\"另外，状态信息 state 可以通过 protected 类型的getState()、setState()和compareAndSetState() 进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。\",\"//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值） protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } \",\"以 ReentrantLock 为例，state 初始值为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1 。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。\",\"再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 state=0 )，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。\"]},\"905\":{\"h\":\"Semaphore 有什么用？\",\"t\":[\"synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，而Semaphore(信号量)可以用来控制同时访问特定资源的线程数量。\",\"Semaphore 的使用简单，我们这里假设有 N(N>5) 个线程来获取 Semaphore 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。\",\"// 初始共享资源数量 final Semaphore semaphore = new Semaphore(5); // 获取1个许可 semaphore.acquire(); // 释放1个许可 semaphore.release(); \",\"当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。\",\"Semaphore 有两种模式：。\",\"公平模式： 调用 acquire() 方法的顺序就是获取许可证的顺序，遵循 FIFO；\",\"非公平模式： 抢占式的。\",\"Semaphore 对应的两个构造方法如下：\",\"public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits); } \",\"这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。\",\"Semaphore 通常用于那些资源有明确访问数量限制的场景比如限流（仅限于单机模式，实际项目中推荐使用 Redis +Lua 来做限流）。\"]},\"906\":{\"h\":\"Semaphore 的原理是什么？\",\"t\":[\"Semaphore 是共享锁的一种实现，它默认构造 AQS 的 state 值为 permits，你可以将 permits 的值理解为许可证的数量，只有拿到许可证的线程才能执行。\",\"调用semaphore.acquire() ，线程尝试获取许可证，如果 state >= 0 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state 的值 state=state-1。如果 state<0 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。\",\"/** * 获取1个许可证 */ public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); } /** * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程 */ public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。 if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); } \",\"调用semaphore.release(); ，线程尝试释放许可证，并使用 CAS 操作去修改 state 的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state 的值 state=state-1 ，如果 state>=0 则获取令牌成功，否则重新进入阻塞队列，挂起线程。\",\"// 释放一个许可证 public void release() { sync.releaseShared(1); } // 释放共享锁，同时会唤醒同步队列中的一个线程。 public final boolean releaseShared(int arg) { //释放共享锁 if (tryReleaseShared(arg)) { //唤醒同步队列中的一个线程 doReleaseShared(); return true; } return false; } \"]},\"907\":{\"h\":\"CountDownLatch 有什么用？\",\"t\":[\"CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。\",\"CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\"]},\"908\":{\"h\":\"CountDownLatch 的原理是什么？\",\"t\":[\"CountDownLatch 是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用 countDown() 方法时,其实使用了tryReleaseShared方法以 CAS 的操作来减少 state,直至 state 为 0 。当调用 await() 方法的时候，如果 state 不为 0，那就证明任务还没有执行完毕，await() 方法就会一直阻塞，也就是说 await() 方法之后的语句不会被执行。直到count 个线程调用了countDown()使 state 值被减为 0，或者调用await()的线程被中断，该线程才会从阻塞中被唤醒，await() 方法之后的语句得到执行。\"]},\"909\":{\"h\":\"用过 CountDownLatch 么？什么场景下用的？\",\"t\":[\"CountDownLatch 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 CountDownLatch 。具体场景是下面这样的：\",\"我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。\",\"为此我们定义了一个线程池和 count 为 6 的CountDownLatch对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用CountDownLatch对象的 await()方法，直到所有文件读取完之后，才会接着执行后面的逻辑。\",\"伪代码是下面这样的：\",\"public class CountDownLatchExample1 { // 处理文件的数量 private static final int threadCount = 6; public static void main(String[] args) throws InterruptedException { // 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建） ExecutorService threadPool = Executors.newFixedThreadPool(10); final CountDownLatch countDownLatch = new CountDownLatch(threadCount); for (int i = 0; i < threadCount; i++) { final int threadnum = i; threadPool.execute(() -> { try { //处理文件的业务操作 //...... } catch (InterruptedException e) { e.printStackTrace(); } finally { //表示一个文件已经被完成 countDownLatch.countDown(); } }); } countDownLatch.await(); threadPool.shutdown(); System.out.println(\\\"finish\\\"); } } \",\"有没有可以改进的地方呢？\",\"可以使用 CompletableFuture 类来改进！Java8 的 CompletableFuture 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。\",\"CompletableFuture<Void> task1 = CompletableFuture.supplyAsync(()->{ //自定义业务操作 }); ...... CompletableFuture<Void> task6 = CompletableFuture.supplyAsync(()->{ //自定义业务操作 }); ...... CompletableFuture<Void> headerFuture=CompletableFuture.allOf(task1,.....,task6); try { headerFuture.join(); } catch (Exception ex) { //...... } System.out.println(\\\"all done. \\\"); \",\"上面的代码还可以继续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。\",\"//文件夹位置 List<String> filePaths = Arrays.asList(...) // 异步处理所有文件 List<CompletableFuture<String>> fileFutures = filePaths.stream() .map(filePath -> doSomeThing(filePath)) .collect(Collectors.toList()); // 将他们合并起来 CompletableFuture<Void> allFutures = CompletableFuture.allOf( fileFutures.toArray(new CompletableFuture[fileFutures.size()]) ); \"]},\"910\":{\"h\":\"CyclicBarrier 有什么用？\",\"t\":[\"CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\",\"CountDownLatch 的实现是基于 AQS 的，而 CycliBarrier 是基于 ReentrantLock(ReentrantLock 也属于 AQS 同步器)和 Condition 的。\",\"CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。\"]},\"911\":{\"h\":\"CyclicBarrier 的原理是什么？\",\"t\":[\"CyclicBarrier 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。\",\"//每次拦截的线程数 private final int parties; //计数器 private int count; \",\"下面我们结合源码来简单看看。\",\"1、CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\",\"public CyclicBarrier(int parties) { this(parties, null); } public CyclicBarrier(int parties, Runnable barrierAction) { if (parties <= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; } \",\"其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。\",\"2、当调用 CyclicBarrier 对象调用 await() 方法时，实际上调用的是 dowait(false, 0L)方法。 await() 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。\",\"public int await() throws InterruptedException, BrokenBarrierException { try { return dowait(false, 0L); } catch (TimeoutException toe) { throw new Error(toe); // cannot happen } } \",\"dowait(false, 0L)方法源码分析如下：\",\" // 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。 private int count; /** * Main barrier code, covering the various policies. */ private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { final ReentrantLock lock = this.lock; // 锁住 lock.lock(); try { final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); // 如果线程中断了，抛出异常 if (Thread.interrupted()) { breakBarrier(); throw new InterruptedException(); } // cout减1 int index = --count; // 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件 if (index == 0) { // tripped boolean ranAction = false; try { final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; // 将 count 重置为 parties 属性的初始化值 // 唤醒之前等待的线程 // 下一波执行开始 nextGeneration(); return 0; } finally { if (!ranAction) breakBarrier(); } } // loop until tripped, broken, interrupted, or timed out for (;;) { try { if (!timed) trip.await(); else if (nanos > 0L) nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation && ! g.broken) { breakBarrier(); throw ie; } else { // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \\\"belong\\\" to subsequent execution. Thread.currentThread().interrupt(); } } if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed && nanos <= 0L) { breakBarrier(); throw new TimeoutException(); } } } finally { lock.unlock(); } } \"]},\"912\":{\"h\":\"虚拟线程\",\"t\":[\"虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\",\"虽然目前面试中问的不多，但还是建议大家去简单了解一下，具体可以阅读这篇文章：虚拟线程极简入门 。重点搞清楚虚拟线程和平台线程的关系以及虚拟线程的优势即可。\"]},\"913\":{\"h\":\"参考\",\"t\":[\"《深入理解 Java 虚拟机》\",\"《实战 Java 高并发程序设计》\",\"带你了解下 SynchronousQueue（并发队列专题）：https://juejin.cn/post/7031196740128768037\",\"阻塞队列 — DelayedWorkQueue 源码分析：https://zhuanlan.zhihu.com/p/310621485\",\"Java 多线程（三）——FutureTask/CompletableFuture：https://www.cnblogs.com/iwehdio/p/14285282.html\",\"Java 并发之 AQS 详解：https://www.cnblogs.com/waterystone/p/4920797.html\",\"Java 并发包基石-AQS 详解：https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\",\"File not found\"]},\"914\":{\"c\":[\"Java\"]},\"915\":{\"c\":[\"Java并发\"]},\"916\":{\"h\":\"Java 线程池最佳实践\",\"t\":[\"简单总结一下我了解的使用线程池的时候应该注意的东西，网上似乎还没有专门写这方面的文章。\"]},\"917\":{\"h\":\"1、正确声明线程池\",\"t\":[\"线程池必须手动通过 ThreadPoolExecutor 的构造函数来声明，避免使用Executors 类创建线程池，会有 OOM 风险。\",\"Executors 返回线程池对象的弊端如下(后文会详细介绍到)：\",\"FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。\",\"ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"说白了就是：使用有界队列，控制线程创建数量。\",\"除了避免 OOM 的原因之外，不推荐使用 Executors提供的两种快捷的线程池的原因还有：\",\"实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。\",\"我们应该显示地给我们的线程池命名，这样有助于我们定位问题。\"]},\"918\":{\"h\":\"2、监测线程池运行状态\",\"t\":[\"你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。\",\"除此之外，我们还可以利用 ThreadPoolExecutor 的相关 API 做一个简陋的监控。从下图可以看出， ThreadPoolExecutor提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。\",\"下面是一个简单的 Demo。printThreadPoolStatus()会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。\",\"/** * 打印线程池的状态 * * @param threadPool 线程池对象 */ public static void printThreadPoolStatus(ThreadPoolExecutor threadPool) { ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(1, createThreadFactory(\\\"print-images/thread-pool-status\\\", false)); scheduledExecutorService.scheduleAtFixedRate(() -> { log.info(\\\"=========================\\\"); log.info(\\\"ThreadPool Size: [{}]\\\", threadPool.getPoolSize()); log.info(\\\"Active Threads: {}\\\", threadPool.getActiveCount()); log.info(\\\"Number of Tasks : {}\\\", threadPool.getCompletedTaskCount()); log.info(\\\"Number of Tasks in Queue: {}\\\", threadPool.getQueue().size()); log.info(\\\"=========================\\\"); }, 0, 1, TimeUnit.SECONDS); } \"]},\"919\":{\"h\":\"3、建议不同类别的业务用不同的线程池\",\"t\":[\"很多人在实际项目中都会有类似这样的问题：我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？\",\"一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。\",\"我们再来看一个真实的事故案例！ (本案例来源自：《线程池运用不当的一次线上事故》 ，很精彩的一个案例)\",\"案例代码概览\",\"上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。\",\"试想这样一种极端情况：假如我们线程池的核心线程数为 n，父任务（扣费任务）数量为 n，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 \\\"死锁\\\" 。\",\"线程池使用不当导致死锁\",\"解决方法也很简单，就是新增加一个用于执行子任务的线程池专门为其服务。\"]},\"920\":{\"h\":\"4、别忘记给线程池命名\",\"t\":[\"初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。\",\"默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。\",\"给线程池里的线程命名通常有下面两种方式：\",\"1、利用 guava 的 ThreadFactoryBuilder\",\"ThreadFactory threadFactory = new ThreadFactoryBuilder() .setNameFormat(threadNamePrefix + \\\"-%d\\\") .setDaemon(true).build(); ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory) \",\"2、自己实现 ThreadFactory。\",\"import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.atomic.AtomicInteger; /** * 线程工厂，它设置线程名称，有利于我们定位问题。 */ public final class NamingThreadFactory implements ThreadFactory { private final AtomicInteger threadNum = new AtomicInteger(); private final ThreadFactory delegate; private final String name; /** * 创建一个带名字的线程池生产工厂 */ public NamingThreadFactory(ThreadFactory delegate, String name) { this.delegate = delegate; this.name = name; // TODO consider uniquifying this } @Override public Thread newThread(Runnable r) { Thread t = delegate.newThread(r); t.setName(name + \\\" [#\\\" + threadNum.incrementAndGet() + \\\"]\\\"); return t; } } \"]},\"921\":{\"h\":\"5、正确配置线程池参数\",\"t\":[\"说到如何给线程池配置参数，美团的骚操作至今让我难忘（后面会提到）！\",\"我们先来看一下各种书籍和博客上一般推荐的配置线程池参数的方式，可以作为参考。\"]},\"922\":{\"h\":\"常规操作\",\"t\":[\"很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了上下文切换 成本。不清楚什么是上下文切换的话，可以看我下面的介绍。\",\"上下文切换：\",\"多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。\",\"上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\",\"Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。\",\"类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。\",\"如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。\",\"如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。\",\"有一个简单并且适用面比较广的公式：\",\"CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\",\"I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。\",\"如何判断是 CPU 密集任务还是 IO 密集任务？\",\"CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。\",\"🌈 拓展一下（参见：issue#1737）：\",\"线程数更严谨的计算的方法应该是：最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间）），其中 WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）。\",\"线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。\",\"我们可以通过 JDK 自带的工具 VisualVM 来查看 WT/ST 比例。\",\"CPU 密集型任务的 WT/ST 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）= N，和我们上面说的 N（CPU 核心数）+1 差不多。\",\"IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT/ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。\",\"注意：上面提到的公示也只是参考，实际项目不太可能直接按照公式来设置线程池参数，毕竟不同的业务场景对应的需求不同，具体还是要根据项目实际线上运行情况来动态调整。接下来介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！\"]},\"923\":{\"h\":\"美团的骚操作\",\"t\":[\"美团技术团队在《Java 线程池实现原理及其在美团业务中的实践》这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。\",\"美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：\",\"corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。\",\"maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"为什么是这三个参数？\",\"我在这篇《新手也能看懂的线程池学习总结》 中就说过这三个参数是 ThreadPoolExecutor 最重要的参数，它们基本决定了线程池对于任务的处理策略。\",\"如何支持参数动态配置？ 且看 ThreadPoolExecutor 提供的下面这些方法。\",\"格外需要注意的是corePoolSize， 程序运行期间的时候，我们调用 setCorePoolSize（）这个方法的话，线程池会首先判断当前工作线程数是否大于corePoolSize，如果大于的话就会回收工作线程。\",\"另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 ResizableCapacityLinkedBlockIngQueue 的队列（主要就是把LinkedBlockingQueue的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。\",\"最终实现的可动态修改线程池参数效果如下。👏👏👏\",\"动态配置线程池参数最终效果\",\"如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：\",\"Hippo4j：异步线程池框架，支持线程池动态变更&监控&报警，无需修改代码轻松引入。支持多种使用模式，轻松引入，致力于提高系统运行保障能力。\",\"Dynamic TP：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。\"]},\"924\":{\"h\":\"6、别忘记关闭线程池\",\"t\":[\"当线程池不再需要使用时，应该显式地关闭线程池，释放线程资源。\",\"线程池提供了两个关闭方法：\",\"shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。\",\"shutdownNow（） :关闭线程池，线程池的状态变为 STOP。线程池会终止当前正在运行的任务，停止处理排队的任务并返回正在等待执行的 List。\",\"调用完 shutdownNow 和 shuwdown 方法后，并不代表线程池已经完成关闭操作，它只是异步的通知线程池进行关闭处理。如果要同步等待线程池彻底关闭后才继续往下执行，需要调用awaitTermination方法进行同步等待。\",\"在调用 awaitTermination() 方法时，应该设置合理的超时时间，以避免程序长时间阻塞而导致性能问题。另外。由于线程池中的任务可能会被取消或抛出异常，因此在使用 awaitTermination() 方法时还需要进行异常处理。awaitTermination() 方法会抛出 InterruptedException 异常，需要捕获并处理该异常，以避免程序崩溃或者无法正常退出。\",\"// ... // 关闭线程池 executor.shutdown(); try { // 等待线程池关闭，最多等待5分钟 if (!executor.awaitTermination(5, TimeUnit.MINUTES)) { // 如果等待超时，则打印日志 System.err.println(\\\"线程池未能在5分钟内完全关闭\\\"); } } catch (InterruptedException e) { // 异常处理 } \"]},\"925\":{\"h\":\"7、线程池尽量不要放耗时任务\",\"t\":[\"线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。\",\"因此，在使用线程池时，我们应该尽量避免将耗时任务提交到线程池中执行。对于一些比较耗时的操作，如网络请求、文件读写等，可以采用异步操作的方式来处理，以避免阻塞线程池中的线程。\"]},\"926\":{\"h\":\"8、线程池使用的一些小坑\"},\"927\":{\"h\":\"重复创建线程池的坑\",\"t\":[\"线程池是可以复用的，一定不要频繁创建线程池比如一个用户请求到了就单独创建一个线程池。\",\"@GetMapping(\\\"wrong\\\") public String wrong() throws InterruptedException { // 自定义线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor(5,10,1L,TimeUnit.SECONDS,new ArrayBlockingQueue<>(100),new ThreadPoolExecutor.CallerRunsPolicy()); // 处理任务 executor.execute(() -> { // ...... } return \\\"OK\\\"; } \",\"出现这种问题的原因还是对于线程池认识不够，需要加强线程池的基础知识。\"]},\"928\":{\"h\":\"Spring 内部线程池的坑\",\"t\":[\"使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。\",\"@Configuration @EnableAsync public class ThreadPoolExecutorConfig { @Bean(name=\\\"threadPoolExecutor\\\") public Executor threadPoolExecutor(){ ThreadPoolTaskExecutor threadPoolExecutor = new ThreadPoolTaskExecutor(); int processNum = Runtime.getRuntime().availableProcessors(); // 返回可用处理器的Java虚拟机的数量 int corePoolSize = (int) (processNum / (1 - 0.2)); int maxPoolSize = (int) (processNum / (1 - 0.5)); threadPoolExecutor.setCorePoolSize(corePoolSize); // 核心池大小 threadPoolExecutor.setMaxPoolSize(maxPoolSize); // 最大线程数 threadPoolExecutor.setQueueCapacity(maxPoolSize * 1000); // 队列程度 threadPoolExecutor.setThreadPriority(Thread.MAX_PRIORITY); threadPoolExecutor.setDaemon(false); threadPoolExecutor.setKeepAliveSeconds(300);// 线程空闲时间 threadPoolExecutor.setThreadNamePrefix(\\\"test-Executor-\\\"); // 线程名字前缀 return threadPoolExecutor; } } \"]},\"929\":{\"h\":\"线程池和 ThreadLocal 共用的坑\",\"t\":[\"线程池和 ThreadLocal共用，可能会导致线程从ThreadLocal获取到的是旧值/脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 ThreadLocal 变量也会被重用，这就导致一个线程可能获取到其他线程的ThreadLocal 值。\",\"不要以为代码中没有显示使用线程池就不存在线程池了，像常用的 Web 服务器 Tomcat 处理任务为了提高并发量，就使用到了线程池，并且使用的是基于原生 Java 线程池改进完善得到的自定义线程池。\",\"当然了，你可以将 Tomcat 设置为单线程处理任务。不过，这并不合适，会严重影响其处理任务的速度。\",\"server.tomcat.max-threads=1 \",\"解决上述问题比较建议的办法是使用阿里巴巴开源的 TransmittableThreadLocal(TTL)。TransmittableThreadLocal类继承并加强了 JDK 内置的InheritableThreadLocal类，在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。\",\"TransmittableThreadLocal 项目地址：https://github.com/alibaba/transmittable-thread-local 。\",\"File not found\"]},\"930\":{\"c\":[\"Java\"]},\"931\":{\"c\":[\"Java并发\"]},\"932\":{\"h\":\"Java 线程池详解\",\"t\":[\"池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\",\"这篇文章我会详细介绍一下线程池的基本概念以及核心原理。\"]},\"933\":{\"h\":\"线程池介绍\",\"t\":[\"顾名思义，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。\",\"这里借用《Java 并发编程的艺术》书中的部分内容来总结一下使用线程池的好处：\",\"降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\",\"提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\",\"线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。\"]},\"934\":{\"h\":\"Executor 框架介绍\",\"t\":[\"Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。\",\"this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。\",\"Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。\",\"Executor 框架结构主要由三大部分组成：\",\"1、任务(Runnable /Callable)\",\"执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。\",\"2、任务的执行(Executor)\",\"如下图所示，包括任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。\",\"这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 ThreadPoolExecutor 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。\",\"注意： 通过查看 ScheduledThreadPoolExecutor 源代码我们发现 ScheduledThreadPoolExecutor 实际上是继承了 ThreadPoolExecutor 并实现了 ScheduledExecutorService ，而 ScheduledExecutorService 又实现了 ExecutorService，正如我们上面给出的类关系图显示的一样。\",\"ThreadPoolExecutor 类描述:\",\"//AbstractExecutorService实现了ExecutorService接口 public class ThreadPoolExecutor extends AbstractExecutorService \",\"ScheduledThreadPoolExecutor 类描述:\",\"//ScheduledExecutorService继承ExecutorService接口 public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService \",\"3、异步计算的结果(Future)\",\"Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。\",\"当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）\",\"Executor 框架的使用示意图：\",\"Executor 框架的使用示意图\",\"主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。\",\"把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command））或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable <T> task））。\",\"如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 execute()方法和 submit()方法的区别，submit()会返回一个 FutureTask 对象）。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。\",\"最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。\"]},\"935\":{\"h\":\"ThreadPoolExecutor 类介绍（重要）\",\"t\":[\"线程池实现类 ThreadPoolExecutor 是 Executor 框架最核心的类。\"]},\"936\":{\"h\":\"构造方法介绍\",\"t\":[\"ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。\",\" /** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */ public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 ) { if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } \",\"下面这些对创建非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。\",\"ThreadPoolExecutor 3 个最重要的参数：\",\"corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。\",\"maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。\",\"workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"ThreadPoolExecutor其他常见参数 :\",\"keepAliveTime:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。\",\"unit : keepAliveTime 参数的时间单位。\",\"threadFactory :executor 创建新线程的时候会用到。\",\"handler :饱和策略。关于饱和策略下面单独介绍一下。\",\"下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：\",\"线程池各个参数的关系\",\"ThreadPoolExecutor 饱和策略定义:\",\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:\",\"ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。\",\"ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。\",\"ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。\",\"ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。\",\"举个例子：\",\"Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）。\"]},\"937\":{\"h\":\"线程池创建两种方式\",\"t\":[\"方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。\",\"通过构造方法实现\",\"方式二：通过 Executor 框架的工具类 Executors 来创建。\",\"我们可以创建多种类型的 ThreadPoolExecutor：\",\"FixedThreadPool：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。\",\"SingleThreadExecutor： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。\",\"CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\",\"ScheduledThreadPool：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。\",\"对应 Executors 工具类中的方法如图所示：\",\"《阿里巴巴 Java 开发手册》强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险\",\"Executors 返回线程池对象的弊端如下(后文会详细介绍到)：\",\"FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。\",\"ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。\",\"// 无界队列 LinkedBlockingQueue public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>()); } // 无界队列 LinkedBlockingQueue public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>())); } // 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE` public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>()); } // DelayedWorkQueue（延迟阻塞队列） public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } \"]},\"938\":{\"h\":\"线程池常用的阻塞队列总结\",\"t\":[\"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。\",\"不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。\",\"容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）：FixedThreadPool 和 SingleThreadExector 。FixedThreadPool最多只能创建核心线程数的线程（核心线程数和最大线程数相等），SingleThreadExector只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。\",\"SynchronousQueue（同步队列）：CachedThreadPool 。SynchronousQueue 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。\",\"DelayedWorkQueue（延迟阻塞队列）：ScheduledThreadPool 和 SingleThreadScheduledExecutor 。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。\"]},\"939\":{\"h\":\"线程池原理分析（重要）\",\"t\":[\"我们上面讲解了 Executor框架以及 ThreadPoolExecutor 类，下面让我们实战一下，来通过写一个 ThreadPoolExecutor 的小 Demo 来回顾上面的内容。\"]},\"940\":{\"h\":\"ThreadPoolExecutor 示例代码\",\"t\":[\"首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）\",\"MyRunnable.java\",\"import java.util.Date; /** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 * @author shuang.kou */ public class MyRunnable implements Runnable { private String command; public MyRunnable(String s) { this.command = s; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \\\" Start. Time = \\\" + new Date()); processCommand(); System.out.println(Thread.currentThread().getName() + \\\" End. Time = \\\" + new Date()); } private void processCommand() { try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } } @Override public String toString() { return this.command; } } \",\"编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。\",\"ThreadPoolExecutorDemo.java\",\"import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; public class ThreadPoolExecutorDemo { private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; public static void main(String[] args) { //使用阿里巴巴推荐的创建线程池的方式 //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue<>(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy()); for (int i = 0; i < 10; i++) { //创建WorkerThread对象（WorkerThread类实现了Runnable 接口） Runnable worker = new MyRunnable(\\\"\\\" + i); //执行Runnable executor.execute(worker); } //终止线程池 executor.shutdown(); while (!executor.isTerminated()) { } System.out.println(\\\"Finished all threads\\\"); } } \",\"可以看到我们上面的代码指定了：\",\"corePoolSize: 核心线程数为 5。\",\"maximumPoolSize：最大线程数 10\",\"keepAliveTime : 等待时间为 1L。\",\"unit: 等待时间的单位为 TimeUnit.SECONDS。\",\"workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;\",\"handler:饱和策略为 CallerRunsPolicy。\",\"输出结构：\",\"pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020 pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020 pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020 pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020 pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020 pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020 pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020 pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020 pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020 pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020 pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020 Finished all threads // 任务全部执行完了才会跳出来，因为executor.isTerminated()判断为true了才会跳出while循环，当且仅当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true \"]},\"941\":{\"h\":\"线程池原理分析\",\"t\":[\"我们通过前面的代码输出结果可以看出：线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）\",\"现在，我们就分析上面的输出内容来简单分析一下线程池原理。\",\"为了搞懂线程池的原理，我们需要首先分析一下 execute方法。 在示例代码中，我们使用 executor.execute(worker)来提交一个任务到线程池中去。\",\"这个方法非常重要，下面我们来看看它的源码：\",\" // 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount) private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int workerCountOf(int c) { return c & CAPACITY; } //任务队列 private final BlockingQueue<Runnable> workQueue; public void execute(Runnable command) { // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // ctl 中保存的线程池当前的一些状态信息 int c = ctl.get(); // 下面会涉及到 3 步 操作 // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) < corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。 // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去 if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。 if (!isRunning(recheck) && remove(command)) reject(command); // 如果当前工作线程数量为0，新创建一个线程并执行。 else if (workerCountOf(recheck) == 0) addWorker(null, false); } //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 // 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command); } \",\"这里简单分析一下整个流程（对整个逻辑进行了简化，方便理解）：\",\"如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。\",\"如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。\",\"如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。\",\"如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用RejectedExecutionHandler.rejectedExecution()方法。\",\"图解线程池实现原理\",\"在 execute 方法中，多次调用 addWorker 方法。addWorker 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。\",\" // 全局锁，并发操作必备 private final ReentrantLock mainLock = new ReentrantLock(); // 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合 private int largestPoolSize; // 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合 private final HashSet<Worker> workers = new HashSet<>(); //获取线程池状态 private static int runStateOf(int c) { return c & ~CAPACITY; } //判断线程池的状态是否为 Running private static boolean isRunning(int c) { return c < SHUTDOWN; } /** * 添加新的工作线程到线程池 * @param firstTask 要执行 * @param core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小 * @return 添加成功就返回true否则返回false */ private boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) { //这两句用来获取线程池的状态 int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs >= SHUTDOWN && ! (rs == SHUTDOWN && firstTask == null && ! workQueue.isEmpty())) return false; for (;;) { //获取线程池中工作的线程的数量 int wc = workerCountOf(c); // core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)) return false; //原子操作将workcount的数量加1 if (compareAndIncrementWorkerCount(c)) break retry; // 如果线程的状态改变了就再次执行上述操作 c = ctl.get(); if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } // 标记工作线程是否启动成功 boolean workerStarted = false; // 标记工作线程是否创建成功 boolean workerAdded = false; Worker w = null; try { w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { // 加锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //获取线程池状态 int rs = runStateOf(ctl.get()); //rs < SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中 //(rs=SHUTDOWN && firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker // firstTask == null证明只新建线程而不执行任务 if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); //更新当前工作线程的最大容量 int s = workers.size(); if (s > largestPoolSize) largestPoolSize = s; // 工作线程是否启动成功 workerAdded = true; } } finally { // 释放锁 mainLock.unlock(); } //// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例 if (workerAdded) { t.start(); /// 标记线程启动成功 workerStarted = true; } } } finally { // 线程启动失败，需要从工作线程中移除对应的Worker if (! workerStarted) addWorkerFailed(w); } return workerStarted; } \",\"更多关于线程池源码分析的内容推荐这篇文章：硬核干货：4W 字从源码上分析 JUC 线程池 ThreadPoolExecutor 的实现原理\",\"现在，让我们在回到示例代码， 现在应该是不是很容易就可以搞懂它的原理了呢？\",\"没搞懂的话，也没关系，可以看看我的分析：\",\"我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。\"]},\"942\":{\"h\":\"几个常见的对比\"},\"943\":{\"h\":\"Runnable vs Callable\",\"t\":[\"Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是 Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。\",\"工具类 Executors 可以实现将 Runnable 对象转换成 Callable 对象。（Executors.callable(Runnable task) 或 Executors.callable(Runnable task, Object result)）。\",\"Runnable.java\",\"@FunctionalInterface public interface Runnable { /** * 被线程执行，没有返回值也无法抛出异常 */ public abstract void run(); } \",\"Callable.java\",\"@FunctionalInterface public interface Callable<V> { /** * 计算结果，或在无法这样做时抛出异常。 * @return 计算得出的结果 * @throws 如果无法计算结果，则抛出异常 */ V call() throws Exception; } \"]},\"944\":{\"h\":\"execute() vs submit()\",\"t\":[\"execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\",\"submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法的话，如果在 timeout 时间内任务还没有执行完，就会抛出 java.util.concurrent.TimeoutException。\",\"这里只是为了演示使用，推荐使用 ThreadPoolExecutor 构造方法来创建线程池。\",\"示例 1：使用 get()方法获取返回值。\",\"ExecutorService executorService = Executors.newFixedThreadPool(3); Future<String> submit = executorService.submit(() -> { try { Thread.sleep(5000L); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"abc\\\"; }); String s = submit.get(); System.out.println(s); executorService.shutdown(); \",\"输出：\",\"abc \",\"示例 2：使用 get（long timeout，TimeUnit unit）方法获取返回值。\",\"ExecutorService executorService = Executors.newFixedThreadPool(3); Future<String> submit = executorService.submit(() -> { try { Thread.sleep(5000L); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"abc\\\"; }); String s = submit.get(3, TimeUnit.SECONDS); System.out.println(s); executorService.shutdown(); \",\"输出：\",\"Exception in thread \\\"main\\\" java.util.concurrent.TimeoutException at java.util.concurrent.FutureTask.get(FutureTask.java:205) \"]},\"945\":{\"h\":\"shutdown() VS shutdownNow()\",\"t\":[\"shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。\",\"shutdownNow（） :关闭线程池，线程池的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。\"]},\"946\":{\"h\":\"isTerminated() VS isShutdown()\",\"t\":[\"isShutDown 当调用 shutdown() 方法后返回为 true。\",\"isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true\"]},\"947\":{\"h\":\"几种常见的内置线程池\"},\"948\":{\"h\":\"FixedThreadPool\"},\"949\":{\"h\":\"介绍\",\"t\":[\"FixedThreadPool 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：\",\" /** * 创建一个可重用固定数量线程的线程池 */ public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory); } \",\"另外还有一个 FixedThreadPool 的实现方法，和上面的类似，所以这里不多做阐述：\",\" public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } \",\"从上面源代码可以看出新创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。\",\"即使 maximumPoolSize 的值比 corePoolSize 大，也至多只会创建 corePoolSize 个线程。这是因为FixedThreadPool 使用的是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列），队列永远不会被放满。\"]},\"950\":{\"h\":\"执行任务过程介绍\",\"t\":[\"FixedThreadPool 的 execute() 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：\",\"FixedThreadPool的execute()方法运行示意图\",\"上图说明：\",\"如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；\",\"当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；\",\"线程池中的线程执行完 手头的任务后，会在循环中反复从 LinkedBlockingQueue 中获取任务来执行；\"]},\"951\":{\"h\":\"为什么不推荐使用 FixedThreadPool ？\",\"t\":[\"FixedThreadPool 使用无界队列 LinkedBlockingQueue（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响：\",\"当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；\",\"由于使用无界队列时 maximumPoolSize 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 FixedThreadPool的源码可以看出创建的 FixedThreadPool 的 corePoolSize 和 maximumPoolSize 被设置为同一个值。\",\"由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数；\",\"运行中的 FixedThreadPool（未执行 shutdown()或 shutdownNow()）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。\"]},\"952\":{\"h\":\"SingleThreadExecutor\"},\"953\":{\"h\":\"介绍\",\"t\":[\"SingleThreadExecutor 是只有一个线程的线程池。下面看看SingleThreadExecutor 的实现：\",\" /** *返回只有一个线程的线程池 */ public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory)); } \",\" public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"从上面源代码可以看出新创建的 SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 都被设置为 1，其他参数和 FixedThreadPool 相同。\"]},\"954\":{\"h\":\"执行任务过程介绍\",\"t\":[\"SingleThreadExecutor 的运行示意图（该图片来源：《Java 并发编程的艺术》）：\",\"SingleThreadExecutor的运行示意图\",\"上图说明 :\",\"如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；\",\"当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue\",\"线程执行完当前的任务后，会在循环中反复从LinkedBlockingQueue 中获取任务来执行；\"]},\"955\":{\"h\":\"为什么不推荐使用 SingleThreadExecutor ？\",\"t\":[\"SingleThreadExecutor 和 FixedThreadPool 一样，使用的都是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue（无界队列）作为线程池的工作队列。SingleThreadExecutor 使用无界队列作为线程池的工作队列会对线程池带来的影响与 FixedThreadPool 相同。说简单点，就是可能会导致 OOM。\"]},\"956\":{\"h\":\"CachedThreadPool\"},\"957\":{\"h\":\"介绍\",\"t\":[\"CachedThreadPool 是一个会根据需要创建新线程的线程池。下面通过源码来看看 CachedThreadPool 的实现：\",\" /** * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。 */ public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), threadFactory); } \",\" public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"CachedThreadPool 的corePoolSize 被设置为空（0），maximumPoolSize被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，CachedThreadPool 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。\"]},\"958\":{\"h\":\"执行任务过程介绍\",\"t\":[\"CachedThreadPool 的 execute() 方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：\",\"CachedThreadPool的execute()方法的执行示意图\",\"上图说明：\",\"首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤 2；\",\"当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 1 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成；\"]},\"959\":{\"h\":\"为什么不推荐使用 CachedThreadPool ？\",\"t\":[\"CachedThreadPool 使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。\"]},\"960\":{\"h\":\"ScheduledThreadPool\"},\"961\":{\"h\":\"介绍\",\"t\":[\"ScheduledThreadPool 用来在给定的延迟后运行任务或者定期执行任务。这个在实际项目中基本不会被用到，也不推荐使用，大家只需要简单了解一下即可。\",\"public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } \",\"ScheduledThreadPool 是通过 ScheduledThreadPoolExecutor 创建的，使用的DelayedWorkQueue（延迟阻塞队列）作为线程池的任务队列。\",\"DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。\",\"ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor，所以创建 ScheduledThreadExecutor 本质也是创建一个 ThreadPoolExecutor 线程池，只是传入的参数不相同。\",\"public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService \"]},\"962\":{\"h\":\"ScheduledThreadPoolExecutor 和 Timer 对比\",\"t\":[\"Timer 对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；\",\"Timer 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;\",\"在TimerTask 中抛出的运行时异常会杀死一个线程，从而导致 Timer 死机即计划任务将不再运行。ScheduledThreadExecutor 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 afterExecute 方法ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。\",\"关于定时任务的详细介绍，可以看这篇文章：Java 定时任务详解 。\"]},\"963\":{\"h\":\"线程池最佳实践\",\"t\":[\"Java 线程池最佳实践这篇文章总结了一些使用线程池的时候应该注意的东西，实际项目使用线程池之前可以看看。\"]},\"964\":{\"h\":\"参考\",\"t\":[\"《Java 并发编程的艺术》\",\"Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example\",\"java.util.concurrent.ScheduledThreadPoolExecutor Example\",\"ThreadPoolExecutor – Java Thread Pool Example\",\"File not found\"]},\"965\":{\"c\":[\"Java\"]},\"966\":{\"c\":[\"Java并发\"]},\"967\":{\"h\":\"JMM（Java 内存模型）详解\",\"t\":[\"JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。\",\"要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！\"]},\"968\":{\"h\":\"从 CPU 缓存模型说起\",\"t\":[\"为什么要弄一个 CPU 高速缓存呢？ 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。\",\"我们甚至可以把 内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。\",\"总结：CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。\",\"为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。\",\"🐛 修正（参见：issue#1848）：对 CPU 缓存模型绘图不严谨的地方进行完善。\",\"CPU 缓存模型示意图\",\"现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache。有些 CPU 可能还有 L4 Cache，这里不做讨论，并不常见\",\"CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不一致性的问题 ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。\",\"CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 MESI 协议）或者其他手段来解决。 这个缓存一致性协议指的是在 CPU 高速缓存与主内存交互的时候需要遵守的原则和规范。不同的 CPU 中，使用的缓存一致性协议通常也会有所不同。\",\"缓存一致性协议\",\"我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，操作系统也就同样需要解决内存缓存不一致性问题。\",\"操作系统通过 内存模型（Memory Model） 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型。\"]},\"969\":{\"h\":\"指令重排序\",\"t\":[\"说完了 CPU 缓存模型，我们再来看看另外一个比较重要的概念 指令重排序 。\",\"为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。\",\"什么是指令重排序？ 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。\",\"常见的指令重排序有下面 2 种情况：\",\"编译器优化重排：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。\",\"指令并行重排：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\",\"另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。\",\"Java 源代码会经历 编译器优化重排 —> 指令并行重排 —> 内存系统重排 的过程，最终才变成操作系统可执行的指令序列。\",\"指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。\",\"编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。\",\"内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。\"]},\"970\":{\"h\":\"JMM(Java Memory Model)\"},\"971\":{\"h\":\"什么是 JMM？为什么需要 JMM？\",\"t\":[\"Java 是最早尝试提供内存模型的编程语言。由于早期内存模型存在一些缺陷（比如非常容易削弱编译器的优化能力），从 Java5 开始，Java 开始使用新的内存模型 《JSR-133：Java Memory Model and Thread Specification》 。\",\"一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。\",\"这只是 JMM 存在的其中一个原因。实际上，对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。\",\"为什么要遵守这些并发相关的原则和规范呢？ 这是因为并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则（后文会详细介绍到）来解决这个指令重排序问题。\",\"JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如 volatile、synchronized、各种 Lock）即可开发出并发安全的程序。\"]},\"972\":{\"h\":\"JMM 是如何抽象线程和主内存之间的关系？\",\"t\":[\"Java 内存模型（JMM） 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。\",\"在 JDK1.2 之前，Java 的内存模型实现总是从 主存 （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 本地内存 （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。\",\"这和我们上面讲到的 CPU 缓存模型非常相似。\",\"什么是主内存？什么是本地内存？\",\"主内存：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。\",\"本地内存：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\",\"Java 内存模型的抽象示意图如下：\",\"JMM(Java 内存模型)\",\"从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：\",\"线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。\",\"线程 2 到主存中读取对应的共享变量的值。\",\"也就是说，JMM 为共享变量提供了可见性的保障。\",\"不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：\",\"线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。\",\"线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。\",\"关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：\",\"锁定（lock）: 作用于主内存中的变量，将他标记为一个线程独享变量。\",\"解锁（unlock）: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。\",\"read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。\",\"load(载入)：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。\",\"use(使用)：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。\",\"assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\",\"store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。\",\"write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。\",\"除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：\",\"不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。\",\"一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。\",\"一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。\",\"如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。\",\"如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。\",\"……\"]},\"973\":{\"h\":\"Java 内存区域和 JMM 有何区别？\",\"t\":[\"这是一个比较常见的问题，很多初学者非常容易搞混。 Java 内存区域和内存模型是完全不一样的两个东西：\",\"JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。\",\"Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。\"]},\"974\":{\"h\":\"happens-before 原则是什么？\",\"t\":[\"happens-before 这个概念最早诞生于 Leslie Lamport 于 1978 年发表的论文《Time，Clocks and the Ordering of Events in a Distributed System》。在这篇论文中，Leslie Lamport 提出了逻辑时钟的概念，这也成了第一个逻辑时钟算法 。在分布式环境中，通过一系列规则来定义逻辑时钟的变化，从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断。逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。\",\"上面提到的 happens-before 这个概念诞生的背景并不是重点，简单了解即可。\",\"JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。\",\"为什么需要 happens-before 原则？ happens-before 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：\",\"为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。\",\"对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。\",\"下面这张是 《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图，非常清晰。\",\"了解了 happens-before 原则的设计思想，我们再来看看 JSR-133 对 happens-before 原则的定义：\",\"如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。\",\"两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。\",\"我们看下面这段代码：\",\"int userNum = getUserNum(); // 1 int teacherNum = getTeacherNum(); // 2 int totalNum = userNum + teacherNum; // 3 \",\"1 happens-before 2\",\"2 happens-before 3\",\"1 happens-before 3\",\"虽然 1 happens-before 2，但对 1 和 2 进行重排序不会影响代码的执行结果，所以 JMM 是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3 执行之前，也就是说 1,2 happens-before 3 。\",\"happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。\",\"举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2 不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。\"]},\"975\":{\"h\":\"happens-before 常见规则有哪些？谈谈你的理解？\",\"t\":[\"happens-before 的规则就 8 条，说多不多，重点了解下面列举的 5 条即可。全记是不可能的，很快就忘记了，意义不大，随时查阅即可。\",\"程序顺序规则：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；\",\"解锁规则：解锁 happens-before 于加锁；\",\"volatile 变量规则：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。\",\"传递规则：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；\",\"线程启动规则：Thread 对象的 start()方法 happens-before 于此线程的每一个动作。\",\"如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。\"]},\"976\":{\"h\":\"happens-before 和 JMM 什么关系？\",\"t\":[\"happens-before 与 JMM 的关系用《Java 并发编程的艺术》这本书中的一张图就可以非常好的解释清楚。\",\"happens-before 与 JMM 的关系\"]},\"977\":{\"h\":\"再看并发编程三个重要特性\"},\"978\":{\"h\":\"原子性\",\"t\":[\"一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。\",\"在 Java 中，可以借助synchronized、各种 Lock 以及各种原子类实现原子性。\",\"synchronized 和各种 Lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 volatile或者final关键字）来保证原子操作。\"]},\"979\":{\"h\":\"可见性\",\"t\":[\"当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。\",\"在 Java 中，可以借助synchronized、volatile 以及各种 Lock 实现可见性。\",\"如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\"]},\"980\":{\"h\":\"有序性\",\"t\":[\"由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。\",\"我们上面讲重排序的时候也提到过：\",\"指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。\",\"在 Java 中，volatile 关键字可以禁止指令进行重排序优化。\"]},\"981\":{\"h\":\"总结\",\"t\":[\"Java 是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。\",\"CPU 可以通过制定缓存一致协议（比如 MESI 协议）来解决内存缓存不一致性问题。\",\"为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致 ，所以在多线程下，指令重排序可能会导致一些问题。\",\"你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。\",\"JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。\"]},\"982\":{\"h\":\"参考\",\"t\":[\"《Java 并发编程的艺术》第三章 Java 内存模型\",\"《深入浅出 Java 多线程》：http://concurrent.redspider.group/RedSpider.html\",\"Java 内存访问重排序的研究：https://tech.meituan.com/2014/09/23/java-memory-reordering.html\",\"嘿，同学，你要的 Java 内存模型 (JMM) 来了：https://xie.infoq.cn/article/739920a92d0d27e2053174ef2\",\"JSR 133 (Java Memory Model) FAQ：https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html\",\"File not found\"]},\"983\":{\"c\":[\"Java\"]},\"984\":{\"c\":[\"Java并发\"]},\"985\":{\"h\":\"乐观锁和悲观锁详解\",\"t\":[\"如果将悲观锁（Pessimistic Lock）和乐观锁（PessimisticLock 或 OptimisticLock）对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。\",\"在程序世界中，乐观锁和悲观锁的最终目的都是为了保证线程安全，避免在并发场景下的资源竞争问题。但是，相比于乐观锁，悲观锁对性能的影响更大！\"]},\"986\":{\"h\":\"什么是悲观锁？\",\"t\":[\"悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\",\"像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。\",\"public void performSynchronisedTask() { synchronized (this) { // 需要同步的操作 } } private Lock lock = new ReentrantLock(); lock.lock(); try { // 需要同步的操作 } finally { lock.unlock(); } \",\"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。\"]},\"987\":{\"h\":\"什么是乐观锁？\",\"t\":[\"乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。\",\"像 Java 中java.util.concurrent.atomic包下面的原子变量类（比如AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式 CAS 实现的。\",\"JUC原子类概览\",\"// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好 // 代价就是会消耗更多的内存空间（空间换时间） LongAdder longAdder = new LongAdder(); // 自增 longAdder.increment(); // 获取结果 longAdder.sum(); \",\"高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试（悲观锁的开销是固定的），这样同样会非常影响性能，导致 CPU 飙升。\",\"不过，大量失败重试的问题也是可以解决的，像我们前面提到的 LongAdder以空间换时间的方式就解决了这个问题。\",\"理论上来说：\",\"悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。\",\"乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考java.util.concurrent.atomic包下面的原子变量类）。\"]},\"988\":{\"h\":\"如何实现乐观锁？\",\"t\":[\"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\"]},\"989\":{\"h\":\"版本号机制\",\"t\":[\"一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。\",\"举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\",\"操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。\",\"在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。\",\"操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。\",\"操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。\",\"这样就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。\"]},\"990\":{\"h\":\"CAS 算法\",\"t\":[\"CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\",\"CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。\",\"原子操作 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。\",\"CAS 涉及到三个操作数：\",\"V：要更新的变量值(Var)\",\"E：预期值(Expected)\",\"N：拟写入的新值(New)\",\"当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。\",\"举一个简单的例子：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。\",\"i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。\",\"i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。\",\"当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。\",\"Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。\",\"sun.misc包下的Unsafe类提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作\",\"/** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */ public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update); public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update); public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update); \",\"关于 Unsafe 类的详细介绍可以看这篇文章：Java 魔法类 Unsafe 详解 - JavaGuide - 2022 。\"]},\"991\":{\"h\":\"乐观锁存在哪些问题？\",\"t\":[\"ABA 问题是乐观锁最常见的问题。\"]},\"992\":{\"h\":\"ABA 问题\",\"t\":[\"如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \\\"ABA\\\"问题。\",\"ABA 问题的解决思路是在变量前面追加上版本号或者时间戳。JDK 1.5 以后的 AtomicStampedReference 类就是用来解决 ABA 问题的，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\",\"public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) { Pair<V> current = pair; return expectedReference == current.reference && expectedStamp == current.stamp && ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp))); } \"]},\"993\":{\"h\":\"循环时间长开销大\",\"t\":[\"CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。\",\"如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：\",\"可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。\",\"可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。\"]},\"994\":{\"h\":\"只能保证一个共享变量的原子操作\",\"t\":[\"CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。\"]},\"995\":{\"h\":\"总结\",\"t\":[\"高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。不过，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。\",\"乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。\",\"CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。\",\"乐观锁的问题：ABA 问题、循环时间长开销大、只能保证一个共享变量的原子操作。\"]},\"996\":{\"h\":\"参考\",\"t\":[\"《Java 并发编程核心 78 讲》\",\"通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其 Java 实现！：https://zhuanlan.zhihu.com/p/71156910\",\"一文彻底搞懂 CAS 实现原理 & 深入到 CPU 指令：https://zhuanlan.zhihu.com/p/94976168\",\"File not found\"]},\"997\":{\"c\":[\"Java\"]},\"998\":{\"c\":[\"Java并发\"]},\"999\":{\"h\":\"从ReentrantLock的实现看AQS的原理及应用\",\"t\":[\"本文转载自：https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\",\"作者：美团技术团队\",\"Java 中的大部分同步类（Semaphore、ReentrantLock 等）都是基于 AbstractQueuedSynchronizer（简称为 AQS）实现的。AQS 是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。\",\"本文会从应用层逐渐深入到原理层，并通过 ReentrantLock 的基本特性和 ReentrantLock 与 AQS 的关联，来深入解读 AQS 相关独占锁的知识点，同时采取问答的模式来帮助大家理解 AQS。由于篇幅原因，本篇文章主要阐述 AQS 中独占锁的逻辑和 Sync Queue，不讲述包含共享锁和 Condition Queue 的部分（本篇文章核心为 AQS 原理剖析，只是简单介绍了 ReentrantLock，感兴趣同学可以阅读一下 ReentrantLock 的源码）。\"]},\"1000\":{\"h\":\"1 ReentrantLock\"},\"1001\":{\"h\":\"1.1 ReentrantLock 特性概览\",\"t\":[\"ReentrantLock 意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解 ReentrantLock 的特性，我们先将 ReentrantLock 跟常用的 Synchronized 进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：\",\"下面通过伪代码，进行更加直观的比较：\",\"// **************************Synchronized的使用方式************************** // 1.用于代码块 synchronized (this) {} // 2.用于对象 synchronized (object) {} // 3.用于方法 public synchronized void test () {} // 4.可重入 for (int i = 0; i < 100; i++) { synchronized (this) {} } // **************************ReentrantLock的使用方式************************** public void test () throw Exception { // 1.初始化选择公平锁、非公平锁 ReentrantLock lock = new ReentrantLock(true); // 2.可用于代码块 lock.lock(); try { try { // 3.支持多种加锁方式，比较灵活; 具有可重入特性 if(lock.tryLock(100, TimeUnit.MILLISECONDS)){ } } finally { // 4.手动释放锁 lock.unlock() } } finally { lock.unlock(); } } \"]},\"1002\":{\"h\":\"1.2 ReentrantLock 与 AQS 的关联\",\"t\":[\"通过上文我们已经了解，ReentrantLock 支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《不可不说的 Java“锁”事》），并且 ReentrantLock 的底层就是由 AQS 来实现的。那么 ReentrantLock 是如何通过公平锁和非公平锁与 AQS 关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与 AQS 之间的关系（加锁过程中与 AQS 的关联比较明显，解锁流程后续会介绍）。\",\"非公平锁源码中的加锁流程如下：\",\"// java.util.concurrent.locks.ReentrantLock#NonfairSync // 非公平锁 static final class NonfairSync extends Sync { ... final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } ... } \",\"这块代码的含义为：\",\"若通过 CAS 设置变量 State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。\",\"若通过 CAS 设置变量 State（同步状态）失败，也就是获取锁失败，则进入 Acquire 方法进行后续处理。\",\"第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：\",\"某个线程获取锁失败的后续流程是什么呢？有以下两种可能：\",\"(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是 AQS 框架的处理流程。\",\"(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\",\"对于问题 1 的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\",\"处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\",\"如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？\",\"带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：\",\"// java.util.concurrent.locks.ReentrantLock#FairSync static final class FairSync extends Sync { ... final void lock() { acquire(1); } ... } \",\"看到这块代码，我们可能会存在这种疑问：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？\",\"结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了 Acquire 方法，而 Acquire 方法是 FairSync 和 UnfairSync 的父类 AQS 中的核心方法。\",\"对于上边提到的问题，其实在 ReentrantLock 类源码中都无法解答，而这些问题的答案，都是位于 Acquire 方法所在的类 AbstractQueuedSynchronizer 中，也就是本文的核心——AQS。下面我们会对 AQS 以及 ReentrantLock 和 AQS 的关联做详细介绍（相关问题答案会在 2.3.5 小节中解答）。\"]},\"1003\":{\"h\":\"2 AQS\",\"t\":[\"首先，我们通过下面的架构图来整体了解一下 AQS 框架：\",\"上图中有颜色的为 Method，无颜色的为 Attribution。\",\"总的来说，AQS 框架共分为五层，自上而下由浅入深，从 AQS 对外暴露的 API 到底层基础数据。\",\"当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的 API 进入 AQS 内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。\",\"下面我们会从整体到细节，从流程到方法逐一剖析 AQS 框架，主要分析过程如下：\"]},\"1004\":{\"h\":\"2.1 原理概览\",\"t\":[\"AQS 核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到队列中。\",\"CLH：Craig、Landin and Hagersten 队列，是单向链表，AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO），AQS 是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。\",\"主要原理图如下：\",\"AQS 使用一个 Volatile 的 int 类型的成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取的排队工作，通过 CAS 完成对 State 值的修改。\"]},\"1005\":{\"h\":\"2.1.1 AQS 数据结构\",\"t\":[\"先来看下 AQS 中最基本的数据结构——Node，Node 即为上面 CLH 变体队列中的节点。\",\"解释一下几个方法和属性值的含义：\",\"方法和属性值\",\"含义\",\"waitStatus\",\"当前节点在队列中的状态\",\"thread\",\"表示处于该节点的线程\",\"prev\",\"前驱指针\",\"predecessor\",\"返回前驱节点，没有的话抛出 npe\",\"nextWaiter\",\"指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍）\",\"next\",\"后继指针\",\"线程两种锁的模式：\",\"模式\",\"含义\",\"SHARED\",\"表示线程以共享的模式等待锁\",\"EXCLUSIVE\",\"表示线程正在以独占的方式等待锁\",\"waitStatus 有下面几个枚举值：\",\"枚举\",\"含义\",\"0\",\"当一个 Node 被初始化的时候的默认值\",\"CANCELLED\",\"为 1，表示线程获取锁的请求已经取消了\",\"CONDITION\",\"为-2，表示节点在等待队列中，节点线程等待唤醒\",\"PROPAGATE\",\"为-3，当前线程处在 SHARED 情况下，该字段才会使用\",\"SIGNAL\",\"为-1，表示线程已经准备好了，就等资源释放了\"]},\"1006\":{\"h\":\"2.1.2 同步状态 State\",\"t\":[\"在了解数据结构后，接下来了解一下 AQS 的同步状态——State。AQS 中维护了一个名为 state 的字段，意为同步状态，是由 Volatile 修饰的，用于展示当前临界资源的获锁情况。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private volatile int state; \",\"下面提供了几个访问这个字段的方法：\",\"方法名\",\"描述\",\"protected final int getState()\",\"获取 State 的值\",\"protected final void setState(int newState)\",\"设置 State 的值\",\"protected final boolean compareAndSetState(int expect, int update)\",\"使用 CAS 方式更新 State\",\"这几个方法都是 Final 修饰的，说明子类中无法重写它们。我们可以通过修改 State 字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。\",\"对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是 AQS 架构图中的第一层：API 层。\"]},\"1007\":{\"h\":\"2.2 AQS 重要方法与 ReentrantLock 的关联\",\"t\":[\"从架构图中可以得知，AQS 提供了大量用于自定义同步器实现的 Protected 方法。自定义同步器实现的相关方法也只是为了通过修改 State 字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock 需要实现的方法如下，并不是全部）：\",\"方法名\",\"描述\",\"protected boolean isHeldExclusively()\",\"该线程是否正在独占资源。只有用到 Condition 才需要去实现它。\",\"protected boolean tryAcquire(int arg)\",\"独占方式。arg 为获取锁的次数，尝试获取资源，成功则返回 True，失败则返回 False。\",\"protected boolean tryRelease(int arg)\",\"独占方式。arg 为释放锁的次数，尝试释放资源，成功则返回 True，失败则返回 False。\",\"protected int tryAcquireShared(int arg)\",\"共享方式。arg 为获取锁的次数，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\",\"protected boolean tryReleaseShared(int arg)\",\"共享方式。arg 为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回 True，否则返回 False。\",\"一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。ReentrantLock 是独占锁，所以实现了 tryAcquire-tryRelease。\",\"以非公平锁为例，这里主要阐述一下非公平锁与 AQS 之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。\",\"🐛 修正（参见：issue#1761）: 图中的一处小错误，(AQS)CAS 修改共享资源 State 成功之后应该是获取锁成功(非公平锁)。\",\"对应的源码如下：\",\"final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread();//获取当前线程 int c = getState(); if (c == 0) { if (compareAndSetState(0, acquires)) {//CAS抢锁 setExclusiveOwnerThread(current);//设置当前线程为独占线程 return true;//抢锁成功 } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } return false; } \",\"为了帮助大家理解 ReentrantLock 和 AQS 之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。\",\"加锁：\",\"通过 ReentrantLock 的加锁方法 Lock 进行加锁操作。\",\"会调用到内部类 Sync 的 Lock 方法，由于 Sync#lock 是抽象方法，根据 ReentrantLock 初始化选择的公平锁和非公平锁，执行相关内部类的 Lock 方法，本质上都会执行 AQS 的 Acquire 方法。\",\"AQS 的 Acquire 方法会执行 tryAcquire 方法，但是由于 tryAcquire 需要自定义同步器实现，因此执行了 ReentrantLock 中的 tryAcquire 方法，由于 ReentrantLock 是通过公平锁和非公平锁内部类实现的 tryAcquire 方法，因此会根据锁类型不同，执行不同的 tryAcquire。\",\"tryAcquire 是获取锁逻辑，获取失败后，会执行框架 AQS 的后续逻辑，跟 ReentrantLock 自定义同步器无关。\",\"解锁：\",\"通过 ReentrantLock 的解锁方法 Unlock 进行解锁。\",\"Unlock 会调用内部类 Sync 的 Release 方法，该方法继承于 AQS。\",\"Release 中会调用 tryRelease 方法，tryRelease 需要自定义同步器实现，tryRelease 只在 ReentrantLock 中的 Sync 实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。\",\"释放成功后，所有处理由 AQS 框架完成，与自定义同步器无关。\",\"通过上面的描述，大概可以总结出 ReentrantLock 加锁解锁时 API 层核心方法的映射关系。\"]},\"1008\":{\"h\":\"3 通过 ReentrantLock 理解 AQS\",\"t\":[\"ReentrantLock 中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。\",\"在非公平锁中，有一段这样的代码：\",\"// java.util.concurrent.locks.ReentrantLock static final class NonfairSync extends Sync { ... final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } ... } \",\"看一下这个 Acquire 是怎么写的：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"再看一下 tryAcquire 方法：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } \",\"可以看出，这里只是 AQS 的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以 ReentrantLock 为例）。如果该方法返回了 True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。\"]},\"1009\":{\"h\":\"3.1 线程加入等待队列\"},\"1010\":{\"h\":\"3.1.1 加入队列的时机\",\"t\":[\"当执行 Acquire(1)时，会通过 tryAcquire 获取锁。在这种情况下，如果获取锁失败，就会调用 addWaiter 加入到等待队列中去。\"]},\"1011\":{\"h\":\"3.1.2 如何加入队列\",\"t\":[\"获取锁失败后，会执行 addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } private final boolean compareAndSetTail(Node expect, Node update) { return unsafe.compareAndSwapObject(this, tailOffset, expect, update); } \",\"主要的流程如下：\",\"通过当前的线程和锁模式新建一个节点。\",\"Pred 指针指向尾节点 Tail。\",\"将 New 中 Node 的 Prev 指针指向 Pred。\",\"通过 compareAndSetTail 方法，完成尾节点的设置。这个方法主要是对 tailOffset 和 Expect 进行比较，如果 tailOffset 的 Node 和 Expect 的 Node 地址是相同的，那么设置 Tail 的值为 Update 的值。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer static { try { stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\\\"state\\\")); headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\\\"head\\\")); tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\\\"tail\\\")); waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\\\"waitStatus\\\")); nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\\\"next\\\")); } catch (Exception ex) { throw new Error(ex); } } \",\"从 AQS 的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset 指的是 tail 对应的偏移量，所以这个时候会将 new 出来的 Node 置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。\",\"如果 Pred 指针是 Null（说明等待队列中没有元素），或者当前 Pred 指针和 Tail 指向的位置不同（说明被别的线程已经修改），就需要看一下 Enq 的方法。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } \",\"如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter 就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。\",\"总结一下，线程获取锁的时候，过程大体如下：\",\"1、当没有线程获取到锁时，线程 1 获取锁成功。\",\"2、线程 2 申请锁，但是锁被线程 1 占有。\",\"img\",\"3、如果再有线程要获取锁，依次在队列中往后排队即可。\",\"回到上边的代码，hasQueuedPredecessors 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回 False，说明当前线程可以争取共享资源；如果返回 True，说明队列中存在有效节点，当前线程必须加入到等待队列中。\",\"// java.util.concurrent.locks.ReentrantLock public final boolean hasQueuedPredecessors() { // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t && ((s = h.next) == null || s.thread != Thread.currentThread()); } \",\"看到这里，我们理解一下 h != t && ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？\",\"双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当 h != t 时：如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了 Tail 指向 Head，没有将 Head 指向 Tail，此时队列中有元素，需要返回 True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时 s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果 s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } \",\"节点入队不是原子操作，所以会出现短暂的 head != tail，此时 Tail 指向最后一个节点，而且 Tail 指向 Head。如果 Head 没有指向 Tail（可见 5、6、7 行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。\"]},\"1012\":{\"h\":\"3.1.3 等待队列中线程出队列时机\",\"t\":[\"回到最初的源码：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"上文解释了 addWaiter 方法，这个方法其实就是把对应的线程以 Node 的数据结构形式加入到双端队列里，返回的是一个包含该线程的 Node。而这个 Node 会作为参数，进入到 acquireQueued 方法中。acquireQueued 方法可以对排队中的线程进行“获锁”操作。\",\"总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued 会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。\",\"下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下 acquireQueued 源码：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) { // 标记是否成功拿到资源 boolean failed = true; try { // 标记等待过程中是否中断过 boolean interrupted = false; // 开始自旋，要么获取锁，要么中断 for (;;) { // 获取当前节点的前驱节点 final Node p = node.predecessor(); // 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点） if (p == head && tryAcquire(arg)) { // 获取锁成功，头指针移动到当前node setHead(node); p.next = null; // help GC failed = false; return interrupted; } // 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析 if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } \",\"注：setHead 方法是把当前节点置为虚节点，但并没有修改 waitStatus，因为它是一直需要用的数据。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } // java.util.concurrent.locks.AbstractQueuedSynchronizer // 靠前驱节点判断当前线程是否应该被阻塞 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 获取头结点的节点状态 int ws = pred.waitStatus; // 说明头结点处于唤醒状态 if (ws == Node.SIGNAL) return true; // 通过枚举值我们知道waitStatus>0是取消状态 if (ws > 0) { do { // 循环向前查找取消节点，把取消节点从队列中剔除 node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { // 设置前任节点等待状态为SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } \",\"parkAndCheckInterrupt 主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } \",\"上述方法的流程图如下：\",\"从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致 CPU 资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire 流程）：\",\"从队列中释放节点的疑虑打消了，那么又有新问题了：\",\"shouldParkAfterFailedAcquire 中取消节点是怎么生成的呢？什么时候会把一个节点的 waitStatus 设置为-1？\",\"是在什么时间释放节点通知到被挂起的线程呢？\"]},\"1013\":{\"h\":\"3.2 CANCELLED 状态节点生成\",\"t\":[\"acquireQueued 方法中的 Finally 代码：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { ... for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { ... failed = false; ... } ... } finally { if (failed) cancelAcquire(node); } } \",\"通过 cancelAcquire 方法，将 Node 的状态标记为 CANCELLED。接下来，我们逐行来分析这个方法的原理：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private void cancelAcquire(Node node) { // 将无效节点过滤 if (node == null) return; // 设置该节点不关联任何线程，也就是虚节点 node.thread = null; Node pred = node.prev; // 通过前驱节点，跳过取消状态的node while (pred.waitStatus > 0) node.prev = pred = pred.prev; // 获取过滤后的前驱节点的后继节点 Node predNext = pred.next; // 把当前node的状态设置为CANCELLED node.waitStatus = Node.CANCELLED; // 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点 // 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null if (node == tail && compareAndSetTail(node, pred)) { compareAndSetNext(pred, predNext, null); } else { int ws; // 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功 // 如果1和2中有一个为true，再判断当前节点的线程是否为null // 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点 if (pred != head && ((ws = pred.waitStatus) == Node.SIGNAL || (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) && pred.thread != null) { Node next = node.next; if (next != null && next.waitStatus <= 0) compareAndSetNext(pred, predNext, next); } else { // 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点 unparkSuccessor(node); } node.next = node; // help GC } } \",\"当前的流程：\",\"获取当前节点的前驱节点，如果前驱节点的状态是 CANCELLED，那就一直往前遍历，找到第一个 waitStatus <= 0 的节点，将找到的 Pred 节点和当前 Node 关联，将当前 Node 设置为 CANCELLED。\",\"根据当前节点的位置，考虑以下三种情况：\",\"(1) 当前节点是尾节点。\",\"(2) 当前节点是 Head 的后继节点。\",\"(3) 当前节点不是 Head 的后继节点，也不是尾节点。\",\"根据上述第二条，我们来分析每一种情况的流程。\",\"当前节点是尾节点。\",\"当前节点是 Head 的后继节点。\",\"当前节点不是 Head 的后继节点，也不是尾节点。\",\"通过上面的流程，我们对于 CANCELLED 节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对 Next 指针进行了操作，而没有对 Prev 指针进行操作呢？什么情况下会对 Prev 指针进行操作？\",\"执行 cancelAcquire 的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过 Try 代码块中的 shouldParkAfterFailedAcquire 方法了），如果此时修改 Prev 指针，有可能会导致 Prev 指向另一个已经移除队列的 Node，因此这块变化 Prev 指针不安全。 shouldParkAfterFailedAcquire 方法中，会执行下面的代码，其实就是在处理 Prev 指针。shouldParkAfterFailedAcquire 是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更 Prev 指针比较安全。\",\"do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); \"]},\"1014\":{\"h\":\"3.3 如何解锁\",\"t\":[\"我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于 ReentrantLock 在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：\",\"// java.util.concurrent.locks.ReentrantLock public void unlock() { sync.release(1); } \",\"可以看到，本质释放锁的地方，是通过框架来完成的。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } \",\"在 ReentrantLock 里面的公平锁和非公平锁的父类 Sync 定义了可重入锁的释放锁机制。\",\"// java.util.concurrent.locks.ReentrantLock.Sync // 方法返回当前锁是不是没有被线程持有 protected final boolean tryRelease(int releases) { // 减少可重入次数 int c = getState() - releases; // 当前线程不是持有锁的线程，抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } \",\"我们来解释下述源码：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer public final boolean release(int arg) { // 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有 if (tryRelease(arg)) { // 获取头结点 Node h = head; // 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态 if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } \",\"这里的判断条件为什么是 h != null && h.waitStatus != 0？\",\"h == null Head 还没初始化。初始情况下，head == null，第一个节点入队，Head 会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现 head == null 的情况。\",\"h != null && waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。\",\"h != null && waitStatus < 0 表明后继节点可能被阻塞了，需要唤醒。\",\"再看一下 unparkSuccessor 方法：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private void unparkSuccessor(Node node) { // 获取头结点waitStatus int ws = node.waitStatus; if (ws < 0) compareAndSetWaitStatus(node, ws, 0); // 获取当前节点的下一个节点 Node s = node.next; // 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点 if (s == null || s.waitStatus > 0) { s = null; // 就从尾部节点开始找，到队首，找到队列第一个waitStatus<0的节点。 for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus <= 0) s = t; } // 如果当前节点的下个节点不为空，而且状态<=0，就把当前节点unpark if (s != null) LockSupport.unpark(s.thread); } \",\"为什么要从后往前找第一个非 Cancelled 的节点呢？原因如下。\",\"之前的 addWaiter 方法：\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } \",\"我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作 Tail 入队的原子操作，但是此时 pred.next = node;还没执行，如果这个时候执行了 unparkSuccessor 方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生 CANCELLED 状态节点的时候，先断开的是 Next 指针，Prev 指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的 Node。\",\"综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和 CANCELLED 节点产生过程中断开 Next 指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行 acquireQueued 方法以后，中断如何处理？\"]},\"1015\":{\"h\":\"3.4 中断恢复后的执行流程\",\"t\":[\"唤醒后，会执行 return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } \",\"再回到 acquireQueued 代码，当 parkAndCheckInterrupt 返回 True 或者 False 的时候，interrupted 的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前 interrupted 返回。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } \",\"如果 acquireQueued 为 True，就会执行 selfInterrupt 方法。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer static void selfInterrupt() { Thread.currentThread().interrupt(); } \",\"该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于 Java 提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：\",\"当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过 Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为 False），并记录下来，如果发现该线程被中断过，就再中断一次。\",\"线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。\",\"这里的处理方式主要是运用线程池中基本运作单元 Worder 中的 runWorker，通过 Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下 ThreadPoolExecutor 源码。\"]},\"1016\":{\"h\":\"3.5 小结\",\"t\":[\"我们在 1.3 小节中提出了一些问题，现在来回答一下。\",\"Q：某个线程获取锁失败的后续流程是什么呢？\",\"A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\",\"Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\",\"A：是 CLH 变体的 FIFO 双端队列。\",\"Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\",\"A：可以详细看下 2.3.1.3 小节。\",\"Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？\",\"A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见 2.3.2 小节。\",\"Q：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？\",\"A：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程。\"]},\"1017\":{\"h\":\"4 AQS 应用\"},\"1018\":{\"h\":\"4.1 ReentrantLock 的可重入应用\",\"t\":[\"ReentrantLock 的可重入性是 AQS 很好的应用之一，在了解完上述知识点以后，我们很容易得知 ReentrantLock 实现可重入的方法。在 ReentrantLock 里面，不管是公平锁还是非公平锁，都有一段逻辑。\",\"公平锁：\",\"// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire if (c == 0) { if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } \",\"非公平锁：\",\"// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire if (c == 0) { if (compareAndSetState(0, acquires)){ setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); setState(nextc); return true; } \",\"从上面这两段都可以看到，有一个同步状态 State 来控制整体可重入的情况。State 是 Volatile 修饰的，用于保证一定的可见性和有序性。\",\"// java.util.concurrent.locks.AbstractQueuedSynchronizer private volatile int state; \",\"接下来看 State 这个字段主要的过程：\",\"State 初始化的时候为 0，表示没有任何线程持有锁。\",\"当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。\",\"解锁也是对这个字段-1，一直到 0，此线程对锁释放。\"]},\"1019\":{\"h\":\"4.2 JUC 中的应用场景\",\"t\":[\"除了上边 ReentrantLock 的可重入性的应用，AQS 作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了 JUC 中的几种同步工具，大体介绍一下 AQS 的应用场景：\",\"同步工具\",\"同步工具与 AQS 的关联\",\"ReentrantLock\",\"使用 AQS 保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock 记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。\",\"Semaphore\",\"使用 AQS 同步状态来保存信号量的当前计数。tryRelease 会增加计数，acquireShared 会减少计数。\",\"CountDownLatch\",\"使用 AQS 同步状态来表示计数。计数为 0 时，所有的 Acquire 操作（CountDownLatch 的 await 方法）才可以通过。\",\"ReentrantReadWriteLock\",\"使用 AQS 同步状态中的 16 位保存写锁持有的次数，剩下的 16 位用于保存读锁的持有次数。\",\"ThreadPoolExecutor\",\"Worker 利用 AQS 同步状态实现对独占线程变量的设置（tryAcquire 和 tryRelease）。\"]},\"1020\":{\"h\":\"4.3 自定义同步工具\",\"t\":[\"了解 AQS 基本原理以后，按照上面所说的 AQS 知识点，自己实现一个同步工具。\",\"public class LeeLock { private static class Sync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire (int arg) { return compareAndSetState(0, 1); } @Override protected boolean tryRelease (int arg) { setState(0); return true; } @Override protected boolean isHeldExclusively () { return getState() == 1; } } private Sync sync = new Sync(); public void lock () { sync.acquire(1); } public void unlock () { sync.release(1); } } \",\"通过我们自己定义的 Lock 完成一定的同步功能。\",\"public class LeeMain { static int count = 0; static LeeLock leeLock = new LeeLock(); public static void main (String[] args) throws InterruptedException { Runnable runnable = new Runnable() { @Override public void run () { try { leeLock.lock(); for (int i = 0; i < 10000; i++) { count++; } } catch (Exception e) { e.printStackTrace(); } finally { leeLock.unlock(); } } }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(count); } } \",\"上述代码每次运行结果都会是 20000。通过简单的几行代码就能实现同步功能，这就是 AQS 的强大之处。\"]},\"1021\":{\"h\":\"5 总结\",\"t\":[\"我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁 ReentrantLock 的原理和 AQS 原理，希望能够成为大家了解 AQS 和 ReentrantLock 等同步器的“敲门砖”。\"]},\"1022\":{\"h\":\"参考资料\",\"t\":[\"Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.\",\"《Java 并发编程实战》\",\"不可不说的 Java“锁”事\",\"File not found\"]},\"1023\":{\"c\":[\"Java\"]},\"1024\":{\"c\":[\"Java并发\"]},\"1025\":{\"h\":\"ThreadLocal 详解\",\"t\":[\"本文来自一枝花算不算浪漫投稿， 原文地址：https://juejin.cn/post/6844904151567040519。\"]},\"1026\":{\"h\":\"前言\",\"t\":[\"全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。\",\"对于ThreadLocal，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下：\",\"ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？\",\"ThreadLocal中ThreadLocalMap的数据结构？\",\"ThreadLocalMap的Hash 算法？\",\"ThreadLocalMap中Hash 冲突如何解决？\",\"ThreadLocalMap的扩容机制？\",\"ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？\",\"ThreadLocalMap.set()方法实现原理？\",\"ThreadLocalMap.get()方法实现原理？\",\"项目中ThreadLocal使用情况？遇到的坑？\",\"……\",\"上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析ThreadLocal的点点滴滴。\"]},\"1027\":{\"h\":\"目录\",\"t\":[\"注明： 本文源码基于JDK 1.8\"]},\"1028\":{\"h\":\"ThreadLocal 代码演示\",\"t\":[\"我们先看下ThreadLocal使用示例：\",\"public class ThreadLocalTest { private List<String> messages = Lists.newArrayList(); public static final ThreadLocal<ThreadLocalTest> holder = ThreadLocal.withInitial(ThreadLocalTest::new); public static void add(String message) { holder.get().messages.add(message); } public static List<String> clear() { List<String> messages = holder.get().messages; holder.remove(); System.out.println(\\\"size: \\\" + holder.get().messages.size()); return messages; } public static void main(String[] args) { ThreadLocalTest.add(\\\"一枝花算不算浪漫\\\"); System.out.println(holder.get().messages); ThreadLocalTest.clear(); } } \",\"打印结果：\",\"[一枝花算不算浪漫] size: 0 \",\"ThreadLocal对象可以提供线程局部变量，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。\"]},\"1029\":{\"h\":\"ThreadLocal 的数据结构\",\"t\":[\"Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程有一个自己的ThreadLocalMap。\",\"ThreadLocalMap有自己的独立实现，可以简单地将它的key视作ThreadLocal，value为代码中放入的值（实际上key并不是ThreadLocal本身，而是它的一个弱引用）。\",\"每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。\",\"ThreadLocalMap有点类似HashMap的结构，只是HashMap是由数组+链表实现的，而ThreadLocalMap中并没有链表结构。\",\"我们还要注意Entry， 它的key是ThreadLocal<?> k ，继承自WeakReference， 也就是我们常说的弱引用类型。\"]},\"1030\":{\"h\":\"GC 之后 key 是否为 null？\",\"t\":[\"回应开头的那个问题， ThreadLocal 的key是弱引用，那么在ThreadLocal.get()的时候，发生GC之后，key是否是null？\",\"为了搞清楚这个问题，我们需要搞清楚Java的四种引用类型：\",\"强引用：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候\",\"软引用：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收\",\"弱引用：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收\",\"虚引用：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知\",\"接着再来看下代码，我们使用反射的方式来看看GC后ThreadLocal中的数据情况：(下面代码来源自：https://blog.csdn.net/thewindkee/article/details/103726942 本地运行演示 GC 回收场景)\",\"public class ThreadLocalDemo { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException { Thread t = new Thread(()->test(\\\"abc\\\",false)); t.start(); t.join(); System.out.println(\\\"--gc后--\\\"); Thread t2 = new Thread(() -> test(\\\"def\\\", true)); t2.start(); t2.join(); } private static void test(String s,boolean isGC) { try { new ThreadLocal<>().set(s); if (isGC) { System.gc(); } Thread t = Thread.currentThread(); Class<? extends Thread> clz = t.getClass(); Field field = clz.getDeclaredField(\\\"threadLocals\\\"); field.setAccessible(true); Object ThreadLocalMap = field.get(t); Class<?> tlmClass = ThreadLocalMap.getClass(); Field tableField = tlmClass.getDeclaredField(\\\"table\\\"); tableField.setAccessible(true); Object[] arr = (Object[]) tableField.get(ThreadLocalMap); for (Object o : arr) { if (o != null) { Class<?> entryClass = o.getClass(); Field valueField = entryClass.getDeclaredField(\\\"value\\\"); Field referenceField = entryClass.getSuperclass().getSuperclass().getDeclaredField(\\\"referent\\\"); valueField.setAccessible(true); referenceField.setAccessible(true); System.out.println(String.format(\\\"弱引用key:%s,值:%s\\\", referenceField.get(o), valueField.get(o))); } } } catch (Exception e) { e.printStackTrace(); } } } \",\"结果如下：\",\"弱引用key:java.lang.ThreadLocal@433619b6,值:abc 弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference@bf97a12 --gc后-- 弱引用key:null,值:def \",\"如图所示，因为这里创建的ThreadLocal并没有指向任何值，也就是没有任何引用：\",\"new ThreadLocal<>().set(s); \",\"所以这里在GC之后，key就会被回收，我们看到上面debug中的referent=null, 如果改动一下代码：\",\"这个问题刚开始看，如果没有过多思考，弱引用，还有垃圾回收，那么肯定会觉得是null。\",\"其实是不对的，因为题目说的是在做 ThreadLocal.get() 操作，证明其实还是有强引用存在的，所以 key 并不为 null，如下图所示，ThreadLocal的强引用仍然是存在的。\",\"如果我们的强引用不存在的话，那么 key 就会被回收，也就是会出现我们 value 没被回收，key 被回收，导致 value 永远存在，出现内存泄漏。\"]},\"1031\":{\"h\":\"ThreadLocal.set() 方法源码详解\",\"t\":[\"ThreadLocal中的set方法原理如上图所示，很简单，主要是判断ThreadLocalMap是否存在，然后使用ThreadLocal中的set方法进行数据处理。\",\"代码如下：\",\"public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } \",\"主要的核心逻辑还是在ThreadLocalMap中的，一步步往下看，后面还有更详细的剖析。\"]},\"1032\":{\"h\":\"ThreadLocalMap Hash 算法\",\"t\":[\"既然是Map结构，那么ThreadLocalMap当然也要实现自己的hash算法来解决散列表数组冲突问题。\",\"int i = key.threadLocalHashCode & (len-1); \",\"ThreadLocalMap中hash算法很简单，这里i就是当前 key 在散列表中对应的数组下标位置。\",\"这里最关键的就是threadLocalHashCode值的计算，ThreadLocal中有一个属性为HASH_INCREMENT = 0x61c88647\",\"public class ThreadLocal<T> { private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } static class ThreadLocalMap { ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } } } \",\"每当创建一个ThreadLocal对象，这个ThreadLocal.nextHashCode 这个值就会增长 0x61c88647 。\",\"这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash分布非常均匀。\",\"我们自己可以尝试下：\",\"可以看到产生的哈希码分布很均匀，这里不去细纠斐波那契具体算法，感兴趣的可以自行查阅相关资料。\"]},\"1033\":{\"h\":\"ThreadLocalMap Hash 冲突\",\"t\":[\"注明： 下面所有示例图中，绿色块Entry代表正常数据，灰色块代表Entry的key值为null，已被垃圾回收。白色块表示Entry为null。\",\"虽然ThreadLocalMap中使用了黄金分割数来作为hash计算因子，大大减少了Hash冲突的概率，但是仍然会存在冲突。\",\"HashMap中解决冲突的方法是在数组上构造一个链表结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成红黑树。\",\"而 ThreadLocalMap 中并没有链表结构，所以这里不能使用 HashMap 解决冲突的方式了。\",\"如上图所示，如果我们插入一个value=27的数据，通过 hash 计算后应该落入槽位 4 中，而槽位 4 已经有了 Entry 数据。\",\"此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 Entry 不为 null 且 key 值相等的情况，还有 Entry 中的 key 值为 null 的情况等等都会有不同的处理，后面会一一详细讲解。\",\"这里还画了一个Entry中的key为null的数据（Entry=2 的灰色块数据），因为key值是弱引用类型，所以会有这种数据存在。在set过程中，如果遇到了key过期的Entry数据，实际上是会进行一轮探测式清理操作的，具体操作方式后面会讲到。\"]},\"1034\":{\"h\":\"ThreadLocalMap.set() 详解\"},\"1035\":{\"h\":\"ThreadLocalMap.set() 原理图解\",\"t\":[\"看完了ThreadLocalhash 算法后，我们再来看set是如何实现的。\",\"往ThreadLocalMap中set数据（新增或者更新数据）分为好几种情况，针对不同的情况我们画图来说明。\",\"第一种情况： 通过hash计算后的槽位对应的Entry数据为空：\",\"这里直接将数据放到该槽位即可。\",\"第二种情况： 槽位数据不为空，key值与当前ThreadLocal通过hash计算获取的key值一致：\",\"这里直接更新该槽位的数据。\",\"第三种情况： 槽位数据不为空，往后遍历过程中，在找到Entry为null的槽位之前，没有遇到key过期的Entry：\",\"遍历散列数组，线性往后查找，如果找到Entry为null的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了key 值相等的数据，直接更新即可。\",\"第四种情况： 槽位数据不为空，往后遍历过程中，在找到Entry为null的槽位之前，遇到key过期的Entry，如下图，往后遍历过程中，遇到了index=7的槽位数据Entry的key=null：\",\"散列数组下标为 7 位置对应的Entry数据key为null，表明此数据key值已经被垃圾回收掉了，此时就会执行replaceStaleEntry()方法，该方法含义是替换过期数据的逻辑，以index=7位起点开始遍历，进行探测式数据清理工作。\",\"初始化探测式清理过期数据扫描的开始位置：slotToExpunge = staleSlot = 7\",\"以当前staleSlot开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标slotToExpunge。for循环迭代，直到碰到Entry为null结束。\",\"如果找到了过期的数据，继续向前迭代，直到遇到Entry=null的槽位才停止迭代，如下图所示，slotToExpunge 被更新为 0：\",\"以当前节点(index=7)向前迭代，检测是否有过期的Entry数据，如果有则更新slotToExpunge值。碰到null则结束探测。以上图为例slotToExpunge被更新为 0。\",\"上面向前迭代的操作是为了更新探测清理过期数据的起始下标slotToExpunge的值，这个值在后面会讲解，它是用来判断当前过期槽位staleSlot之前是否还有过期元素。\",\"接着开始以staleSlot位置(index=7)向后迭代，如果找到了相同 key 值的 Entry 数据：\",\"从当前节点staleSlot向后查找key值相等的Entry元素，找到后更新Entry的值并交换staleSlot元素的位置(staleSlot位置为过期元素)，更新Entry数据，然后开始进行过期Entry的清理工作，如下图所示：\",\"向后遍历过程中，如果没有找到相同 key 值的 Entry 数据：\",\"从当前节点staleSlot向后查找key值相等的Entry元素，直到Entry为null则停止寻找。通过上图可知，此时table中没有key值相同的Entry。\",\"创建新的Entry，替换table[stableSlot]位置：\",\"替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：expungeStaleEntry()和cleanSomeSlots()，具体细节后面会讲到，请继续往后看。\"]},\"1036\":{\"h\":\"ThreadLocalMap.set() 源码详解\",\"t\":[\"上面已经用图的方式解析了set()实现的原理，其实已经很清晰了，我们接着再看下源码：\",\"java.lang.ThreadLocal.ThreadLocalMap.set():\",\"private void set(ThreadLocal<?> key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal<?> k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } \",\"这里会通过key来计算在散列表中的对应位置，然后以当前key对应的桶的位置向后查找，找到可以使用的桶。\",\"Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); \",\"什么情况下桶才是可以使用的呢？\",\"k = key 说明是替换操作，可以使用\",\"碰到一个过期的桶，执行替换逻辑，占用过期桶\",\"查找过程中，碰到桶中Entry=null的情况，直接使用\",\"接着就是执行for循环遍历，向后查找，我们先看下nextIndex()、prevIndex()方法实现：\",\"private static int nextIndex(int i, int len) { return ((i + 1 < len) ? i + 1 : 0); } private static int prevIndex(int i, int len) { return ((i - 1 >= 0) ? i - 1 : len - 1); } \",\"接着看剩下for循环中的逻辑：\",\"遍历当前key值对应的桶中Entry数据为空，这说明散列数组这里没有数据冲突，跳出for循环，直接set数据到对应的桶中\",\"如果key值对应的桶中Entry数据不为空 2.1 如果k = key，说明当前set操作是一个替换操作，做替换逻辑，直接返回 2.2 如果key = null，说明当前桶位置的Entry是过期数据，执行replaceStaleEntry()方法(核心方法)，然后返回\",\"for循环执行完毕，继续往下执行说明向后迭代的过程中遇到了entry为null的情况 3.1 在Entry为null的桶中创建一个新的Entry对象 3.2 执行++size操作\",\"调用cleanSomeSlots()做一次启发式清理工作，清理散列数组中Entry的key过期的数据 4.1 如果清理工作完成后，未清理到任何数据，且size超过了阈值(数组长度的 2/3)，进行rehash()操作 4.2 rehash()中会先进行一轮探测式清理，清理过期key，清理完成后如果size >= threshold - threshold / 4，就会执行真正的扩容逻辑(扩容逻辑往后看)\",\"接着重点看下replaceStaleEntry()方法，replaceStaleEntry()方法提供替换过期数据的功能，我们可以对应上面第四种情况的原理图来再回顾下，具体代码如下：\",\"java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry():\",\"private void replaceStaleEntry(ThreadLocal<?> key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal<?> k = e.get(); if (k == key) { e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } if (k == null && slotToExpunge == staleSlot) slotToExpunge = i; } tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); } \",\"slotToExpunge表示开始探测式清理过期数据的开始下标，默认从当前的staleSlot开始。以当前的staleSlot开始，向前迭代查找，找到没有过期的数据，for循环一直碰到Entry为null才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即slotToExpunge=i\",\"for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)){ if (e.get() == null){ slotToExpunge = i; } } \",\"接着开始从staleSlot向后查找，也是碰到Entry为null的桶结束。 如果迭代过程中，碰到 k == key，这说明这里是替换逻辑，替换新数据并且交换当前staleSlot位置。如果slotToExpunge == staleSlot，这说明replaceStaleEntry()一开始向前查找过期数据时并未找到过期的Entry数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即slotToExpunge = i。最后调用cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);进行启发式过期数据清理。\",\"if (k == key) { e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } \",\"cleanSomeSlots()和expungeStaleEntry()方法后面都会细讲，这两个是和清理相关的方法，一个是过期key相关Entry的启发式清理(Heuristically scan)，另一个是过期key相关Entry的探测式清理。\",\"如果 k != key则会接着往下走，k == null说明当前遍历的Entry是一个过期数据，slotToExpunge == staleSlot说明，一开始的向前查找数据并未找到过期的Entry。如果条件成立，则更新slotToExpunge 为当前位置，这个前提是前驱节点扫描时未发现过期数据。\",\"if (k == null && slotToExpunge == staleSlot) slotToExpunge = i; \",\"往后迭代的过程中如果没有找到k == key的数据，且碰到Entry为null的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到table[staleSlot] 对应的slot中。\",\"tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); \",\"最后判断除了staleSlot以外，还发现了其他过期的slot数据，就要开启清理数据的逻辑：\",\"if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); \"]},\"1037\":{\"h\":\"ThreadLocalMap 过期 key 的探测式清理流程\",\"t\":[\"上面我们有提及ThreadLocalMap的两种过期key数据清理方式：探测式清理和启发式清理。\",\"我们先讲下探测式清理，也就是expungeStaleEntry方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的Entry设置为null，沿途中碰到未过期的数据则将此数据rehash后重新在table数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的Entry=null的桶中，使rehash后的Entry数据距离正确的桶的位置更近一些。操作逻辑如下：\",\"如上图，set(27) 经过 hash 计算后应该落到index=4的桶中，由于index=4桶已经有了数据，所以往后迭代最终数据放入到index=7的桶中，放入后一段时间后index=5中的Entry数据key变为了null\",\"如果再有其他数据set到map中，就会触发探测式清理操作。\",\"如上图，执行探测式清理后，index=5的数据被清理掉，继续往后迭代，到index=7的元素时，经过rehash后发现该元素正确的index=4，而此位置已经有了数据，往后查找离index=4最近的Entry=null的节点(刚被探测式清理掉的数据：index=5)，找到后移动index= 7的数据到index=5中，此时桶的位置离正确的位置index=4更近了。\",\"经过一轮探测式清理后，key过期的数据会被清理掉，没过期的数据经过rehash重定位后所处的桶位置理论上更接近i= key.hashCode & (tab.len - 1)的位置。这种优化会提高整个散列表查询性能。\",\"接着看下expungeStaleEntry()具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理：\",\"我们假设expungeStaleEntry(3) 来调用此方法，如上图所示，我们可以看到ThreadLocalMap中table的数据情况，接着执行清理操作：\",\"第一步是清空当前staleSlot位置的数据，index=3位置的Entry变成了null。然后接着往后探测：\",\"执行完第二步后，index=4 的元素挪到 index=3 的槽位中。\",\"继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算slot位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置\",\"在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体实现源代码：\",\"private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode & (len - 1); if (h != i) { tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; } \",\"这里我们还是以staleSlot=3 来做示例说明，首先是将tab[staleSlot]槽位的数据清空，然后设置size-- 接着以staleSlot位置往后迭代，如果遇到k==null的过期数据，也是清空该槽位数据，然后size--\",\"ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } \",\"如果key没有过期，重新计算当前key的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了hash冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放entry的位置。\",\"int h = k.threadLocalHashCode & (len - 1); if (h != i) { tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } \",\"这里是处理正常的产生Hash冲突的数据，经过迭代后，有过Hash冲突数据的Entry位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。\"]},\"1038\":{\"h\":\"ThreadLocalMap 扩容机制\",\"t\":[\"在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash()逻辑：\",\"if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); \",\"接着看下rehash()具体实现：\",\"private void rehash() { expungeStaleEntries(); if (size >= threshold - threshold / 4) resize(); } private void expungeStaleEntries() { Entry[] tab = table; int len = tab.length; for (int j = 0; j < len; j++) { Entry e = tab[j]; if (e != null && e.get() == null) expungeStaleEntry(j); } } \",\"这里首先是会进行探测式清理工作，从table的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，table中可能有一些key为null的Entry数据被清理掉，所以此时通过判断size >= threshold - threshold / 4 也就是size >= threshold * 3/4 来决定是否扩容。\",\"我们还记得上面进行rehash()的阈值是size >= threshold，所以当面试官套路我们ThreadLocalMap扩容机制的时候 我们一定要说清楚这两个步骤：\",\"接着看看具体的resize()方法，为了方便演示，我们以oldTab.len=8来举例：\",\"扩容后的tab的大小为oldLen * 2，然后遍历老的散列表，重新计算hash位置，然后放到新的tab数组中，如果出现hash冲突则往后寻找最近的entry为null的槽位，遍历完成之后，oldTab中所有的entry数据都已经放入到新的tab中了。重新计算tab下次扩容的阈值，具体代码如下：\",\"private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j < oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal<?> k = e.get(); if (k == null) { e.value = null; } else { int h = k.threadLocalHashCode & (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } \"]},\"1039\":{\"h\":\"ThreadLocalMap.get() 详解\",\"t\":[\"上面已经看完了set()方法的源码，其中包括set数据、清理数据、优化数据桶的位置等操作，接着看看get()操作的原理。\"]},\"1040\":{\"h\":\"ThreadLocalMap.get() 图解\",\"t\":[\"第一种情况： 通过查找key值计算出散列表中slot位置，然后该slot位置中的Entry.key和查找的key一致，则直接返回：\",\"第二种情况：slot位置中的Entry.key和要查找的key不一致：\",\"我们以get(ThreadLocal1)为例，通过hash计算后，正确的slot位置应该是 4，而index=4的槽位已经有了数据，且key值不等于ThreadLocal1，所以需要继续往后迭代查找。\",\"迭代到index=5的数据时，此时Entry.key=null，触发一次探测式数据回收操作，执行expungeStaleEntry()方法，执行完后，index 5,8的数据都会被回收，而index 6,7的数据都会前移。index 6,7前移之后，继续从 index=5 往后迭代，于是就在 index=5 找到了key值相等的Entry数据，如下图所示：\"]},\"1041\":{\"h\":\"ThreadLocalMap.get() 源码详解\",\"t\":[\"java.lang.ThreadLocal.ThreadLocalMap.getEntry():\",\"private Entry getEntry(ThreadLocal<?> key) { int i = key.threadLocalHashCode & (table.length - 1); Entry e = table[i]; if (e != null && e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal<?> k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; } \"]},\"1042\":{\"h\":\"ThreadLocalMap 过期 key 的启发式清理流程\",\"t\":[\"上面多次提及到ThreadLocalMap过期 key 的两种清理方式：探测式清理(expungeStaleEntry())、启发式清理(cleanSomeSlots())\",\"探测式清理是以当前Entry 往后清理，遇到值为null则结束清理，属于线性探测清理。\",\"而启发式清理被作者定义为：Heuristically scan some cells looking for stale entries.\",\"具体代码如下：\",\"private boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null && e.get() == null) { n = len; removed = true; i = expungeStaleEntry(i); } } while ( (n >>>= 1) != 0); return removed; } \"]},\"1043\":{\"h\":\"InheritableThreadLocal\",\"t\":[\"我们使用ThreadLocal的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。\",\"为了解决这个问题，JDK 中还有一个InheritableThreadLocal类，我们来看一个例子：\",\"public class InheritableThreadLocalDemo { public static void main(String[] args) { ThreadLocal<String> ThreadLocal = new ThreadLocal<>(); ThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>(); ThreadLocal.set(\\\"父类数据:threadLocal\\\"); inheritableThreadLocal.set(\\\"父类数据:inheritableThreadLocal\\\"); new Thread(new Runnable() { @Override public void run() { System.out.println(\\\"子线程获取父类ThreadLocal数据：\\\" + ThreadLocal.get()); System.out.println(\\\"子线程获取父类inheritableThreadLocal数据：\\\" + inheritableThreadLocal.get()); } }).start(); } } \",\"打印结果：\",\"子线程获取父类ThreadLocal数据：null 子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal \",\"实现原理是子线程是通过在父线程中通过调用new Thread()方法来创建子线程，Thread#init方法在Thread的构造方法中被调用。在init方法中拷贝父线程数据到子线程中：\",\"private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { if (name == null) { throw new NullPointerException(\\\"name cannot be null\\\"); } if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID(); } \",\"但InheritableThreadLocal仍然有缺陷，一般我们做异步化处理都是使用的线程池，而InheritableThreadLocal是在new Thread中的init()方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。\",\"当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个TransmittableThreadLocal组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。\"]},\"1044\":{\"h\":\"ThreadLocal 项目中使用实战\"},\"1045\":{\"h\":\"ThreadLocal 使用场景\",\"t\":[\"我们现在项目中日志记录用的是ELK+Logstash，最后在Kibana中进行展示和检索。\",\"现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 traceId 来关联，但是不同项目之间如何传递 traceId 呢？\",\"这里我们使用 org.slf4j.MDC 来实现此功能，内部就是通过 ThreadLocal 来实现的，具体实现如下：\",\"当前端发送请求到服务 A时，服务 A会生成一个类似UUID的traceId字符串，将此字符串放入当前线程的ThreadLocal中，在调用服务 B的时候，将traceId写入到请求的Header中，服务 B在接收请求时会先判断请求的Header中是否有traceId，如果存在则写入自己线程的ThreadLocal中。\",\"图中的requestId即为我们各个系统链路关联的traceId，系统间互相调用，通过这个requestId即可找到对应链路，这里还有会有一些其他场景：\",\"针对于这些场景，我们都可以有相应的解决方案，如下所示\"]},\"1046\":{\"h\":\"Feign 远程调用解决方案\",\"t\":[\"服务发送请求：\",\"@Component @Slf4j public class FeignInvokeInterceptor implements RequestInterceptor { @Override public void apply(RequestTemplate template) { String requestId = MDC.get(\\\"requestId\\\"); if (StringUtils.isNotBlank(requestId)) { template.header(\\\"requestId\\\", requestId); } } } \",\"服务接收请求：\",\"@Slf4j @Component public class LogInterceptor extends HandlerInterceptorAdapter { @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) { MDC.remove(\\\"requestId\\\"); } @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) { } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestId = request.getHeader(BaseConstant.REQUEST_ID_KEY); if (StringUtils.isBlank(requestId)) { requestId = UUID.randomUUID().toString().replace(\\\"-\\\", \\\"\\\"); } MDC.put(\\\"requestId\\\", requestId); return true; } } \"]},\"1047\":{\"h\":\"线程池异步调用，requestId 传递\",\"t\":[\"因为MDC是基于ThreadLocal去实现的，异步过程中，子线程并没有办法获取到父线程ThreadLocal存储的数据，所以这里可以自定义线程池执行器，修改其中的run()方法：\",\"public class MyThreadPoolTaskExecutor extends ThreadPoolTaskExecutor { @Override public void execute(Runnable runnable) { Map<String, String> context = MDC.getCopyOfContextMap(); super.execute(() -> run(runnable, context)); } @Override private void run(Runnable runnable, Map<String, String> context) { if (context != null) { MDC.setContextMap(context); } try { runnable.run(); } finally { MDC.remove(); } } } \"]},\"1048\":{\"h\":\"使用 MQ 发送消息给第三方系统\",\"t\":[\"在 MQ 发送的消息体中自定义属性requestId，接收方消费消息后，自己解析requestId使用即可。\",\"File not found\"]},\"1049\":{\"c\":[\"Java\"]},\"1050\":{\"c\":[\"Java并发\"]},\"1051\":{\"h\":\"虚拟线程极简入门\",\"t\":[\"本文部分内容来自 Lorin 的PR。\",\"虚拟线程在 Java 21 正式发布，这是一项重量级的更新。\"]},\"1052\":{\"h\":\"什么是虚拟线程？\",\"t\":[\"虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\"]},\"1053\":{\"h\":\"虚拟线程和平台线程有什么关系？\",\"t\":[\"在引入虚拟线程之前，java.lang.Thread 包已经支持所谓的平台线程（Platform Thread），也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。\",\"虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：How to Use Java 19 Virtual Threads）：\",\"虚拟线程、平台线程和系统内核线程的关系\",\"关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: JVM 中的线程模型是用户级的么？。\"]},\"1054\":{\"h\":\"虚拟线程有什么优点和缺点？\"},\"1055\":{\"h\":\"优点\",\"t\":[\"非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。\",\"简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。\",\"减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。\"]},\"1056\":{\"h\":\"缺点\",\"t\":[\"不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。\",\"依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。\"]},\"1057\":{\"h\":\"四种创建虚拟线程的方法\",\"t\":[\"Java 21 已经正式支持虚拟线程，大家可以在官网下载使用，在使用上官方为了降低使用门槛，尽量复用原有的 Thread 类，让大家可以更加平滑的使用。\",\"官方提供了以下四种方式创建虚拟线程：\",\"使用 Thread.startVirtualThread() 创建\",\"使用 Thread.ofVirtual() 创建\",\"使用 ThreadFactory 创建\"]},\"1058\":{\"h\":\"使用 Thread.startVirtualThread()创建\",\"t\":[\"public class VirtualThreadTest { public static void main(String[] args) { CustomThread customThread = new CustomThread(); Thread.startVirtualThread(customThread); } } static class CustomThread implements Runnable { @Override public void run() { System.out.println(\\\"CustomThread run\\\"); } } \"]},\"1059\":{\"h\":\"使用 Thread.ofVirtual()创建\",\"t\":[\"public class VirtualThreadTest { public static void main(String[] args) { CustomThread customThread = new CustomThread(); // 创建不启动 Thread unStarted = Thread.ofVirtual().unstarted(customThread); unStarted.start(); // 创建直接启动 Thread.ofVirtual().start(customThread); } } static class CustomThread implements Runnable { @Override public void run() { System.out.println(\\\"CustomThread run\\\"); } } \"]},\"1060\":{\"h\":\"使用 ThreadFactory 创建\",\"t\":[\"public class VirtualThreadTest { public static void main(String[] args) { CustomThread customThread = new CustomThread(); ThreadFactory factory = Thread.ofVirtual().factory(); Thread thread = factory.newThread(customThread); thread.start(); } } static class CustomThread implements Runnable { @Override public void run() { System.out.println(\\\"CustomThread run\\\"); } } \"]},\"1061\":{\"h\":\"使用 Executors.newVirtualThreadPerTaskExecutor()创建\",\"t\":[\"public class VirtualThreadTest { public static void main(String[] args) { CustomThread customThread = new CustomThread(); ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor(); executor.submit(customThread); } } static class CustomThread implements Runnable { @Override public void run() { System.out.println(\\\"CustomThread run\\\"); } } \"]},\"1062\":{\"h\":\"虚拟线程和平台线程性能对比\",\"t\":[\"通过多线程和虚拟线程的方式处理相同的任务，对比创建的系统线程数和处理耗时。\",\"说明：统计创建的系统线程中部分为后台线程（比如 GC 线程），两种场景下都一样，所以并不影响对比。\",\"测试代码：\",\"public class VirtualThreadTest { static List<Integer> list = new ArrayList<>(); public static void main(String[] args) { // 开启线程 统计平台线程数 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(() -> { ThreadMXBean threadBean = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfo = threadBean.dumpAllThreads(false, false); updateMaxThreadNum(threadInfo.length); }, 10, 10, TimeUnit.MILLISECONDS); long start = System.currentTimeMillis(); // 虚拟线程 ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor(); // 使用平台线程 // ExecutorService executor = Executors.newFixedThreadPool(200); for (int i = 0; i < 10000; i++) { executor.submit(() -> { try { // 线程睡眠 0.5 s，模拟业务处理 TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException ignored) { } }); } executor.close(); System.out.println(\\\"max：\\\" + list.get(0) + \\\" platform thread/os thread\\\"); System.out.printf(\\\"totalMillis：%dms\\\\n\\\", System.currentTimeMillis() - start); } // 更新创建的平台最大线程数 private static void updateMaxThreadNum(int num) { if (list.isEmpty()) { list.add(num); } else { Integer integer = list.get(0); if (num > integer) { list.add(0, num); } } } } \",\"请求数 10000 单请求耗时 1s：\",\"// Virtual Thread max：22 platform thread/os thread totalMillis：1806ms // Platform Thread 线程数200 max：209 platform thread/os thread totalMillis：50578ms // Platform Thread 线程数500 max：509 platform thread/os thread totalMillis：20254ms // Platform Thread 线程数1000 max：1009 platform thread/os thread totalMillis：10214ms // Platform Thread 线程数2000 max：2009 platform thread/os thread totalMillis：5358ms \",\"请求数 10000 单请求耗时 0.5s：\",\"// Virtual Thread max：22 platform thread/os thread totalMillis：1316ms // Platform Thread 线程数200 max：209 platform thread/os thread totalMillis：25619ms // Platform Thread 线程数500 max：509 platform thread/os thread totalMillis：10277ms // Platform Thread 线程数1000 max：1009 platform thread/os thread totalMillis：5197ms // Platform Thread 线程数2000 max：2009 platform thread/os thread totalMillis：2865ms \",\"可以看到在密集 IO 的场景下，需要创建大量的平台线程异步处理才能达到虚拟线程的处理速度。\",\"因此，在密集 IO 的场景，虚拟线程可以大幅提高线程的执行效率，减少线程资源的创建以及上下文切换。\",\"吐槽：虽然虚拟线程我很想用，但是我 Java8 有机会升级到 Java21 吗？呜呜\",\"注意：有段时间 JDK 一直致力于 Reactor 响应式编程来提高 Java 性能，但响应式编程难以理解、调试、使用，最终又回到了同步编程，最终虚拟线程诞生。\"]},\"1063\":{\"c\":[\"Java\"]},\"1064\":{\"c\":[\"Java并发\"]},\"1065\":{\"h\":\"CAP & BASE理论详解\",\"t\":[\"经历过技术面试的小伙伴想必对 CAP & BASE 这个两个理论已经再熟悉不过了！\",\"我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。\",\"我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。\"]},\"1066\":{\"h\":\"CAP 理论\",\"t\":[\"CAP 理论/定理起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 布鲁尔定理（Brewer’s theorem）\",\"2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。\"]},\"1067\":{\"h\":\"简介\",\"t\":[\"CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。\",\"CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 Consistency、Availability、Partition Tolerance 三个单词的明确定义。\",\"因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。\",\"在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：\",\"一致性（Consistency） : 所有节点访问同一份最新的数据副本\",\"可用性（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。\",\"分区容错性（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。\",\"什么是网络分区？\",\"分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 网络分区。\",\"partition-tolerance\"]},\"1068\":{\"h\":\"不是所谓的“3 选 2”\",\"t\":[\"大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。\",\"当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。\",\"简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。\",\"因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。\",\"为啥不可能选择 CA 架构呢？ 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。\",\"选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。\",\"另外，需要补充说明的一点是：如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。\"]},\"1069\":{\"h\":\"CAP 实际应用案例\",\"t\":[\"我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。\",\"下图是 Dubbo 的架构图。注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？\",\"注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。\",\"常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。\",\"ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。\",\"Eureka 保证的则是 AP。 Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。\",\"Nacos 不仅支持 CP 也支持 AP。\",\"🐛 修正（参见：issue#1906）：\",\"ZooKeeper 通过可线性化（Linearizable）写入、全局 FIFO 顺序访问等机制来保障数据一致性。多节点部署的情况下， ZooKeeper 集群处于 Quorum 模式。Quorum 模式下的 ZooKeeper 集群， 是一组 ZooKeeper 服务器节点组成的集合，其中大多数节点必须同意任何变更才能被视为有效。\",\"由于 Quorum 模式下的读请求不会触发各个 ZooKeeper 节点之间的数据同步，因此在某些情况下还是可能会存在读取到旧数据的情况，导致不同的客户端视图上看到的结果不同，这可能是由于网络延迟、丢包、重传等原因造成的。ZooKeeper 为了解决这个问题，提供了 Watcher 机制和版本号机制来帮助客户端检测数据的变化和版本号的变更，以保证数据的一致性。\"]},\"1070\":{\"h\":\"总结\",\"t\":[\"在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等\",\"在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”\",\"如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。\",\"总结：如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。\"]},\"1071\":{\"h\":\"推荐阅读\",\"t\":[\"CAP 定理简化 （英文，有趣的案例）\",\"神一样的 CAP 理论被应用在何方 （中文，列举了很多实际的例子）\",\"请停止呼叫数据库 CP 或 AP （英文，带给你不一样的思考）\"]},\"1072\":{\"h\":\"BASE 理论\",\"t\":[\"BASE 理论起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。\"]},\"1073\":{\"h\":\"简介\",\"t\":[\"BASE 是 Basically Available（基本可用）、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。\"]},\"1074\":{\"h\":\"BASE 理论的核心思想\",\"t\":[\"即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\",\"也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。\",\"BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。\",\"为什么这样说呢？\",\"CAP 理论这节我们也说过了：\",\"如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。\",\"因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。\"]},\"1075\":{\"h\":\"BASE 理论三要素\",\"t\":[\"BASE理论三要素\"]},\"1076\":{\"h\":\"基本可用\",\"t\":[\"基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。\",\"什么叫允许损失部分可用性呢？\",\"响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。\",\"系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。\"]},\"1077\":{\"h\":\"软状态\",\"t\":[\"软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。\"]},\"1078\":{\"h\":\"最终一致性\",\"t\":[\"最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。\",\"分布式一致性的 3 种级别：\",\"强一致性：系统写入了什么，读出来的就是什么。\",\"弱一致性：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。\",\"最终一致性：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。\",\"业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。\",\"那实现最终一致性的具体方式是什么呢? 《分布式协议与算法实战》 中是这样介绍：\",\"读时修复 : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。\",\"写时修复 : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。\",\"异步修复 : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。\",\"比较推荐 写时修复，这种方式对性能消耗比较低。\"]},\"1079\":{\"h\":\"总结\",\"t\":[\"ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。\",\"File not found\"]},\"1080\":{\"c\":[\"分布式\"]},\"1081\":{\"c\":[\"分布式理论\"]},\"1082\":{\"h\":\"Gossip 协议详解\"},\"1083\":{\"h\":\"背景\",\"t\":[\"在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。\",\"一种比较简单粗暴的方法就是 集中式发散消息，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。\",\"于是，分散式发散消息 的 Gossip 协议 就诞生了。\"]},\"1084\":{\"h\":\"Gossip 协议介绍\",\"t\":[\"Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。\",\"Gossip 协议 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 随机传播特性 （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。\",\"Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。\",\"正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。\",\"在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。\",\"下面我们来对 Gossip 协议的定义做一个总结：Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。\"]},\"1085\":{\"h\":\"Gossip 协议应用\",\"t\":[\"NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。\",\"我们这里以 Redis Cluster 为例说明 Gossip 协议的实际应用。\",\"我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。\",\"Redis 的官方集群解决方案\",\"Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，Redis Cluster 中的各个节点基于 Gossip 协议 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。\",\"Redis Cluster 的节点之间会相互发送多种 Gossip 消息：\",\"MEET：在 Redis Cluster 中的某个 Redis 节点上执行 CLUSTER MEET ip port 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。\",\"PING/PONG：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。\",\"FAIL：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。\",\"……\",\"下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。\",\"有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。\",\"关于 Redis Cluster 的详细介绍，可以查看这篇文章 Redis 集群详解(付费) 。\"]},\"1086\":{\"h\":\"Gossip 协议消息传播模式\",\"t\":[\"Gossip 设计了两种可能的消息传播模式：反熵（Anti-Entropy） 和 传谣（Rumor-Mongering）。\"]},\"1087\":{\"h\":\"反熵(Anti-entropy)\",\"t\":[\"根据维基百科：\",\"熵的概念最早起源于物理学，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。\",\"在这里，你可以把反熵中的熵了解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。\",\"具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。\",\"在实现反熵的时候，主要有推、拉和推拉三种方式：\",\"推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。\",\"拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。\",\"推拉就是同时修复自己副本和对方副本中的熵。\",\"伪代码如下：\",\"反熵伪代码\",\"在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。\",\"节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。\",\"节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。\",\"节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。\",\"节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。\",\"虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 谣言传播(Rumor mongering) 。\"]},\"1088\":{\"h\":\"谣言传播(Rumor mongering)\",\"t\":[\"谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。\",\"如下图所示（下图来自于INTRODUCTION TO GOSSIP 这篇文章）：\",\"![Gossip 传播示意图](./images/gossip/gossip-rumor- mongering.gif)\",\"伪代码如下：\",\"谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。\"]},\"1089\":{\"h\":\"总结\",\"t\":[\"反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。\",\"我们一般会给反熵设计一个闭环。\",\"谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。\"]},\"1090\":{\"h\":\"Gossip 协议优势和缺陷\",\"t\":[\"优势：\",\"1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。\",\"2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。\",\"3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。\",\"缺陷 :\",\"1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。\",\"2、由于拜占庭将军问题，不允许存在恶意节点。\",\"3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。\"]},\"1091\":{\"h\":\"总结\",\"t\":[\"Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。\",\"Gossip 协议被 Redis、Apache Cassandra、Consul 等项目应用。\",\"谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。\"]},\"1092\":{\"h\":\"参考\",\"t\":[\"一万字详解 Redis Cluster Gossip 协议：https://segmentfault.com/a/1190000038373546\",\"《分布式协议与算法实战》\",\"《Redis 设计与实现》\",\"File not found\"]},\"1093\":{\"c\":[\"分布式\"]},\"1094\":{\"c\":[\"分布式协议&算法\",\"共识算法\"]},\"1095\":{\"h\":\"Paxos 算法详解\"},\"1096\":{\"h\":\"背景\",\"t\":[\"Paxos 算法是 Leslie Lamport（莱斯利·兰伯特）在 1990 年提出了一种分布式系统 共识 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。\",\"为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。\",\"不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。\",\"于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。\",\"直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 1998 年重新发表论文 《The Part-Time Parliament》。\",\"论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 2001 年的时候，兰伯特专门又写了一篇 《Paxos Made Simple》 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。\",\"《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：\",\"The Paxos algorithm, when presented in plain English, is very simple.\",\"翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！\",\"有没有感觉到来自兰伯特大佬满满地嘲讽的味道？\"]},\"1097\":{\"h\":\"介绍\",\"t\":[\"Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。\",\"兰伯特当时提出的 Paxos 算法主要包含 2 个部分:\",\"Basic Paxos 算法：描述的是多节点之间如何就某个值(提案 Value)达成共识。\",\"Multi-Paxos 思想：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。\",\"由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—Raft 算法 。更具体点来说，Raft 是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。\",\"针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进的。\",\"针对存在恶意节点的情况，一般使用的是 工作量证明（POW，Proof-of-Work）、 权益证明（PoS，Proof-of-Stake ） 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。\",\"区块链系统使用的共识算法需要解决的核心问题是 拜占庭将军问题 ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。\",\"下面我们来对 Paxos 算法的定义做一个总结：\",\"Paxos 算法是兰伯特在 1990 年提出了一种分布式系统共识算法。\",\"兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。\",\"Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。\"]},\"1098\":{\"h\":\"Basic Paxos 算法\",\"t\":[\"Basic Paxos 中存在 3 个重要的角色：\",\"提议者（Proposer）：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。\",\"接受者（Acceptor）：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；\",\"学习者（Learner）：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。\",\"为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。\"]},\"1099\":{\"h\":\"Multi Paxos 思想\",\"t\":[\"Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Basic Paxos 思想。\",\"⚠️注意：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。\",\"由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解和实现上比较困难。\",\"不过，也不需要担心，我们并不需要自己实现基于 Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法。\"]},\"1100\":{\"h\":\"参考\",\"t\":[\"https://zh.wikipedia.org/wiki/Paxos\",\"分布式系统中的一致性与共识算法：http://www.xuyasong.com/?p=1970\",\"File not found\"]},\"1101\":{\"c\":[\"分布式\"]},\"1102\":{\"c\":[\"分布式协议&算法\",\"共识算法\"]},\"1103\":{\"h\":\"Raft 算法详解\",\"t\":[\"本文由 SnailClimb 和 Xieqijun 共同完成。\"]},\"1104\":{\"h\":\"1 背景\",\"t\":[\"当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。\",\"因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。\",\"幸运的是，分布式共识可以帮助应对这些挑战。\"]},\"1105\":{\"h\":\"1.1 拜占庭将军\",\"t\":[\"在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。\",\"假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？\",\"解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。\",\"举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。\"]},\"1106\":{\"h\":\"1.2 共识算法\",\"t\":[\"共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。\",\"共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组Server的状态机计算相同状态的副本，即使有一部分的Server宕机了它们仍然能够继续运行。\",\"rsm-architecture.png\",\"图-1 复制状态机架构\",\"一般通过使用复制日志来实现复制状态机。每个Server存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。\",\"因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。\",\"适用于实际系统的共识算法通常具有以下特性：\",\"安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。\",\"高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。\",\"一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。\",\"在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。\"]},\"1107\":{\"h\":\"2 基础\"},\"1108\":{\"h\":\"2.1 节点类型\",\"t\":[\"一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：\",\"Leader：负责发起心跳，响应客户端，创建日志，同步日志。\",\"Candidate：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。\",\"Follower：接受 Leader 的心跳和日志同步数据，投票给 Candidate。\",\"在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。\",\"图-2：服务器的状态\"]},\"1109\":{\"h\":\"2.2 任期\",\"t\":[\"图-3：任期\",\"如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。\",\"每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。\"]},\"1110\":{\"h\":\"2.3 日志\",\"t\":[\"entry：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<term,index,cmd>其中 cmd 是可以应用到状态机的操作。\",\"log：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。\"]},\"1111\":{\"h\":\"3 领导人选举\",\"t\":[\"raft 使用心跳机制来触发 Leader 的选举。\",\"如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。\",\"Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。\",\"为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：\",\"赢得选举\",\"其他节点赢得选举\",\"一轮选举结束，无人胜出\",\"赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票（N/2+1），就可以成为 Leader。\",\"在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：\",\"该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。\",\"该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。\",\"由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。\",\"raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。\"]},\"1112\":{\"h\":\"4 日志复制\",\"t\":[\"一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（Replicated State Mechine）执行的命令。\",\"Leader 收到客户端请求后，会生成一个 entry，包含<index,term,cmd>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。\",\"如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。\",\"如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。\",\"raft 保证以下两个性质：\",\"在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd\",\"在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同\",\"通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。\",\"一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。\",\"为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。\",\"Leader 给每一个Follower 维护了一个 nextIndex，它表示 Leader 将要发送给该追随者的下一条日志条目的索引。当一个 Leader 开始掌权时，它会将 nextIndex 初始化为它的最新的日志条目索引数+1。如果一个 Follower 的日志和 Leader 的不一致，AppendEntries 一致性检查会在下一次 AppendEntries RPC 时返回失败。在失败之后，Leader 会将 nextIndex 递减然后重试 AppendEntries RPC。最终 nextIndex 会达到一个 Leader 和 Follower 日志一致的地方。这时，AppendEntries 会返回成功，Follower 中冲突的日志条目都被移除了，并且添加所缺少的上了 Leader 的日志条目。一旦 AppendEntries 返回成功，Follower 和 Leader 的日志就一致了，这样的状态会保持到该任期结束。\"]},\"1113\":{\"h\":\"5 安全性\"},\"1114\":{\"h\":\"5.1 选举限制\",\"t\":[\"Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。\",\"每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。\",\"判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。\"]},\"1115\":{\"h\":\"5.2 节点崩溃\",\"t\":[\"如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。\",\"如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。\"]},\"1116\":{\"h\":\"5.3 时间与可用性\",\"t\":[\"raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：\",\"broadcastTime << electionTimeout << MTBF\",\"broadcastTime：向其他节点并发发送消息的平均响应时间；\",\"electionTimeout：选举超时时间；\",\"MTBF(mean time between failures)：单台机器的平均健康时间；\",\"broadcastTime应该比electionTimeout小一个数量级，为的是使Leader能够持续发送心跳信息（heartbeat）来阻止Follower开始选举；\",\"electionTimeout也要比MTBF小几个数量级，为的是使得系统稳定运行。当Leader崩溃时，大约会在整个electionTimeout的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。\",\"由于broadcastTime和MTBF是由系统决定的属性，因此需要决定electionTimeout的时间。\",\"一般来说，broadcastTime 一般为 0.5～20ms，electionTimeout 可以设置为 10～500ms，MTBF 一般为一两个月。\"]},\"1117\":{\"h\":\"6 参考\",\"t\":[\"https://tanxinyu.work/raft/\",\"https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md\",\"https://github.com/ongardie/dissertation/blob/master/stanford.pdf\",\"https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html\",\"File not found\"]},\"1118\":{\"c\":[\"分布式\"]},\"1119\":{\"c\":[\"分布式协议&算法\",\"共识算法\"]},\"1120\":{\"h\":\"Dubbo常见问题总结\",\"t\":[\"提示\",\"Dubbo3 已经发布，这篇文章是基于 Dubbo2 写的。Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。\",\"本文中的很多链接已经失效，主要原因是因为 Dubbo 官方文档进行了修改导致 URL 失效。\",\"这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！\"]},\"1121\":{\"h\":\"Dubbo 基础\"},\"1122\":{\"h\":\"什么是 Dubbo?\",\"t\":[\"Dubbo 官网\",\"Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源 WEB 和 RPC 框架。\",\"根据 Dubbo 官方文档的介绍，Dubbo 提供了六大核心能力\",\"面向接口代理的高性能 RPC 调用。\",\"智能容错和负载均衡。\",\"服务自动注册和发现。\",\"高度可扩展能力。\",\"运行期流量调度。\",\"可视化的服务治理与运维。\",\"Dubbo提供的六大核心能力\",\"简单来说就是：Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。\",\"Dubbo 目前已经有接近 34.4 k 的 Star 。\",\"在 2020 年度 OSC 中国开源项目 评选活动中，Dubbo 位列开发框架和基础组件类项目的第 7 名。相比几年前来说，热度和排名有所下降。\",\"Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。\"]},\"1123\":{\"h\":\"为什么要用 Dubbo?\",\"t\":[\"随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。\",\"分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。\",\"我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian 这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。\",\"不过，Dubbo 的出现让上述问题得到了解决。Dubbo 帮助我们解决了什么问题呢？\",\"负载均衡：同一个服务部署在不同的机器时该调用哪一台机器上的服务。\",\"服务调用链路生成：随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。\",\"服务访问压力以及时长统计、资源调度和治理：基于访问压力实时管理集群容量，提高集群利用率。\",\"……\",\"Dubbo 能力概览\",\"另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。\",\"我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？\"]},\"1124\":{\"h\":\"分布式基础\"},\"1125\":{\"h\":\"什么是分布式?\",\"t\":[\"分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。\",\"分布式事务示意图\"]},\"1126\":{\"h\":\"为什么要分布式?\",\"t\":[\"从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。\",\"另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？\"]},\"1127\":{\"h\":\"Dubbo 架构\"},\"1128\":{\"h\":\"Dubbo 架构中的核心角色有哪些？\",\"t\":[\"官方文档中的框架设计章节 已经介绍的非常详细了，我这里把一些比较重要的点再提一下。\",\"dubbo-relation\",\"上述节点简单介绍以及他们之间的关系：\",\"Container： 服务运行容器，负责加载、运行服务提供者。必须。\",\"Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。\",\"Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。\",\"Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。\",\"Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。\"]},\"1129\":{\"h\":\"Dubbo 中的 Invoker 概念了解么？\",\"t\":[\"Invoker 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 Invoker 的身影。\",\"简单来说，Invoker 就是 Dubbo 对远程调用的抽象。\",\"dubbo_rpc_invoke.jpg\",\"按照 Dubbo 官方的话来说，Invoker 分为\",\"服务提供 Invoker\",\"服务消费 Invoker\",\"假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 Invoker 实现， Invoker 实现了真正的远程服务调用。\"]},\"1130\":{\"h\":\"Dubbo 的工作原理了解么？\",\"t\":[\"下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。\",\"左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\",\"dubbo-framework\",\"config 配置层：Dubbo 相关的配置。支持代码配置，同时也支持基于 Spring 来做配置，以 ServiceConfig, ReferenceConfig 为中心\",\"proxy 服务代理层：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 ServiceProxy 为中心。\",\"registry 注册中心层：封装服务地址的注册与发现。\",\"cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。\",\"monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心。\",\"protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心。\",\"exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心。\",\"transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心。\",\"serialize 数据序列化层：对需要在网络传输的数据进行序列化。\"]},\"1131\":{\"h\":\"Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？\",\"t\":[\"SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。\",\"SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。\",\"Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java 原生的 SPI 机制进行了增强，以便更好满足自己的需求。\",\"那我们如何扩展 Dubbo 中的默认实现呢？\",\"比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 XxxLoadBalance 实现 LoadBalance 接口或者 AbstractLoadBalance 类。\",\"package com.xxx; import org.apache.dubbo.rpc.cluster.LoadBalance; import org.apache.dubbo.rpc.Invoker; import org.apache.dubbo.rpc.Invocation; import org.apache.dubbo.rpc.RpcException; public class XxxLoadBalance implements LoadBalance { public <T> Invoker<T> select(List<Invoker<T>> invokers, Invocation invocation) throws RpcException { // ... } } \",\"我们将这个实现类的路径写入到resources 目录下的 META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance文件中即可。\",\"src |-main |-java |-com |-xxx |-XxxLoadBalance.java (实现LoadBalance接口) |-resources |-META-INF |-dubbo |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance) \",\"org.apache.dubbo.rpc.cluster.LoadBalance\",\"xxx=com.xxx.XxxLoadBalance \",\"其他还有很多可供扩展的选择，你可以在官方文档中找到。\"]},\"1132\":{\"h\":\"Dubbo 的微内核架构了解吗？\",\"t\":[\"Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。\",\"何为微内核架构呢？ 《软件架构模式》 这本书是这样介绍的：\",\"微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。\",\"微内核架构包含两类组件：核心系统（core system） 和 插件模块（plug-in modules）。\",\"核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。\",\"我们常见的一些 IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE 比如 IDEA、VSCode 都提供了插件来丰富自己的功能。\",\"正是因为 Dubbo 基于微内核架构，才使得我们可以随心所欲替换 Dubbo 的功能点。比如你觉得 Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！\",\"通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自己造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件：JDK 标准的 SPI 扩展机制 （java.util.ServiceLoader）。\"]},\"1133\":{\"h\":\"关于 Dubbo 架构的一些自测小问题\"},\"1134\":{\"h\":\"注册中心的作用了解么？\",\"t\":[\"注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。\"]},\"1135\":{\"h\":\"服务提供者宕机后，注册中心会做什么？\",\"t\":[\"注册中心会立即推送事件通知消费者。\"]},\"1136\":{\"h\":\"监控中心的作用呢？\",\"t\":[\"监控中心负责统计各服务调用次数，调用时间等。\"]},\"1137\":{\"h\":\"注册中心和监控中心都宕机的话，服务都会挂掉吗？\",\"t\":[\"不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。\"]},\"1138\":{\"h\":\"Dubbo 的负载均衡策略\"},\"1139\":{\"h\":\"什么是负载均衡？\",\"t\":[\"先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：\",\"负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。\",\"上面讲的大家可能不太好理解，再用通俗的话给大家说一下。\",\"我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。\"]},\"1140\":{\"h\":\"Dubbo 提供的负载均衡策略有哪些？\",\"t\":[\"在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 random 随机调用。我们还可以自行扩展负载均衡策略（参考 Dubbo SPI 机制）。\",\"在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。\",\"public abstract class AbstractLoadBalance implements LoadBalance { static int calculateWarmupWeight(int uptime, int warmup, int weight) { } @Override public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) { } protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation); int getWeight(Invoker<?> invoker, Invocation invocation) { } } \",\"AbstractLoadBalance 的实现类有下面这些：\",\"官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance 。\"]},\"1141\":{\"h\":\"RandomLoadBalance\",\"t\":[\"根据权重随机选择（对加权随机算法的实现）。这是 Dubbo 默认采用的一种负载均衡策略。\",\"RandomLoadBalance 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。\",\"我们把这些权重值分布在坐标区间会得到：S1->[0, 7) ，S2->[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。\",\"RandomLoadBalance\",\"RandomLoadBalance 的源码非常简单，简单花几分钟时间看一下。\",\"以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。\",\"public class RandomLoadBalance extends AbstractLoadBalance { public static final String NAME = \\\"random\\\"; @Override protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) { int length = invokers.size(); boolean sameWeight = true; int[] weights = new int[length]; int totalWeight = 0; // 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（）， // 除此之外，还会检测每个服务提供者的权重是否相同 for (int i = 0; i < length; i++) { int weight = getWeight(invokers.get(i), invocation); totalWeight += weight; weights[i] = totalWeight; if (sameWeight && totalWeight != weight * (i + 1)) { sameWeight = false; } } if (totalWeight > 0 && !sameWeight) { // 随机生成一个 [0, totalWeight) 区间内的数字 int offset = ThreadLocalRandom.current().nextInt(totalWeight); // 判断会落在哪个服务提供者的区间 for (int i = 0; i < length; i++) { if (offset < weights[i]) { return invokers.get(i); } } return invokers.get(ThreadLocalRandom.current().nextInt(length)); } } \"]},\"1142\":{\"h\":\"LeastActiveLoadBalance\",\"t\":[\"LeastActiveLoadBalance 直译过来就是最小活跃数负载均衡。\",\"这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。\",\"我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。\",\"因此，Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。\",\"如果有多个服务提供者的活跃数相等怎么办？\",\"很简单，那就再走一遍 RandomLoadBalance 。\",\"public class LeastActiveLoadBalance extends AbstractLoadBalance { public static final String NAME = \\\"leastactive\\\"; @Override protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) { int length = invokers.size(); int leastActive = -1; int leastCount = 0; int[] leastIndexes = new int[length]; int[] weights = new int[length]; int totalWeight = 0; int firstWeight = 0; boolean sameWeight = true; // 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker // 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等 for (int i = 0; i < length; i++) { Invoker<T> invoker = invokers.get(i); // 获取 invoker 对应的活跃(active)数 int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); int afterWarmup = getWeight(invoker, invocation); weights[i] = afterWarmup; if (leastActive == -1 || active < leastActive) { leastActive = active; leastCount = 1; leastIndexes[0] = i; totalWeight = afterWarmup; firstWeight = afterWarmup; sameWeight = true; } else if (active == leastActive) { leastIndexes[leastCount++] = i; totalWeight += afterWarmup; if (sameWeight && afterWarmup != firstWeight) { sameWeight = false; } } } // 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可 if (leastCount == 1) { return invokers.get(leastIndexes[0]); } // 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同 // 这里的处理方式就和 RandomLoadBalance 一致了 if (!sameWeight && totalWeight > 0) { int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight); for (int i = 0; i < leastCount; i++) { int leastIndex = leastIndexes[i]; offsetWeight -= weights[leastIndex]; if (offsetWeight < 0) { return invokers.get(leastIndex); } } } return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]); } } \",\"活跃数是通过 RpcStatus 中的一个 ConcurrentMap 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。\",\"public class RpcStatus { private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS = new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>(); public static RpcStatus getStatus(URL url, String methodName) { String uri = url.toIdentityString(); ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.computeIfAbsent(uri, k -> new ConcurrentHashMap<>()); return map.computeIfAbsent(methodName, k -> new RpcStatus()); } public int getActive() { return active.get(); } } \"]},\"1143\":{\"h\":\"ConsistentHashLoadBalance\",\"t\":[\"ConsistentHashLoadBalance 小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。\",\"ConsistentHashLoadBalance 即一致性 Hash 负载均衡策略。 ConsistentHashLoadBalance 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。\",\"另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。\",\"官方有详细的源码分析：https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance 。这里还有一个相关的 PR#5440 来修复老版本中 ConsistentHashLoadBalance 存在的一些 Bug。感兴趣的小伙伴，可以多花点时间研究一下。我这里不多分析了，这个作业留给你们！\"]},\"1144\":{\"h\":\"RoundRobinLoadBalance\",\"t\":[\"加权轮询负载均衡。\",\"轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。\",\"如果我们有 10 次请求，那么 7 次会被 S1 处理，3 次被 S2 处理。\",\"但是，如果是 RandomLoadBalance 的话，很可能存在 10 次请求有 9 次都被 S1 处理的情况（概率性问题）。\",\"Dubbo 中的 RoundRobinLoadBalance 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 RoundRobinLoadBalance 为平滑加权轮询算法。\"]},\"1145\":{\"h\":\"Dubbo 序列化协议\"},\"1146\":{\"h\":\"Dubbo 支持哪些序列化方式呢？\",\"t\":[\"Dubbo 支持的序列化协议\",\"Dubbo 支持多种序列化方式：JDK 自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf 等等。\",\"Dubbo 默认使用的序列化方式是 hessian2。\"]},\"1147\":{\"h\":\"谈谈你对这些序列化协议了解？\",\"t\":[\"一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：\",\"不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。\",\"性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。\",\"JSON 序列化由于性能问题，我们一般也不会考虑使用。\",\"像 Protostuff，ProtoBuf、hessian2 这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。\",\"Kryo 和 FST 这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。\",\"Dubbo 官方文档中还有一个关于这些序列化协议的性能对比图可供参考。\",\"序列化协议的性能对比\",\"File not found\"]},\"1148\":{\"c\":[\"分布式\"]},\"1149\":{\"c\":[\"rpc\"]},\"1150\":{\"h\":\"有了 HTTP 协议，为什么还要有 RPC ？\",\"t\":[\"本文来自小白 debug投稿，原文：https://juejin.cn/post/7121882245605883934 。\",\"我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？\",\"于是就到网上去搜。\",\"不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在用一个我们不认识的概念去解释另外一个我们不认识的概念，懂的人不需要看，不懂的人看了还是不懂。\",\"这种看了，又好像没看的感觉，云里雾里的很难受，我懂。\",\"为了避免大家有强烈的审丑疲劳，今天我们来尝试重新换个方式讲一讲。\"]},\"1151\":{\"h\":\"从 TCP 聊起\",\"t\":[\"作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。\",\"这时候，我们可选项一般也就TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。\",\"类似下面这样。\",\"fd = socket(AF_INET,SOCK_STREAM,0); \",\"其中SOCK_STREAM，是指使用字节流传输数据，说白了就是TCP 协议。\",\"在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用bind()绑定 IP 端口，用connect()发起建连。\",\"握手建立连接流程\",\"在连接建立之后，我们就可以使用send()发送数据，recv()接收数据。\",\"光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？\",\"不行，这么用会有问题。\"]},\"1152\":{\"h\":\"使用纯裸 TCP 会有什么问题\",\"t\":[\"八股文常背，TCP 是有三个特点，面向连接、可靠、基于字节流。\",\"TCP是什么\",\"这三个特点真的概括的 非常精辟 ，这个八股文我们没白背。\",\"每个特点展开都能聊一篇文章，而今天我们需要关注的是 基于字节流 这一点。\",\"字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 01 串 。纯裸 TCP 收发的这些 01 串之间是 没有任何边界 的，你根本不知道到哪个地方才算一条完整消息。\",\"01二进制字节流\",\"正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 \\\"夏洛\\\"和\\\"特烦恼\\\" 的时候，接收端收到的就是 \\\"夏洛特烦恼\\\" ，这时候接收端没发区分你是想要表达 \\\"夏洛\\\"+\\\"特烦恼\\\" 还是 \\\"夏洛特\\\"+\\\"烦恼\\\" 。\",\"消息对比\",\"这就是所谓的 粘包问题，之前也写过一篇专门的文章聊过这个问题。\",\"说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 自定义的规则 ，用于区分 消息边界 。\",\"于是我们会把每条要发送的数据都包装一下，比如加入 消息头 ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 消息体 。\",\"消息边界长度标志\",\"而这里头提到的 消息头 ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 协议。\",\"每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 有区别，但原理都类似。\",\"于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。\"]},\"1153\":{\"h\":\"HTTP 和 RPC\"},\"1154\":{\"h\":\"RPC 其实是一种调用方式\",\"t\":[\"我们回过头来看网络的分层图。\",\"四层网络协议\",\"TCP 是传输层的协议 ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 应用层协议 而已。\",\"HTTP（Hyper Text Transfer Protocol）协议又叫做 超文本传输协议 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。\",\"HTTP调用\",\"而 RPC（Remote Procedure Call）又叫做 远程过程调用，它本身并不是一个具体的协议，而是一种 调用方式 。\",\"举个例子，我们平时调用一个 本地方法 就像下面这样。\",\" res = localFunc(req) \",\"如果现在这不是个本地方法，而是个远端服务器暴露出来的一个方法remoteFunc，如果我们还能像调用本地方法那样去调用它，这样就可以屏蔽掉一些网络细节，用起来更方便，岂不美哉？\",\"res = remoteFunc(req) \",\"RPC可以像调用本地方法那样调用远端方法\",\"基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的gRPC，thrift。\",\"值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。\",\"到这里，我们回到文章标题的问题。\"]},\"1155\":{\"h\":\"那既然有 RPC 了，为什么还要有 HTTP 呢？\",\"t\":[\"其实，TCP 是 70 年 代出来的协议，而 HTTP 是 90 年代 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 80 年代 出来的RPC。\",\"所以我们该问的不是 既然有 HTTP 协议为什么要有 RPC ，而是 为什么有 RPC 还要有 HTTP 协议?\",\"现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client/Server (C/S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。\",\"但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的服务器（Server） ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 Browser/Server (B/S) 的协议。\",\"也就是说在多年以前，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。 很多软件同时支持多端，比如某度云盘，既要支持网页版，还要支持手机端和 PC 端，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。\",\"那这么说的话，都用 HTTP 得了，还用什么 RPC？\",\"仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。\"]},\"1156\":{\"h\":\"HTTP 和 RPC 有什么区别\",\"t\":[\"我们来看看 RPC 和 HTTP 区别比较明显的几个点。\"]},\"1157\":{\"h\":\"服务发现\",\"t\":[\"首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口 。这个找到服务对应的 IP 端口的过程，其实就是 服务发现。\",\"在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务 去解析得到它背后的 IP 地址，默认 80 端口。\",\"而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 CoreDNS。\",\"可以看出服务发现这一块，两者是有些区别，但不太能分高低。\"]},\"1158\":{\"h\":\"底层连接形式\",\"t\":[\"以主流的 HTTP1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。\",\"而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。\",\"connection_pool\",\"由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。\",\"可以看出这一块两者也没太大区别，所以也不是关键。\"]},\"1159\":{\"h\":\"传输的内容\",\"t\":[\"基于 TCP 传输的消息，说到底，无非都是 消息头 Header 和消息体 Body。\",\"Header 是用于标记一些特殊信息，其中最重要的是 消息体长度。\",\"Body 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 JSON，Protocol Buffers (Protobuf) 。\",\"这个将结构体转为二进制数组的过程就叫 序列化 ，反过来将二进制数组复原成结构体的过程叫 反序列化。\",\"序列化和反序列化\",\"对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 JSON 来 序列化 结构体数据。\",\"我们可以随便截个图直观看下。\",\"HTTP报文\",\"可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 Content-Type，就不需要每次都真的把 Content-Type 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。\",\"而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。\",\"HTTP原理\",\"RPC原理\",\"当然上面说的 HTTP，其实 特指的是现在主流使用的 HTTP1.1，HTTP2在前者的基础上做了很多改进，所以 性能可能比很多 RPC 协议还要好，甚至连gRPC底层都直接用的HTTP2。\",\"那么问题又来了。\"]},\"1160\":{\"h\":\"为什么既然有了 HTTP2，还要有 RPC 协议？\",\"t\":[\"这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。\"]},\"1161\":{\"h\":\"总结\",\"t\":[\"纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 消息边界 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。\",\"RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。\",\"从发展历史来说，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。\",\"RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。\",\"HTTP2.0 在 HTTP1.1 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。\",\"File not found\"]},\"1162\":{\"c\":[\"分布式\"]},\"1163\":{\"c\":[\"rpc\"]},\"1164\":{\"h\":\"RPC基础知识总结\",\"t\":[\"这篇文章会简单介绍一下 RPC 相关的基础概念。\"]},\"1165\":{\"h\":\"RPC 是什么?\",\"t\":[\"RPC（Remote Procedure Call） 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。\",\"为什么要 RPC ？ 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。\",\"RPC 能帮助我们做什么呢？ 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。\",\"举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。\",\"一言蔽之：RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。\"]},\"1166\":{\"h\":\"RPC 的原理是什么?\",\"t\":[\"为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：\",\"客户端（服务消费端）：调用远程方法的一端。\",\"客户端 Stub（桩）：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。\",\"网络传输：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。\",\"服务端 Stub（桩）：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。\",\"服务端（服务提供端）：提供远程方法的一端。\",\"具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。\",\"RPC原理图\",\"服务消费端（client）以本地调用的方式调用远程服务；\",\"客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest；\",\"客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；\",\"服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: RpcRequest；\",\"服务端 Stub（桩）根据RpcRequest中的类、方法、方法参数等信息调用本地的方法；\",\"服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；\",\"客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:RpcResponse ，这样也就得到了最终结果。over!\",\"相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。\",\"虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。\",\"最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。\"]},\"1167\":{\"h\":\"有哪些常见的 RPC 框架？\",\"t\":[\"我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、Motan、gRPC 这些。 如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如 Feign。\"]},\"1168\":{\"h\":\"Dubbo\",\"t\":[\"Apache Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案， 涵盖 Java、Golang 等多种语言 SDK 实现。\",\"Dubbo 提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持 Triple 协议（基于 HTTP/2 之上定义的下一代 RPC 通信协议）、应用级服务发现、Dubbo Mesh （Dubbo3 赋予了很多云原生友好的新特性）等特性。\",\"Dubbo 是由阿里开源，后来加入了 Apache 。正是由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。\",\"Dubbo 算的是比较优秀的国产开源项目了，它的源码也是非常值得学习和阅读的！\",\"GitHub：https://github.com/apache/incubator-dubbo\",\"官网：https://dubbo.apache.org/zh/\"]},\"1169\":{\"h\":\"Motan\",\"t\":[\"Motan 是新浪微博开源的一款 RPC 框架，据说在新浪微博正支撑着千亿次调用。不过笔者倒是很少看到有公司使用，而且网上的资料也比较少。\",\"很多人喜欢拿 Motan 和 Dubbo 作比较，毕竟都是国内大公司开源的。笔者在查阅了很多资料，以及简单查看了其源码之后发现：Motan 更像是一个精简版的 Dubbo，可能是借鉴了 Dubbo 的思想，Motan 的设计更加精简，功能更加纯粹。\",\"不过，我不推荐你在实际项目中使用 Motan。如果你要是公司实际使用的话，还是推荐 Dubbo ，其社区活跃度以及生态都要好很多。\",\"从 Motan 看 RPC 框架设计：http://kriszhang.com/motan-rpc-impl/\",\"Motan 中文文档：https://github.com/weibocom/motan/wiki/zh_overview\"]},\"1170\":{\"h\":\"gRPC\",\"t\":[\"gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计（支持双向流、消息头压缩等功能，更加节省带宽），基于 ProtoBuf 序列化协议开发，并且支持众多开发语言。\",\"何谓 ProtoBuf？ProtoBuf（ Protocol Buffer） 是一种更加灵活、高效的数据格式，可用于通讯协议、数据存储等领域，基本支持所有主流编程语言且与平台无关。不过，通过 ProtoBuf 定义接口和数据类型还挺繁琐的，这是一个小问题。\",\"不得不说，gRPC 的通信层的设计还是非常优秀的，Dubbo-go 3.0 的通信层改进主要借鉴了 gRPC。\",\"不过，gRPC 的设计导致其几乎没有服务治理能力。如果你想要解决这个问题的话，就需要依赖其他组件比如腾讯的 PolarisMesh（北极星）了。\",\"GitHub：https://github.com/grpc/grpc\",\"官网：https://grpc.io/\"]},\"1171\":{\"h\":\"Thrift\",\"t\":[\"Apache Thrift 是 Facebook 开源的跨语言的 RPC 通信框架，目前已经捐献给 Apache 基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于 thrift 研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。\",\"Thrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等（相比于 gRPC 支持的语言更多 ）。\",\"官网：https://thrift.apache.org/\",\"Thrift 简单介绍：https://www.jianshu.com/p/8f25d057a5a9\"]},\"1172\":{\"h\":\"总结\",\"t\":[\"gRPC 和 Thrift 虽然支持跨语言的 RPC 调用，但是它们只提供了最基本的 RPC 框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。\",\"Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。而且，Dubbo 在国内有很多成功的案例比如当当网、滴滴等等，是一款经得起生产考验的成熟稳定的 RPC 框架。最重要的是你还能找到非常多的 Dubbo 参考资料，学习成本相对也较低。\",\"下图展示了 Dubbo 的生态系统。\",\"Dubbo 也是 Spring Cloud Alibaba 里面的一个组件。\",\"但是，Dubbo 和 Motan 主要是给 Java 语言使用。虽然，Dubbo 和 Motan 目前也能兼容部分语言，但是不太推荐。如果需要跨多种语言调用的话，可以考虑使用 gRPC。\",\"综上，如果是 Java 后端技术栈，并且你在纠结选择哪一种 RPC 框架的话，我推荐你考虑一下 Dubbo。\"]},\"1173\":{\"h\":\"如何设计并实现一个 RPC 框架？\",\"t\":[\"《手写 RPC 框架》 是我的知识星球的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。\",\"麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。\",\"内容概览：\"]},\"1174\":{\"h\":\"既然有了 HTTP 协议，为什么还要有 RPC ？\",\"t\":[\"关于这个问题的详细答案，请看这篇文章：有了 HTTP 协议，为什么还要有 RPC ？ 。\",\"File not found\"]},\"1175\":{\"c\":[\"分布式\"]},\"1176\":{\"c\":[\"rpc\"]},\"1177\":{\"h\":\"Disruptor常见问题总结\",\"t\":[\"Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。\",\"一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！ 。\",\"这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。\"]},\"1178\":{\"h\":\"Disruptor 是什么？\",\"t\":[\"Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。\",\"根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 The LMAX Architecture 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。\",\"LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke's Choice Awards(Duke 选择大奖)。\",\"“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！\",\"我专门找到了 Oracle 官方当年颁布获得 Duke's Choice Awards 项目的那篇文章（文章地址：https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award） 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。\",\"2011 年的 Oracle 官方的 Duke's Choice Awards\",\"Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。\",\"Github 地址：https://github.com/LMAX-Exchange/disruptor\",\"官方教程： https://lmax-exchange.github.io/disruptor/user-guide/index.html\",\"关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章：Spring Boot + Disruptor 实战入门 。\"]},\"1179\":{\"h\":\"为什么要用 Disruptor？\",\"t\":[\"Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。\",\"JDK 中常见的线程安全的队列如下：\",\"队列名字\",\"锁\",\"是否有界\",\"ArrayBlockingQueue\",\"加锁（ReentrantLock）\",\"有界\",\"LinkedBlockingQueue\",\"加锁（ReentrantLock）\",\"有界\",\"LinkedTransferQueue\",\"无锁（CAS）\",\"无界\",\"ConcurrentLinkedQueue\",\"无锁（CAS）\",\"无界\",\"从上表中可以看出：这些队列要不就是加锁有界，要不就是无锁无界。而加锁的的队列势必会影响性能，无界的队列又存在内存溢出的风险。\",\"因此，一般情况下，我们都是不建议使用 JDK 内置线程安全队列。\",\"Disruptor 就不一样了！它在无锁的情况下还能保证队列有界，并且还是线程安全的。\",\"下面这张图是 Disruptor 官网提供的 Disruptor 和 ArrayBlockingQueue 的延迟直方图对比。\",\"disruptor-latency-histogram\",\"Disruptor 真的很快，关于它为什么这么快这个问题，会在后文介绍到。\",\"此外，Disruptor 还提供了丰富的扩展功能比如支持批量操作、支持多种等待策略。\"]},\"1180\":{\"h\":\"Kafka 和 Disruptor 什么区别？\",\"t\":[\"Kafka：分布式消息队列，一般用在系统或者服务之间的消息传递，还可以被用作流式处理平台。\",\"Disruptor：内存级别的消息队列，一般用在系统内部中线程间的消息传递。\"]},\"1181\":{\"h\":\"哪些组件用到了 Disruptor？\",\"t\":[\"用到 Disruptor 的开源项目还是挺多的，这里简单举几个例子：\",\"Log4j2：Log4j2 是一款常用的日志框架，它基于 Disruptor 来实现异步日志。\",\"SOFATracer：SOFATracer 是蚂蚁金服开源的分布式应用链路追踪工具，它基于 Disruptor 来实现异步日志。\",\"Storm : Storm 是一个开源的分布式实时计算系统，它基于 Disruptor 来实现工作进程内发生的消息传递（同一 Storm 节点上的线程间，无需网络通信）。\",\"HBase：HBase 是一个分布式列存储数据库系统，它基于 Disruptor 来提高写并发性能。\",\"……\"]},\"1182\":{\"h\":\"Disruptor 核心概念有哪些？\",\"t\":[\"Event：你可以把 Event 理解为存放在队列中等待消费的消息对象。\",\"EventFactory：事件工厂用于生产事件，我们在初始化 Disruptor 类的时候需要用到。\",\"EventHandler：Event 在对应的 Handler 中被处理，你可以将其理解为生产消费者模型中的消费者。\",\"EventProcessor：EventProcessor 持有特定消费者(Consumer)的 Sequence，并提供用于调用事件处理实现的事件循环(Event Loop)。\",\"Disruptor：事件的生产和消费需要用到 Disruptor 对象。\",\"RingBuffer：RingBuffer（环形数组）用于保存事件。\",\"WaitStrategy：等待策略。决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。\",\"Producer：生产者，只是泛指调用 Disruptor 对象发布事件的用户代码，Disruptor 没有定义特定接口或类型。\",\"ProducerType：指定是单个事件发布者模式还是多个事件发布者模式（发布者和生产者的意思类似，我个人比较喜欢用发布者）。\",\"Sequencer：Sequencer 是 Disruptor 的真正核心。此接口有两个实现类 SingleProducerSequencer、MultiProducerSequencer ，它们定义在生产者和消费者之间快速、正确地传递数据的并发算法。\",\"下面这张图摘自 Disruptor 官网，展示了 LMAX 系统使用 Disruptor 的示例。\",\"LMAX 系统使用 Disruptor 的示例\"]},\"1183\":{\"h\":\"Disruptor 等待策略有哪些？\",\"t\":[\"等待策略（WaitStrategy） 决定了没有事件可以消费的时候，事件消费者如何等待新事件的到来。\",\"常见的等待策略有下面这些：\",\"Disruptor 等待策略\",\"BlockingWaitStrategy：基于 ReentrantLock+Condition 来实现等待和唤醒操作，实现代码非常简单，是 Disruptor 默认的等待策略。虽然最慢，但也是 CPU 使用率最低和最稳定的选项生产环境推荐使用；\",\"BusySpinWaitStrategy：性能很好，存在持续自旋的风险，使用不当会造成 CPU 负载 100%，慎用；\",\"LiteBlockingWaitStrategy：基于 BlockingWaitStrategy 的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用;\",\"TimeoutBlockingWaitStrategy：带超时的等待策略，超时后会执行业务指定的处理逻辑;\",\"LiteTimeoutBlockingWaitStrategy：基于TimeoutBlockingWaitStrategy的策略，当没有锁竞争的时候会省去唤醒操作;\",\"SleepingWaitStrategy：三段式策略，第一阶段自旋，第二阶段执行 Thread.yield 让出 CPU，第三阶段睡眠执行时间，反复的睡眠；\",\"YieldingWaitStrategy：二段式策略，第一阶段自旋，第二阶段执行 Thread.yield 交出 CPU;\",\"PhasedBackoffWaitStrategy：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行 Thread.yield 交出 CPU，第四阶段调用成员变量的waitFor方法，该成员变量可以被设置为BlockingWaitStrategy、LiteBlockingWaitStrategy、SleepingWaitStrategy三个中的一个。\"]},\"1184\":{\"h\":\"Disruptor 为什么这么快？\",\"t\":[\"RingBuffer（环形数组） : Disruptor 内部的 RingBuffer 是通过数组实现的。由于这个数组中的所有元素在初始化时一次性全部创建，因此这些元素的内存地址一般来说是连续的。这样做的好处是，当生产者不断往 RingBuffer 中插入新的事件对象时，这些事件对象的内存地址就能够保持连续，从而利用 CPU 缓存的局部性原理，将相邻的事件对象一起加载到缓存中，提高程序的性能。这类似于 MySQL 的预读机制，将连续的几个页预读到内存里。除此之外，RingBuffer 基于数组还支持批量操作（一次处理多个元素）、还可以避免频繁的内存分配和垃圾回收（RingBuffer 是一个固定大小的数组，当向数组中添加新元素时，如果数组已满，则新元素将覆盖掉最旧的元素）。\",\"避免了伪共享问题：CPU 缓存内部是按照 Cache Line（缓存行）管理的，一般的 Cache Line 大小在 64 字节左右。Disruptor 为了确保目标字段独占一个 Cache Line，会在目标字段前后增加了 64 个字节的填充（前 56 个字节和后 8 个字节），这样可以避免 Cache Line 的伪共享（False Sharing）问题。\",\"无锁设计：Disruptor 采用无锁设计，避免了传统锁机制带来的竞争和延迟。Disruptor 的无锁实现起来比较复杂，主要是基于 CAS、内存屏障（Memory Barrier）、RingBuffer 等技术实现的。\",\"综上所述，Disruptor 之所以能够如此快，是基于一系列优化策略的综合作用，既充分利用了现代 CPU 缓存结构的特点，又避免了常见的并发问题和性能瓶颈。\",\"关于 Disruptor 高性能队列原理的详细介绍，可以查看这篇文章：Disruptor 高性能队列原理浅析 （参考了美团技术团队的高性能队列——Disruptor这篇文章）。\",\"🌈 这里额外补充一点：数组中对象元素地址连续为什么可以提高性能？\",\"CPU 缓存是通过将最近使用的数据存储在高速缓存中来实现更快的读取速度，并使用预取机制提前加载相邻内存的数据以利用局部性原理。\",\"在计算机系统中，CPU 主要访问高速缓存和内存。高速缓存是一种速度非常快、容量相对较小的内存，通常被分为多级缓存，其中 L1、L2、L3 分别表示一级缓存、二级缓存、三级缓存。越靠近 CPU 的缓存，速度越快，容量也越小。相比之下，内存容量相对较大，但速度较慢。\",\"CPU 缓存模型示意图\",\"为了加速数据的读取过程，CPU 会先将数据从内存中加载到高速缓存中，如果下一次需要访问相同的数据，就可以直接从高速缓存中读取，而不需要再次访问内存。这就是所谓的 缓存命中 。另外，为了利用 局部性原理 ，CPU 还会根据之前访问的内存地址预取相邻的内存数据，因为在程序中，连续的内存地址通常会被频繁访问到，这样做可以提高数据的缓存命中率，进而提高程序的性能。\"]},\"1185\":{\"h\":\"参考\",\"t\":[\"Disruptor 高性能之道-等待策略：<http://wuwenliang.net/2022/02/28/Disruptor 高性能之道-等待策略/>\",\"《Java 并发编程实战》- 40 | 案例分析（三）：高性能队列 Disruptor：https://time.geekbang.org/column/article/98134\",\"File not found\"]},\"1186\":{\"c\":[\"高性能\"]},\"1187\":{\"c\":[\"消息队列\"]},\"1188\":{\"h\":\"Kafka常见问题总结\"},\"1189\":{\"h\":\"Kafka 基础\"},\"1190\":{\"h\":\"Kafka 是什么？主要应用场景有哪些？\",\"t\":[\"Kafka 是一个分布式流式处理平台。这到底是什么意思呢？\",\"流平台具有三个关键功能：\",\"消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。\",\"容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。\",\"流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。\",\"Kafka 主要有两大应用场景：\",\"消息队列：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。\",\"数据处理： 构建实时的流数据处理程序来转换或处理数据流。\"]},\"1191\":{\"h\":\"和其他消息队列相比,Kafka 的优势在哪里？\",\"t\":[\"我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：\",\"极致的性能：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。\",\"生态系统兼容性无可匹敌：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。\",\"实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。\",\"随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，Kafka 作为消息队列不可靠这个说法已经过时！\"]},\"1192\":{\"h\":\"队列模型了解吗？Kafka 的消息模型知道吗？\",\"t\":[\"题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 JavaGuide的 《消息队列其实很简单》这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。\"]},\"1193\":{\"h\":\"队列模型：早期的消息模型\",\"t\":[\"队列模型\",\"使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）\",\"队列模型存在的问题：\",\"假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。\",\"这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。\"]},\"1194\":{\"h\":\"发布-订阅模型:Kafka 消息模型\",\"t\":[\"发布-订阅模型主要是为了解决队列模型存在的问题。\",\"发布订阅模型\",\"发布订阅模型（Pub-Sub） 使用主题（Topic） 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。\",\"在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。\",\"Kafka 采用的就是发布 - 订阅模型。\",\"RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。\"]},\"1195\":{\"h\":\"Kafka 核心概念\"},\"1196\":{\"h\":\"什么是 Producer、Consumer、Broker、Topic、Partition？\",\"t\":[\"Kafka 将生产者发布的消息发送到 Topic（主题） 中，需要这些消息的消费者可以订阅这些 Topic（主题），如下图所示：\",\"上面这张图也为我们引出了，Kafka 比较重要的几个概念：\",\"Producer（生产者） : 产生消息的一方。\",\"Consumer（消费者） : 消费消息的一方。\",\"Broker（代理） : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。\",\"同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：\",\"Topic（主题） : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。\",\"Partition（分区） : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。\",\"划重点：Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？\"]},\"1197\":{\"h\":\"Kafka 的多副本机制了解吗？带来了什么好处？\",\"t\":[\"还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。\",\"生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。\",\"Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？\",\"Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。\",\"Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。\"]},\"1198\":{\"h\":\"Zookeeper 和 Kafka\"},\"1199\":{\"h\":\"Zookeeper 在 Kafka 中的作用是什么？\",\"t\":[\"要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：https://www.jianshu.com/p/a036405f989c 。\",\"下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。\",\"ZooKeeper 主要为 Kafka 提供元数据的管理的功能。\",\"从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：\",\"Broker 注册：在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 /brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去\",\"Topic 注册：在 Kafka 中，同一个Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：/brokers/topics/my-topic/Partitions/0、/brokers/topics/my-topic/Partitions/1\",\"负载均衡：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。\",\"……\"]},\"1200\":{\"h\":\"使用 Kafka 能否不引入 Zookeeper?\",\"t\":[\"在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。\",\"不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。\",\"![](https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/kafka3.3.1-kraft- production-ready.png)\"]},\"1201\":{\"h\":\"Kafka 消费顺序、消息丢失和重复消费\"},\"1202\":{\"h\":\"Kafka 如何保证消息的消费顺序？\",\"t\":[\"我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：\",\"更改用户会员等级。\",\"根据会员等级计算订单价格。\",\"假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。\",\"我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。\",\"每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 Kafka 只能为我们保证 Partition(分区) 中的消息有序。\",\"消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。\",\"所以，我们就有一种很简单的保证消息消费顺序的方法：1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。\",\"Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。\",\"总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：\",\"1 个 Topic 只对应一个 Partition。\",\"（推荐）发送消息的时候指定 key/Partition。\",\"当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，\"]},\"1203\":{\"h\":\"Kafka 如何保证消息不丢失？\"},\"1204\":{\"h\":\"生产者丢失消息的情况\",\"t\":[\"生产者(Producer) 调用send方法发送消息之后，消息可能因为网络问题并没有发送过去。\",\"所以，我们不能默认在调用send方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 send 方法发送消息实际上是异步的操作，我们可以通过 get()方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：\",\"详细代码见我的这篇文章：Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?\",\"SendResult<String, Object> sendResult = kafkaTemplate.send(topic, o).get(); if (sendResult.getRecordMetadata() != null) { logger.info(\\\"生产者成功发送消息到\\\" + sendResult.getProducerRecord().topic() + \\\"-> \\\" + sendRe sult.getProducerRecord().value().toString()); } \",\"但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：\",\" ListenableFuture<SendResult<String, Object>> future = kafkaTemplate.send(topic, o); future.addCallback(result -> logger.info(\\\"生产者成功发送消息到topic:{} partition:{}的消息\\\", result.getRecordMetadata().topic(), result.getRecordMetadata().partition()), ex -> logger.error(\\\"生产者发送消失败，原因：{}\\\", ex.getMessage())); \",\"如果消息发送失败的话，我们检查失败的原因之后重新发送即可！\",\"另外，这里推荐为 Producer 的retries（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。\"]},\"1205\":{\"h\":\"消费者丢失消息的情况\",\"t\":[\"我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。\",\"kafka offset\",\"当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。\",\"解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。\"]},\"1206\":{\"h\":\"Kafka 弄丢了消息\",\"t\":[\"我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。\",\"试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。\",\"设置 acks = all\",\"解决办法就是我们设置 acks = all。acks 是 Kafka 生产者(Producer) 很重要的一个参数。\",\"acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 acks = all 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.\",\"设置 replication.factor >= 3\",\"为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 replication.factor >= 3。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。\",\"设置 min.insync.replicas > 1\",\"一般情况下我们还需要设置 min.insync.replicas> 1 ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。min.insync.replicas 的默认值为 1 ，在实际生产中应尽量避免默认值 1。\",\"但是，为了保证整个 Kafka 服务的高可用性，你需要确保 replication.factor > min.insync.replicas 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 replication.factor = min.insync.replicas + 1。\",\"设置 unclean.leader.election.enable = false\",\"Kafka 0.11.0.0 版本开始 unclean.leader.election.enable 参数的默认值由原来的 true 改为 false\",\"我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 unclean.leader.election.enable = false 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。\"]},\"1207\":{\"h\":\"Kafka 如何保证消息不重复消费？\",\"t\":[\"kafka 出现消息重复消费的原因：\",\"服务端侧已经消费的数据没有成功提交 offset（根本原因）。\",\"Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。\",\"解决方案：\",\"消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。\",\"将 enable.auto.commit 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：什么时候提交 offset 合适？\",\"处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样\",\"拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。\"]},\"1208\":{\"h\":\"Kafka 重试机制\",\"t\":[\"在 Kafka 如何保证消息不丢失这里，我们提到了 Kafka 的重试机制。由于这部分内容较为重要，我们这里再来详细介绍一下。\",\"网上关于 Spring Kafka 的默认重试机制文章很多，但大多都是过时的，和实际运行结果完全不一样。以下是根据 spring-kafka-2.9.3 源码重新梳理一下。\"]},\"1209\":{\"h\":\"消费失败会怎么样？\",\"t\":[\"在消费过程中，当其中一个消息消费异常时，会不会卡住后续队列消息的消费？这样业务岂不是卡住了？\",\"生产者代码：\",\" for (int i = 0; i < 10; i++) { kafkaTemplate.send(KafkaConst.TEST_TOPIC, String.valueOf(i)) } \",\"消费者消代码：\",\" @KafkaListener(topics = {KafkaConst.TEST_TOPIC},groupId = \\\"apple\\\") private void customer(String message) throws InterruptedException { log.info(\\\"kafka customer:{}\\\",message); Integer n = Integer.parseInt(message); if (n%5==0){ throw new RuntimeException(); } } \",\"在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息。下面是一段消费的日志，可以看出当 test-0@95 重试多次后会被跳过。\",\"2023-08-10 12:03:32.918 DEBUG 9700 --- [ntainer#0-0-C-1] o.s.kafka.listener.DefaultErrorHandler : Skipping seek of: test-0@95 2023-08-10 12:03:32.918 TRACE 9700 --- [ntainer#0-0-C-1] o.s.kafka.listener.DefaultErrorHandler : Seeking: test-0 to: 96 2023-08-10 12:03:32.918 INFO 9700 --- [ntainer#0-0-C-1] o.a.k.clients.consumer.KafkaConsumer : [Consumer clientId=consumer-apple-1, groupId=apple] Seeking to offset 96 for partition test-0 \",\"因此，即使某个消息消费异常，Kafka 消费者仍然能够继续消费后续的消息，不会一直卡在当前消息，保证了业务的正常进行。\"]},\"1210\":{\"h\":\"默认会重试多少次？\",\"t\":[\"默认配置下，消费异常会进行重试，重试次数是多少, 重试是否有时间间隔？\",\"看源码 FailedRecordTracker 类有个 recovered 函数，返回 Boolean 值判断是否要进行重试，下面是这个函数中判断是否重试的逻辑：\",\" @Override public boolean recovered(ConsumerRecord << ? , ? > record, Exception exception, @Nullable MessageListenerContainer container, @Nullable Consumer << ? , ? > consumer) throws InterruptedException { if (this.noRetries) { // 不支持重试 attemptRecovery(record, exception, null, consumer); return true; } // 取已经失败的消费记录集合 Map < TopicPartition, FailedRecord > map = this.failures.get(); if (map == null) { this.failures.set(new HashMap < > ()); map = this.failures.get(); } // 获取消费记录所在的Topic和Partition TopicPartition topicPartition = new TopicPartition(record.topic(), record.partition()); FailedRecord failedRecord = getFailedRecordInstance(record, exception, map, topicPartition); // 通知注册的重试监听器，消息投递失败 this.retryListeners.forEach(rl - > rl.failedDelivery(record, exception, failedRecord.getDeliveryAttempts().get())); // 获取下一次重试的时间间隔 long nextBackOff = failedRecord.getBackOffExecution().nextBackOff(); if (nextBackOff != BackOffExecution.STOP) { this.backOffHandler.onNextBackOff(container, exception, nextBackOff); return false; } else { attemptRecovery(record, exception, topicPartition, consumer); map.remove(topicPartition); if (map.isEmpty()) { this.failures.remove(); } return true; } } \",\"其中， BackOffExecution.STOP 的值为 -1。\",\"@FunctionalInterface public interface BackOffExecution { long STOP = -1; long nextBackOff(); } \",\"nextBackOff 的值调用 BackOff 类的 nextBackOff() 函数。如果当前执行次数大于最大执行次数则返回 STOP，既超过这个最大执行次数后才会停止重试。\",\"public long nextBackOff() { this.currentAttempts++; if (this.currentAttempts <= getMaxAttempts()) { return getInterval(); } else { return STOP; } } \",\"那么这个 getMaxAttempts 的值又是多少呢？回到最开始，当执行出错会进入 DefaultErrorHandler 。DefaultErrorHandler 默认的构造函数是：\",\"public DefaultErrorHandler() { this(null, SeekUtils.DEFAULT_BACK_OFF); } \",\"SeekUtils.DEFAULT_BACK_OFF 定义的是:\",\"public static final int DEFAULT_MAX_FAILURES = 10; public static final FixedBackOff DEFAULT_BACK_OFF = new FixedBackOff(0, DEFAULT_MAX_FAILURES - 1); \",\"DEFAULT_MAX_FAILURES 的值是 10，currentAttempts 从 0 到 9，所以总共会执行 10 次，每次重试的时间间隔为 0。\",\"最后，简单总结一下：Kafka 消费者在默认配置下会进行最多 10 次 的重试，每次重试的时间间隔为 0，即立即进行重试。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，消息将被视为消费失败。\"]},\"1211\":{\"h\":\"如何自定义重试次数以及时间间隔?\",\"t\":[\"从上面的代码可以知道，默认错误处理器的重试次数以及时间间隔是由 FixedBackOff 控制的，FixedBackOff 是 DefaultErrorHandler 初始化时默认的。所以自定义重试次数以及时间间隔，只需要在 DefaultErrorHandler 初始化的时候传入自定义的 FixedBackOff 即可。重新实现一个 KafkaListenerContainerFactory ，调用 setCommonErrorHandler 设置新的自定义的错误处理器就可以实现。\",\"@Bean public KafkaListenerContainerFactory kafkaListenerContainerFactory(ConsumerFactory<String, String> consumerFactory) { ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory(); // 自定义重试时间间隔以及次数 FixedBackOff fixedBackOff = new FixedBackOff(1000, 5); factory.setCommonErrorHandler(new DefaultErrorHandler(fixedBackOff)); factory.setConsumerFactory(consumerFactory); return factory; } \"]},\"1212\":{\"h\":\"如何在重试失败后进行告警?\",\"t\":[\"自定义重试失败后逻辑，需要手动实现，以下是一个简单的例子，重写 DefaultErrorHandler 的 handleRemaining 函数，加上自定义的告警等操作。\",\"@Slf4j public class DelErrorHandler extends DefaultErrorHandler { public DelErrorHandler(FixedBackOff backOff) { super(null,backOff); } @Override public void handleRemaining(Exception thrownException, List<ConsumerRecord<?, ?>> records, Consumer<?, ?> consumer, MessageListenerContainer container) { super.handleRemaining(thrownException, records, consumer, container); log.info(\\\"重试多次失败\\\"); // 自定义操作 } } \",\"DefaultErrorHandler 只是默认的一个错误处理器，Spring Kafka 还提供了 CommonErrorHandler 接口。手动实现 CommonErrorHandler 就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。\"]},\"1213\":{\"h\":\"重试失败后的数据如何再次处理?\",\"t\":[\"当达到最大重试次数后，数据会直接被跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的数据呢？\",\"死信队列（Dead Letter Queue，简称 DLQ） 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被\\\"丢弃\\\"或\\\"死亡\\\"的情况。当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。\",\"@RetryableTopic 是 Spring Kafka 中的一个注解,它用于配置某个 Topic 支持消息重试，更推荐使用这个注解来完成重试。\",\"// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒 @RetryableTopic( attempts = \\\"5\\\", backoff = @Backoff(delay = 100, maxDelay = 1000) ) @KafkaListener(topics = {KafkaConst.TEST_TOPIC}, groupId = \\\"apple\\\") private void customer(String message) { log.info(\\\"kafka customer:{}\\\", message); Integer n = Integer.parseInt(message); if (n % 5 == 0) { throw new RuntimeException(); } System.out.println(n); } \",\"当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。对于死信队列的处理，既可以用 @DltHandler 处理，也可以使用 @KafkaListener 重新消费。\"]},\"1214\":{\"h\":\"参考\",\"t\":[\"Kafka 官方文档：https://kafka.apache.org/documentation/\",\"极客时间—《Kafka 核心技术与实战》第 11 节：无消息丢失配置怎么实现？\",\"File not found\"]},\"1215\":{\"c\":[\"高性能\"]},\"1216\":{\"c\":[\"消息队列\"]},\"1217\":{\"h\":\"消息队列基础知识总结\",\"t\":[\"提示\",\"这篇文章中的消息队列主要指的是分布式消息队列。\",\"“RabbitMQ？”“Kafka？”“RocketMQ？”...在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。\",\"如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。\"]},\"1218\":{\"h\":\"什么是消息队列？\",\"t\":[\"我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。\",\"参与消息传递的双方称为 生产者 和 消费者 ，生产者负责发送消息，消费者负责处理消息。\",\"发布/订阅（Pub/Sub）模型\",\"我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件/模块之前的通信，属于一种 中间件 。\",\"维基百科是这样介绍中间件的：\",\"中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。\",\"简单来说：中间件就是一类为应用软件服务的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。\",\"除了消息队列之外，常见的中间件还有 RPC 框架、分布式组件、HTTP 服务器、任务调度框架、配置中心、数据库层的分库分表工具和数据迁移工具等等。\",\"关于中间件比较详细的介绍可以参考阿里巴巴淘系技术的一篇回答：https://www.zhihu.com/question/19730582/answer/1663627873 。\",\"随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰，是分布式和微服务系统中重要的组件之一。\"]},\"1219\":{\"h\":\"消息队列有什么用？\",\"t\":[\"通常来说，使用消息队列能为我们的系统带来下面三点好处：\",\"通过异步处理提高系统性能（减少响应所需时间）\",\"削峰/限流\",\"降低系统耦合性。\",\"如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。\"]},\"1220\":{\"h\":\"通过异步处理提高系统性能（减少响应所需时间）\",\"t\":[\"通过异步处理提高系统性能\",\"将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。\",\"因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。\"]},\"1221\":{\"h\":\"削峰/限流\",\"t\":[\"先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。\",\"举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：\",\"削峰\"]},\"1222\":{\"h\":\"降低系统耦合性\",\"t\":[\"使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：\",\"解耦\",\"生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。\",\"消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。\",\"消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。\",\"另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。\",\"备注： 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型。\"]},\"1223\":{\"h\":\"实现分布式事务\",\"t\":[\"我们知道分布式事务的解决方案之一就是 MQ 事务。\",\"RocketMQ、 Kafka、Pulsar、QMQ 都提供了事务相关的功能。事务允许事件流应用将消费，处理，生产消息整个过程定义为一个原子操作。\",\"详细介绍可以查看 分布式事务详解(付费) 这篇文章。\",\"分布式事务详解 - MQ事务\"]},\"1224\":{\"h\":\"使用消息队列会带来哪些问题？\",\"t\":[\"系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！\",\"系统复杂性提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！\",\"一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!\"]},\"1225\":{\"h\":\"JMS 和 AMQP\"},\"1226\":{\"h\":\"JMS 是什么？\",\"t\":[\"JMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\",\"JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收以一些不同形式的数据：\",\"StreamMessage：Java 原始值的数据流\",\"MapMessage：一套名称-值对\",\"TextMessage：一个字符串对象\",\"ObjectMessage：一个序列化的 Java 对象\",\"BytesMessage：一个字节的数据流\",\"ActiveMQ（已被淘汰） 就是基于 JMS 规范实现的。\"]},\"1227\":{\"h\":\"JMS 两种消息模型\"},\"1228\":{\"h\":\"点到点（P2P）模型\",\"t\":[\"队列模型\",\"使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）\"]},\"1229\":{\"h\":\"发布/订阅（Pub/Sub）模型\",\"t\":[\"发布/订阅（Pub/Sub）模型\",\"发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者。\"]},\"1230\":{\"h\":\"AMQP 是什么？\",\"t\":[\"AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。\",\"RabbitMQ 就是基于 AMQP 协议实现的。\"]},\"1231\":{\"h\":\"JMS vs AMQP\",\"t\":[\"对比方向\",\"JMS\",\"AMQP\",\"定义\",\"Java API\",\"协议\",\"跨语言\",\"否\",\"是\",\"跨平台\",\"否\",\"是\",\"支持消息类型\",\"提供两种消息模型：①Peer-2-Peer;②Pub/sub\",\"提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；\",\"支持消息类型\",\"支持多种消息类型 ，我们在上面提到过\",\"byte[]（二进制）\",\"总结：\",\"AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。\",\"JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。\",\"由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。\"]},\"1232\":{\"h\":\"RPC 和消息队列的区别\",\"t\":[\"RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：\",\"从用途来看：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。\",\"从通信方式来看：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。\",\"从架构上来看：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。\",\"从请求处理的时效性来看：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。\",\"RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈。\"]},\"1233\":{\"h\":\"分布式消息队列技术选型\"},\"1234\":{\"h\":\"常见的消息队列有哪些？\"},\"1235\":{\"h\":\"Kafka\",\"t\":[\"Kafka 是 LinkedIn 开源的一个分布式流式处理平台，已经成为 Apache 顶级项目，早期被用来用于处理海量的日志，后面才慢慢发展成了一款功能全面的高性能消息队列。\",\"流式处理平台具有三个关键功能：\",\"消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。\",\"容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。\",\"流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。\",\"Kafka 是一个分布式系统，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成，可以部署在在本地和云环境中的裸机硬件、虚拟机和容器上。\",\"在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka。\",\"不过，要提示一下：如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（Kafka Raft）共识协议标记为生产就绪的版本。\",\"Kafka 官网：http://kafka.apache.org/\",\"Kafka 更新记录（可以直观看到项目是否还在维护）：https://kafka.apache.org/downloads\"]},\"1236\":{\"h\":\"RocketMQ\",\"t\":[\"RocketMQ 是阿里开源的一款云原生“消息、事件、流”实时数据处理平台，借鉴了 Kafka，已经成为 Apache 顶级项目。\",\"RocketMQ 的核心特性（摘自 RocketMQ 官网）：\",\"云原生：生与云，长与云，无限弹性扩缩，K8s 友好\",\"高吞吐：万亿级吞吐保证，同时满足微服务与大数据场景。\",\"流处理：提供轻量、高扩展、高性能和丰富功能的流计算引擎。\",\"金融级：金融级的稳定性，广泛用于交易核心链路。\",\"架构极简：零外部依赖，Shared-nothing 架构。\",\"生态友好：无缝对接微服务、实时计算、数据湖等周边生态。\",\"根据官网介绍：\",\"Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。\",\"RocketMQ 官网：https://rocketmq.apache.org/ （文档很详细，推荐阅读）\",\"RocketMQ 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/rocketmq/releases\"]},\"1237\":{\"h\":\"RabbitMQ\",\"t\":[\"RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。\",\"RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：\",\"可靠性： RabbitMQ 使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。\",\"灵活的路由： 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。\",\"扩展性： 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。\",\"高可用性： 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。\",\"支持多种协议： RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。\",\"多语言客户端： RabbitMQ 几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript 等。\",\"易用的管理界面： RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。\",\"插件机制： RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI 机制\",\"RabbitMQ 官网：https://www.rabbitmq.com/ 。\",\"RabbitMQ 更新记录（可以直观看到项目是否还在维护）：https://www.rabbitmq.com/news.html\"]},\"1238\":{\"h\":\"Pulsar\",\"t\":[\"Pulsar 是下一代云原生分布式消息流平台，最初由 Yahoo 开发 ，已经成为 Apache 顶级项目。\",\"Pulsar 集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性，被看作是云原生时代实时消息流传输、存储和计算最佳解决方案。\",\"Pulsar 的关键特性如下（摘自官网）：\",\"是下一代云原生分布式消息流平台。\",\"Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。\",\"极低的发布延迟和端到端延迟。\",\"可无缝扩展到超过一百万个 topic。\",\"简单的客户端 API，支持 Java、Go、Python 和 C++。\",\"主题的多种订阅模式（独占、共享和故障转移）。\",\"通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。\",\"由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。\",\"基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。\",\"分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如 S3、GCS）中。\",\"Pulsar 官网：https://pulsar.apache.org/\",\"Pulsar 更新记录（可以直观看到项目是否还在维护）：https://github.com/apache/pulsar/releases\"]},\"1239\":{\"h\":\"ActiveMQ\",\"t\":[\"目前已经被淘汰，不推荐使用，不建议学习。\"]},\"1240\":{\"h\":\"如何选择？\",\"t\":[\"参考《Java 工程师面试突击第 1 季-中华石杉老师》\",\"对比方向\",\"概要\",\"吞吐量\",\"万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。\",\"可用性\",\"都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 Kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\",\"时效性\",\"RabbitMQ 基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他几个都是 ms 级。\",\"功能支持\",\"Pulsar 的功能更全面，支持多租户、多种消费模式和持久性模式等功能，是下一代云原生分布式消息流平台。\",\"消息丢失\",\"ActiveMQ 和 RabbitMQ 丢失的可能性非常低， Kafka、RocketMQ 和 Pulsar 理论上可以做到 0 丢失。\",\"总结：\",\"ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用，已经被淘汰了。\",\"RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。\",\"RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。\",\"RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。\",\"Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。Kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。\"]},\"1241\":{\"h\":\"参考\",\"t\":[\"《大型网站技术架构 》\",\"KRaft: Apache Kafka Without ZooKeeper：https://developer.confluent.io/learn/kraft/\",\"消息队列的使用场景是什么样的？：https://mp.weixin.qq.com/s/4V1jI6RylJr7Jr9JsQe73A\",\"File not found\"]},\"1242\":{\"c\":[\"高性能\"]},\"1243\":{\"c\":[\"消息队列\"]},\"1244\":{\"h\":\"RabbitMQ常见问题总结\",\"t\":[\"本篇文章由 JavaGuide 收集自网络，原出处不明。\"]},\"1245\":{\"h\":\"RabbitMQ 是什么？\",\"t\":[\"RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。\",\"RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。\",\"PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。\"]},\"1246\":{\"h\":\"RabbitMQ 特点?\",\"t\":[\"可靠性: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。\",\"灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。\",\"扩展性: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。\",\"高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。\",\"多种协议: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。\",\"多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。\",\"管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。\",\"插件机制 : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。\"]},\"1247\":{\"h\":\"RabbitMQ 核心概念？\",\"t\":[\"RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。\",\"RabbitMQ 的整体模型架构如下：\",\"图1-RabbitMQ 的整体模型架构\",\"下面我会一一介绍上图中的一些概念。\"]},\"1248\":{\"h\":\"Producer(生产者) 和 Consumer(消费者)\",\"t\":[\"Producer(生产者) :生产消息的一方（邮件投递者）\",\"Consumer(消费者) :消费消息的一方（邮件收件人）\",\"消息一般由 2 部分组成：消息头（或者说是标签 Label）和 消息体。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。\"]},\"1249\":{\"h\":\"Exchange(交换器)\",\"t\":[\"在 RabbitMQ 中，消息并不是直接被投递到 Queue(消息队列) 中的，中间还必须经过 Exchange(交换器) 这一层，Exchange(交换器) 会把我们的消息分配到对应的 Queue(消息队列) 中。\",\"Exchange(交换器) 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producer(生产者) ，或许会被直接丢弃掉 。这里可以将 RabbitMQ 中的交换器看作一个简单的实体。\",\"RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略：direct(默认)，fanout, topic, 和 headers，不同类型的 Exchange 转发消息的策略有所区别。这个会在介绍 Exchange Types(交换器类型) 的时候介绍到。\",\"Exchange(交换器) 示意图如下：\",\"Exchange(交换器) 示意图\",\"生产者将消息发给交换器的时候，一般会指定一个 RoutingKey(路由键)，用来指定这个消息的路由规则，而这个 RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。\",\"RabbitMQ 中通过 Binding(绑定) 将 Exchange(交换器) 与 Queue(消息队列) 关联起来，在绑定的时候一般会指定一个 BindingKey(绑定建) ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。\",\"Binding(绑定) 示意图：\",\"Binding(绑定) 示意图\",\"生产者将消息发送给交换器时，需要一个 RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如 fanout 类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。\"]},\"1250\":{\"h\":\"Queue(消息队列)\",\"t\":[\"Queue(消息队列) 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。\",\"RabbitMQ 中消息只能存储在 队列 中，这一点和 Kafka 这种消息中间件相反。Kafka 将消息存储在 topic（主题） 这个逻辑层面，而相对应的队列逻辑只是 topic 实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。\",\"多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。\",\"RabbitMQ 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。\"]},\"1251\":{\"h\":\"Broker（消息中间件的服务节点）\",\"t\":[\"对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者 RabbitMQ 服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。\",\"下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从 Broker 中消费数据的整个流程。\",\"消息队列的运转过程\",\"这样图 1 中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 Exchange Types(交换器类型) 。\"]},\"1252\":{\"h\":\"Exchange Types(交换器类型)\",\"t\":[\"RabbitMQ 常用的 Exchange Type 有 fanout、direct、topic、headers 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。\",\"1、fanout\",\"fanout 类型的 Exchange 路由规则非常简单，它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。\",\"2、direct\",\"direct 类型的 Exchange 路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。\",\"direct 类型交换器\",\"以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为\\\"Info”或者\\\"debug”，消息只会路由到 Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。\",\"direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。\",\"3、topic\",\"前面讲到 direct 类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic 类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：\",\"RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;\",\"BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；\",\"BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。\",\"topic 类型交换器\",\"以上图为例：\",\"路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2;\",\"路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；\",\"路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；\",\"路由键为 “java.rabbitmq.demo” 的消息只会路由到 Queue1 中；\",\"路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。\",\"4、headers(不推荐)\",\"headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ 会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。\"]},\"1253\":{\"h\":\"AMQP 是什么?\",\"t\":[\"RabbitMQ 就是 AMQP 协议的 Erlang 的实现(当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。\",\"RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。\",\"AMQP 协议的三层：\",\"Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。\",\"Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。\",\"TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。\",\"AMQP 模型的三大组件：\",\"交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。\",\"队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。\",\"绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。\"]},\"1254\":{\"h\":\"说说生产者 Producer 和消费者 Consumer?\",\"t\":[\"生产者 :\",\"消息生产者，就是投递消息的一方。\",\"消息一般包含两个部分：消息体（payload)和标签(Label)。\",\"消费者：\",\"消费消息，也就是接收消息的一方。\",\"消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。\"]},\"1255\":{\"h\":\"说说 Broker 服务节点、Queue 队列、Exchange 交换器？\",\"t\":[\"Broker：可以看做 RabbitMQ 的服务节点。一般情况下一个 Broker 可以看做一个 RabbitMQ 服务器。\",\"Queue：RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。\",\"Exchange：生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。\"]},\"1256\":{\"h\":\"什么是死信队列？如何导致的？\",\"t\":[\"DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。\",\"导致的死信的几种原因：\",\"消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。\",\"消息 TTL 过期。\",\"队列满了，无法再添加。\"]},\"1257\":{\"h\":\"什么是延迟队列？RabbitMQ 怎么实现延迟队列？\",\"t\":[\"延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。\",\"RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：\",\"通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。\",\"在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。\",\"也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。\"]},\"1258\":{\"h\":\"什么是优先级队列？\",\"t\":[\"RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。\",\"可以通过x-max-priority参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。\"]},\"1259\":{\"h\":\"RabbitMQ 有哪些工作模式？\",\"t\":[\"简单模式\",\"work 工作模式\",\"pub/sub 发布订阅模式\",\"Routing 路由模式\",\"Topic 主题模式\"]},\"1260\":{\"h\":\"RabbitMQ 消息怎么传输？\",\"t\":[\"由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。\"]},\"1261\":{\"h\":\"如何保证消息的可靠性？\",\"t\":[\"消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。\",\"生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。\",\"RabbitMQ 自身：持久化、集群、普通模式、镜像模式。\",\"RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。\"]},\"1262\":{\"h\":\"如何保证 RabbitMQ 消息的顺序性？\",\"t\":[\"拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；\",\"或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。\"]},\"1263\":{\"h\":\"如何保证 RabbitMQ 高可用的？\",\"t\":[\"RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。\",\"单机模式\",\"Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。\",\"普通集群模式\",\"意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。\",\"你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。\",\"镜像集群模式\",\"这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。\",\"这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。\"]},\"1264\":{\"h\":\"如何解决消息队列的延时以及过期失效问题？\",\"t\":[\"RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。\",\"File not found\"]},\"1265\":{\"c\":[\"高性能\"]},\"1266\":{\"c\":[\"消息队列\"]},\"1267\":{\"h\":\"RocketMQ常见问题总结\",\"t\":[\"本文由 FrancisQ 投稿！ 相比原文主要进行了下面这些完善：\",\"分析了 RocketMQ 高性能读写的原因和顺序消费的具体实现\",\"增加了消息类型、消费者类型、消费者组和生产者组的介绍\"]},\"1268\":{\"h\":\"消息队列扫盲\",\"t\":[\"消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？\",\"所以问题并不是消息队列是什么，而是 消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？\"]},\"1269\":{\"h\":\"消息队列为什么会出现？\",\"t\":[\"消息队``列算是作为后端程序员的一个必备技能吧，因为分布式应用必定涉及到各个系统之间的通信问题，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。\"]},\"1270\":{\"h\":\"消息队列能用来干什么？\"},\"1271\":{\"h\":\"异步\",\"t\":[\"你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？\",\"很好 👍，你又提出了一个概念，同步通信。就比如现在业界使用比较多的 Dubbo 就是一个适用于各个系统之间同步通信的 RPC 框架。\",\"我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。\",\"我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。\",\"当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 头重脚轻 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？\",\"这样整个系统的调用链又变长了，整个时间就变成了 550ms。\",\"当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。\",\"我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦 😋😋😋” 咦~~~ 为了多吃点，真恶心。\",\"然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。\",\"最终我们从大妈手中接过饭菜然后去寻找座位了...\",\"回想一下，我们在给大妈发送需要的信息之后我们是 同步等待大妈给我配好饭菜 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。\",\"那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 (传达一个消息) ，然后我们就可以在饭桌上安心的玩手机了 (干自己其他事情) ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 异步 的概念。\",\"所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。\",\"这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。\",\"但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。\"]},\"1272\":{\"h\":\"解耦\",\"t\":[\"回到最初同步调用的过程，我们写个伪代码简单概括一下。\",\"那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？\",\"如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？\",\"这样改来改去是不是很麻烦，那么 此时我们就用一个消息队列在中间进行解耦 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 result ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 “广播消息” 来实现。\",\"我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 订阅 特定的主题。比如我们这里的主题就可以叫做 订票 ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 生产消息到指定主题中 ，而 消费者只需要关注从指定主题中拉取消息 就行了。\",\"如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。\"]},\"1273\":{\"h\":\"削峰\",\"t\":[\"我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？\",\"如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 直接崩溃 了？\",\"短信业务又不是我们的主业务，我们能不能 折中处理 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 尽自己所能地去消息队列中取消息和消费消息 ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。\",\"留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？\"]},\"1274\":{\"h\":\"消息队列能带来什么好处？\",\"t\":[\"其实上面我已经说了。异步、解耦、削峰。 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。\"]},\"1275\":{\"h\":\"消息队列会带来副作用吗？\",\"t\":[\"没有哪一门技术是“银弹”，消息队列也有它的副作用。\",\"比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 降低了系统的可用性 ？\",\"那这样是不是要保证 HA(高可用)？是不是要搞集群？那么我 整个系统的复杂度是不是上升了 ？\",\"抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。\",\"或者我消费端处理失败了，请求重发，这样也会产生重复的消息。\",\"对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？\",\"那么，又 如何解决重复消费消息的问题 呢？\",\"如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个 id 为 1 的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？\",\"那么，又 如何解决消息的顺序消费问题 呢？\",\"就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 Spring 的话我们在上面伪代码中加入 @Transactional 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。\",\"那么，又如何 解决分布式事务问题 呢？\",\"我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？\",\"那么，又如何 解决消息堆积的问题 呢？\",\"可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊 😵？\",\"别急，办法总是有的。\"]},\"1276\":{\"h\":\"RocketMQ 是什么？\",\"t\":[\"哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 RocketMQ ，还让不让人活了？！🤬\",\"别急别急，话说你现在清楚 MQ 的构造吗，我还没讲呢，我们先搞明白 MQ 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。\",\"RocketMQ 是一个 队列模型 的消息中间件，具有高性能、高可靠、高实时、分布式 的特点。它是一个采用 Java 语言开发的分布式的消息系统，由阿里巴巴团队开发，在 2016 年底贡献给 Apache，成为了 Apache 的一个顶级项目。 在阿里内部，RocketMQ 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 RocketMQ 流转。\",\"废话不多说，想要了解 RocketMQ 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 RocketMQ 很快、很牛、而且经历过双十一的实践就行了！\"]},\"1277\":{\"h\":\"队列模型和主题模型是什么？\",\"t\":[\"在谈 RocketMQ 的技术架构之前，我们先来了解一下两个名词概念——队列模型 和 主题模型 。\",\"首先我问一个问题，消息队列为什么要叫消息队列？\",\"你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？\",\"的确，早期的消息中间件是通过 队列 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。\",\"但是，如今例如 RocketMQ、Kafka 这些优秀的消息中间件不仅仅是通过一个 队列 来实现消息存储的。\"]},\"1278\":{\"h\":\"队列模型\",\"t\":[\"就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。\",\"在一开始我跟你提到了一个 “广播” 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。\",\"当然你可以让 Producer 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 解耦 这一原则。\"]},\"1279\":{\"h\":\"主题模型\",\"t\":[\"那么有没有好的方法去解决这一个问题呢？有，那就是 主题模型 或者可以称为 发布订阅模型 。\",\"感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。\",\"在主题模型中，消息的生产者称为 发布者(Publisher) ，消息的消费者称为 订阅者(Subscriber) ，存放消息的容器称为 主题(Topic) 。\",\"其中，发布者将消息发送到指定主题中，订阅者需要 提前订阅主题 才能接受特定主题的消息。\"]},\"1280\":{\"h\":\"RocketMQ 中的消息模型\",\"t\":[\"RocketMQ 中的消息模型就是按照 主题模型 所实现的。你可能会好奇这个 主题 到底是怎么实现的呢？你上面也没有讲到呀！\",\"其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 Kafka 中的 分区 ，RocketMQ 中的 队列 ，RabbitMQ 中的 Exchange 。我们可以理解为 主题模型/发布订阅模型 就是一个标准，那些中间件只不过照着这个标准去实现而已。\",\"所以，RocketMQ 中的 主题模型 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。\",\"我们可以看到在整个图中有 Producer Group、Topic、Consumer Group 三个角色，我来分别介绍一下他们。\",\"Producer Group 生产者组：代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 Producer Group 生产者组，它们一般生产相同的消息。\",\"Consumer Group 消费者组：代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 Consumer Group 消费者组，它们一般消费相同的消息。\",\"Topic 主题：代表一类消息，比如订单消息，物流消息等等。\",\"你可以看到图中生产者组中的生产者会向主题发送消息，而 主题中存在多个队列，生产者每次生产消息之后是指定主题中的某个队列发送消息的。\",\"每个主题中都有多个队列(分布在不同的 Broker中，如果是集群的话，Broker又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 topic 的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 Consumer1 和 Consumer2 分别对应着两个队列，而 Consumer3 是没有队列对应的，所以一般来讲要控制 消费者组中的消费者个数和主题中队列个数相同 。\",\"当然也可以消费者个数小于队列个数，只不过不太建议。如下图。\",\"每个消费组在每个队列上维护一个消费位置 ，为什么呢？\",\"因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 消费位移(offset) ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。\",\"可能你还有一个问题，为什么一个主题中需要维护多个队列 ？\",\"答案是 提高并发能力 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 发布订阅模式 。如下图。\",\"但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 Consumer 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。\",\"所以总结来说，RocketMQ 通过使用在一个 Topic 中配置多个队列并且每个队列维护每个消费者组的消费位置 实现了 主题模式/发布订阅模式 。\"]},\"1281\":{\"h\":\"RocketMQ 的架构图\",\"t\":[\"讲完了消息模型，我们理解起 RocketMQ 的技术架构起来就容易多了。\",\"RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer、Consumer 。我来向大家分别解释一下这四个角色是干啥的。\",\"Broker：主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 Broker ，消费者从 Broker 拉取消息并消费。\",\"这里，我还得普及一下关于 Broker、Topic 和 队列的关系。上面我讲解了 Topic 和队列的关系——一个 Topic 中存在多个队列，那么这个 Topic 和队列存放在哪呢？\",\"一个 Topic 分布在多个 Broker上，一个 Broker 可以配置多个 Topic ，它们是多对多的关系。\",\"如果某个 Topic 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 尽量多分布在不同 Broker 上，以减轻某个 Broker 的压力 。\",\"Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。\",\"所以说我们需要配置多个 Broker。\",\"NameServer：不知道你们有没有接触过 ZooKeeper 和 Spring Cloud 中的 Eureka ，它其实也是一个 注册中心 ，主要提供两个功能：Broker 管理 和 路由信息管理 。说白了就是 Broker 会将自己的信息注册到 NameServer 中，此时 NameServer 就存放了很多 Broker 的信息(Broker 的路由表)，消费者和生产者就从 NameServer 中获取路由表然后照着路由表的信息和对应的 Broker 进行通信(生产者和消费者定期会向 NameServer 去查询相关的 Broker 的信息)。\",\"Producer：消息发布的角色，支持分布式集群方式部署。说白了就是生产者。\",\"Consumer：消息消费的角色，支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。\",\"听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？\",\"嗯？你可能会发现一个问题，这老家伙 NameServer 干啥用的，这不多余吗？直接 Producer、Consumer 和 Broker 直接进行生产消息，消费消息不就好了么？\",\"但是，我们上文提到过 Broker 是需要保证高可用的，如果整个系统仅仅靠着一个 Broker 来维持的话，那么这个 Broker 的压力会不会很大？所以我们需要使用多个 Broker 来保证 负载均衡 。\",\"如果说，我们的消费者和生产者直接和多个 Broker 相连，那么当 Broker 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 NameServer 注册中心就是用来解决这个问题的。\",\"如果还不是很理解的话，可以去看我介绍 Spring Cloud 的那篇文章，其中介绍了 Eureka 注册中心。\",\"当然，RocketMQ 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。\",\"其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来 🤨。\",\"第一、我们的 Broker做了集群并且还进行了主从部署 ，由于消息分布在各个 Broker 上，一旦某个 Broker 宕机，则该Broker 上的消息读写都会受到影响。所以 Rocketmq 提供了 master/slave 的结构，salve 定时从 master 同步数据(同步刷盘或者异步刷盘)，如果 master 宕机，则 slave 提供消费服务，但是不能写入消息 (后面我还会提到哦)。\",\"第二、为了保证 HA ，我们的 NameServer 也做了集群部署，但是请注意它是 去中心化 的。也就意味着它没有主节点，你可以很明显地看出 NameServer 的所有节点是没有进行 Info Replicate 的，在 RocketMQ 中是通过 单个 Broker 和所有 NameServer 保持长连接 ，并且在每隔 30 秒 Broker 会向所有 Nameserver 发送心跳，心跳包含了自身的 Topic 配置信息，这个步骤就对应这上面的 Routing Info 。\",\"第三、在生产者需要向 Broker 发送消息的时候，需要先从 NameServer 获取关于 Broker 的路由信息，然后通过 轮询 的方法去向每个队列中生产数据以达到 负载均衡 的效果。\",\"第四、消费者通过 NameServer 获取所有 Broker 的路由信息后，向 Broker 发送 Pull 请求来获取消息数据。Consumer 可以以两种模式启动—— 广播（Broadcast）和集群（Cluster）。广播模式下，一条消息会发送给 同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。\"]},\"1282\":{\"h\":\"RocketMQ 功能特性\"},\"1283\":{\"h\":\"消息\"},\"1284\":{\"h\":\"普通消息\",\"t\":[\"普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。以在线的电商交易场景为例，上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至 RocketMQ 服务端，下游按需从服务端订阅消息并按照本地消费逻辑处理下游任务。每个消息之间都是相互独立的，且不需要产生关联。另外还有日志系统，以离线的日志收集场景为例，通过埋点组件收集前端应用的相关操作日志，并转发到 RocketMQ 。\",\"普通消息生命周期\",\"初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。\",\"待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。\",\"消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。\",\"消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。\",\"消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。\"]},\"1285\":{\"h\":\"定时消息\",\"t\":[\"在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 RocketMQ 的定时消息可以简化定时调度任务的开发逻辑，实现高性能、可扩展、高可靠的定时触发能力。定时消息仅支持在 MessageType 为 Delay 的主题内使用，即定时消息只能发送至类型为定时消息的主题中，发送的消息的类型必须和主题的类型一致。\",\"基于定时消息的超时任务处理具备如下优势：\",\"精度高、开发门槛低：基于消息通知方式不存在定时阶梯间隔。可以轻松实现任意精度事件触发，无需业务去重。\",\"高性能可扩展：传统的数据库扫描方式较为复杂，需要频繁调用接口扫描，容易产生性能瓶颈。RocketMQ 的定时消息具有高并发和水平扩展的能力。\",\"定时消息生命周期\",\"初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。\",\"定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达。\",\"待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。\",\"消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。\",\"消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。\",\"消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。\",\"定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。\"]},\"1286\":{\"h\":\"顺序消息\",\"t\":[\"顺序消息仅支持使用 MessageType 为 FIFO 的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。和普通消息发送相比，顺序消息发送必须要设置消息组。（推荐实现 MessageQueueSelector 的方式，见下文）。要保证消息的顺序性需要单一生产者串行发送。\",\"单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。\"]},\"1287\":{\"h\":\"事务消息\",\"t\":[\"施工中。。。\"]},\"1288\":{\"h\":\"关于发送消息\"},\"1289\":{\"h\":\"不建议单一进程创建大量生产者\",\"t\":[\"Apache RocketMQ 的生产者和主题是多对多的关系，支持同一个生产者向多个主题发送消息。对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则，如果有需要发送消息到多个主题的场景，无需为每个主题都创建一个生产者。\"]},\"1290\":{\"h\":\"不建议频繁创建和销毁生产者\",\"t\":[\"Apache RocketMQ 的生产者是可以重复利用的底层资源，类似数据库的连接池。因此不需要在每次发送消息时动态创建生产者，且在发送结束后销毁生产者。这样频繁的创建销毁会在服务端产生大量短连接请求，严重影响系统性能。\",\"正确示例：\",\"Producer p = ProducerBuilder.build(); for (int i =0;i<n;i++){ Message m= MessageBuilder.build(); p.send(m); } p.shutdown(); \"]},\"1291\":{\"h\":\"消费者分类\"},\"1292\":{\"h\":\"PushConsumer\",\"t\":[\"高度封装的消费者类型，消费消息仅仅通过消费监听器监听并返回结果。消息的获取、消费状态提交以及消费重试都通过 RocketMQ 的客户端 SDK 完成。\",\"PushConsumer 的消费监听器执行结果分为以下三种情况：\",\"返回消费成功：以 Java SDK 为例，返回ConsumeResult.SUCCESS，表示该消息处理成功，服务端按照消费结果更新消费进度。\",\"返回消费失败：以 Java SDK 为例，返回ConsumeResult.FAILURE，表示该消息处理失败，需要根据消费重试逻辑判断是否进行重试消费。\",\"出现非预期失败：例如抛异常等行为，该结果按照消费失败处理，需要根据消费重试逻辑判断是否进行重试消费。\",\"具体实现可以参见这篇文章RocketMQ 对 pull 和 push 的实现。\",\"使用 PushConsumer 消费者消费时，不允许使用以下方式处理消息，否则 RocketMQ 无法保证消息的可靠性。\",\"错误方式一：消息还未处理完成，就提前返回消费成功结果。此时如果消息消费失败，RocketMQ 服务端是无法感知的，因此不会进行消费重试。\",\"错误方式二：在消费监听器内将消息再次分发到自定义的其他线程，消费监听器提前返回消费结果。此时如果消息消费失败，RocketMQ 服务端同样无法感知，因此也不会进行消费重试。\",\"PushConsumer 严格限制了消息同步处理及每条消息的处理超时时间，适用于以下场景： \",\"消息处理时间可预估：如果不确定消息处理耗时，经常有预期之外的长时间耗时的消息，PushConsumer 的可靠性保证会频繁触发消息重试机制造成大量重复消息。\",\"无异步化、高级定制场景：PushConsumer 限制了消费逻辑的线程模型，由客户端 SDK 内部按最大吞吐量触发消息处理。该模型开发逻辑简单，但是不允许使用异步化和自定义处理流程。\"]},\"1293\":{\"h\":\"SimpleConsumer\",\"t\":[\"SimpleConsumer 是一种接口原子型的消费者类型，消息的获取、消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成。\",\"一个来自官网的例子：\",\"// 消费示例：使用 SimpleConsumer 消费普通消息，主动获取消息处理并提交。 ClientServiceProvider provider = ClientServiceProvider.loadService(); String topic = \\\"YourTopic\\\"; FilterExpression filterExpression = new FilterExpression(\\\"YourFilterTag\\\", FilterExpressionType.TAG); SimpleConsumer simpleConsumer = provider.newSimpleConsumerBuilder() // 设置消费者分组。 .setConsumerGroup(\\\"YourConsumerGroup\\\") // 设置接入点。 .setClientConfiguration(ClientConfiguration.newBuilder().setEndpoints(\\\"YourEndpoint\\\").build()) // 设置预绑定的订阅关系。 .setSubscriptionExpressions(Collections.singletonMap(topic, filterExpression)) // 设置从服务端接受消息的最大等待时间 .setAwaitDuration(Duration.ofSeconds(1)) .build(); try { // SimpleConsumer 需要主动获取消息，并处理。 List<MessageView> messageViewList = simpleConsumer.receive(10, Duration.ofSeconds(30)); messageViewList.forEach(messageView -> { System.out.println(messageView); // 消费处理完成后，需要主动调用 ACK 提交消费结果。 try { simpleConsumer.ack(messageView); } catch (ClientException e) { logger.error(\\\"Failed to ack message, messageId={}\\\", messageView.getMessageId(), e); } }); } catch (ClientException e) { // 如果遇到系统流控等原因造成拉取失败，需要重新发起获取消息请求。 logger.error(\\\"Failed to receive message\\\", e); } \",\"SimpleConsumer 适用于以下场景：\",\"消息处理时长不可控：如果消息处理时长无法预估，经常有长时间耗时的消息处理情况。建议使用 SimpleConsumer 消费类型，可以在消费时自定义消息的预估处理时长，若实际业务中预估的消息处理时长不符合预期，也可以通过接口提前修改。\",\"需要异步化、批量消费等高级定制场景：SimpleConsumer 在 SDK 内部没有复杂的线程封装，完全由业务逻辑自由定制，可以实现异步分发、批量消费等高级定制场景。\",\"需要自定义消费速率：SimpleConsumer 是由业务逻辑主动调用接口获取消息，因此可以自由调整获取消息的频率，自定义控制消费速率。\"]},\"1294\":{\"h\":\"PullConsumer\",\"t\":[\"施工中。。。\"]},\"1295\":{\"h\":\"消费者分组和生产者分组\"},\"1296\":{\"h\":\"生产者分组\",\"t\":[\"RocketMQ 服务端 5.x 版本开始，生产者是匿名的，无需管理生产者分组（ProducerGroup）；对于历史版本服务端 3.x 和 4.x 版本，已经使用的生产者分组可以废弃无需再设置，且不会对当前业务产生影响。\"]},\"1297\":{\"h\":\"消费者分组\",\"t\":[\"消费者分组是多个消费行为一致的消费者的负载均衡分组。消费者分组不是具体实体而是一个逻辑资源。通过消费者分组实现消费性能的水平扩展以及高可用容灾。\",\"消费者分组中的订阅关系、投递顺序性、消费重试策略是一致的。\",\"订阅关系：Apache RocketMQ 以消费者分组的粒度管理订阅关系，实现订阅关系的管理和追溯。\",\"投递顺序性：Apache RocketMQ 的服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。\",\"消费重试策略： 消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。\",\"RocketMQ 服务端 5.x 版本：上述消费者的消费行为从关联的消费者分组中统一获取，因此，同一分组内所有消费者的消费行为必然是一致的，客户端无需关注。\",\"RocketMQ 服务端 3.x/4.x 历史版本：上述消费逻辑由消费者客户端接口定义，因此，您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致。[来自官方网站]\"]},\"1298\":{\"h\":\"如何解决顺序消费和重复消费？\",\"t\":[\"其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 RocketMQ ，而是应该每个消息中间件都需要去解决的。\",\"在上面我介绍 RocketMQ 的技术架构的时候我已经向你展示了 它是如何保证高可用的 ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 RocketMQ 集群。\",\"其实 Kafka 的架构基本和 RocketMQ 类似，只是它注册中心使用了 Zookeeper、它的 分区 就相当于 RocketMQ 中的 队列 。还有一些小细节不同会在后面提到。\"]},\"1299\":{\"h\":\"顺序消费\",\"t\":[\"在上面的技术架构介绍中，我们已经知道了 RocketMQ 在主题上是无序的、它只有在队列层面才是保证有序 的。\",\"这又扯到两个概念——普通顺序 和 严格顺序 。\",\"所谓普通顺序是指 消费者通过 同一个消费队列收到的消息是有顺序的 ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 Broker重启情况下不会保证消息顺序性 (短暂时间) 。\",\"所谓严格顺序是指 消费者收到的 所有消息 均是有顺序的。严格顺序消息 即使在异常情况下也会保证消息的顺序性 。\",\"但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，Broker 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 binlog 同步。\",\"一般而言，我们的 MQ 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。\",\"那么，我们现在使用了 普通顺序模式 ，我们从上面学习知道了在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。\",\"那么，怎么解决呢？\",\"其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 Hash 取模法 来保证同一个订单在同一个队列中就行了。\",\"RocketMQ 实现了两种队列选择算法，也可以自己实现\",\"轮询算法\",\"轮询算法就是向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布\",\"是 RocketMQ 默认队列选择算法\",\"最小投递延迟算法\",\"每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可。\",\"producer.setSendLatencyFaultEnable(true); \",\"继承 MessageQueueSelector 实现\",\"SendResult sendResult = producer.send(msg, new MessageQueueSelector() { @Override public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) { //从mqs中选择一个队列,可以根据msg特点选择 return null; } }, new Object()); \"]},\"1300\":{\"h\":\"特殊情况处理\"},\"1301\":{\"h\":\"发送异常\",\"t\":[\"选择队列后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时此时 RocketMQ 会进行重试。\",\"重新选择其他 Broker 中的消息队列进行发送，默认重试两次，可以手动设置。\",\"producer.setRetryTimesWhenSendFailed(5); \"]},\"1302\":{\"h\":\"消息过大\",\"t\":[\"消息超过 4k 时 RocketMQ 会将消息压缩后在发送到 Broker 上，减少网络资源的占用。\"]},\"1303\":{\"h\":\"重复消费\",\"t\":[\"emmm，就两个字—— 幂等 。在编程中一个幂等 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如 Broker 意外重启等等)，这条回应没有发送成功。\",\"那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？\",\"所以我们需要给我们的消费者实现 幂等 ，也就是对同一个消息的处理结果，执行多少次都不变。\",\"那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 写入 Redis 来保证，因为 Redis 的 key 和 value 就是天然支持幂等的。当然还有使用 数据库插入法 ，基于数据库的唯一键来保证重复数据不会被插入多条。\",\"不过最主要的还是需要 根据特定场景使用特定的解决方案 ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。\",\"而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，在其他场景中来解决重复请求或者重复调用的问题 。比如将 HTTP 服务设计成幂等的，解决前端或者 APP 重复提交表单数据的问题 ，也可以将一个微服务设计成幂等的，解决 RPC 框架自动重试导致的 重复调用问题 。\"]},\"1304\":{\"h\":\"RocketMQ 如何实现分布式事务？\",\"t\":[\"如何解释分布式事务呢？事务大家都知道吧？要么都执行要么都不执行 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现 A 系统下了订单，但是 B 系统增加积分失败或者 A 系统没有下订单，B 系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。\",\"那么，如何去解决这个问题呢？\",\"如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，都不是完美的解决方案。\",\"在 RocketMQ 中使用的是 事务消息加上事务反查机制 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。\",\"在第一步发送的 half 消息 ，它的意思是 在事务提交之前，对于消费者来说，这个消息是不可见的 。\",\"那么，如何做到写入消息但是对用户不可见呢？RocketMQ 事务消息的做法是：如果消息是 half 消息，将备份原消息的主题与消息消费队列，然后 改变主题 为 RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费 half 类型的消息，然后 RocketMQ 会开启一个定时任务，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。\",\"你可以试想一下，如果没有从第 5 步开始的 事务反查机制 ，如果出现网路波动第 4 步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 RocketMQ 中就是使用的上述的事务反查来解决的，而在 Kafka 中通常是直接抛出一个异常让用户来自行解决。\",\"你还需要注意的是，在 MQ Server 指向系统 B 的操作已经和系统 A 不相关了，也就是说在消息队列中的分布式事务是——本地事务和存储消息到消息队列才是同一个事务。这样也就产生了事务的最终一致性，因为整个过程是异步的，每个系统只要保证它自己那一部分的事务就行了。\"]},\"1305\":{\"h\":\"如何解决消息堆积问题？\",\"t\":[\"在上面我们提到了消息队列一个很重要的功能——削峰 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？\",\"其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。\",\"我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 限流降级 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 是否是消费者出现了大量的消费错误 ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。\",\"当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 同时你还需要增加每个主题的队列数量 。\",\"别忘了在 RocketMQ 中，一个队列只会被一个消费者消费 ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。\"]},\"1306\":{\"h\":\"什么是回溯消费？\",\"t\":[\"回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，在RocketMQ 中， Broker 在向Consumer 投递成功消息后，消息仍然需要保留 。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。\",\"这是官方文档的解释，我直接照搬过来就当科普了 😁😁😁。\"]},\"1307\":{\"h\":\"RocketMQ 如何保证高性能读写\"},\"1308\":{\"h\":\"传统 IO 方式\",\"t\":[\"3\",\"传统的 IO 读写其实就是 read + write 的操作，整个过程会分为如下几步\",\"用户调用 read()方法，开始读取数据，此时发生一次上下文从用户态到内核态的切换，也就是图示的切换 1\",\"将磁盘数据通过 DMA 拷贝到内核缓存区\",\"将内核缓存区的数据拷贝到用户缓冲区，这样用户，也就是我们写的代码就能拿到文件的数据\",\"read()方法返回，此时就会从内核态切换到用户态，也就是图示的切换 2\",\"当我们拿到数据之后，就可以调用 write()方法，此时上下文会从用户态切换到内核态，即图示切换 3\",\"CPU 将用户缓冲区的数据拷贝到 Socket 缓冲区\",\"将 Socket 缓冲区数据拷贝至网卡\",\"write()方法返回，上下文重新从内核态切换到用户态，即图示切换 4\",\"整个过程发生了 4 次上下文切换和 4 次数据的拷贝，这在高并发场景下肯定会严重影响读写性能故引入了零拷贝技术\"]},\"1309\":{\"h\":\"零拷贝技术\"},\"1310\":{\"h\":\"mmap\",\"t\":[\"mmap（memory map）是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。\",\"简单地说就是内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次 CPU 拷贝。基于此上述架构图可变为：\",\"4\",\"基于 mmap IO 读写其实就变成 mmap + write 的操作，也就是用 mmap 替代传统 IO 中的 read 操作。\",\"当用户发起 mmap 调用的时候会发生上下文切换 1，进行内存映射，然后数据被拷贝到内核缓冲区，mmap 返回，发生上下文切换 2；随后用户调用 write，发生上下文切换 3，将内核缓冲区的数据拷贝到 Socket 缓冲区，write 返回，发生上下文切换 4。\",\"发生 4 次上下文切换和 3 次 IO 拷贝操作，在 Java 中的实现：\",\"FileChannel fileChannel = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\").getChannel(); MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size()); \"]},\"1311\":{\"h\":\"sendfile\",\"t\":[\"sendfile()跟 mmap()一样，也会减少一次 CPU 拷贝，但是它同时也会减少两次上下文切换。\",\"5\",\"如图，用户在发起 sendfile()调用时会发生切换 1，之后数据通过 DMA 拷贝到内核缓冲区，之后再将内核缓冲区的数据 CPU 拷贝到 Socket 缓冲区，最后拷贝到网卡，sendfile()返回，发生切换 2。发生了 3 次拷贝和两次切换。Java 也提供了相应 api：\",\"FileChannel channel = FileChannel.open(Paths.get(\\\"./test.txt\\\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE); //调用transferTo方法向目标数据传输 channel.transferTo(position, len, target); \",\"在如上代码中，并没有文件的读写操作，而是直接将文件的数据传输到 target 目标缓冲区，也就是说，sendfile 是无法知道文件的具体的数据的；但是 mmap 不一样，他是可以修改内核缓冲区的数据的。假设如果需要对文件的内容进行修改之后再传输，只有 mmap 可以满足。\",\"通过上面的一些介绍，结论是基于零拷贝技术，可以减少 CPU 的拷贝次数和上下文切换次数，从而可以实现文件高效的读写操作。\",\"RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。\"]},\"1312\":{\"h\":\"RocketMQ 的刷盘机制\",\"t\":[\"上面我讲了那么多的 RocketMQ 的架构和设计原理，你有没有好奇\",\"在 Topic 中的 队列是以什么样的形式存在的？\",\"队列中的消息又是如何进行存储持久化的呢？\",\"我在上文中提到的 同步刷盘 和 异步刷盘 又是什么呢？它们会给持久化带来什么样的影响呢？\",\"下面我将给你们一一解释。\"]},\"1313\":{\"h\":\"同步刷盘和异步刷盘\",\"t\":[\"如上图所示，在同步刷盘中需要等待一个刷盘成功的 ACK ，同步刷盘对 MQ 消息可靠性来说是一种不错的保障，但是 性能上会有较大影响 ，一般地适用于金融等特定业务场景。\",\"而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， 降低了读写延迟 ，提高了 MQ 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。\",\"一般地，异步刷盘只有在 Broker 意外宕机的时候会丢失部分数据，你可以设置 Broker 的参数 FlushDiskType 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。\"]},\"1314\":{\"h\":\"同步复制和异步复制\",\"t\":[\"上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 Borker 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。\",\"同步复制：也叫 “同步双写”，也就是说，只有消息同步双写到主从节点上时才返回写入成功 。\",\"异步复制：消息写入主节点之后就直接返回写入成功 。\",\"然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。\",\"那么，异步复制会不会也像异步刷盘那样影响消息的可靠性呢？\",\"答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 可用性 。为什么呢？其主要原因是 RocketMQ 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了。\",\"比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，消费者可以自动切换到从节点进行消费(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。\",\"在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？一个主从不行那就多个主从的呗，别忘了在我们最初的架构图中，每个 Topic 是分布在不同 Broker 中的。\",\"但是这种复制方式同样也会带来一个问题，那就是无法保证 严格顺序 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 Topic 下的队列来保证顺序性的。如果此时我们主节点 A 负责的是订单 A 的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点 A 的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。\",\"而在 RocketMQ 中采用了 Dledger 解决这个问题。他要求在写入消息的时候，要求至少消息复制到半数以上的节点之后，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。\",\"也不是说 Dledger 是个完美的方案，至少在 Dledger 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的。\"]},\"1315\":{\"h\":\"存储机制\",\"t\":[\"还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。\",\"但是，在 Topic 中的 队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？ 还未解决，其实这里涉及到了 RocketMQ 是如何设计它的存储结构了。我首先想大家介绍 RocketMQ 消息存储架构中的三大角色——CommitLog、ConsumeQueue 和 IndexFile 。\",\"CommitLog：消息主体以及元数据的存储主体，存储 Producer 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G ，文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G=1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。\",\"ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能(我们再前面也讲了)，由于RocketMQ 是基于主题 Topic 的订阅模式，消息消费是针对主题进行的，如果要遍历 commitlog 文件中根据 Topic 检索消息是非常低效的。Consumer 即可根据 ConsumeQueue 来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset，消息大小 size 和消息 Tag 的 HashCode 值。consumequeue 文件可以看成是基于 topic 的 commitlog 索引文件，故 consumequeue 文件夹的组织方式如下：topic/queue/file 三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 consumequeue 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 commitlog 物理偏移量、4 字节的消息长度、8 字节 tag hashcode，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 ConsumeQueue文件大小约 5.72M；\",\"IndexFile：IndexFile（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。这里只做科普不做详细介绍。\",\"总结来说，整个消息存储的结构，最主要的就是 CommitLoq 和 ConsumeQueue 。而 ConsumeQueue 你可以大概理解为 Topic 中的队列。\",\"RocketMQ 采用的是 混合型的存储结构 ，即为 Broker 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 Kafka 中会为每个 Topic 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，RockeMQ 是不分书的种类直接成批的塞上去的，而 Kafka 是将书本放入指定的分类区域的。\",\"而 RocketMQ 为什么要这么做呢？原因是 提高数据的写入效率 ，不分 Topic 意味着我们有更大的几率获取 成批 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。\",\"所以，在 RocketMQ 中又使用了 ConsumeQueue 作为每个队列的索引文件来 提升读取消息的效率。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度 20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。\",\"讲到这里，你可能对 RockeMQ 的存储架构还有些模糊，没事，我们结合着图来理解一下。\",\"emmm，是不是有一点复杂 🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。\",\"如果上面没看懂的读者一定要认真看下面的流程分析！\",\"首先，在最上面的那一块就是我刚刚讲的你现在可以直接 把 ConsumerQueue 理解为 Queue。\",\"在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 Topic、QueueId 和具体消息内容，而在 Broker 中管你是哪门子消息，他直接 全部顺序存储到了 CommitLog。而根据生产者指定的 Topic 和 QueueId 将这条消息本身在 CommitLog 的偏移(offset)，消息本身大小，和 tag 的 hash 值存入对应的 ConsumeQueue 索引文件中。而在每个队列中都保存了 ConsumeOffset 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 ConsumeOffset 获取下一个未被消费的消息就行了。\",\"上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。\",\"因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考 🤔🤔 一下吧。\",\"为什么 CommitLog 文件要设计成固定大小的长度呢？提醒：内存映射机制。\"]},\"1316\":{\"h\":\"总结\",\"t\":[\"总算把这篇博客写完了。我讲的你们还记得吗 😅？\",\"这篇文章中我主要想大家介绍了\",\"消息队列出现的原因\",\"消息队列的作用(异步，解耦，削峰)\",\"消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)\",\"消息队列的两种消息模型——队列和主题模式\",\"分析了 RocketMQ 的技术架构(NameServer、Broker、Producer、Comsumer)\",\"结合 RocketMQ 回答了消息队列副作用的解决方案\",\"介绍了 RocketMQ 的存储机制和刷盘策略。\",\"等等。。。\",\"File not found\"]},\"1317\":{\"c\":[\"高性能\"]},\"1318\":{\"c\":[\"RocketMQ\",\"消息队列\"]},\"1319\":{\"h\":\"ZooKeeper 实战\",\"t\":[\"这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java 客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。\",\"如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！\"]},\"1320\":{\"h\":\"ZooKeeper 安装\"},\"1321\":{\"h\":\"使用 Docker 安装 zookeeper\",\"t\":[\"a.使用 Docker 下载 ZooKeeper\",\"docker pull zookeeper:3.5.8 \",\"b.运行 ZooKeeper\",\"docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8 \"]},\"1322\":{\"h\":\"连接 ZooKeeper 服务\",\"t\":[\"a.进入 ZooKeeper 容器中\",\"先使用 docker ps 查看 ZooKeeper 的 ContainerID，然后使用 docker exec -it ContainerID /bin/bash 命令进入容器中。\",\"b.先进入 bin 目录,然后通过 ./zkCli.sh -server 127.0.0.1:2181命令连接 ZooKeeper 服务\",\"root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin \",\"如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。\",\"连接 ZooKeeper 服务\"]},\"1323\":{\"h\":\"ZooKeeper 常用命令演示\"},\"1324\":{\"h\":\"查看常用命令(help 命令)\",\"t\":[\"通过 help 命令查看 ZooKeeper 常用命令\"]},\"1325\":{\"h\":\"创建节点(create 命令)\",\"t\":[\"通过 create 命令在根目录创建了 node1 节点，与它关联的字符串是\\\"node1\\\"\",\"[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1” \",\"通过 create 命令在根目录创建了 node1 节点，与它关联的内容是数字 123\",\"[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123 Created /node1/node1.1 \"]},\"1326\":{\"h\":\"更新节点数据内容(set 命令)\",\"t\":[\"[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 \\\"set node1\\\" \"]},\"1327\":{\"h\":\"获取节点的数据(get 命令)\",\"t\":[\"get 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 set 命令已经将节点数据内容改为 \\\"set node1\\\"。\",\"[zk: zookeeper(CONNECTED) 12] get -s /node1 set node1 cZxid = 0x47 ctime = Sun Jan 20 10:22:59 CST 2019 mZxid = 0x4b mtime = Sun Jan 20 10:41:10 CST 2019 pZxid = 0x4a cversion = 1 dataVersion = 1 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 9 numChildren = 1 \"]},\"1328\":{\"h\":\"查看某个目录下的子节点(ls 命令)\",\"t\":[\"通过 ls 命令查看根目录下的节点\",\"[zk: 127.0.0.1:2181(CONNECTED) 37] ls / [dubbo, ZooKeeper, node1] \",\"通过 ls 命令查看 node1 目录下的节点\",\"[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1 [node1.1] \",\"ZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）\"]},\"1329\":{\"h\":\"查看节点状态(stat 命令)\",\"t\":[\"通过 stat 命令查看节点状态\",\"[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1 cZxid = 0x47 ctime = Sun Jan 20 10:22:59 CST 2019 mZxid = 0x47 mtime = Sun Jan 20 10:22:59 CST 2019 pZxid = 0x4a cversion = 1 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 11 numChildren = 1 \",\"上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “ZooKeeper 相关概念总结(入门)” 这篇文章中已经介绍到。\"]},\"1330\":{\"h\":\"查看节点信息和状态(ls2 命令)\",\"t\":[\"ls2 命令更像是 ls 命令和 stat 命令的结合。 ls2 命令返回的信息包括 2 部分：\",\"子节点列表\",\"当前节点的 stat 信息。\",\"[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1 [node1.1] cZxid = 0x47 ctime = Sun Jan 20 10:22:59 CST 2019 mZxid = 0x47 mtime = Sun Jan 20 10:22:59 CST 2019 pZxid = 0x4a cversion = 1 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 11 numChildren = 1 \"]},\"1331\":{\"h\":\"删除节点(delete 命令)\",\"t\":[\"这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。\",\"[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1 \",\"在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。\"]},\"1332\":{\"h\":\"ZooKeeper Java 客户端 Curator 简单使用\",\"t\":[\"Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。\",\"下面我们就来简单地演示一下 Curator 的使用吧！\",\"Curator4.0+版本对 ZooKeeper 3.5.x 支持比较好。开始之前，请先将下面的依赖添加进你的项目。\",\"<dependency> <groupId>org.apache.curator</groupId> <artifactId>curator-framework</artifactId> <version>4.2.0</version> </dependency> <dependency> <groupId>org.apache.curator</groupId> <artifactId>curator-recipes</artifactId> <version>4.2.0</version> </dependency> \"]},\"1333\":{\"h\":\"连接 ZooKeeper 客户端\",\"t\":[\"通过 CuratorFrameworkFactory 创建 CuratorFramework 对象，然后再调用 CuratorFramework 对象的 start() 方法即可！\",\"private static final int BASE_SLEEP_TIME = 1000; private static final int MAX_RETRIES = 3; // Retry strategy. Retry 3 times, and will increase the sleep time between retries. RetryPolicy retryPolicy = new ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRIES); CuratorFramework zkClient = CuratorFrameworkFactory.builder() // the server to connect to (can be a server list) .connectString(\\\"127.0.0.1:2181\\\") .retryPolicy(retryPolicy) .build(); zkClient.start(); \",\"对于一些基本参数的说明：\",\"baseSleepTimeMs：重试之间等待的初始时间\",\"maxRetries：最大重试次数\",\"connectString：要连接的服务器列表\",\"retryPolicy：重试策略\"]},\"1334\":{\"h\":\"数据节点的增删改查\"},\"1335\":{\"h\":\"创建节点\",\"t\":[\"我们在 ZooKeeper 常见概念解读 中介绍到，我们通常是将 znode 分为 4 大类：\",\"持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\",\"临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点 只能做叶子节点 ，不能创建子节点。\",\"持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\",\"临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。\",\"你在使用的 ZooKeeper 的时候，会发现 CreateMode 类中实际有 7 种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。\",\"a.创建持久化节点\",\"你可以通过下面两种方式创建持久化的节点。\",\"//注意:下面的代码会报错，下文说了具体原因 zkClient.create().forPath(\\\"/node1/00001\\\"); zkClient.create().withMode(CreateMode.PERSISTENT).forPath(\\\"/node1/00002\\\"); \",\"但是，你运行上面的代码会报错，这是因为的父节点node1还未创建。\",\"你可以先创建父节点 node1 ，然后再执行上面的代码就不会报错了。\",\"zkClient.create().forPath(\\\"/node1\\\"); \",\"更推荐的方式是通过下面这行代码， creatingParentsIfNeeded() 可以保证父节点不存在的时候自动创建父节点，这是非常有用的。\",\"zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(\\\"/node1/00001\\\"); \",\"b.创建临时节点\",\"zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(\\\"/node1/00001\\\"); \",\"c.创建节点并指定数据内容\",\"zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(\\\"/node1/00001\\\",\\\"java\\\".getBytes()); zkClient.getData().forPath(\\\"/node1/00001\\\");//获取节点的数据内容，获取到的是 byte数组 \",\"d.检测节点是否创建成功\",\"zkClient.checkExists().forPath(\\\"/node1/00001\\\");//不为null的话，说明节点创建成功 \"]},\"1336\":{\"h\":\"删除节点\",\"t\":[\"a.删除一个子节点\",\"zkClient.delete().forPath(\\\"/node1/00001\\\"); \",\"b.删除一个节点以及其下的所有子节点\",\"zkClient.delete().deletingChildrenIfNeeded().forPath(\\\"/node1\\\"); \"]},\"1337\":{\"h\":\"获取/更新节点数据内容\",\"t\":[\"zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(\\\"/node1/00001\\\",\\\"java\\\".getBytes()); zkClient.getData().forPath(\\\"/node1/00001\\\");//获取节点的数据内容 zkClient.setData().forPath(\\\"/node1/00001\\\",\\\"c++\\\".getBytes());//更新节点数据内容 \"]},\"1338\":{\"h\":\"获取某个节点的所有子节点路径\",\"t\":[\"List<String> childrenPaths = zkClient.getChildren().forPath(\\\"/node1\\\"); \",\"File not found\"]},\"1339\":{\"c\":[\"分布式\"]},\"1340\":{\"c\":[\"ZooKeeper\"]},\"1341\":{\"h\":\"ZooKeeper相关概念总结(入门)\",\"t\":[\"相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？\",\"拿我自己来说吧！我本人在大学曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。\",\"前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：\",\"ZooKeeper 可以被用作注册中心、分布式锁；\",\"ZooKeeper 是 Hadoop 生态系统的一员；\",\"构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。\",\"由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。\",\"所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。\",\"另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。\",\"如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！\"]},\"1342\":{\"h\":\"ZooKeeper 介绍\"},\"1343\":{\"h\":\"ZooKeeper 由来\",\"t\":[\"正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。\",\"下面这段内容摘自《从 Paxos 到 ZooKeeper》第四章第一节，推荐大家阅读一下：\",\"ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。\",\"关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调一一于是，ZooKeeper 的名字也就由此诞生了。\"]},\"1344\":{\"h\":\"ZooKeeper 概览\",\"t\":[\"ZooKeeper 是一个开源的分布式协调服务，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。\",\"原语： 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。\",\"ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。这些功能的实现主要依赖于 ZooKeeper 提供的 数据存储+事件监听 功能（后文会详细介绍到） 。\",\"ZooKeeper 将数据保存在内存中，性能是不错的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。\",\"另外，很多顶级的开源项目都用到了 ZooKeeper，比如：\",\"Kafka : ZooKeeper 主要为 Kafka 提供 Broker 和 Topic 的注册以及多个 Partition 的负载均衡等功能。不过，在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构。\",\"Hbase : ZooKeeper 为 Hbase 提供确保整个集群只有一个 Master 以及保存和提供 regionserver 状态信息（是否在线）等功能。\",\"Hadoop : ZooKeeper 为 Namenode 提供高可用支持。\"]},\"1345\":{\"h\":\"ZooKeeper 特点\",\"t\":[\"顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\",\"原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\",\"单一系统映像： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\",\"可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\"]},\"1346\":{\"h\":\"ZooKeeper 应用场景\",\"t\":[\"ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。\",\"下面选 3 个典型的应用场景来专门说说：\",\"命名服务：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID。\",\"数据发布/订阅：通过 Watcher 机制 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。\",\"分布式锁：通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。分布式锁的实现也需要用到 Watcher 机制 ，我在 分布式锁详解 这篇文章中有详细介绍到如何基于 ZooKeeper 实现分布式锁。\",\"实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。\"]},\"1347\":{\"h\":\"ZooKeeper 重要概念\",\"t\":[\"破音：拿出小本本，下面的内容非常重要哦！\"]},\"1348\":{\"h\":\"Data model（数据模型）\",\"t\":[\"ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。\",\"强调一句：ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。\",\"从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠\\\"/\\\"进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。\",\"ZooKeeper 数据模型\"]},\"1349\":{\"h\":\"znode（数据节点）\",\"t\":[\"介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 znode，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。\",\"我们通常是将 znode 分为 4 大类：\",\"持久（PERSISTENT）节点：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。\",\"临时（EPHEMERAL）节点：临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失 。并且，临时节点只能做叶子节点 ，不能创建子节点。\",\"持久顺序（PERSISTENT_SEQUENTIAL）节点：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 /node1/app0000000001、/node1/app0000000002 。\",\"临时顺序（EPHEMERAL_SEQUENTIAL）节点：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性\",\"每个 znode 由 2 部分组成:\",\"stat：状态信息\",\"data：节点存放的数据的具体内容\",\"如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。\",\"[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo # 该数据节点关联的数据内容为空 null # 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出 cZxid = 0x2 ctime = Tue Nov 27 11:05:34 CST 2018 mZxid = 0x2 mtime = Tue Nov 27 11:05:34 CST 2018 pZxid = 0x3 cversion = 1 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 0 numChildren = 1 \",\"Stat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID（cZxid）、节点创建时间（ctime） 和子节点个数（numChildren） 等等。\",\"下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！（下面的内容来源于《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》，因为 Guide 确实也不是特别清楚，要学会参考资料的嘛！ ）：\",\"znode 状态信息\",\"解释\",\"cZxid\",\"create ZXID，即该数据节点被创建时的事务 id\",\"ctime\",\"create time，即该节点的创建时间\",\"mZxid\",\"modified ZXID，即该节点最终一次更新时的事务 id\",\"mtime\",\"modified time，即该节点最后一次的更新时间\",\"pZxid\",\"该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新\",\"cversion\",\"子节点版本号，当前节点的子节点每次变化时值增加 1\",\"dataVersion\",\"数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1\",\"aclVersion\",\"节点的 ACL 版本号，表示该节点 ACL 信息变更次数\",\"ephemeralOwner\",\"创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0\",\"dataLength\",\"数据节点内容长度\",\"numChildren\",\"当前节点的子节点个数\"]},\"1350\":{\"h\":\"版本（version）\",\"t\":[\"在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：\",\"dataVersion：当前 znode 节点的版本号\",\"cversion：当前 znode 子节点的版本\",\"aclVersion：当前 znode 的 ACL 的版本。\"]},\"1351\":{\"h\":\"ACL（权限控制）\",\"t\":[\"ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。\",\"对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：\",\"CREATE : 能创建子节点\",\"READ：能获取节点数据和列出其子节点\",\"WRITE : 能设置/更新节点数据\",\"DELETE : 能删除子节点\",\"ADMIN : 能设置节点 ACL 的权限\",\"其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对 子节点 的权限控制。\",\"对于身份认证，提供了以下几种方式：\",\"world：默认方式，所有用户都可无条件访问。\",\"auth :不使用任何 id，代表任何已认证的用户。\",\"digest :用户名:密码认证方式：username:password 。\",\"ip : 对指定 ip 进行限制。\"]},\"1352\":{\"h\":\"Watcher（事件监听器）\",\"t\":[\"Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\",\"ZooKeeper Watcher 机制\",\"破音：非常有用的一个特性，都拿出小本本记好了，后面用到 ZooKeeper 基本离不开 Watcher（事件监听器）机制。\"]},\"1353\":{\"h\":\"会话（Session）\",\"t\":[\"Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。\",\"Session 有一个属性叫做：sessionTimeout ，sessionTimeout 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\",\"另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。\"]},\"1354\":{\"h\":\"ZooKeeper 集群\",\"t\":[\"为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。\",\"ZooKeeper 集群架构\",\"上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。\",\"最典型集群模式：Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。\"]},\"1355\":{\"h\":\"ZooKeeper 集群角色\",\"t\":[\"但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示\",\"ZooKeeper 集群中角色\",\"ZooKeeper 集群中的所有机器通过一个 Leader 选举过程 来选定一台称为 “Leader” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和 Observer 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。\",\"角色\",\"说明\",\"Leader\",\"为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。\",\"Follower\",\"为客户端提供读服务，如果是写服务则转发给 Leader。参与选举过程中的投票。\",\"Observer\",\"为客户端提供读服务，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。\"]},\"1356\":{\"h\":\"ZooKeeper 集群 Leader 选举过程\",\"t\":[\"当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。\",\"这个过程大致是这样的：\",\"Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。\",\"Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。\",\"Synchronization（同步阶段） :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后准 leader 才会成为真正的 leader。\",\"Broadcast（广播阶段） :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。\",\"ZooKeeper 集群中的服务器状态有下面几种：\",\"LOOKING：寻找 Leader。\",\"LEADING：Leader 状态，对应的节点为 Leader。\",\"FOLLOWING：Follower 状态，对应的节点为 Follower。\",\"OBSERVING：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。\"]},\"1357\":{\"h\":\"ZooKeeper 集群为啥最好奇数台？\",\"t\":[\"ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。\",\"比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。 假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。\",\"综上，何必增加那一个不必要的 ZooKeeper 呢？\"]},\"1358\":{\"h\":\"ZooKeeper 选举的过半机制防止脑裂\",\"t\":[\"何为集群脑裂？\",\"对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。\",\"举例说明：比如现在有一个由 6 台服务器所组成的一个集群，部署在了 2 个机房，每个机房 3 台。正常情况下只有 1 个 leader，但是当两个机房中间网络断开的时候，每个机房的 3 台服务器都会认为另一个机房的 3 台服务器下线，而选出自己的 leader 并对外提供服务。若没有过半机制，当网络恢复的时候会发现有 2 个 leader。仿佛是 1 个大脑（leader）分散成了 2 个大脑，这就发生了脑裂现象。脑裂期间 2 个大脑都可能对外提供了服务，这将会带来数据一致性等问题。\",\"过半机制是如何防止脑裂现象产生的？\",\"ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。\"]},\"1359\":{\"h\":\"ZAB 协议和 Paxos 算法\",\"t\":[\"Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 Zookeeper 设计的崩溃可恢复的原子消息广播算法。\"]},\"1360\":{\"h\":\"ZAB 协议介绍\",\"t\":[\"ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\"]},\"1361\":{\"h\":\"ZAB 协议两种基本的模式：崩溃恢复和消息广播\",\"t\":[\"ZAB 协议包括两种基本的模式，分别是\",\"崩溃恢复：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。\",\"消息广播：当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。 当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\",\"关于 ZAB 协议&Paxos 算法 需要讲和理解的东西太多了，具体可以看下面这几篇文章：\",\"Paxos 算法详解\",\"Zookeeper ZAB 协议分析\",\"Raft 算法详解\"]},\"1362\":{\"h\":\"总结\",\"t\":[\"ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。\",\"为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\",\"ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。\",\"ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\",\"ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。\",\"ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。\"]},\"1363\":{\"h\":\"参考\",\"t\":[\"《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》\",\"File not found\"]},\"1364\":{\"c\":[\"分布式\"]},\"1365\":{\"c\":[\"ZooKeeper\"]},\"1366\":{\"h\":\"ZooKeeper相关概念总结(进阶)\",\"t\":[\"FrancisQ 投稿。\"]},\"1367\":{\"h\":\"什么是 ZooKeeper\",\"t\":[\"ZooKeeper 由 Yahoo 开发，后来捐赠给了 Apache ，现已成为 Apache 顶级项目。ZooKeeper 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 Paxos 算法的 ZAB 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。\",\"简单来说， ZooKeeper 是一个 分布式协调服务框架 。分布式？协调服务？这啥玩意？🤔🤔\",\"其实解释到分布式这个概念的时候，我发现有些同学并不是能把 分布式和集群 这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— Cluster ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。\",\"比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 一样 提供秒杀服务，这个时候就是 Cluster 集群 。\",\"cluster\",\"但是，我现在换一种方式，我将一个秒杀服务 拆分成多个子服务 ，比如创建订单服务，增加积分服务，扣优惠券服务等等，然后我将这些子服务都部署在不同的服务器上 ，这个时候就是 Distributed 分布式 。\",\"distributed\",\"而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。\",\"比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。ZooKeeper 主要就是解决这些问题的。\"]},\"1368\":{\"h\":\"一致性问题\",\"t\":[\"设计一个分布式系统必定会遇到一个问题—— 因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡 。这就是著名的 CAP 定理。\",\"理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。\",\"而上述前者就是 Eureka 的处理方式，它保证了 AP（可用性），后者就是我们今天所要讲的 ZooKeeper 的处理方式，它保证了 CP（数据一致性）。\"]},\"1369\":{\"h\":\"一致性协议和算法\",\"t\":[\"而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos 算法等等。\",\"这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？\",\"这个时候就引申出一个概念—— 拜占庭将军问题 。它意指 在不可靠信道上试图通过消息传递的方式达到一致性是不可能的， 所以所有的一致性算法的 必要前提 就是安全可靠的消息通道。\",\"而为什么要去解决数据一致性的问题？你想想，如果一个秒杀系统将服务拆分成了下订单和加积分服务，这两个服务部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？\"]},\"1370\":{\"h\":\"2PC（两阶段提交）\",\"t\":[\"两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 分布式事务 的处理。\",\"在介绍 2PC 之前，我们先来想想分布式事务到底有什么问题呢？\",\"还拿秒杀系统的下订单和加积分两个系统来举例吧（我想你们可能都吐了 🤮🤮🤮），我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了。如果我们仅仅是发送一个消息也不收回复，那么我们的订单系统怎么能知道积分系统的收到消息的情况呢？如果我们增加一个收回复的过程，那么当积分系统收到消息后返回给订单系统一个 Response ，但在中间出现了网络波动，那个回复消息没有发送成功，订单系统是不是以为积分系统消息接收失败了？它是不是会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。\",\"所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 原子性问题 。\",\"在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。\",\"第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 prepare 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 prepare 消息后，他们会开始执行事务（但不提交），并将 Undo 和 Redo 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。\",\"第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。\",\"比如这个时候 所有的参与者 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 Commit 请求 ，当参与者收到 Commit 请求的时候会执行前面执行的事务的 提交操作 ，提交完毕之后将给协调者发送提交成功的响应。\",\"而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 回滚事务的 rollback 请求，参与者收到之后将会 回滚它在第一阶段所做的事务处理 ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。\",\"2PC流程\",\"个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题。\",\"单点故障问题，如果协调者挂了那么整个系统都处于不可用的状态了。\",\"阻塞问题，即当协调者发送 prepare 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。\",\"数据不一致问题，比如当第二阶段，协调者只发送了一部分的 commit 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。\"]},\"1371\":{\"h\":\"3PC（三阶段提交）\",\"t\":[\"因为 2PC 存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 3PC（三阶段提交） 。那么这三阶段又分别是什么呢？\",\"千万不要吧 PC 理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。\",\"CanCommit 阶段：协调者向所有参与者发送 CanCommit 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。\",\"PreCommit 阶段：协调者根据参与者返回的响应来决定是否可以进行下面的 PreCommit 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 PreCommit 预提交请求，参与者收到预提交请求后，会进行事务的执行操作，并将 Undo 和 Redo 信息写入事务日志中 ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 任何一个 NO 的信息，或者 在一定时间内 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。\",\"DoCommit 阶段：这个阶段其实和 2PC 的第二阶段差不多，如果协调者收到了所有参与者在 PreCommit 阶段的 YES 响应，那么协调者将会给所有参与者发送 DoCommit 请求，参与者收到 DoCommit 请求后则会进行事务的提交工作，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 PreCommit 阶段 收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应 ，那么就会进行中断请求的发送，参与者收到中断请求后则会 通过上面记录的回滚日志 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。\",\"3PC流程\",\"这里是 3PC 在成功的环境下的流程图，你可以看到 3PC 在很多地方进行了超时中断的处理，比如协调者在指定时间内未收到全部的确认消息则进行事务中断的处理，这样能 减少同步阻塞的时间 。还有需要注意的是，3PC 在 DoCommit 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交。为什么这么做呢？是因为这个时候我们肯定保证了在第一阶段所有的协调者全部返回了可以执行事务的响应，这个时候我们有理由相信其他系统都能进行事务的执行和提交，所以不管协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。\",\"总之，3PC 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 DoCommit 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。\",\"所以，要解决一致性问题还需要靠 Paxos 算法 ⭐️ ⭐️ ⭐️ 。\"]},\"1372\":{\"h\":\"Paxos 算法\",\"t\":[\"Paxos 算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致 。\",\"在 Paxos 中主要有三个角色，分别为 Proposer提案者、Acceptor表决者、Learner学习者。Paxos 算法和 2PC 一样，也有两个阶段，分别为 Prepare 和 accept 阶段。\"]},\"1373\":{\"h\":\"prepare 阶段\",\"t\":[\"Proposer提案者：负责提出 proposal，每个提案者在提出提案时都会首先获取到一个 具有全局唯一性的、递增的提案编号 N，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在第一阶段是只将提案编号发送给所有的表决者。\",\"Acceptor表决者：每个表决者在 accept 某提案后，会将该提案编号 N 记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为 maxN。每个表决者仅会 accept 编号大于自己本地 maxN 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 Proposer 。\",\"下面是 prepare 阶段的流程图，你可以对照着参考一下。\",\"paxos第一阶段\"]},\"1374\":{\"h\":\"accept 阶段\",\"t\":[\"当一个提案被 Proposer 提出后，如果 Proposer 收到了超过半数的 Acceptor 的批准（Proposer 本身同意），那么此时 Proposer 会给所有的 Acceptor 发送真正的提案（你可以理解为第一阶段为试探），这个时候 Proposer 就会发送提案的内容和提案编号。\",\"表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 大于等于 已经批准过的最大提案编号，那么就 accept 该提案（此时执行提案内容但不提交），随后将情况返回给 Proposer 。如果不满足则不回应或者返回 NO 。\",\"paxos第二阶段1\",\"当 Proposer 收到超过半数的 accept ，那么它这个时候会向所有的 acceptor 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 acceptor 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要向未批准的 acceptor 发送提案内容和提案编号并让它无条件执行和提交，而对于前面已经批准过该提案的 acceptor 来说 仅仅需要发送该提案的编号 ，让 acceptor 执行提交就行了。\",\"paxos第二阶段2\",\"而如果 Proposer 如果没有收到超过半数的 accept 那么它将会将 递增 该 Proposal 的编号，然后 重新进入 Prepare 阶段 。\",\"对于 Learner 来说如何去学习 Acceptor 批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。\"]},\"1375\":{\"h\":\"paxos 算法的死循环问题\",\"t\":[\"其实就有点类似于两个人吵架，小明说我是对的，小红说我才是对的，两个人据理力争的谁也不让谁 🤬🤬。\",\"比如说，此时提案者 P1 提出一个方案 M1，完成了 Prepare 阶段的工作，这个时候 acceptor 则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了 Prepare 阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为 acceptor 已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入 Prepare 阶段，然后 acceptor ，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入 Prepare 阶段。。。\",\"就这样无休无止的永远提案下去，这就是 paxos 算法的死循环问题。\",\"那么如何解决呢？很简单，人多了容易吵架，我现在 就允许一个能提案 就行了。\"]},\"1376\":{\"h\":\"引出 ZAB\"},\"1377\":{\"h\":\"Zookeeper 架构\",\"t\":[\"作为一个优秀高效且可靠的分布式协调框架，ZooKeeper 在解决分布式数据一致性问题时并没有直接使用 Paxos ，而是专门定制了一致性协议叫做 ZAB(ZooKeeper Atomic Broadcast) 原子广播协议，该协议能够很好地支持 崩溃恢复 。\",\"Zookeeper架构\"]},\"1378\":{\"h\":\"ZAB 中的三个角色\",\"t\":[\"和介绍 Paxos 一样，在介绍 ZAB 协议之前，我们首先来了解一下在 ZAB 中三个主要的角色，Leader 领导者、Follower跟随者、Observer观察者 。\",\"Leader：集群中 唯一的写请求处理者 ，能够发起投票（投票也是为了进行写请求）。\",\"Follower：能够接收客户端的请求，如果是读请求则可以自己处理，如果是写请求则要转发给 Leader 。在选举过程中会参与投票，有选举权和被选举权 。\",\"Observer：就是没有选举权和被选举权的 Follower 。\",\"在 ZAB 协议中对 zkServer(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 消息广播 和 崩溃恢复 。\"]},\"1379\":{\"h\":\"消息广播模式\",\"t\":[\"说白了就是 ZAB 协议是如何处理写请求的，上面我们不是说只有 Leader 能处理写请求嘛？那么我们的 Follower 和 Observer 是不是也需要 同步更新数据 呢？总不能数据只在 Leader 中更新了，其他角色都没有得到更新吧？\",\"不就是 在整个集群中保持数据的一致性 嘛？如果是你，你会怎么做呢？\",\"废话，第一步肯定需要 Leader 将写请求 广播 出去呀，让 Leader 问问 Followers 是否同意更新，如果超过半数以上的同意那么就进行 Follower 和 Observer 的更新（和 Paxos 一样）。当然这么说有点虚，画张图理解一下。\",\"消息广播\",\"嗯。。。看起来很简单，貌似懂了 🤥🤥🤥。这两个 Queue 哪冒出来的？答案是 ZAB 需要让 Follower 和 Observer 保证顺序性 。何为顺序性，比如我现在有一个写请求 A，此时 Leader 将请求 A 广播出去，因为只需要半数同意就行，所以可能这个时候有一个 Follower F1 因为网络原因没有收到，而 Leader 又广播了一个请求 B，因为网络原因，F1 竟然先收到了请求 B 然后才收到了请求 A，这个时候请求处理的顺序不同就会导致数据的不同，从而 产生数据不一致问题 。\",\"所以在 Leader 这端，它为每个其他的 zkServer 准备了一个 队列 ，采用先进先出的方式发送消息。由于协议是 通过 TCP 来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。\",\"除此之外，在 ZAB 中还定义了一个 全局单调递增的事务 ID ZXID ，它是一个 64 位 long 型，其中高 32 位表示 epoch 年代，低 32 位表示事务 id。epoch 是会根据 Leader 的变化而变化的，当一个 Leader 挂了，新的 Leader 上位的时候，年代（epoch）就变了。而低 32 位可以简单理解为递增的事务 id。\",\"定义这个的原因也是为了顺序性，每个 proposal 在 Leader 中生成后需要 通过其 ZXID 来进行排序 ，才能得到处理。\"]},\"1380\":{\"h\":\"崩溃恢复模式\",\"t\":[\"说到崩溃恢复我们首先要提到 ZAB 中的 Leader 选举算法，当系统出现崩溃影响最大应该是 Leader 的崩溃，因为我们只有一个 Leader ，所以当 Leader 出现问题的时候我们势必需要重新选举 Leader 。\",\"Leader 选举可以分为两个不同的阶段，第一个是我们提到的 Leader 宕机需要重新选举，第二则是当 Zookeeper 启动时需要进行系统的 Leader 初始化选举。下面我先来介绍一下 ZAB 是如何进行初始化选举的。\",\"假设我们集群中有 3 台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 server1 ，它会首先 投票给自己 ，投票内容为服务器的 myid 和 ZXID ，因为初始化所以 ZXID 都为 0，此时 server1 发出的投票为 (1,0)。但此时 server1 的投票仅为 1，所以不能作为 Leader ，此时还在选举阶段所以整个集群处于 Looking 状态。\",\"接着 server2 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（server1也会，只是它那时没有其他的服务器了），server1 在收到 server2 的投票信息后会将投票信息与自己的作比较。首先它会比较 ZXID ，ZXID 大的优先为 Leader，如果相同则比较 myid，myid 大的优先作为 Leader。所以此时server1 发现 server2 更适合做 Leader，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后server2 收到之后发现和自己的一样无需做更改，并且自己的 投票已经超过半数 ，则 确定 server2 为 Leader，server1 也会将自己服务器设置为 Following 变为 Follower。整个服务器就从 Looking 变为了正常状态。\",\"当 server3 启动发现集群没有处于 Looking 状态时，它会直接以 Follower 的身份加入集群。\",\"还是前面三个 server 的例子，如果在整个集群运行的过程中 server2 挂了，那么整个集群会如何重新选举 Leader 呢？其实和初始化选举差不多。\",\"首先毫无疑问的是剩下的两个 Follower 会将自己的状态 从 Following 变为 Looking 状态 ，然后每个 server 会向初始化投票一样首先给自己投票（这不过这里的 zxid 可能不是 0 了，这里为了方便随便取个数字）。\",\"假设 server1 给自己投票为(1,99)，然后广播给其他 server，server3 首先也会给自己投票(3,95)，然后也广播给其他 server。server1 和 server3 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（zxid 大的优先，如果相同那么就 myid 大的优先）。这个时候 server1 收到了 server3 的投票发现没自己的合适故不变，server3 收到 server1 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 server1 收到了发现自己的投票已经超过半数就把自己设为 Leader，server3 也随之变为 Follower。\",\"请注意 ZooKeeper 为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，但是挂了两个也不能正常工作了，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以 Zookeeper 推荐奇数个 server 。\",\"那么说完了 ZAB 中的 Leader 选举方式之后我们再来了解一下 崩溃恢复 是什么玩意？\",\"其实主要就是 当集群中有机器挂了，我们整个集群如何保证数据一致性？\",\"如果只是 Follower 挂了，而且挂的没超过半数的时候，因为我们一开始讲了在 Leader 中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。\",\"如果 Leader 挂了那就麻烦了，我们肯定需要先暂停服务变为 Looking 状态然后进行 Leader 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交 和 跳过那些已经被丢弃的提案 。\",\"确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交是什么意思呢？\",\"假设 Leader (server2) 发送 commit 请求（忘了请看上面的消息广播模式），他发送给了 server3，然后要发给 server1 的时候突然挂了。这个时候重新选举的时候我们如果把 server1 作为 Leader 的话，那么肯定会产生数据不一致性，因为 server3 肯定会提交刚刚 server2 发送的 commit 请求的提案，而 server1 根本没收到所以会丢弃。\",\"崩溃恢复\",\"那怎么解决呢？\",\"聪明的同学肯定会质疑，这个时候 server1 已经不可能成为 Leader 了，因为 server1 和 server3 进行投票选举的时候会比较 ZXID ，而此时 server3 的 ZXID 肯定比 server1 的大了。(不理解可以看前面的选举算法)\",\"那么跳过那些已经被丢弃的提案又是什么意思呢？\",\"假设 Leader (server2) 此时同意了提案 N1，自身提交了这个事务并且要发送给所有 Follower 要 commit 的请求，却在这个时候挂了，此时肯定要重新进行 Leader 的选举，比如说此时选 server1 为 Leader （这无所谓）。但是过了一会，这个 挂掉的 Leader 又重新恢复了 ，此时它肯定会作为 Follower 的身份进入集群中，需要注意的是刚刚 server2 已经同意提交了提案 N1，但其他 server 并没有收到它的 commit 信息，所以其他 server 不可能再提交这个提案 N1 了，这样就会出现数据不一致性问题了，所以 该提案 N1 最终需要被抛弃掉 。\",\"崩溃恢复\"]},\"1381\":{\"h\":\"Zookeeper 的几个理论知识\",\"t\":[\"了解了 ZAB 协议还不够，它仅仅是 Zookeeper 内部实现的一种方式，而我们如何通过 Zookeeper 去做一些典型的应用场景呢？比如说集群管理，分布式锁，Master 选举等等。\",\"这就涉及到如何使用 Zookeeper 了，但在使用之前我们还需要掌握几个概念。比如 Zookeeper 的 数据模型、会话机制、ACL、Watcher 机制 等等。\"]},\"1382\":{\"h\":\"数据模型\",\"t\":[\"zookeeper 数据存储结构与标准的 Unix 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 zookeeper 中没有文件系统中目录与文件的概念，而是 使用了 znode 作为数据节点 。znode 是 zookeeper 中的最小数据单元，每个 znode 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。\",\"zk数据模型\",\"每个 znode 都有自己所属的 节点类型 和 节点状态。\",\"其中节点类型可以分为 持久节点、持久顺序节点、临时节点 和 临时顺序节点。\",\"持久节点：一旦创建就一直存在，直到将其删除。\",\"持久顺序节点：一个父节点可以为其子节点 维护一个创建的先后顺序 ，这个顺序体现在 节点名称 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。\",\"临时节点：临时节点的生命周期是与 客户端会话 绑定的，会话消失则节点消失 。临时节点 只能做叶子节点 ，不能创建子节点。\",\"临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。\",\"节点状态中包含了很多节点的属性比如 czxid、mzxid 等等，在 zookeeper 中是使用 Stat 这个类来维护的。下面我列举一些属性解释。\",\"czxid：Created ZXID，该数据节点被 创建 时的事务 ID。\",\"mzxid：Modified ZXID，节点 最后一次被更新时 的事务 ID。\",\"ctime：Created Time，该节点被创建的时间。\",\"mtime：Modified Time，该节点最后一次被修改的时间。\",\"version：节点的版本号。\",\"cversion：子节点 的版本号。\",\"aversion：节点的 ACL 版本号。\",\"ephemeralOwner：创建该节点的会话的 sessionID ，如果该节点为持久节点，该值为 0。\",\"dataLength：节点数据内容的长度。\",\"numChildre：该节点的子节点个数，如果为临时节点为 0。\",\"pzxid：该节点子节点列表最后一次被修改时的事务 ID，注意是子节点的 列表 ，不是内容。\"]},\"1383\":{\"h\":\"会话\",\"t\":[\"我想这个对于后端开发的朋友肯定不陌生，不就是 session 吗？只不过 zk 客户端和服务端是通过 TCP 长连接 维持的会话机制，其实对于会话来说你可以理解为 保持连接状态 。\",\"在 zookeeper 中，会话还有对应的事件，比如 CONNECTION_LOSS 连接丢失事件、SESSION_MOVED 会话转移事件、SESSION_EXPIRED 会话超时失效事件 。\"]},\"1384\":{\"h\":\"ACL\",\"t\":[\"ACL 为 Access Control Lists ，它是一种权限控制。在 zookeeper 中定义了 5 种权限，它们分别为：\",\"CREATE：创建子节点的权限。\",\"READ：获取节点数据和子节点列表的权限。\",\"WRITE：更新节点数据的权限。\",\"DELETE：删除子节点的权限。\",\"ADMIN：设置节点 ACL 的权限。\"]},\"1385\":{\"h\":\"Watcher 机制\",\"t\":[\"Watcher 为事件监听器，是 zk 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 注册 指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会 向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后 执行相应的回调方法 。\",\"watcher机制\"]},\"1386\":{\"h\":\"Zookeeper 的几个典型应用场景\",\"t\":[\"前面说了这么多的理论知识，你可能听得一头雾水，这些玩意有啥用？能干啥事？别急，听我慢慢道来。\"]},\"1387\":{\"h\":\"选主\",\"t\":[\"还记得上面我们的所说的临时节点吗？因为 Zookeeper 的强一致性，能够很好地在保证 在高并发的情况下保证节点创建的全局唯一性 (即无法重复创建同样的节点)。\",\"利用这个特性，我们可以 让多个客户端创建一个指定的节点 ，创建成功的就是 master。\",\"但是，如果这个 master 挂了怎么办？？？\",\"你想想为什么我们要创建临时节点？还记得临时节点的生命周期吗？master 挂了是不是代表会话断了？会话断了是不是意味着这个节点没了？还记得 watcher 吗？我们是不是可以 让其他不是 master 的节点监听节点的状态 ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 master 挂了，这个时候我们 触发回调函数进行重新选举 ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 master 是否挂了等等。\",\"选主\",\"总的来说，我们可以完全 利用 临时节点、节点状态 和 watcher 来实现选主的功能，临时节点主要用来选举，节点状态和watcher 可以用来判断 master 的活性和进行重新选举。\"]},\"1388\":{\"h\":\"分布式锁\",\"t\":[\"分布式锁的实现方式有很多种，比如 Redis、数据库、zookeeper 等。个人认为 zookeeper 在实现分布式锁这方面是非常非常简单的。\",\"上面我们已经提到过了 zk 在高并发的情况下保证节点创建的全局唯一性，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式的情况下，所以能实现分布式锁呗。\",\"如何实现呢？这玩意其实跟选主基本一样，我们也可以利用临时节点的创建来实现。\",\"首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，创建成功的就说明获取到了锁 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 watcher 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。\",\"zk 中不需要向 redis 那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。是不是很简单？\",\"那能不能使用 zookeeper 同时实现 共享锁和独占锁 呢？答案是可以的，不过稍微有点复杂而已。\",\"还记得 有序的节点 吗？\",\"这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 没有比自己更小的节点，或比自己小的节点都是读请求 ，则可以获取到读锁，然后就可以开始读了。若比自己小的节点中有写请求 ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。\",\"如果你是写请求（获取独占锁），若 没有比自己更小的节点 ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁 ，等待所有前面的操作完成。\",\"这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 羊群效应 。此时你可以通过让等待的节点只监听他们前面的节点。\",\"具体怎么做呢？其实也很简单，你可以让 读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点 ，感兴趣的小伙伴可以自己去研究一下。\"]},\"1389\":{\"h\":\"命名服务\",\"t\":[\"如何给一个对象设置 ID，大家可能都会想到 UUID，但是 UUID 最大的问题就在于它太长了。。。(太长不一定是好事，嘿嘿嘿)。那么在条件允许的情况下，我们能不能使用 zookeeper 来实现呢？\",\"我们之前提到过 zookeeper 是通过 树形结构 来存储数据节点的，那也就是说，对于每个节点的 全路径，它必定是唯一的，我们可以使用节点的全路径作为命名方式了。而且更重要的是，路径是我们可以自己定义的，这对于我们对有些有语意的对象的 ID 设置可以更加便于理解。\"]},\"1390\":{\"h\":\"集群管理和注册中心\",\"t\":[\"看到这里是不是觉得 zookeeper 实在是太强大了，它怎么能这么能干！\",\"别急，它能干的事情还很多呢。可能我们会有这样的需求，我们需要了解整个集群中有多少机器在工作，我们想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。\",\"而 zookeeper 天然支持的 watcher 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 watcher 进行状态监控和回调。\",\"集群管理\",\"至于注册中心也很简单，我们同样也是让 服务提供者 在 zookeeper 中创建一个临时节点并且将自己的 ip、port、调用方式 写入节点，当 服务消费者 需要进行调用的时候会 通过注册中心找到相应的服务的地址列表(IP 端口什么的) ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。\",\"当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机（当然你可以让消费者进行节点监听，我记得 Eureka 会先试错，然后再更新）。\",\"注册中心\"]},\"1391\":{\"h\":\"总结\",\"t\":[\"看到这里的同学实在是太有耐心了 👍👍👍 不知道大家是否还记得我讲了什么 😒。\",\"这篇文章中我带大家入门了 zookeeper 这个强大的分布式协调框架。现在我们来简单梳理一下整篇文章的内容。\",\"分布式与集群的区别\",\"2PC、3PC 以及 paxos 算法这些一致性框架的原理和实现。\",\"zookeeper 专门的一致性算法 ZAB 原子广播协议的内容（Leader 选举、崩溃恢复、消息广播）。\",\"zookeeper 中的一些基本概念，比如 ACL，数据节点，会话，watcher机制等等。\",\"zookeeper 的典型应用场景，比如选主，注册中心等等。\",\"如果忘了可以回去看看再次理解一下，如果有疑问和建议欢迎提出 🤝🤝🤝。\",\"File not found\"]},\"1392\":{\"c\":[\"分布式\"]},\"1393\":{\"c\":[\"ZooKeeper\"]},\"1394\":{\"h\":\"Note\"},\"1395\":{\"h\":\"Protocol\"},\"1396\":{\"h\":\"Rpc\"},\"1397\":{\"h\":\"Message Queue\"},\"1398\":{\"h\":\"Zookeeper\"},\"1399\":{\"h\":\"Distributed Process Coordination\"}},\"dirtCount\":0,\"index\":[[\"羊群效应\",{\"1\":{\"1388\":1}}],[\"聪明的同学肯定会质疑\",{\"1\":{\"1380\":1}}],[\"聪明的程序员在中间也加了个类似于服务员的中间件\",{\"1\":{\"1271\":1}}],[\"竟然先收到了请求\",{\"1\":{\"1379\":1}}],[\"貌似懂了\",{\"1\":{\"1379\":1}}],[\"貌似平时也不怎么需要关注\",{\"1\":{\"37\":1}}],[\"画张图理解一下\",{\"1\":{\"1379\":1}}],[\"画个图给大家捋一捋\",{\"1\":{\"919\":1}}],[\"嘛\",{\"1\":{\"1379\":1}}],[\"批准的提案内容\",{\"1\":{\"1374\":1}}],[\"批准执行了该提案内容\",{\"1\":{\"1374\":1}}],[\"批量消费等高级定制场景\",{\"1\":{\"1293\":2}}],[\"批量删除结果\",{\"1\":{\"593\":2}}],[\"批量操作还可以减少\",{\"1\":{\"285\":1}}],[\"批量操作\",{\"1\":{\"280\":1}}],[\"批量获取多个\",{\"1\":{\"177\":1}}],[\"批量设置\",{\"1\":{\"177\":1}}],[\"决议\",{\"1\":{\"1372\":1}}],[\"决定了没有事件可以消费的时候\",{\"1\":{\"1182\":1,\"1183\":1}}],[\"决定了\",{\"1\":{\"1068\":1}}],[\"决定\",{\"1\":{\"340\":1,\"1105\":1}}],[\"⭐️\",{\"1\":{\"1371\":3}}],[\"千万不要吧\",{\"1\":{\"1371\":1}}],[\"千万级别以上\",{\"1\":{\"207\":1}}],[\"告诉参与者你们需要执行事务了\",{\"1\":{\"1370\":1}}],[\"告知交换器消息应该将消息投递给哪个队列\",{\"1\":{\"1253\":1}}],[\"告知linkedhashmap移除最老的缓存项\",{\"1\":{\"706\":1,\"712\":1}}],[\"告知\",{\"1\":{\"706\":1}}],[\"散布\",{\"1\":{\"1368\":1}}],[\"散列数组下标为\",{\"1\":{\"1035\":1}}],[\"散列\",{\"1\":{\"174\":1,\"253\":1}}],[\"扣优惠券服务等等\",{\"1\":{\"1367\":1}}],[\"扣费任务下的子任务\",{\"1\":{\"919\":1}}],[\"扣费任务\",{\"1\":{\"919\":1}}],[\"瞬时节点被删除\",{\"1\":{\"1362\":1}}],[\"瞬时节点就一直存在\",{\"1\":{\"1362\":1}}],[\"脑裂期间\",{\"1\":{\"1358\":1}}],[\"脑裂\",{\"1\":{\"1358\":1}}],[\"脑海中只是简单的能浮现出几句话\",{\"1\":{\"1341\":1}}],[\"台机器\",{\"1\":{\"1380\":1}}],[\"台服务器下线\",{\"1\":{\"1358\":1}}],[\"台服务器都会认为另一个机房的\",{\"1\":{\"1358\":1}}],[\"台服务器所组成的一个集群\",{\"1\":{\"1358\":1}}],[\"台服务器就可以构成一个\",{\"1\":{\"1354\":1}}],[\"台的的时候也同样只允许宕掉\",{\"1\":{\"1357\":2}}],[\"台\",{\"1\":{\"1357\":7,\"1358\":1}}],[\"角色\",{\"1\":{\"1355\":1}}],[\"角度说进程和线程之间的关系\",{\"1\":{\"809\":1}}],[\"密码认证方式\",{\"1\":{\"1351\":1}}],[\"密集任务\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集任务还是\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集型简单理解就是利用\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集型任务下\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集型任务的\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集型任务的应用中\",{\"1\":{\"895\":1,\"922\":1}}],[\"密集型任务\",{\"1\":{\"895\":2,\"922\":2,\"1056\":1}}],[\"密集型的\",{\"1\":{\"819\":4}}],[\"密集型的线程主要进行输入输出操作\",{\"1\":{\"819\":1}}],[\"密集型的线程主要进行计算和逻辑处理\",{\"1\":{\"819\":1}}],[\"密集型\",{\"1\":{\"819\":1,\"895\":1,\"922\":1}}],[\"密集型和\",{\"1\":{\"819\":1}}],[\"密集型服务部署在一起\",{\"1\":{\"169\":1}}],[\"密集型应用\",{\"1\":{\"169\":1}}],[\"密集索引\",{\"0\":{\"106\":1}}],[\"破音\",{\"1\":{\"1347\":1,\"1352\":1}}],[\"破坏循环等待条件\",{\"1\":{\"824\":2}}],[\"破坏不剥夺条件\",{\"1\":{\"824\":1}}],[\"破坏请求与保持条件\",{\"1\":{\"824\":1}}],[\"破坏死锁的产生的必要条件即可\",{\"1\":{\"824\":1}}],[\"破坏了\",{\"1\":{\"359\":1}}],[\"命名服务\",{\"0\":{\"1389\":1},\"1\":{\"1344\":1,\"1346\":2}}],[\"命令在下面会介绍到\",{\"1\":{\"1349\":1}}],[\"命令在根目录创建了\",{\"1\":{\"1325\":2}}],[\"命令返回的信息包括\",{\"1\":{\"1330\":1}}],[\"命令更像是\",{\"1\":{\"1330\":1}}],[\"命令中的\",{\"1\":{\"1328\":1}}],[\"命令和\",{\"1\":{\"1328\":1,\"1330\":1}}],[\"命令已经将节点数据内容改为\",{\"1\":{\"1327\":1}}],[\"命令已经帮我们找到发生死锁的线程的具体信息\",{\"1\":{\"370\":1}}],[\"命令进入容器中\",{\"1\":{\"1322\":1}}],[\"命令进行死锁检查\",{\"1\":{\"370\":1}}],[\"命令就可以完成\",{\"1\":{\"1106\":1}}],[\"命令调节新生代大小\",{\"1\":{\"479\":1}}],[\"命令里的内存相关字段\",{\"1\":{\"412\":1}}],[\"命令查看节点状态\",{\"1\":{\"1329\":1}}],[\"命令查看根目录下的节点\",{\"1\":{\"1328\":1}}],[\"命令查看\",{\"1\":{\"400\":1,\"403\":1,\"412\":1,\"851\":1,\"1324\":1,\"1328\":1}}],[\"命令分析\",{\"1\":{\"370\":1}}],[\"命令用于生成虚拟机当前时刻的线程快照\",{\"1\":{\"370\":1}}],[\"命令用于生成堆转储快照\",{\"1\":{\"368\":1}}],[\"命令下可以通过\",{\"1\":{\"368\":1}}],[\"命令使用格式\",{\"1\":{\"366\":1}}],[\"命令类似\",{\"1\":{\"365\":1}}],[\"命令行工具\",{\"0\":{\"364\":1}}],[\"命令并非不能使用\",{\"1\":{\"319\":1}}],[\"命令并将输出重定向至文件\",{\"1\":{\"298\":1}}],[\"命令默认返回最近\",{\"1\":{\"302\":1}}],[\"命令直接设置\",{\"1\":{\"302\":1}}],[\"命令是\",{\"1\":{\"298\":1}}],[\"命令是可以帮助我们实现互斥\",{\"1\":{\"47\":1}}],[\"命令结合\",{\"1\":{\"294\":1}}],[\"命令会被一次性提交到\",{\"1\":{\"287\":1}}],[\"命令会被提交到\",{\"1\":{\"283\":1}}],[\"命令封装成一组\",{\"1\":{\"287\":1}}],[\"命令执行耗时超过\",{\"1\":{\"302\":1}}],[\"命令执行\",{\"1\":{\"285\":1,\"301\":1}}],[\"命令执行事务时\",{\"1\":{\"280\":1}}],[\"命令排队\",{\"1\":{\"285\":1,\"301\":1}}],[\"命令的结合\",{\"1\":{\"1330\":1}}],[\"命令的执行可以简化为以下\",{\"1\":{\"285\":1,\"301\":1}}],[\"命令的底层原理解析可以看看阿里的这篇文章\",{\"1\":{\"210\":1}}],[\"命令实际也是不完全满足原子性的\",{\"1\":{\"283\":1}}],[\"命令同时执行\",{\"1\":{\"283\":1,\"288\":1}}],[\"命令碰到\",{\"1\":{\"280\":1}}],[\"命令提交事务之前修改\",{\"1\":{\"280\":1}}],[\"命令监视的\",{\"1\":{\"280\":1}}],[\"命令监听指定的\",{\"1\":{\"280\":1}}],[\"命令取消一个事务\",{\"1\":{\"280\":1}}],[\"命令入队\",{\"1\":{\"280\":1}}],[\"命令后通过对文件中请求进行归类分析即可找出这段时间中的\",{\"1\":{\"298\":1}}],[\"命令后\",{\"1\":{\"280\":1}}],[\"命令后可以输入多个命令\",{\"1\":{\"280\":1}}],[\"命令手册\",{\"1\":{\"274\":1}}],[\"命令手动执行\",{\"1\":{\"233\":1}}],[\"命令可以获取指定节点的数据内容和节点的状态\",{\"1\":{\"1327\":1}}],[\"命令可以按照一定的模式和数量返回匹配的\",{\"1\":{\"293\":1}}],[\"命令可以移除一个键的过期时间\",{\"1\":{\"270\":1}}],[\"命令可以实现一个最简易的分布式锁\",{\"1\":{\"178\":1,\"254\":1}}],[\"命令来获取\",{\"1\":{\"1349\":1}}],[\"命令来快速查看\",{\"1\":{\"327\":1}}],[\"命令来分批次删除\",{\"1\":{\"294\":1}}],[\"命令来异步删除一个或多个指定的\",{\"1\":{\"294\":1}}],[\"命令来设置过期时间\",{\"1\":{\"270\":1}}],[\"命令来查找大\",{\"1\":{\"164\":1}}],[\"命令回复处理器\",{\"1\":{\"265\":1}}],[\"命令请求处理器\",{\"1\":{\"265\":1}}],[\"命令追加\",{\"1\":{\"230\":1}}],[\"命令将\",{\"1\":{\"220\":1}}],[\"命令即可\",{\"1\":{\"302\":1}}],[\"命令即可查看\",{\"1\":{\"219\":1}}],[\"命令即可实现对\",{\"1\":{\"35\":1}}],[\"命令以及详细使用指南\",{\"1\":{\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1}}],[\"命令时要关注\",{\"1\":{\"319\":1}}],[\"命令时的不同效果\",{\"1\":{\"280\":1}}],[\"命令时\",{\"1\":{\"162\":1}}],[\"命令生成编译后的\",{\"1\":{\"851\":1}}],[\"命令生成\",{\"1\":{\"158\":1}}],[\"命令\",{\"0\":{\"157\":1,\"1324\":1,\"1325\":1,\"1326\":1,\"1327\":1,\"1328\":1,\"1329\":1,\"1330\":1,\"1331\":1},\"1\":{\"158\":1,\"177\":1,\"181\":3,\"185\":1,\"189\":1,\"193\":1,\"202\":1,\"206\":1,\"210\":2,\"258\":1,\"283\":1,\"293\":3,\"298\":1,\"364\":1,\"365\":1,\"368\":1,\"376\":1,\"1085\":1}}],[\"命令删除对应的\",{\"1\":{\"47\":1}}],[\"稳定的分布式数据一致性解决方案\",{\"1\":{\"1344\":1}}],[\"雅虎的整个分布式系统看上去就像一个大型的动物园了\",{\"1\":{\"1343\":1}}],[\"雅虎的工程师希望给这个项目也取一个动物的名字\",{\"1\":{\"1343\":1}}],[\"雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架\",{\"1\":{\"1343\":1}}],[\"研究人员发现\",{\"1\":{\"1343\":1}}],[\"研发一套分布式服务框架\",{\"1\":{\"1171\":1}}],[\"忘了请看上面的消息广播模式\",{\"1\":{\"1380\":1}}],[\"忘了的同学可以回去看一下\",{\"1\":{\"1315\":1}}],[\"忘掉它的存在吧\",{\"1\":{\"391\":1}}],[\"硬着头皮往下看就行\",{\"1\":{\"1315\":1}}],[\"硬核干货\",{\"1\":{\"941\":1}}],[\"拷贝到\",{\"1\":{\"1311\":1}}],[\"拷贝到内核缓冲区\",{\"1\":{\"1311\":1}}],[\"拷贝到内核缓存区\",{\"1\":{\"1308\":1}}],[\"拷贝操作\",{\"1\":{\"1310\":1}}],[\"拷贝\",{\"1\":{\"1310\":1,\"1311\":1}}],[\"零拷贝技术\",{\"0\":{\"1309\":1}}],[\"零外部依赖\",{\"1\":{\"1236\":1}}],[\"半消息机制\",{\"1\":{\"1304\":1}}],[\"积分怎么办呢\",{\"1\":{\"1303\":1}}],[\"幂等不仅仅适用于消息队列的重复消费问题\",{\"1\":{\"1303\":1}}],[\"幂等\",{\"1\":{\"1303\":2}}],[\"施工中\",{\"1\":{\"1287\":1,\"1294\":1}}],[\"见下文\",{\"1\":{\"1286\":1}}],[\"精度高\",{\"1\":{\"1285\":1}}],[\"精确到天\",{\"1\":{\"261\":1}}],[\"心跳包含了自身的\",{\"1\":{\"1281\":1}}],[\"干啥用的\",{\"1\":{\"1281\":1}}],[\"干自己其他事情\",{\"1\":{\"1271\":1}}],[\"嗯\",{\"1\":{\"1281\":1,\"1379\":1}}],[\"听我慢慢道来\",{\"1\":{\"1386\":1}}],[\"听我细细道来\",{\"1\":{\"1281\":1}}],[\"听完了上面的解释你可能会觉得\",{\"1\":{\"1281\":1}}],[\"听完上面的介绍\",{\"1\":{\"1276\":1}}],[\"听说\",{\"1\":{\"412\":1,\"486\":1}}],[\"废话\",{\"1\":{\"1379\":1}}],[\"废话不多说\",{\"1\":{\"1276\":1}}],[\"废弃常量\",{\"1\":{\"394\":1}}],[\"话说你现在清楚\",{\"1\":{\"1276\":1}}],[\"话题热度排行榜等等\",{\"1\":{\"194\":1,\"258\":1}}],[\"哇\",{\"1\":{\"1276\":1}}],[\"办法总是有的\",{\"1\":{\"1275\":1}}],[\"银弹\",{\"1\":{\"1275\":1}}],[\"折中处理\",{\"1\":{\"1273\":1}}],[\"韭菜鸡蛋\",{\"1\":{\"1271\":1}}],[\"咦~~~\",{\"1\":{\"1271\":1}}],[\"帮我浇点汁上去\",{\"1\":{\"1271\":1}}],[\"帮助我们解决了什么问题呢\",{\"1\":{\"1123\":1}}],[\"姐姐\",{\"1\":{\"1271\":1}}],[\"购票是一个不太耗时的流程\",{\"1\":{\"1271\":1}}],[\"购物车信息建议使用\",{\"1\":{\"257\":1}}],[\"购物车信息用\",{\"0\":{\"257\":1}}],[\"购物车信息\",{\"1\":{\"186\":1}}],[\"乍看没什么问题\",{\"1\":{\"1271\":1}}],[\"短暂时间\",{\"1\":{\"1299\":1}}],[\"短信业务又不是我们的主业务\",{\"1\":{\"1273\":1}}],[\"短信系统处理需要\",{\"1\":{\"1271\":1}}],[\"短网址服务把客户的长网址转换成短网址\",{\"1\":{\"24\":1}}],[\"短网址作用\",{\"1\":{\"24\":1}}],[\"短网址可以更方便地在电子邮件\",{\"1\":{\"24\":1}}],[\"短网址主要功能包括网址缩短与还原两大功能\",{\"1\":{\"24\":1}}],[\"短网址\",{\"0\":{\"24\":1}}],[\"坏处在于\",{\"1\":{\"1263\":1}}],[\"镜像集群下\",{\"1\":{\"1263\":1}}],[\"镜像集群模式\",{\"1\":{\"1263\":2}}],[\"镜像模式\",{\"1\":{\"1261\":1}}],[\"邮件收件人\",{\"1\":{\"1248\":1}}],[\"邮件投递者\",{\"1\":{\"1248\":1}}],[\"邮箱和邮递员组成的一个系统\",{\"1\":{\"1247\":1}}],[\"邮局会暂存并最终将邮件通过邮递员送到收件人的手上\",{\"1\":{\"1247\":1}}],[\"己的插件\",{\"1\":{\"1246\":1}}],[\"己经提供了一些内置的交换器来实现\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"群中的节点等\",{\"1\":{\"1246\":1}}],[\"十万级\",{\"1\":{\"1240\":1}}],[\"级别的\",{\"1\":{\"1263\":1}}],[\"级的延迟\",{\"1\":{\"1240\":1}}],[\"级\",{\"1\":{\"1240\":1,\"1328\":1}}],[\"级锁\",{\"1\":{\"868\":1}}],[\"季\",{\"1\":{\"1240\":1}}],[\"易用的管理界面\",{\"1\":{\"1237\":1}}],[\"灵活的路由\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"历史版本\",{\"1\":{\"1297\":1}}],[\"历史的同学可以自己去搜寻资料\",{\"1\":{\"1276\":1}}],[\"历史最悠久的垃圾收集器了\",{\"1\":{\"401\":1}}],[\"历经十余年的大规模场景打磨\",{\"1\":{\"1236\":1}}],[\"广播出去\",{\"1\":{\"1379\":1}}],[\"广播阶段\",{\"1\":{\"1356\":1}}],[\"广播模式下\",{\"1\":{\"1281\":1}}],[\"广播\",{\"1\":{\"1272\":1,\"1278\":1,\"1281\":1,\"1379\":1}}],[\"广播消息\",{\"1\":{\"1272\":1}}],[\"广泛用于交易核心链路\",{\"1\":{\"1236\":1}}],[\"广告服务在新版本上线后\",{\"1\":{\"412\":1}}],[\"金融级的稳定性\",{\"1\":{\"1236\":1}}],[\"金融级\",{\"1\":{\"1236\":1}}],[\"友好\",{\"1\":{\"1236\":1}}],[\"友们可以看看京东的\",{\"1\":{\"788\":1}}],[\"借鉴了\",{\"1\":{\"1236\":1}}],[\"借助于算法\",{\"1\":{\"824\":1}}],[\"借助子类加载器\",{\"1\":{\"359\":1}}],[\"借助开源项目\",{\"1\":{\"298\":1}}],[\"借助开源工具分析\",{\"1\":{\"293\":1}}],[\"借助公有云的\",{\"1\":{\"293\":1,\"298\":1}}],[\"顶级项目\",{\"1\":{\"1235\":1,\"1236\":1,\"1238\":1,\"1367\":1}}],[\"顶级开源项目\",{\"1\":{\"8\":1,\"9\":1}}],[\"体系中\",{\"1\":{\"1231\":1}}],[\"否\",{\"1\":{\"1231\":2}}],[\"否则这个\",{\"1\":{\"1362\":1}}],[\"否则不会路由到该队列\",{\"1\":{\"1252\":1}}],[\"否则执行下面的步骤\",{\"1\":{\"958\":1}}],[\"否则的话返回的就是\",{\"1\":{\"941\":1}}],[\"否则新建一个线程来处理任务\",{\"1\":{\"892\":1,\"938\":1}}],[\"否则重新进入阻塞队列\",{\"1\":{\"906\":1}}],[\"否则重新进入等待队列\",{\"1\":{\"748\":1}}],[\"否则重试更新操作\",{\"1\":{\"840\":1,\"989\":1}}],[\"否则报\",{\"1\":{\"799\":1}}],[\"否则可能会导致主线程一直等待\",{\"1\":{\"785\":1}}],[\"否则才将列表转换为红黑树\",{\"1\":{\"683\":1}}],[\"否则才会尝试加载\",{\"1\":{\"352\":1,\"357\":1}}],[\"否则返回上一个元素\",{\"1\":{\"680\":1}}],[\"否则返回false\",{\"1\":{\"592\":1}}],[\"否则返回\",{\"1\":{\"571\":1,\"752\":1,\"773\":1,\"899\":1,\"1007\":1,\"1371\":1}}],[\"否则是\",{\"1\":{\"558\":1}}],[\"否则直接返回最小容量\",{\"1\":{\"553\":1,\"557\":1}}],[\"否则会抛出java\",{\"1\":{\"851\":1}}],[\"否则会抛出\",{\"1\":{\"677\":1}}],[\"否则会\",{\"1\":{\"456\":1}}],[\"否则就会触发\",{\"1\":{\"412\":1}}],[\"否则就会被真的回收\",{\"1\":{\"391\":1}}],[\"否则将进行\",{\"1\":{\"388\":1}}],[\"否则有被攻击的风险\",{\"1\":{\"307\":1}}],[\"否则最多等待10秒\",{\"1\":{\"251\":1}}],[\"否则依然存在数据丢失的风险\",{\"1\":{\"229\":1}}],[\"否则innodb会从建一个隐藏的row\",{\"1\":{\"113\":1}}],[\"否则做那件事\",{\"1\":{\"70\":1}}],[\"否则\",{\"1\":{\"53\":1,\"89\":1,\"553\":2,\"558\":1,\"559\":1,\"610\":1,\"619\":1,\"622\":1,\"1151\":1,\"1292\":1}}],[\"否则加锁失败\",{\"1\":{\"51\":1}}],[\"否则取消续期操作\",{\"1\":{\"49\":1}}],[\"否则只需要根据顺序往下查询就能搜索到别的考生的成绩\",{\"1\":{\"18\":1}}],[\"挂掉的\",{\"1\":{\"1380\":1}}],[\"挂掉等等的情况\",{\"1\":{\"1224\":1}}],[\"挂了是不是代表会话断了\",{\"1\":{\"1387\":1}}],[\"挂了怎么办\",{\"1\":{\"1387\":1}}],[\"挂了那就麻烦了\",{\"1\":{\"1380\":1}}],[\"挂了一个也能工作\",{\"1\":{\"1380\":1}}],[\"挂了一个我们还能正常工作\",{\"1\":{\"1380\":1}}],[\"挂了两个我们就不能正常工作了\",{\"1\":{\"1380\":1}}],[\"挂了\",{\"1\":{\"1379\":1,\"1380\":2,\"1387\":1}}],[\"挂了或者网络波动发送消息超时此时\",{\"1\":{\"1301\":1}}],[\"挂起线程\",{\"1\":{\"748\":2,\"752\":2,\"906\":2}}],[\"挂起当前线程\",{\"1\":{\"748\":2,\"906\":2}}],[\"驱动的业务架构可以是一系列流程\",{\"1\":{\"1222\":1}}],[\"促销活动中\",{\"1\":{\"1221\":1}}],[\"削峰\",{\"0\":{\"1221\":1,\"1273\":1},\"1\":{\"1219\":1,\"1221\":1,\"1274\":1,\"1305\":1,\"1316\":1}}],[\"侧\",{\"1\":{\"1207\":1}}],[\"突然挂掉\",{\"1\":{\"1206\":1}}],[\"突然挂掉了\",{\"1\":{\"1205\":1}}],[\"弄丢了消息\",{\"0\":{\"1206\":1}}],[\"却在这个时候挂了\",{\"1\":{\"1380\":1}}],[\"却被自动提交了\",{\"1\":{\"1205\":1}}],[\"却不知道这条语句在\",{\"1\":{\"81\":1}}],[\"副本中和\",{\"1\":{\"1206\":1}}],[\"副本中拉取消息进行同步\",{\"1\":{\"1197\":1,\"1206\":2}}],[\"副本发生故障时就不会从\",{\"1\":{\"1206\":1}}],[\"副本发生故障时会从\",{\"1\":{\"1197\":1}}],[\"副本之间的消息同步情况不一样\",{\"1\":{\"1206\":1}}],[\"副本能同步消息\",{\"1\":{\"1206\":1}}],[\"副本能有\",{\"1\":{\"1206\":1}}],[\"副本接收之后就算被成功发送\",{\"1\":{\"1206\":1}}],[\"副本的同步的话\",{\"1\":{\"1206\":1}}],[\"副本的拷贝\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"副本重新选出一个\",{\"1\":{\"1206\":1}}],[\"副本所在的\",{\"1\":{\"1206\":1}}],[\"副本交互\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"副本才能从\",{\"1\":{\"1197\":1,\"1206\":2}}],[\"副本\",{\"1\":{\"1197\":1,\"1206\":2}}],[\"划重点\",{\"1\":{\"1196\":1}}],[\"划分出来的一块作为存储空间的内存\",{\"1\":{\"444\":1}}],[\"划分内存空间以及有优先级的区域回收方式\",{\"1\":{\"407\":1}}],[\"划分的内存单元如下图所示\",{\"1\":{\"218\":1}}],[\"浪费资源不说\",{\"1\":{\"1193\":1}}],[\"题外话\",{\"1\":{\"1192\":1}}],[\"逐步修复完善\",{\"1\":{\"1191\":1}}],[\"逐个攻破\",{\"1\":{\"80\":1}}],[\"慎用\",{\"1\":{\"1183\":1}}],[\"环形数组\",{\"1\":{\"1182\":1,\"1184\":1}}],[\"环境然后自己进\",{\"1\":{\"1199\":1}}],[\"环境信息\",{\"1\":{\"377\":1}}],[\"环境\",{\"1\":{\"242\":1}}],[\"拼多多等大厂\",{\"1\":{\"1177\":1}}],[\"淘宝\",{\"1\":{\"1177\":1}}],[\"圆梦\",{\"1\":{\"1177\":1}}],[\"麻雀虽小五脏俱全\",{\"1\":{\"1173\":1}}],[\"麻省理工学院的\",{\"1\":{\"1066\":1}}],[\"篇文章来讲解如何从零开始基于\",{\"1\":{\"1173\":1}}],[\"篇幅问题\",{\"1\":{\"744\":1}}],[\"北极星\",{\"1\":{\"1170\":1}}],[\"据说在新浪微博正支撑着千亿次调用\",{\"1\":{\"1169\":1}}],[\"桩\",{\"1\":{\"1166\":5}}],[\"仿佛是\",{\"1\":{\"1358\":1}}],[\"仿佛又回到了文章开头的样子\",{\"1\":{\"1155\":1}}],[\"仿制券码\",{\"1\":{\"19\":1}}],[\"端写入的消息主体内容\",{\"1\":{\"1315\":1}}],[\"端\",{\"1\":{\"1155\":1}}],[\"端口什么的\",{\"1\":{\"1390\":1}}],[\"端口的过程\",{\"1\":{\"1157\":1}}],[\"端口\",{\"1\":{\"1151\":1,\"1157\":1}}],[\"卫士\",{\"1\":{\"1155\":1}}],[\"管家\",{\"1\":{\"1155\":1}}],[\"管理界面\",{\"1\":{\"1246\":1}}],[\"管理着计算资源和网络通信\",{\"1\":{\"1218\":1}}],[\"管理着任务执行的情况\",{\"1\":{\"900\":1}}],[\"管理的\",{\"1\":{\"1184\":1}}],[\"管理\",{\"1\":{\"7\":1,\"8\":1,\"1281\":1,\"1362\":1}}],[\"管理工具\",{\"1\":{\"7\":1,\"372\":1}}],[\"岂不美哉\",{\"1\":{\"1154\":1}}],[\"造出来的\",{\"1\":{\"1154\":1}}],[\"造成数据的不一致\",{\"1\":{\"972\":1}}],[\"造成了这个现象\",{\"1\":{\"412\":1}}],[\"造成了浪费\",{\"1\":{\"256\":1}}],[\"造成的阻塞问题还会进一步影响到主从同步和集群扩容\",{\"1\":{\"292\":1}}],[\"造成的阻塞问题如下\",{\"1\":{\"163\":1}}],[\"造成不必要的切换\",{\"1\":{\"167\":1}}],[\"造成这个问题的原因是我们在学习\",{\"1\":{\"144\":1}}],[\"互相都认就可以了\",{\"1\":{\"1152\":1}}],[\"互斥条件\",{\"1\":{\"823\":1}}],[\"互斥\",{\"1\":{\"47\":1,\"61\":1,\"63\":1}}],[\"截取出来后它们就是我们真正要传输的\",{\"1\":{\"1152\":1}}],[\"粘包问题\",{\"1\":{\"1152\":1}}],[\"烦恼\",{\"1\":{\"1152\":1}}],[\"夏洛特\",{\"1\":{\"1152\":1}}],[\"夏洛特烦恼\",{\"1\":{\"1152\":1}}],[\"夏洛\",{\"1\":{\"1152\":2}}],[\"八股文常背\",{\"1\":{\"1152\":1}}],[\"光这样一个纯裸的\",{\"1\":{\"1151\":1}}],[\"握手建立连接流程\",{\"1\":{\"1151\":1}}],[\"电脑的进程\",{\"1\":{\"1151\":1}}],[\"电脑的进程发一段数据到\",{\"1\":{\"1151\":1}}],[\"聊起\",{\"0\":{\"1151\":1}}],[\"聊聊\",{\"1\":{\"868\":1}}],[\"懂的人不需要看\",{\"1\":{\"1150\":1}}],[\"谈谈你对这些序列化协议了解\",{\"0\":{\"1147\":1}}],[\"谈谈你的理解\",{\"0\":{\"975\":1}}],[\"轮询算法就是向消息指定的\",{\"1\":{\"1299\":1}}],[\"轮询算法\",{\"1\":{\"1299\":1}}],[\"轮询\",{\"1\":{\"1255\":1,\"1281\":1}}],[\"轮询就是把请求依次分配给每个服务提供者\",{\"1\":{\"1144\":1}}],[\"轮转调度\",{\"1\":{\"820\":1}}],[\"谁知道后面误打误撞在消息队列领域占据了一席之地\",{\"1\":{\"1191\":1}}],[\"谁的处理速度就越快\",{\"1\":{\"1142\":1}}],[\"谁也无从得知\",{\"1\":{\"1090\":1}}],[\"领导者\",{\"1\":{\"1378\":1}}],[\"领导人选举\",{\"0\":{\"1111\":1}}],[\"领域还是很少有技术银弹的说法\",{\"1\":{\"1303\":1}}],[\"领域模型中非常重要的一个概念\",{\"1\":{\"1129\":1}}],[\"暴露服务的服务提供方\",{\"1\":{\"1128\":1}}],[\"暴露给组织以外的开发人员\",{\"1\":{\"2\":1}}],[\"拆分成多个子服务\",{\"1\":{\"1367\":1}}],[\"拆分多个\",{\"1\":{\"1262\":1}}],[\"拆分之后的每个服务可以部署在不同的机器上\",{\"1\":{\"1125\":1}}],[\"拆分为多个\",{\"1\":{\"294\":1}}],[\"登录系统等等\",{\"1\":{\"1125\":1}}],[\"垂直应用架构无法满足我们的需求\",{\"1\":{\"1123\":1}}],[\"评选活动中\",{\"1\":{\"1122\":1}}],[\"智能容错和负载均衡\",{\"1\":{\"1122\":1}}],[\"欢迎在评论区指出\",{\"1\":{\"1319\":1,\"1341\":1}}],[\"欢迎补充\",{\"1\":{\"1120\":1}}],[\"欢迎指出\",{\"1\":{\"416\":1}}],[\"失效\",{\"1\":{\"1120\":1}}],[\"失败则返回\",{\"1\":{\"1007\":2}}],[\"失败则返回false\",{\"1\":{\"744\":3}}],[\"失败则加入阻塞队列\",{\"1\":{\"906\":1}}],[\"失败则加入等待队列\",{\"1\":{\"748\":1,\"752\":1}}],[\"失败则自旋保证成功\",{\"1\":{\"577\":1}}],[\"失败\",{\"1\":{\"533\":1,\"1002\":1}}],[\"演讲后\",{\"1\":{\"1178\":1}}],[\"演进而来\",{\"1\":{\"1120\":1}}],[\"演示使用\",{\"1\":{\"24\":2}}],[\"崩溃恢复模式\",{\"0\":{\"1380\":1}}],[\"崩溃恢复\",{\"1\":{\"1361\":1,\"1377\":1,\"1378\":1,\"1380\":3,\"1391\":1}}],[\"崩溃恢复和消息广播\",{\"0\":{\"1361\":1}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"89\":1}}],[\"崩溃退出与重启等异常情况时\",{\"1\":{\"1356\":1,\"1361\":1}}],[\"崩溃等问题\",{\"1\":{\"1139\":1}}],[\"崩溃\",{\"1\":{\"1115\":2}}],[\"赢得选举的条件是\",{\"1\":{\"1111\":1}}],[\"赢得选举\",{\"1\":{\"1111\":1}}],[\"赢得了选举\",{\"1\":{\"1109\":1}}],[\"周期性发送心跳来保证自己的\",{\"1\":{\"1111\":1}}],[\"周志明先生在\",{\"1\":{\"387\":1}}],[\"投票已经超过半数\",{\"1\":{\"1380\":1}}],[\"投票内容为服务器的\",{\"1\":{\"1380\":1}}],[\"投票也是为了进行写请求\",{\"1\":{\"1378\":1}}],[\"投票给自己\",{\"1\":{\"1380\":1}}],[\"投票给\",{\"1\":{\"1108\":1}}],[\"投递成功消息后\",{\"1\":{\"1306\":1}}],[\"投递方式在消费者分组中统一配置\",{\"1\":{\"1297\":1}}],[\"投递顺序性\",{\"1\":{\"1297\":2}}],[\"投递和查询以及服务高可用保证\",{\"1\":{\"1281\":1}}],[\"投递消息给指定\",{\"1\":{\"251\":1}}],[\"投稿\",{\"1\":{\"1267\":1,\"1366\":1}}],[\"倒计时一结束\",{\"1\":{\"1105\":1}}],[\"倒计时器\",{\"0\":{\"750\":1}}],[\"拜占庭将军\",{\"0\":{\"1105\":1}}],[\"拜占庭将军问题\",{\"1\":{\"1097\":1,\"1369\":1}}],[\"幸运的是\",{\"1\":{\"1104\":1}}],[\"幸存代占新生代的\",{\"1\":{\"455\":1}}],[\"幸存代\",{\"1\":{\"453\":1}}],[\"思想的共识算法\",{\"1\":{\"1099\":1}}],[\"思想的核心\",{\"1\":{\"1099\":1}}],[\"思想缺少代码实现的必要细节\",{\"1\":{\"1099\":1}}],[\"思想\",{\"0\":{\"1099\":1},\"1\":{\"1097\":2,\"1099\":1}}],[\"思否\",{\"1\":{\"486\":1}}],[\"达成一致\",{\"1\":{\"1372\":1}}],[\"达成一致的看法\",{\"1\":{\"1097\":1}}],[\"达成共识\",{\"1\":{\"1097\":1}}],[\"达到微秒级\",{\"1\":{\"1240\":2}}],[\"达到压缩的目的\",{\"1\":{\"230\":1}}],[\"达到配置的失败阈值后\",{\"1\":{\"2\":1}}],[\"言语中还略显调侃之意\",{\"1\":{\"1096\":1}}],[\"论文发表之后\",{\"1\":{\"1096\":1}}],[\"审稿人并不认可这篇论文的幽默\",{\"1\":{\"1096\":1}}],[\"兰伯特当时提出的\",{\"1\":{\"1097\":2}}],[\"兰伯特专门又写了一篇\",{\"1\":{\"1096\":1}}],[\"兰伯特专门写了一篇幽默风趣的论文\",{\"1\":{\"1096\":1}}],[\"兰伯特在\",{\"1\":{\"1096\":1}}],[\"兰伯特就把论文发给了他们\",{\"1\":{\"1096\":1}}],[\"兰伯特一听就不开心了\",{\"1\":{\"1096\":1}}],[\"兰伯特\",{\"1\":{\"1096\":1}}],[\"莱斯利\",{\"1\":{\"1096\":1}}],[\"宕机需要重新选举\",{\"1\":{\"1380\":1}}],[\"宕机\",{\"1\":{\"1281\":2}}],[\"宕机或者重启\",{\"1\":{\"1090\":1}}],[\"宕机都会导致消息丢失\",{\"1\":{\"251\":1}}],[\"谣言传播比较适合节点数量比较多的情况\",{\"1\":{\"1088\":1}}],[\"谣言传播指的是分布式系统中的一个节点一旦有了新数据之后\",{\"1\":{\"1088\":1}}],[\"谣言传播\",{\"0\":{\"1088\":1},\"1\":{\"1087\":1,\"1089\":1,\"1091\":1}}],[\"伪代码如下\",{\"1\":{\"1087\":1,\"1088\":1}}],[\"伪代码是下面这样的\",{\"1\":{\"909\":1}}],[\"推\",{\"1\":{\"1281\":1}}],[\"推送数据给\",{\"1\":{\"1087\":2}}],[\"推送数据给节点\",{\"1\":{\"1087\":1}}],[\"推拉就是同时修复自己副本和对方副本中的熵\",{\"1\":{\"1087\":1}}],[\"推给对方\",{\"1\":{\"1087\":1}}],[\"推方式\",{\"1\":{\"1087\":1}}],[\"推荐奇数个\",{\"1\":{\"1380\":1}}],[\"推荐大家阅读一下\",{\"1\":{\"1343\":1}}],[\"推荐实现\",{\"1\":{\"1286\":1}}],[\"推荐小伙伴们看看\",{\"1\":{\"1140\":1}}],[\"推荐文章\",{\"1\":{\"799\":1}}],[\"推荐显示指定大小\",{\"1\":{\"478\":1}}],[\"推荐资料\",{\"1\":{\"359\":1}}],[\"推荐阅读下面这两篇文章\",{\"1\":{\"604\":1}}],[\"推荐阅读\",{\"0\":{\"360\":1,\"1071\":1},\"1\":{\"341\":1,\"486\":1,\"868\":1,\"1236\":1}}],[\"推荐阅读官方文档\",{\"1\":{\"7\":1}}],[\"推荐使用构造方法创建\",{\"1\":{\"909\":1}}],[\"推荐使用for\",{\"1\":{\"732\":1}}],[\"推荐使用并发集合类\",{\"1\":{\"651\":1}}],[\"推荐使用\",{\"1\":{\"53\":1,\"685\":1,\"944\":1}}],[\"推荐使用我们上面提到的\",{\"1\":{\"50\":1}}],[\"推荐\",{\"1\":{\"8\":1,\"29\":1,\"267\":1,\"634\":1,\"778\":2,\"779\":2,\"888\":1,\"896\":1,\"897\":1,\"937\":1,\"1166\":1,\"1202\":1}}],[\"熵最好理解为不确定性的量度而不是确定性的量度\",{\"1\":{\"1087\":1}}],[\"熵的概念最早起源于物理学\",{\"1\":{\"1087\":1}}],[\"疑似下线状态\",{\"1\":{\"1085\":1}}],[\"癌细胞扩散等生活中常见的情景\",{\"1\":{\"1084\":1}}],[\"别急别急\",{\"1\":{\"1276\":1}}],[\"别急\",{\"1\":{\"1275\":1,\"1386\":1,\"1390\":1}}],[\"别告诉我你连队列都不知道是啥吧\",{\"1\":{\"1268\":1}}],[\"别的\",{\"1\":{\"1263\":1}}],[\"别名很多\",{\"1\":{\"1084\":1}}],[\"别忘了在我们最初的架构图中\",{\"1\":{\"1314\":1}}],[\"别忘了在\",{\"1\":{\"1305\":1}}],[\"别忘了头结点是虚节点\",{\"1\":{\"1012\":1}}],[\"别忘记关闭线程池\",{\"0\":{\"924\":1}}],[\"别忘记给线程池命名\",{\"0\":{\"920\":1}}],[\"疫情传播算法\",{\"1\":{\"1084\":1}}],[\"疫情期间\",{\"1\":{\"19\":1}}],[\"背景\",{\"0\":{\"1083\":1,\"1096\":1,\"1104\":1}}],[\"业界已经有了比较出名的实现\",{\"1\":{\"1099\":1}}],[\"业界比较推崇是最终一致性级别\",{\"1\":{\"1078\":1}}],[\"业务功能丰富\",{\"1\":{\"1236\":1}}],[\"业务场景来手动配置线程池的参数比如核心线程数\",{\"1\":{\"917\":1}}],[\"业务代码\",{\"1\":{\"848\":3}}],[\"业务代码中记录分析\",{\"1\":{\"298\":1}}],[\"业务类型\",{\"1\":{\"34\":1}}],[\"仍需要保持系统整体\",{\"1\":{\"1074\":1}}],[\"仍然能够对外提供服务\",{\"1\":{\"1067\":1}}],[\"仍然能够把数据恢复回来\",{\"1\":{\"89\":1}}],[\"仍然保留获取锁的可能\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"仍然还有停顿\",{\"1\":{\"401\":1}}],[\"仍然用前面的\",{\"1\":{\"89\":1}}],[\"神一样的\",{\"1\":{\"1071\":1}}],[\"神的如何设置线程池参数\",{\"1\":{\"896\":1}}],[\"英文\",{\"1\":{\"1071\":2}}],[\"英语\",{\"1\":{\"585\":1,\"1218\":1}}],[\"丢弃标签\",{\"1\":{\"1254\":1}}],[\"丢弃\",{\"1\":{\"1213\":1}}],[\"丢包\",{\"1\":{\"1069\":1}}],[\"丢失的可能性非常低\",{\"1\":{\"1240\":1}}],[\"丢失\",{\"1\":{\"89\":1,\"1240\":1}}],[\"平时上网在浏览器上敲个网址就能访问网页\",{\"1\":{\"1154\":1}}],[\"平等的\",{\"1\":{\"1069\":1}}],[\"平台创建\",{\"1\":{\"1226\":1}}],[\"平台的具体实现必须要按照\",{\"1\":{\"974\":1}}],[\"平台线程和系统内核线程的关系\",{\"1\":{\"1053\":1}}],[\"平台线程和系统内核线程的关系图如下所示\",{\"1\":{\"1053\":1}}],[\"平台线程可以切换到执行另一个虚拟线程\",{\"1\":{\"1053\":1}}],[\"平台线程\",{\"1\":{\"808\":1}}],[\"平台增加了\",{\"1\":{\"529\":1}}],[\"平台无关性\",{\"1\":{\"515\":1}}],[\"平台开发\",{\"1\":{\"377\":1}}],[\"平台下也是受限制的\",{\"1\":{\"368\":1}}],[\"平台\",{\"1\":{\"6\":1}}],[\"猜想的时候\",{\"1\":{\"1067\":1}}],[\"教授在分布式计算原理研讨会\",{\"1\":{\"1066\":1}}],[\"呜呜\",{\"1\":{\"1062\":1}}],[\"吗\",{\"1\":{\"1062\":1,\"1383\":1,\"1387\":1,\"1388\":1}}],[\"吐槽\",{\"1\":{\"1062\":1}}],[\"协调者收到参与者返回的消息后\",{\"1\":{\"1371\":1}}],[\"协调者收到所有参与者返回的事务提交成功的响应之后则完成事务\",{\"1\":{\"1371\":1}}],[\"协调者根据参与者返回的响应来决定是否可以进行下面的\",{\"1\":{\"1371\":1}}],[\"协调者向所有参与者发送\",{\"1\":{\"1371\":1}}],[\"协调者只发送了一部分的\",{\"1\":{\"1370\":1}}],[\"协调者此时会给所有的参与者发送\",{\"1\":{\"1370\":1}}],[\"协调服务\",{\"1\":{\"1367\":1}}],[\"协程需要编程语言或库提供支持\",{\"1\":{\"1056\":1}}],[\"协议中对\",{\"1\":{\"1378\":1}}],[\"协议中相\",{\"1\":{\"1253\":1}}],[\"协议之前\",{\"1\":{\"1378\":1}}],[\"协议完成的\",{\"1\":{\"1367\":1}}],[\"协议分析\",{\"1\":{\"1361\":1}}],[\"协议就会退出恢复模式\",{\"1\":{\"1361\":1}}],[\"协议就会进入恢复模式并选举产生新的\",{\"1\":{\"1361\":1}}],[\"协议就是在\",{\"1\":{\"1161\":1}}],[\"协议包括两种基本的模式\",{\"1\":{\"1361\":1}}],[\"协议两种基本的模式\",{\"0\":{\"1361\":1}}],[\"协议来实现分布式数据一致性\",{\"1\":{\"1360\":1}}],[\"协议来实现集群中各个节点数据的最终一致性\",{\"1\":{\"1085\":1}}],[\"协议是如何处理写请求的\",{\"1\":{\"1379\":1}}],[\"协议是为分布式协调服务\",{\"1\":{\"1360\":1}}],[\"协议是一种允许在分布式系统中共享状态的通信协议\",{\"1\":{\"1091\":1}}],[\"协议是一种允许在分布式系统中共享状态的去中心化通信协议\",{\"1\":{\"1084\":1}}],[\"协议并不像\",{\"1\":{\"1359\":1}}],[\"协议作为其保证数据一致性的核心算法\",{\"1\":{\"1359\":1}}],[\"协议以及\",{\"1\":{\"1257\":1}}],[\"协议实现的\",{\"1\":{\"1230\":1}}],[\"协议还不够\",{\"1\":{\"1381\":1}}],[\"协议还提供了另外\",{\"1\":{\"1222\":1}}],[\"协议还要好\",{\"1\":{\"1159\":1}}],[\"协议标准而设计\",{\"1\":{\"1170\":1}}],[\"协议打交道\",{\"1\":{\"1167\":1}}],[\"协议都要好\",{\"1\":{\"1161\":1}}],[\"协议都已经跑了好些年了\",{\"1\":{\"1160\":1}}],[\"协议进行通讯\",{\"1\":{\"1161\":1}}],[\"协议一般还会再建个\",{\"1\":{\"1158\":1}}],[\"协议为例\",{\"1\":{\"1158\":1}}],[\"协议为什么要有\",{\"1\":{\"1155\":1}}],[\"协议底层使用\",{\"1\":{\"1154\":1}}],[\"协议又叫做\",{\"1\":{\"1154\":1}}],[\"协议用的好好的\",{\"1\":{\"1150\":1}}],[\"协议被\",{\"1\":{\"1091\":1}}],[\"协议强调的是最终一致\",{\"1\":{\"1090\":1}}],[\"协议理解起来非常简单\",{\"1\":{\"1090\":1}}],[\"协议优势和缺陷\",{\"0\":{\"1090\":1}}],[\"协议消息传播模式\",{\"0\":{\"1086\":1}}],[\"协议互相探测健康状态\",{\"1\":{\"1085\":1}}],[\"协议的服务器启动后加入到集群中时\",{\"1\":{\"1361\":1}}],[\"协议的三层\",{\"1\":{\"1253\":1}}],[\"协议的\",{\"1\":{\"1200\":1,\"1235\":1,\"1253\":1,\"1344\":1}}],[\"协议的实际应用\",{\"1\":{\"1085\":1}}],[\"协议的定义做一个总结\",{\"1\":{\"1084\":1}}],[\"协议有助于我们搞清很多技术的底层原理\",{\"1\":{\"1085\":1}}],[\"协议应用\",{\"0\":{\"1085\":1}}],[\"协议下这些节点都是平等的\",{\"1\":{\"1090\":1}}],[\"协议下\",{\"1\":{\"1084\":1}}],[\"协议其名一样\",{\"1\":{\"1084\":1}}],[\"协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据\",{\"1\":{\"1084\":1}}],[\"协议最高层\",{\"1\":{\"1253\":1}}],[\"协议最早是在\",{\"1\":{\"1084\":1}}],[\"协议最主要的特点\",{\"1\":{\"1084\":1}}],[\"协议介绍\",{\"0\":{\"1084\":1,\"1360\":1}}],[\"协议详解\",{\"0\":{\"1082\":1}}],[\"协议\",{\"0\":{\"1150\":1,\"1160\":1,\"1174\":1},\"1\":{\"968\":1,\"981\":1,\"1083\":1,\"1084\":2,\"1085\":2,\"1092\":1,\"1097\":2,\"1150\":2,\"1151\":1,\"1152\":1,\"1154\":3,\"1155\":2,\"1158\":1,\"1161\":2,\"1168\":1,\"1174\":1,\"1231\":1,\"1237\":1,\"1246\":1,\"1354\":1,\"1361\":1}}],[\"协议和\",{\"0\":{\"1359\":1},\"1\":{\"244\":1}}],[\"协议做分布式共识\",{\"1\":{\"8\":1}}],[\"协议转换\",{\"1\":{\"2\":1}}],[\"协议转换等功能\",{\"1\":{\"1\":1}}],[\"载体线程\",{\"1\":{\"1053\":1}}],[\"载入\",{\"1\":{\"972\":1}}],[\"探测式清理是以当前entry\",{\"1\":{\"1042\":1}}],[\"探测式清理\",{\"1\":{\"1042\":1}}],[\"探测式清理和启发式清理\",{\"1\":{\"1037\":1}}],[\"探测式清理和启发式清理流程\",{\"1\":{\"1026\":1}}],[\"触发回调函数进行重新选举\",{\"1\":{\"1387\":1}}],[\"触发了分区\",{\"1\":{\"1207\":1}}],[\"触发一次探测式数据回收操作\",{\"1\":{\"1040\":1}}],[\"触发器\",{\"1\":{\"82\":1}}],[\"槽位的数据清空\",{\"1\":{\"1037\":1}}],[\"槽位数据不为空\",{\"1\":{\"1035\":3}}],[\"刚被探测式清理掉的数据\",{\"1\":{\"1037\":1}}],[\"沿途中碰到未过期的数据则将此数据rehash后重新在table数组中定位\",{\"1\":{\"1037\":1}}],[\"沿用上一个任务的线程池\",{\"1\":{\"779\":1}}],[\"碰到正常数据\",{\"1\":{\"1037\":1}}],[\"碰到\",{\"1\":{\"1036\":1}}],[\"碰到桶中entry=null的情况\",{\"1\":{\"1036\":1}}],[\"碰到一个过期的桶\",{\"1\":{\"1036\":1}}],[\"碰到null则结束探测\",{\"1\":{\"1035\":1}}],[\"碰撞解决方法\",{\"1\":{\"692\":1}}],[\"碰撞\",{\"1\":{\"686\":1}}],[\"碰撞的判断\",{\"1\":{\"686\":1}}],[\"遇到值为null则结束清理\",{\"1\":{\"1042\":1}}],[\"遇到了index=7的槽位数据entry的key=null\",{\"1\":{\"1035\":1}}],[\"遇到了key\",{\"1\":{\"1035\":1}}],[\"遇到key过期的entry\",{\"1\":{\"1035\":1}}],[\"遇到的坑\",{\"1\":{\"1026\":1}}],[\"白色块表示entry为null\",{\"1\":{\"1033\":1}}],[\"灰色块代表entry的key值为null\",{\"1\":{\"1033\":1}}],[\"灰度发布\",{\"1\":{\"2\":1}}],[\"绿色块entry代表正常数据\",{\"1\":{\"1033\":1}}],[\"黄金分割数\",{\"1\":{\"1032\":1}}],[\"证明其实还是有强引用存在的\",{\"1\":{\"1030\":1}}],[\"证书部署到\",{\"1\":{\"2\":1}}],[\"证书管理\",{\"1\":{\"2\":1}}],[\"哪冒出来的\",{\"1\":{\"1379\":1}}],[\"哪怕你上面的都没看懂也千万要记住这六个字\",{\"1\":{\"1274\":1}}],[\"哪怕内存不足的时候\",{\"1\":{\"1030\":1}}],[\"哪些组件用到了\",{\"0\":{\"1181\":1}}],[\"哪些已经死去\",{\"1\":{\"445\":1}}],[\"哪些对象可以作为\",{\"1\":{\"391\":1}}],[\"哪些对象应放在老年代中\",{\"1\":{\"386\":1}}],[\"哪些情况可能会导致\",{\"0\":{\"317\":1}}],[\"冲突的数据挂载到链表上\",{\"1\":{\"1033\":1}}],[\"冲突的情况\",{\"1\":{\"22\":1}}],[\"冲突\",{\"0\":{\"1033\":1}}],[\"冲突如何解决\",{\"1\":{\"1026\":1}}],[\"敲门砖\",{\"1\":{\"1021\":1}}],[\"考虑以下三种情况\",{\"1\":{\"1013\":1}}],[\"考虑到之前内部很多项目都是使用动物的名字来命名的\",{\"1\":{\"1343\":1}}],[\"考虑到很多小伙伴不知道注册中心是干嘛的\",{\"1\":{\"1069\":1}}],[\"考虑到很多读者不太了解二者的区别\",{\"1\":{\"808\":1}}],[\"考虑到这些接口之间有大部分都是\",{\"1\":{\"772\":1}}],[\"考虑到运营活动的频率\",{\"1\":{\"19\":1}}],[\"靠前驱节点判断当前线程是否应该被阻塞\",{\"1\":{\"1012\":1}}],[\"靠按序申请资源来预防\",{\"1\":{\"824\":1}}],[\"何必增加那一个不必要的\",{\"1\":{\"1357\":1}}],[\"何况几乎是全世界这个领域的事实性规范\",{\"1\":{\"1240\":1}}],[\"何谓\",{\"1\":{\"1170\":1}}],[\"何时出队列\",{\"1\":{\"1012\":1}}],[\"何为顺序性\",{\"1\":{\"1379\":1}}],[\"何为集群脑裂\",{\"1\":{\"1358\":1}}],[\"何为微内核架构呢\",{\"1\":{\"1132\":1}}],[\"何为线程\",{\"0\":{\"807\":1}}],[\"何为进程\",{\"0\":{\"806\":1}}],[\"申请锁\",{\"1\":{\"1011\":1}}],[\"申请一个新的数组\",{\"1\":{\"562\":1}}],[\"置为当前队列的尾节点\",{\"1\":{\"1011\":1}}],[\"抢锁成功\",{\"1\":{\"1007\":1}}],[\"抢占式的\",{\"1\":{\"747\":1,\"905\":1}}],[\"枚举\",{\"1\":{\"1005\":1}}],[\"蓝色部分为本篇文章主要剖析的点\",{\"1\":{\"1001\":1}}],[\"讲到这里\",{\"1\":{\"1315\":1}}],[\"讲完了消息模型\",{\"1\":{\"1281\":1}}],[\"讲\",{\"1\":{\"996\":1}}],[\"嘿嘿嘿\",{\"1\":{\"1389\":1}}],[\"嘿\",{\"1\":{\"982\":1}}],[\"书写在前面的操作\",{\"1\":{\"975\":1}}],[\"书中的部分内容来总结一下使用线程池的好处\",{\"1\":{\"933\":1}}],[\"意外宕机的时候会丢失部分数据\",{\"1\":{\"1313\":1}}],[\"意外重启等等\",{\"1\":{\"1303\":1}}],[\"意思就是在多台机器上启动多个\",{\"1\":{\"1263\":1}}],[\"意思为可重入锁\",{\"1\":{\"1001\":1}}],[\"意为同步状态\",{\"1\":{\"1006\":1}}],[\"意义不大\",{\"1\":{\"975\":1}}],[\"意味着我们有更大的几率获取\",{\"1\":{\"1315\":1}}],[\"意味着这是第一次添加元素\",{\"1\":{\"729\":1}}],[\"意味着它可以保证多个线程同时对它进行读写操作时\",{\"1\":{\"694\":1}}],[\"意味着你使用\",{\"1\":{\"219\":1}}],[\"遵守既定规则编码即可\",{\"1\":{\"974\":1}}],[\"遵循\",{\"1\":{\"747\":1,\"905\":1}}],[\"于此线程的每一个动作\",{\"1\":{\"975\":1}}],[\"于后面对这个\",{\"1\":{\"975\":1}}],[\"于加锁\",{\"1\":{\"975\":1}}],[\"于书写在后面的操作\",{\"1\":{\"975\":1}}],[\"于\",{\"1\":{\"974\":1}}],[\"于是基于\",{\"1\":{\"1152\":1}}],[\"于是我们会把每条要发送的数据都包装一下\",{\"1\":{\"1152\":1}}],[\"于是我单独抽了一篇文章来总结\",{\"1\":{\"263\":1,\"831\":1}}],[\"于是就有了各种协议\",{\"1\":{\"1161\":1}}],[\"于是就到网上去搜\",{\"1\":{\"1150\":1}}],[\"于是就在\",{\"1\":{\"1040\":1}}],[\"于是乎\",{\"1\":{\"1096\":1}}],[\"于是将\",{\"1\":{\"603\":1}}],[\"于是将数据存放进去\",{\"1\":{\"535\":1}}],[\"于是队列可以存放新数据了\",{\"1\":{\"535\":1}}],[\"于是阻塞队列就将当前线程挂起\",{\"1\":{\"535\":1}}],[\"于是生产者将队列塞满后再次尝试将数据存入队列\",{\"1\":{\"535\":1}}],[\"于是引用计数算法无法通知\",{\"1\":{\"390\":1}}],[\"于是\",{\"1\":{\"15\":1,\"60\":1,\"235\":1,\"412\":1,\"968\":1,\"1083\":1,\"1096\":2,\"1155\":1}}],[\"诞生初衷是为了解决内存队列的性能和内存安全问题\",{\"1\":{\"1178\":1}}],[\"诞生\",{\"1\":{\"972\":1}}],[\"寄存器以及其他的硬件和编译器优化\",{\"1\":{\"972\":1}}],[\"极高的可用性以及可靠性\",{\"1\":{\"1240\":1}}],[\"极低的发布延迟和端到端延迟\",{\"1\":{\"1238\":1}}],[\"极致的性能\",{\"1\":{\"1191\":1}}],[\"极端情况下\",{\"1\":{\"957\":1}}],[\"极客时间\",{\"1\":{\"221\":1,\"1214\":1}}],[\"几种常见的内置线程池\",{\"0\":{\"947\":1}}],[\"几个常见的对比\",{\"0\":{\"942\":1}}],[\"几乎支持所有常用语言\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"几乎全是线程等待时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"几乎所有对象都在这里分配内存\",{\"1\":{\"813\":1}}],[\"几乎所有的对象实例以及数组都在这里分配内存\",{\"1\":{\"477\":1,\"495\":1}}],[\"几乎完全重写了\",{\"1\":{\"691\":1}}],[\"几乎\",{\"1\":{\"495\":1}}],[\"几乎可以忽略不计\",{\"1\":{\"1\":1}}],[\"务必拿着小本本记清楚\",{\"1\":{\"936\":1}}],[\"逃逸是指在构造函数返回之前其他线程就持有该对象的引用\",{\"1\":{\"934\":1}}],[\"逃逸问题\",{\"1\":{\"934\":1}}],[\"框架自动重试导致的\",{\"1\":{\"1303\":1}}],[\"框架功能\",{\"1\":{\"1172\":1}}],[\"框架设计\",{\"1\":{\"1169\":1}}],[\"框架指的是可以让客户端直接调用服务端方法\",{\"1\":{\"1167\":1}}],[\"框架完成\",{\"1\":{\"1007\":1}}],[\"框架共分为五层\",{\"1\":{\"1003\":1}}],[\"框架\",{\"0\":{\"1167\":1,\"1173\":1},\"1\":{\"1003\":2,\"1122\":1,\"1167\":1,\"1169\":1,\"1170\":1,\"1172\":1,\"1173\":2,\"1218\":1,\"1238\":1,\"1271\":1}}],[\"框架最核心的类\",{\"1\":{\"935\":1}}],[\"框架的话\",{\"1\":{\"1172\":1}}],[\"框架的核心原理讲清楚了\",{\"1\":{\"1166\":1}}],[\"框架的处理流程\",{\"1\":{\"1002\":1}}],[\"框架的使用示意图\",{\"1\":{\"934\":2}}],[\"框架的工具类\",{\"1\":{\"888\":1,\"937\":1}}],[\"框架结构主要由三大部分组成\",{\"1\":{\"934\":1}}],[\"框架让并发编程变得更加简单\",{\"1\":{\"934\":1}}],[\"框架不仅包括了线程池的管理\",{\"1\":{\"934\":1}}],[\"框架是\",{\"1\":{\"934\":1}}],[\"框架介绍\",{\"0\":{\"934\":1}}],[\"脏数据\",{\"1\":{\"929\":1}}],[\"脏读1000+2000\",{\"1\":{\"127\":1}}],[\"脏读就是指当一个事务正在访问数据\",{\"1\":{\"127\":1}}],[\"脏读\",{\"0\":{\"127\":1},\"1\":{\"132\":4}}],[\"停止处理排队的任务并返回正在等待执行的\",{\"1\":{\"924\":1}}],[\"停顿时间\",{\"1\":{\"407\":1}}],[\"停顿时间要求的同时\",{\"1\":{\"407\":1}}],[\"风险\",{\"1\":{\"917\":1}}],[\"什么区别\",{\"0\":{\"1180\":1}}],[\"什么叫允许损失部分可用性呢\",{\"1\":{\"1076\":1}}],[\"什么情况下桶才是可以使用的呢\",{\"1\":{\"1036\":1}}],[\"什么情况下会对\",{\"1\":{\"1013\":1}}],[\"什么时候提交\",{\"1\":{\"1207\":1}}],[\"什么时候会把一个节点的\",{\"1\":{\"1012\":1}}],[\"什么时候可以有机会获取锁呢\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"什么关系\",{\"0\":{\"976\":1}}],[\"什么异步\",{\"1\":{\"909\":1}}],[\"什么场景下用的\",{\"0\":{\"909\":1}}],[\"什么是回溯消费\",{\"0\":{\"1306\":1}}],[\"什么是优先级队列\",{\"0\":{\"1258\":1}}],[\"什么是延迟队列\",{\"0\":{\"1257\":1}}],[\"什么是死信队列\",{\"0\":{\"1256\":1}}],[\"什么是消息队列\",{\"0\":{\"1218\":1}}],[\"什么是负载均衡\",{\"0\":{\"1139\":1}}],[\"什么是网络分区\",{\"1\":{\"1067\":1}}],[\"什么是网关\",{\"0\":{\"1\":1}}],[\"什么是虚拟线程\",{\"0\":{\"1052\":1}}],[\"什么是本地内存\",{\"1\":{\"972\":1}}],[\"什么是主内存\",{\"1\":{\"972\":1}}],[\"什么是指令重排序\",{\"1\":{\"969\":1}}],[\"什么是乐观锁\",{\"0\":{\"838\":1,\"987\":1}}],[\"什么是悲观锁\",{\"0\":{\"837\":1,\"986\":1}}],[\"什么是线程池\",{\"0\":{\"886\":1}}],[\"什么是线程死锁\",{\"0\":{\"822\":1}}],[\"什么是线程上下文切换\",{\"0\":{\"821\":1}}],[\"什么是线程和进程\",{\"0\":{\"805\":1}}],[\"什么是钩子方法呢\",{\"1\":{\"744\":1}}],[\"什么是缓存雪崩\",{\"0\":{\"313\":1}}],[\"什么是缓存击穿\",{\"0\":{\"309\":1}}],[\"什么是缓存穿透\",{\"0\":{\"306\":1}}],[\"什么是内存碎片\",{\"0\":{\"217\":1},\"1\":{\"303\":1}}],[\"什么是undo\",{\"0\":{\"137\":1}}],[\"什么是redo\",{\"0\":{\"135\":1}}],[\"什么是分布式\",{\"0\":{\"29\":1,\"1125\":1}}],[\"什么是\",{\"0\":{\"28\":1,\"68\":1,\"226\":1,\"229\":1,\"242\":1,\"279\":1,\"291\":1,\"296\":1,\"670\":1,\"715\":1,\"971\":1,\"1122\":1,\"1196\":1,\"1367\":1},\"1\":{\"168\":1,\"318\":1,\"631\":1}}],[\"饥饿问题这个可以通过优化设计来解决\",{\"1\":{\"897\":1}}],[\"致力于提高系统运行保障能力\",{\"1\":{\"896\":1,\"923\":1}}],[\"报警\",{\"1\":{\"896\":1,\"923\":1}}],[\"报错\",{\"1\":{\"634\":1,\"1261\":1}}],[\"😒\",{\"1\":{\"1391\":1}}],[\"😅\",{\"1\":{\"1316\":1}}],[\"😁😁😁\",{\"1\":{\"1306\":1}}],[\"😵\",{\"1\":{\"1275\":1}}],[\"😋😋😋\",{\"1\":{\"1271\":1}}],[\"👍👍👍\",{\"1\":{\"1391\":1}}],[\"👍\",{\"1\":{\"1271\":1}}],[\"👇\",{\"1\":{\"1067\":1,\"1166\":1}}],[\"👏👏👏\",{\"1\":{\"896\":1,\"923\":1}}],[\"🐛\",{\"1\":{\"359\":1,\"393\":1,\"444\":1,\"480\":1,\"495\":1,\"687\":1,\"708\":1,\"762\":1,\"968\":1,\"1007\":1,\"1069\":1}}],[\"格外需要注意的是corepoolsize\",{\"1\":{\"896\":1,\"923\":1}}],[\"格式表示\",{\"1\":{\"485\":1}}],[\"格式上符合描述一个\",{\"1\":{\"341\":1}}],[\"格式的问题\",{\"1\":{\"236\":1}}],[\"格式\",{\"1\":{\"235\":1}}],[\"∗\",{\"1\":{\"895\":2,\"922\":2}}],[\"概念\",{\"1\":{\"1355\":1}}],[\"概念了解么\",{\"0\":{\"1129\":1}}],[\"概览中\",{\"1\":{\"1346\":1}}],[\"概览\",{\"0\":{\"1344\":1}}],[\"概要\",{\"1\":{\"1240\":1}}],[\"概率性问题\",{\"1\":{\"1144\":1}}],[\"概括来说就是\",{\"1\":{\"895\":1,\"922\":1}}],[\"概述\",{\"0\":{\"476\":1}}],[\"采取的策略是为每个线程分配时间片并轮转的形式\",{\"1\":{\"895\":1,\"922\":1}}],[\"采用先进先出的方式发送消息\",{\"1\":{\"1379\":1}}],[\"采用计算与存储分离架构设计\",{\"1\":{\"1238\":1}}],[\"采用无锁设计\",{\"1\":{\"1184\":1}}],[\"采用适当的方式来使系统达到最终一致性\",{\"1\":{\"1074\":1}}],[\"采用拉链法结合红黑树\",{\"1\":{\"692\":1}}],[\"采用拉链法\",{\"1\":{\"692\":1}}],[\"采用的就是发布\",{\"1\":{\"1194\":1}}],[\"采用的数据结构跟\",{\"1\":{\"688\":1}}],[\"采用的是\",{\"1\":{\"164\":1,\"272\":1,\"286\":1,\"289\":1,\"293\":1,\"1315\":1}}],[\"采用二进制位操作\",{\"1\":{\"684\":1}}],[\"采用二叉小顶堆的思想确保值小的元素排在最前面\",{\"1\":{\"607\":1}}],[\"采用二级缓存的方式进行处理\",{\"1\":{\"299\":1}}],[\"采用链表存储\",{\"1\":{\"552\":1,\"656\":1}}],[\"采用数组存储\",{\"1\":{\"552\":1,\"656\":1}}],[\"采用合适的数据结构\",{\"1\":{\"294\":1}}],[\"采用异步方式延迟释放\",{\"1\":{\"289\":1,\"294\":1}}],[\"采用两种方式计数\",{\"1\":{\"205\":1}}],[\"采用了尾插法而不是头插法来避免链表倒置\",{\"1\":{\"685\":1}}],[\"采用了\",{\"1\":{\"141\":1}}],[\"采用\",{\"1\":{\"6\":1,\"314\":1,\"691\":1,\"692\":2,\"834\":1,\"1132\":1,\"1351\":1}}],[\"饱和策略为\",{\"1\":{\"940\":1}}],[\"饱和策略的话来配置线程池的时候默认使用的是\",{\"1\":{\"936\":1}}],[\"饱和策略定义\",{\"1\":{\"936\":1}}],[\"饱和策略等等\",{\"1\":{\"917\":1}}],[\"饱和策略会调用rejectedexecutionhandler\",{\"1\":{\"893\":1,\"941\":1}}],[\"饱和策略来配置线程池的时候\",{\"1\":{\"891\":1}}],[\"饱和策略\",{\"1\":{\"890\":1,\"936\":1}}],[\"拒绝策略\",{\"1\":{\"890\":1,\"936\":1}}],[\"待消费\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"待发送到服务端的状态\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"待线程空闲\",{\"1\":{\"888\":1,\"937\":1}}],[\"待有线程空闲时\",{\"1\":{\"888\":1,\"937\":1}}],[\"池化技术的思想主要是为了减少每次获取资源的消耗\",{\"1\":{\"887\":1,\"932\":1}}],[\"池化技术想必大家已经屡见不鲜了\",{\"1\":{\"887\":1,\"932\":1}}],[\"池中可用的常用分配字符串的缓存\",{\"1\":{\"485\":1}}],[\"永远不会覆盖已经存在的日志条目\",{\"1\":{\"1114\":1}}],[\"永远存在\",{\"1\":{\"1030\":1}}],[\"永远无法被\",{\"1\":{\"884\":1}}],[\"永久存在\",{\"1\":{\"480\":1,\"496\":1}}],[\"永久区一开始就占用了\",{\"1\":{\"456\":1}}],[\"永久区的设置\",{\"0\":{\"456\":1}}],[\"永久\",{\"1\":{\"382\":1}}],[\"永久代是\",{\"1\":{\"496\":1}}],[\"永久代并不会出现这种情况\",{\"1\":{\"480\":1}}],[\"永久代\",{\"1\":{\"382\":1,\"449\":1,\"480\":2,\"495\":2,\"496\":2}}],[\"盒子中可以存储每个线程的私有数据\",{\"1\":{\"881\":1}}],[\"型\",{\"1\":{\"1379\":1}}],[\"型的数据戳\",{\"1\":{\"871\":1}}],[\"型数组\",{\"1\":{\"633\":1}}],[\"乐观读\",{\"1\":{\"871\":2}}],[\"乐观锁的问题\",{\"1\":{\"995\":1}}],[\"乐观锁通常多于写比较少的情况下\",{\"1\":{\"987\":1}}],[\"乐观锁通常多用于写比较少的情况\",{\"1\":{\"838\":1}}],[\"乐观锁有点像是一位比较乐观的人\",{\"1\":{\"985\":1}}],[\"乐观锁存在哪些问题\",{\"0\":{\"842\":1,\"991\":1}}],[\"乐观锁一般会使用版本号机制或\",{\"1\":{\"839\":1,\"988\":1,\"995\":1}}],[\"乐观锁主要针对的对象是单个共享变量\",{\"1\":{\"838\":1,\"987\":1}}],[\"乐观锁相比悲观锁来说\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"乐观锁总是假设最好的情况\",{\"1\":{\"838\":1,\"987\":1}}],[\"乐观锁和悲观锁的最终目的都是为了保证线程安全\",{\"1\":{\"985\":1}}],[\"乐观锁和悲观锁详解\",{\"0\":{\"985\":1}}],[\"乐观锁和悲观锁\",{\"0\":{\"836\":1}}],[\"乐观锁\",{\"1\":{\"34\":1,\"996\":1}}],[\"悲观读\",{\"1\":{\"871\":1}}],[\"悲观锁\",{\"1\":{\"996\":1}}],[\"悲观锁对性能的影响更大\",{\"1\":{\"985\":1}}],[\"悲观锁有点像是一位比较悲观\",{\"1\":{\"985\":1}}],[\"悲观锁的开销是固定的\",{\"1\":{\"838\":1,\"987\":2}}],[\"悲观锁通常多用于写比较多的情况下\",{\"1\":{\"987\":1}}],[\"悲观锁通常多用于写比较多的情况\",{\"1\":{\"838\":1}}],[\"悲观锁还可能会存在死锁问题\",{\"1\":{\"837\":1,\"986\":1,\"995\":1}}],[\"悲观锁总是假设最坏的情况\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"🤝🤝🤝\",{\"1\":{\"1391\":1}}],[\"🤥🤥🤥\",{\"1\":{\"1379\":1}}],[\"🤮🤮🤮\",{\"1\":{\"1370\":1}}],[\"🤔🤔\",{\"1\":{\"1315\":1,\"1367\":1}}],[\"🤣\",{\"1\":{\"1315\":1}}],[\"🤨\",{\"1\":{\"1281\":1}}],[\"🤬🤬\",{\"1\":{\"1375\":1}}],[\"🤬\",{\"1\":{\"1276\":1}}],[\"🧗🏻\",{\"1\":{\"853\":1}}],[\"🤐\",{\"1\":{\"256\":1}}],[\"偏向锁状态\",{\"1\":{\"854\":1}}],[\"偏向锁\",{\"1\":{\"847\":1,\"996\":1}}],[\"偏移量\",{\"1\":{\"201\":1,\"212\":1,\"261\":1,\"570\":1,\"1205\":1}}],[\"早期被用来用于处理海量的日志\",{\"1\":{\"1235\":1}}],[\"早期的消息中间件是通过\",{\"1\":{\"1277\":1}}],[\"早期的消息模型\",{\"0\":{\"1193\":1}}],[\"早期的\",{\"1\":{\"1191\":1,\"1192\":1}}],[\"早期\",{\"1\":{\"1151\":1}}],[\"早期版本中\",{\"1\":{\"847\":1}}],[\"早在\",{\"1\":{\"668\":1}}],[\"初是用于做网页文本展示的\",{\"1\":{\"1159\":1}}],[\"初次读取的时候是\",{\"1\":{\"843\":1,\"992\":1}}],[\"初始状态下所有服务提供者的活跃数均为\",{\"1\":{\"1142\":1}}],[\"初始状态\",{\"1\":{\"820\":1}}],[\"初始许可证数量\",{\"1\":{\"749\":1}}],[\"初始共享资源数量\",{\"1\":{\"747\":1,\"905\":1}}],[\"初始列表\",{\"1\":{\"593\":1}}],[\"初始容量大小和每次扩充容量大小的不同\",{\"1\":{\"677\":1}}],[\"初始容量大于0\",{\"1\":{\"555\":1}}],[\"初始容量暂时存放到\",{\"1\":{\"621\":1}}],[\"初始容量小于0\",{\"1\":{\"555\":1}}],[\"初始容量等于0\",{\"1\":{\"555\":1}}],[\"初始调用previous将返回指定索引减1的元素\",{\"1\":{\"553\":1}}],[\"初始情况下\",{\"1\":{\"1014\":1}}],[\"初始情况\",{\"1\":{\"553\":1,\"557\":1}}],[\"初始大小为\",{\"1\":{\"888\":1}}],[\"初始大小\",{\"1\":{\"480\":1,\"496\":1}}],[\"初始空间\",{\"1\":{\"456\":1}}],[\"初始值为\",{\"1\":{\"904\":1}}],[\"初始值\",{\"1\":{\"449\":1}}],[\"初始堆大小\",{\"1\":{\"449\":1}}],[\"初始标记\",{\"1\":{\"406\":1,\"407\":1}}],[\"初始化选举\",{\"1\":{\"1380\":1}}],[\"初始化选择的公平锁和非公平锁\",{\"1\":{\"1007\":1}}],[\"初始化选择公平锁\",{\"1\":{\"1001\":1}}],[\"初始化时默认的\",{\"1\":{\"1211\":1}}],[\"初始化时获得\",{\"1\":{\"571\":1}}],[\"初始化为它的最新的日志条目索引数+1\",{\"1\":{\"1112\":1}}],[\"初始化为10\",{\"1\":{\"553\":1}}],[\"初始化探测式清理过期数据扫描的开始位置\",{\"1\":{\"1035\":1}}],[\"初始化的时候传入自定义的\",{\"1\":{\"1211\":1}}],[\"初始化的时候为\",{\"1\":{\"1018\":1}}],[\"初始化的头结点并不是当前线程节点\",{\"1\":{\"1011\":1}}],[\"初始化线程池的时候需要显示命名\",{\"1\":{\"894\":1,\"920\":1}}],[\"初始化节点\",{\"1\":{\"729\":1}}],[\"初始化参数顺序分别是\",{\"1\":{\"727\":1}}],[\"初始化和\",{\"1\":{\"624\":1}}],[\"初始化数组桶\",{\"1\":{\"577\":1}}],[\"初始化数据\",{\"1\":{\"261\":1}}],[\"初始化大小\",{\"1\":{\"576\":1}}],[\"初始化长度\",{\"1\":{\"571\":1}}],[\"初始化容量和锁的公平性\",{\"1\":{\"534\":1}}],[\"初始化一个\",{\"1\":{\"649\":2}}],[\"初始化一个数组用于存放队列的元素\",{\"1\":{\"534\":1}}],[\"初始化一个类\",{\"1\":{\"344\":1}}],[\"初始化零值完成之后\",{\"1\":{\"505\":1}}],[\"初始化零值\",{\"0\":{\"504\":1}}],[\"初始化代码如下所示\",{\"1\":{\"480\":1}}],[\"初始化元空间大小\",{\"1\":{\"443\":1}}],[\"初始化其实就是执行类构造器方法的<clinit>\",{\"1\":{\"430\":1}}],[\"初始化阶段类变量如果在静态代码块中又进行了更改\",{\"1\":{\"430\":1}}],[\"初始化阶段是执行初始化方法\",{\"1\":{\"344\":1}}],[\"初始化阶段才会赋值\",{\"1\":{\"342\":1}}],[\"初始化\",{\"0\":{\"344\":1,\"430\":1,\"534\":1,\"570\":1,\"576\":1,\"587\":1,\"728\":1},\"1\":{\"338\":1,\"427\":1,\"570\":1,\"571\":2,\"834\":1,\"1284\":1,\"1285\":1}}],[\"魔法类\",{\"1\":{\"841\":1,\"990\":1}}],[\"魔数\",{\"0\":{\"326\":1}}],[\"拟写入的新值\",{\"1\":{\"841\":1,\"990\":1}}],[\"试想一种情况\",{\"1\":{\"1206\":1}}],[\"试想一下\",{\"1\":{\"400\":1,\"1205\":1}}],[\"试想这样一种极端情况\",{\"1\":{\"919\":1}}],[\"试图向数据库提交数据\",{\"1\":{\"840\":1,\"989\":1}}],[\"连续的内存地址通常会被频繁访问到\",{\"1\":{\"1184\":1}}],[\"连同帐户扣除后余额\",{\"1\":{\"840\":1,\"989\":1}}],[\"连接丢失事件\",{\"1\":{\"1383\":1}}],[\"连接池\",{\"1\":{\"1158\":1}}],[\"连接池等等都是对这个思想的应用\",{\"1\":{\"887\":1,\"932\":1}}],[\"连接之后会一直保持这个连接\",{\"1\":{\"1158\":1}}],[\"连接时\",{\"1\":{\"373\":1}}],[\"连接远程进程\",{\"1\":{\"373\":1}}],[\"连接\",{\"0\":{\"373\":1,\"1322\":1,\"1333\":1},\"1\":{\"373\":1,\"1151\":1,\"1322\":1}}],[\"连接阶段可能就已经开始了\",{\"1\":{\"340\":1}}],[\"连接过程又可分为三步\",{\"1\":{\"339\":1,\"349\":1}}],[\"连接应答处理器\",{\"1\":{\"265\":1}}],[\"连接拒绝\",{\"1\":{\"170\":1}}],[\"连接耗尽\",{\"1\":{\"165\":1}}],[\"连接命令一般是这么写的\",{\"1\":{\"84\":1}}],[\"连接比较占用内存\",{\"1\":{\"84\":1}}],[\"连接器会到权限表里面查出你拥有的权限\",{\"1\":{\"84\":1}}],[\"连接器负责跟客户端建立连接\",{\"1\":{\"84\":1}}],[\"连接器\",{\"0\":{\"84\":1},\"1\":{\"81\":1}}],[\"飙升\",{\"1\":{\"838\":1,\"873\":1,\"987\":1,\"995\":1}}],[\"激烈的锁竞争会造成线程阻塞\",{\"1\":{\"837\":1,\"986\":1,\"995\":1}}],[\"屏蔽了操作系统底层的差异\",{\"1\":{\"834\":1}}],[\"屏障才会开门\",{\"1\":{\"755\":1,\"910\":1}}],[\"称\",{\"1\":{\"824\":1}}],[\"留得江山在\",{\"1\":{\"1273\":1}}],[\"留待线程下次占用\",{\"1\":{\"821\":1}}],[\"留存的记录数的百分比\",{\"1\":{\"120\":1}}],[\"终止探测\",{\"1\":{\"1037\":1}}],[\"终止线程池\",{\"1\":{\"940\":1}}],[\"终止\",{\"1\":{\"820\":1}}],[\"终止状态\",{\"1\":{\"820\":1}}],[\"式\",{\"1\":{\"820\":1}}],[\"摘自官网\",{\"1\":{\"1238\":1}}],[\"摘自\",{\"1\":{\"820\":1,\"1236\":1}}],[\"挑错\",{\"1\":{\"820\":1}}],[\"损耗大量内存\",{\"1\":{\"798\":1}}],[\"勇哥\",{\"1\":{\"788\":1}}],[\"形成一个树形化命名空间\",{\"1\":{\"1382\":1}}],[\"形成闭环\",{\"1\":{\"1087\":1}}],[\"形成异步计算的流水线\",{\"1\":{\"774\":2,\"901\":1}}],[\"形形色色的参数很多\",{\"1\":{\"460\":1}}],[\"物理偏移量\",{\"1\":{\"1315\":1}}],[\"物理内存的\",{\"1\":{\"449\":4}}],[\"物流消息等等\",{\"1\":{\"1280\":1}}],[\"物流信息\",{\"1\":{\"772\":1}}],[\"物联网等领域的业务场景\",{\"1\":{\"1236\":1}}],[\"困惑\",{\"1\":{\"767\":2}}],[\"栅栏才会打开\",{\"1\":{\"756\":1,\"911\":1}}],[\"递增\",{\"1\":{\"1374\":1}}],[\"递增的提案编号\",{\"1\":{\"1373\":1}}],[\"递减然后重试\",{\"1\":{\"1112\":1}}],[\"递减到\",{\"1\":{\"752\":1}}],[\"递归调用实现续期\",{\"1\":{\"49\":1}}],[\"退化为排他锁\",{\"1\":{\"747\":1,\"905\":1}}],[\"退单\",{\"1\":{\"18\":1}}],[\"信道是建立在\",{\"1\":{\"1260\":1}}],[\"信道\",{\"1\":{\"1260\":1}}],[\"信道服用\",{\"1\":{\"1253\":1}}],[\"信使可能会被暗杀\",{\"1\":{\"1105\":1}}],[\"信使回到将军\",{\"1\":{\"1105\":1}}],[\"信使的信息可靠但有可能被暗杀的情况下\",{\"1\":{\"1105\":1}}],[\"信号的线程\",{\"1\":{\"807\":1}}],[\"信号量\",{\"0\":{\"746\":1},\"1\":{\"747\":1,\"905\":1}}],[\"信息写入事务日志中\",{\"1\":{\"1371\":1}}],[\"信息记入事务日志中\",{\"1\":{\"1370\":1}}],[\"信息变更次数\",{\"1\":{\"1349\":1}}],[\"信息交换层\",{\"1\":{\"1130\":1}}],[\"信息共享是一个基本的需求\",{\"1\":{\"1083\":1}}],[\"信息流展示\",{\"1\":{\"182\":1}}],[\"信息安全\",{\"1\":{\"18\":1}}],[\"信息\",{\"1\":{\"17\":1,\"483\":1,\"807\":1,\"1085\":1,\"1157\":1,\"1330\":1,\"1380\":1}}],[\"钩子方法是一种被声明在抽象类中的方法\",{\"1\":{\"744\":1}}],[\"唤醒后还是会不断地去尝试获取锁\",{\"1\":{\"1015\":1}}],[\"唤醒后\",{\"1\":{\"1015\":1}}],[\"唤醒对应的线程后\",{\"1\":{\"1014\":1}}],[\"唤醒同步队列中的一个线程\",{\"1\":{\"906\":1}}],[\"唤醒之前等待的线程\",{\"1\":{\"756\":1,\"911\":1}}],[\"唤醒主线程\",{\"1\":{\"742\":1}}],[\"唤醒等待的线程\",{\"1\":{\"55\":1}}],[\"暂时获取不到锁的线程将被加入到该队列中\",{\"1\":{\"742\":1}}],[\"暂停所有的其他线程\",{\"1\":{\"406\":1}}],[\"充分利用了双向链表的特性来提高效率\",{\"1\":{\"730\":1}}],[\"测试插入\",{\"1\":{\"713\":1}}],[\"测试代码如下\",{\"1\":{\"562\":1,\"706\":1}}],[\"测试代码\",{\"1\":{\"384\":1,\"1062\":1}}],[\"迭代到index=5的数据时\",{\"1\":{\"1040\":1}}],[\"迭代器对应的移除元素的方法如下\",{\"1\":{\"732\":1}}],[\"迭代元素的顺序是不确定的\",{\"1\":{\"719\":1}}],[\"迭代效率相对于前者高效了需多\",{\"1\":{\"713\":1}}],[\"迭代效率会高很多\",{\"1\":{\"702\":1}}],[\"迭代键值对时会用到一个\",{\"1\":{\"713\":1}}],[\"展示了\",{\"1\":{\"710\":1,\"711\":1,\"1182\":1}}],[\"追加到链表末端\",{\"1\":{\"710\":1}}],[\"追加到\",{\"1\":{\"710\":1}}],[\"追加写\",{\"1\":{\"89\":1}}],[\"断开\",{\"1\":{\"731\":2}}],[\"断开联系\",{\"1\":{\"710\":1}}],[\"断言下标未越界\",{\"1\":{\"730\":1}}],[\"断言的对应关系如下\",{\"1\":{\"71\":1}}],[\"断言配置示例\",{\"1\":{\"70\":1}}],[\"断言配置\",{\"1\":{\"70\":1}}],[\"断言配置的示例如下\",{\"1\":{\"70\":1}}],[\"断言\",{\"1\":{\"70\":1,\"75\":1,\"729\":1,\"731\":1}}],[\"略低\",{\"1\":{\"719\":1}}],[\"略\",{\"1\":{\"708\":1,\"711\":1,\"712\":1}}],[\"拥有相同的\",{\"1\":{\"1112\":2}}],[\"拥有存储链表的引用\",{\"1\":{\"708\":1}}],[\"拥有了队列的常见操作\",{\"1\":{\"533\":1}}],[\"旋转\",{\"1\":{\"696\":1}}],[\"交换器和队列绑定\",{\"1\":{\"1253\":1}}],[\"交换器类型\",{\"0\":{\"1252\":1},\"1\":{\"1249\":1,\"1251\":1,\"1253\":1}}],[\"交换器\",{\"0\":{\"1249\":1,\"1255\":1},\"1\":{\"1249\":7,\"1253\":1}}],[\"交换两个索引位置的元素\",{\"1\":{\"696\":1}}],[\"交出\",{\"1\":{\"1183\":2}}],[\"交出给其它线程使用\",{\"1\":{\"895\":1,\"922\":1}}],[\"交互\",{\"1\":{\"895\":1,\"922\":1}}],[\"交集\",{\"1\":{\"190\":5,\"259\":3}}],[\"违背了使用\",{\"1\":{\"694\":1}}],[\"寻址时间复杂度为\",{\"1\":{\"691\":2}}],[\"寻找\",{\"1\":{\"1356\":1}}],[\"寻找并发级别\",{\"1\":{\"570\":1}}],[\"寻找最优秀的垃圾收集器的过程仍然在继续\",{\"1\":{\"401\":1}}],[\"守护着一个\",{\"1\":{\"690\":1}}],[\"扮演锁的角色\",{\"1\":{\"690\":1}}],[\"±\",{\"1\":{\"687\":8}}],[\"覆盖了\",{\"1\":{\"686\":1}}],[\"覆盖索引是select的数据列只用从索引中就能够取得\",{\"1\":{\"104\":1}}],[\"覆盖索引\",{\"1\":{\"104\":1}}],[\"亿长度的数组\",{\"1\":{\"684\":1}}],[\"亿的映射空间\",{\"1\":{\"684\":1}}],[\"亿个券码\",{\"1\":{\"19\":1}}],[\"吧\",{\"1\":{\"677\":1,\"1271\":1}}],[\"典型例题包括堆排序\",{\"1\":{\"669\":1}}],[\"典型的策略是将名称转换为文件名\",{\"1\":{\"351\":1}}],[\"均是有顺序的\",{\"1\":{\"1299\":1}}],[\"均可以通过\",{\"1\":{\"1231\":1}}],[\"均摊性能相比更慢\",{\"1\":{\"668\":1}}],[\"均会进入时长不等的阻塞状态\",{\"1\":{\"167\":1}}],[\"规定了从\",{\"1\":{\"973\":1}}],[\"规避资源耗尽的风险\",{\"1\":{\"889\":1,\"937\":1}}],[\"规则\",{\"1\":{\"667\":1,\"975\":1}}],[\"规范里还提到两种\",{\"1\":{\"1252\":1}}],[\"规范\",{\"1\":{\"1231\":1}}],[\"规范实现的\",{\"1\":{\"1226\":1}}],[\"规范代码结构\",{\"1\":{\"1173\":1}}],[\"规范和安全\",{\"1\":{\"429\":1}}],[\"规范规定魔数为固定值\",{\"1\":{\"326\":1}}],[\"构架\",{\"1\":{\"1245\":1}}],[\"构建\",{\"1\":{\"1341\":1}}],[\"构建实时的流数据处理程序来转换或处理数据流\",{\"1\":{\"1190\":1}}],[\"构建索引查找效率的提升就会非常明显\",{\"1\":{\"800\":1}}],[\"构成一个高效可靠的原语集\",{\"1\":{\"1344\":1}}],[\"构成一个环\",{\"1\":{\"657\":1}}],[\"构成的数组\",{\"1\":{\"1110\":1}}],[\"构造成一个新的消息类型\",{\"1\":{\"1222\":1}}],[\"构造函数自定义参数的方式来创建线程池\",{\"1\":{\"940\":1}}],[\"构造函数的方式\",{\"1\":{\"889\":1,\"937\":1}}],[\"构造函数等映射成\",{\"1\":{\"523\":1}}],[\"构造方法来创建线程池\",{\"1\":{\"944\":1}}],[\"构造方法来指定是否是公平的\",{\"1\":{\"862\":1}}],[\"构造方法介绍\",{\"0\":{\"936\":1}}],[\"构造方法本身就属于线程安全的\",{\"1\":{\"849\":1}}],[\"构造方法不能使用\",{\"1\":{\"849\":1}}],[\"构造方法可以用\",{\"0\":{\"849\":1}}],[\"构造方法有\",{\"1\":{\"709\":1}}],[\"构造方法中指定\",{\"1\":{\"706\":1}}],[\"构造方法\",{\"0\":{\"602\":1,\"621\":1,\"709\":1},\"1\":{\"705\":1}}],[\"构造方法源码如下\",{\"1\":{\"555\":1}}],[\"构造包含指定collection元素的列表\",{\"1\":{\"555\":1}}],[\"构造一个包含指定集合的元素的列表\",{\"1\":{\"553\":1}}],[\"尾部删除\",{\"1\":{\"653\":1}}],[\"尾部插入\",{\"1\":{\"653\":1,\"654\":1,\"725\":1}}],[\"允许你发送并接收以一些不同形式的数据\",{\"1\":{\"1226\":1}}],[\"允许你使用泛型来确保类型安全\",{\"1\":{\"649\":1}}],[\"允许应用程序组件基于\",{\"1\":{\"1226\":1}}],[\"允许消息延时的场景\",{\"1\":{\"1207\":1}}],[\"允许损失部分可用性\",{\"1\":{\"1076\":1}}],[\"允许创建的线程数量为\",{\"1\":{\"889\":1,\"917\":1,\"937\":1,\"959\":1}}],[\"允许多个线程获取乐观读以及读锁\",{\"1\":{\"871\":1}}],[\"允许\",{\"1\":{\"751\":1,\"907\":1,\"909\":1}}],[\"允许用户在指定节点上注册一些\",{\"1\":{\"55\":1,\"1352\":1}}],[\"传统的\",{\"1\":{\"1308\":1}}],[\"传统的数据库扫描方式较为复杂\",{\"1\":{\"1285\":1}}],[\"传统\",{\"0\":{\"1308\":1}}],[\"传达一个消息\",{\"1\":{\"1271\":1}}],[\"传输确认及发布确认等\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"传输的消息\",{\"1\":{\"1159\":1}}],[\"传输的内容\",{\"0\":{\"1159\":1}}],[\"传字符串和数字都问题不大\",{\"1\":{\"1159\":1}}],[\"传播示意图\",{\"1\":{\"1088\":1}}],[\"传谣\",{\"1\":{\"1086\":1}}],[\"传递\",{\"0\":{\"1047\":1}}],[\"传递规则\",{\"1\":{\"975\":1}}],[\"传递了变量值\",{\"1\":{\"883\":1}}],[\"传递的数组必须是对象数组\",{\"1\":{\"634\":1}}],[\"传入\",{\"1\":{\"900\":1,\"941\":1}}],[\"传入其中的任务必须是具备排序能力的\",{\"1\":{\"897\":1}}],[\"传入一个\",{\"1\":{\"857\":1,\"865\":1}}],[\"传入的是类型完全一致\",{\"1\":{\"633\":1}}],[\"传入的邮箱格式不对的时候直接返回错误消息给客户端等等\",{\"1\":{\"307\":1}}],[\"传入了三个参数的默认值\",{\"1\":{\"570\":1}}],[\"传入参数和\",{\"1\":{\"364\":1}}],[\"莫名其妙地发现自己有元素被\",{\"1\":{\"631\":1}}],[\"王五\",{\"1\":{\"625\":1,\"663\":2}}],[\"王者荣耀中的段位排行榜\",{\"1\":{\"194\":1,\"258\":1}}],[\"李四2\",{\"1\":{\"625\":2}}],[\"李四\",{\"1\":{\"625\":3,\"663\":2}}],[\"衡量数组是否需要扩增的一个标准\",{\"1\":{\"619\":1}}],[\"太长不一定是好事\",{\"1\":{\"1389\":1}}],[\"太小导致数组的利用率低\",{\"1\":{\"619\":1}}],[\"太大导致查找元素效率低\",{\"1\":{\"619\":1}}],[\"越靠近\",{\"1\":{\"1184\":1}}],[\"越小\",{\"1\":{\"619\":1}}],[\"越趋近于\",{\"1\":{\"619\":1}}],[\"阈值=容量\",{\"1\":{\"621\":1}}],[\"阈值\",{\"1\":{\"619\":1}}],[\"桶中不止一个节点\",{\"1\":{\"623\":1}}],[\"桶中已经存在元素\",{\"1\":{\"622\":1,\"686\":1}}],[\"桶中结构转化为红黑树对应的table的最小容量\",{\"1\":{\"619\":1}}],[\"桶为空\",{\"1\":{\"622\":1,\"686\":1}}],[\"桶内为空\",{\"1\":{\"577\":1}}],[\"忽略符号位\",{\"1\":{\"618\":1,\"682\":1}}],[\"忽略释放失败的锁\",{\"1\":{\"53\":1}}],[\"^=\",{\"1\":{\"618\":1,\"682\":1}}],[\"^\",{\"1\":{\"618\":5,\"619\":1,\"682\":5}}],[\"^41\",{\"1\":{\"38\":1}}],[\"拉两种模式对消息进行消费\",{\"1\":{\"1281\":1}}],[\"拉取消息并消费\",{\"1\":{\"1281\":1}}],[\"拉取到消息即提交\",{\"1\":{\"1207\":1}}],[\"拉方式\",{\"1\":{\"1087\":1}}],[\"拉和推拉三种方式\",{\"1\":{\"1087\":1}}],[\"拉链法\",{\"1\":{\"616\":1,\"618\":1,\"645\":1,\"682\":1}}],[\"拉出一个链表\",{\"1\":{\"96\":1}}],[\"持有特定消费者\",{\"1\":{\"1182\":1}}],[\"持有资源\",{\"1\":{\"823\":2}}],[\"持续为空\",{\"1\":{\"604\":1}}],[\"持久节点\",{\"1\":{\"1382\":2}}],[\"持久节点是指一旦这个\",{\"1\":{\"1362\":1}}],[\"持久代一般固定大小为\",{\"1\":{\"450\":1}}],[\"持久代大小\",{\"1\":{\"450\":1}}],[\"持久代\",{\"1\":{\"449\":1}}],[\"持久性\",{\"1\":{\"125\":2,\"133\":2,\"281\":2}}],[\"持久顺序节点\",{\"1\":{\"1382\":2}}],[\"持久顺序\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"持久\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"持久化存储\",{\"1\":{\"1238\":1}}],[\"持久化相比\",{\"1\":{\"282\":1}}],[\"持久化详解\",{\"1\":{\"237\":1}}],[\"持久化或者开启\",{\"1\":{\"236\":1}}],[\"持久化功能的实现可以简单分为\",{\"1\":{\"230\":1}}],[\"持久化的fsync策略为\",{\"1\":{\"282\":1}}],[\"持久化的实时性更好\",{\"1\":{\"229\":1,\"282\":1}}],[\"持久化的时候也提到过\",{\"1\":{\"160\":1,\"232\":1}}],[\"持久化机制相关的知识点和问题\",{\"1\":{\"263\":1}}],[\"持久化机制\",{\"0\":{\"263\":1},\"1\":{\"263\":1}}],[\"持久化机制详解\",{\"1\":{\"161\":1,\"263\":1}}],[\"持久化机制是在执行完命令之后再记录日志\",{\"1\":{\"160\":1,\"232\":1}}],[\"持久化方式有哪些\",{\"0\":{\"231\":1}}],[\"持久化方式\",{\"1\":{\"161\":1,\"231\":1,\"282\":1}}],[\"持久化后每执行一条会更改\",{\"1\":{\"161\":1,\"229\":1}}],[\"持久化\",{\"0\":{\"225\":1,\"226\":1,\"228\":1,\"229\":1},\"1\":{\"35\":1,\"164\":1,\"237\":1,\"242\":1,\"263\":2,\"293\":1,\"1245\":1,\"1261\":1}}],[\"笔者在查阅了很多资料\",{\"1\":{\"1169\":1}}],[\"笔者对这两个容器进行了压测\",{\"1\":{\"713\":1}}],[\"笔者初始化缓存容量为\",{\"1\":{\"706\":1}}],[\"笔者将以\",{\"1\":{\"604\":1}}],[\"笔者已详细注释\",{\"1\":{\"603\":1}}],[\"旧值\",{\"1\":{\"591\":1}}],[\"毕竟在\",{\"1\":{\"1303\":1}}],[\"毕竟都是国内大公司开源的\",{\"1\":{\"1169\":1}}],[\"毕竟计算机只认识这玩意\",{\"1\":{\"1159\":1}}],[\"毕竟\",{\"1\":{\"1090\":1}}],[\"毕竟不同的业务场景对应的需求不同\",{\"1\":{\"922\":1}}],[\"毕竟需要对任务进行排序操作\",{\"1\":{\"897\":1}}],[\"毕竟写锁属于是独占锁\",{\"1\":{\"869\":1}}],[\"毕竟数据量这么庞大\",{\"1\":{\"713\":1}}],[\"毕竟对于读取操作来说是安全的\",{\"1\":{\"584\":1,\"793\":1}}],[\"毕竟是从硬盘中读取的\",{\"1\":{\"246\":1}}],[\"头重脚轻\",{\"1\":{\"1271\":1}}],[\"头结点不为空并且头结点的waitstatus不是初始化节点情况\",{\"1\":{\"1014\":1}}],[\"头结点hash值小于0\",{\"1\":{\"578\":1}}],[\"头结点hash值相同\",{\"1\":{\"578\":1}}],[\"头指针移动到当前node\",{\"1\":{\"1012\":1}}],[\"头部删除\",{\"1\":{\"653\":1}}],[\"头部插入\",{\"1\":{\"653\":1,\"654\":1,\"725\":1}}],[\"头插法可能会导致链表中的节点指向错误的位置\",{\"1\":{\"685\":1}}],[\"头插法插入新的节点\",{\"1\":{\"572\":1}}],[\"头插法到指定\",{\"1\":{\"572\":1}}],[\"≥64\",{\"1\":{\"577\":1}}],[\"坐标的值\",{\"1\":{\"571\":1}}],[\"独占该锁并将\",{\"1\":{\"904\":1}}],[\"独占方式\",{\"1\":{\"744\":2,\"1007\":2}}],[\"独占\",{\"1\":{\"743\":1,\"1238\":1}}],[\"独占模式获取锁\",{\"1\":{\"742\":1}}],[\"独占锁确保存取操作的线程安全\",{\"1\":{\"601\":1}}],[\"独占锁\",{\"1\":{\"571\":1,\"867\":1,\"871\":1}}],[\"独立实现的\",{\"1\":{\"871\":1}}],[\"独立出来\",{\"1\":{\"710\":1}}],[\"独立存储\",{\"1\":{\"492\":1}}],[\"独立文件存储的方式\",{\"1\":{\"233\":1}}],[\"独立部署的发号器服务还是很有必要的\",{\"1\":{\"30\":1}}],[\"独立部署\",{\"1\":{\"30\":1}}],[\"段\",{\"1\":{\"690\":1}}],[\"段的操作\",{\"1\":{\"571\":1}}],[\"段和初始化\",{\"1\":{\"571\":1}}],[\"末读代码的投稿\",{\"1\":{\"567\":1}}],[\"末尾添加了当前的进程\",{\"1\":{\"22\":1}}],[\"阅读过\",{\"1\":{\"727\":1}}],[\"阅读源码的话\",{\"1\":{\"560\":1}}],[\"阅读本篇文章的时候\",{\"1\":{\"340\":1}}],[\"想了半天\",{\"1\":{\"1341\":1}}],[\"想想在哪里加也不好\",{\"1\":{\"1315\":1}}],[\"想知道这个数组的长度则用到了\",{\"1\":{\"558\":1}}],[\"想要了解\",{\"1\":{\"1276\":1}}],[\"想要访问某个服务\",{\"1\":{\"1157\":1}}],[\"想要理解下面的内容\",{\"1\":{\"604\":1}}],[\"想要执行这个\",{\"1\":{\"419\":1}}],[\"想要进一步了解的朋友\",{\"1\":{\"40\":1}}],[\"明显的中断通常是不可接受的\",{\"1\":{\"1104\":1}}],[\"明显右移了\",{\"1\":{\"558\":1}}],[\"明确指出线程资源必须通过线程池提供\",{\"1\":{\"889\":1}}],[\"明明一次批量执行多个命令就可以了\",{\"1\":{\"279\":1}}],[\"移出\",{\"1\":{\"1238\":1}}],[\"移动互联网\",{\"1\":{\"1236\":1}}],[\"移动元素\",{\"1\":{\"710\":1}}],[\"移位运算符\",{\"1\":{\"558\":1}}],[\"移除此链表中的所有元素\",{\"1\":{\"731\":1}}],[\"移除此列表中的所有元素\",{\"1\":{\"591\":1}}],[\"移除此列表中指定位置上的元素\",{\"1\":{\"591\":1}}],[\"移除的步骤很简单\",{\"1\":{\"712\":1}}],[\"移除的原因可以大致了解一下\",{\"1\":{\"443\":1}}],[\"移除了\",{\"1\":{\"557\":1}}],[\"移除了永久代用元空间\",{\"1\":{\"393\":1}}],[\"移除队列头部的元素\",{\"1\":{\"536\":1}}],[\"移除最不经常使用的\",{\"1\":{\"273\":1,\"298\":1}}],[\"移除最近最少使用的\",{\"1\":{\"273\":1}}],[\"移除元素\",{\"1\":{\"210\":1,\"539\":1}}],[\"移除并获取指定列表的最后一个元素\",{\"1\":{\"181\":1}}],[\"移除并获取指定列表的第一个元素\",{\"1\":{\"181\":1}}],[\"移除\",{\"1\":{\"157\":1,\"301\":1,\"712\":1}}],[\"移除或更新服务实例时\",{\"1\":{\"72\":1}}],[\"奇偶不同\",{\"1\":{\"558\":1}}],[\"细心的朋友一定会发现\",{\"1\":{\"1205\":1}}],[\"细心的同学一定会发现\",{\"1\":{\"555\":1}}],[\"细说的话可以扯很多\",{\"1\":{\"316\":1}}],[\"含金量非常高\",{\"1\":{\"1178\":1}}],[\"含\",{\"1\":{\"553\":1}}],[\"含义\",{\"1\":{\"120\":1,\"449\":1,\"1005\":3}}],[\"赋值一个新的数组\",{\"1\":{\"624\":1}}],[\"赋值给\",{\"1\":{\"621\":1}}],[\"赋值给新的object类型的elementdata数组\",{\"1\":{\"553\":1}}],[\"赋值\",{\"1\":{\"571\":1,\"972\":1}}],[\"赋予了很多云原生友好的新特性\",{\"1\":{\"1168\":1}}],[\"赋予了\",{\"1\":{\"7\":1,\"351\":1}}],[\"系开源项目\",{\"1\":{\"1240\":1}}],[\"系列新增的角色\",{\"1\":{\"1355\":1}}],[\"系列第三篇\",{\"1\":{\"1204\":1}}],[\"系列\",{\"1\":{\"545\":1}}],[\"系统故障\",{\"1\":{\"1306\":1}}],[\"系统却增加了积分\",{\"1\":{\"1304\":1}}],[\"系统没有下订单\",{\"1\":{\"1304\":1}}],[\"系统增加积分失败或者\",{\"1\":{\"1304\":1}}],[\"系统下了订单\",{\"1\":{\"1304\":1}}],[\"系统复杂性提高\",{\"1\":{\"1224\":1}}],[\"系统可用性在某种程度上降低\",{\"1\":{\"1224\":1}}],[\"系统可用性降低\",{\"1\":{\"1224\":1}}],[\"系统再对消息进行消费\",{\"1\":{\"1220\":1}}],[\"系统使用\",{\"1\":{\"1182\":2}}],[\"系统被拆分成不同的服务比如短信服务\",{\"1\":{\"1123\":1}}],[\"系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误\",{\"1\":{\"1116\":1}}],[\"系统必须在正常操作期间处理服务器的上下线\",{\"1\":{\"1104\":1}}],[\"系统研究中心\",{\"1\":{\"1096\":1}}],[\"系统就自动修复数据\",{\"1\":{\"1078\":1}}],[\"系统就会出现两个不同的\",{\"1\":{\"358\":1}}],[\"系统查询数据的时候\",{\"1\":{\"1078\":1}}],[\"系统写入了什么\",{\"1\":{\"1078\":1}}],[\"系统功能上的损失\",{\"1\":{\"1076\":1}}],[\"系统应该达到最终一致性\",{\"1\":{\"1074\":1}}],[\"系统在绝大部分时候所处的状态\",{\"1\":{\"1068\":1}}],[\"系统在处理请求的时候又调用了\",{\"1\":{\"23\":1}}],[\"系统中一部分数据不可用或者不一致时\",{\"1\":{\"1074\":1}}],[\"系统中的某个节点在进行写操作\",{\"1\":{\"1068\":1}}],[\"系统中对应的\",{\"1\":{\"23\":1}}],[\"系统间互相调用\",{\"1\":{\"1045\":1}}],[\"系统\",{\"1\":{\"895\":1,\"922\":1,\"968\":2,\"1126\":2}}],[\"系统一般将这两个状态统称为\",{\"1\":{\"820\":1}}],[\"系统本身就支持多对多的线程模型\",{\"1\":{\"808\":1}}],[\"系统是一个特例\",{\"1\":{\"808\":1,\"1053\":1}}],[\"系统运行一个程序即是一个进程从创建\",{\"1\":{\"806\":1}}],[\"系统才会真正复制一份专用副本\",{\"1\":{\"585\":1}}],[\"系统的架构\",{\"1\":{\"1178\":1}}],[\"系统的部分非核心功能无法使用\",{\"1\":{\"1076\":1}}],[\"系统的效率\",{\"1\":{\"816\":1}}],[\"系统的空闲空间\",{\"1\":{\"451\":4}}],[\"系统的最大空间\",{\"1\":{\"451\":4}}],[\"系统的订单服务一共部署了\",{\"1\":{\"60\":1}}],[\"系统会不会\",{\"1\":{\"1273\":1}}],[\"系统会保证在一定时间内达到数据一致的状态\",{\"1\":{\"1078\":1}}],[\"系统会用大部分的时间来处理\",{\"1\":{\"895\":1,\"922\":1}}],[\"系统会启动一个\",{\"1\":{\"425\":1}}],[\"系统会首先判断当前类是否被加载过\",{\"1\":{\"352\":1,\"357\":1}}],[\"系统某开放接口从\",{\"1\":{\"412\":1}}],[\"系统变量所指定的路径下的所有类\",{\"1\":{\"353\":1}}],[\"系统需要明确知道这个方法所在的位置\",{\"1\":{\"343\":1}}],[\"系统加载\",{\"1\":{\"339\":1}}],[\"系统直接提供了一些函数用于对文件和设备进行访问和控制\",{\"1\":{\"230\":1}}],[\"系统内核缓存区的数据还未同步\",{\"1\":{\"229\":1}}],[\"系统调用再做一遍解释\",{\"1\":{\"230\":1}}],[\"系统调用\",{\"1\":{\"161\":1,\"230\":3,\"231\":1,\"285\":1}}],[\"系统重启之后在读取redo\",{\"1\":{\"136\":1}}],[\"系统即使崩溃\",{\"1\":{\"89\":1}}],[\"系统时钟回拨问题\",{\"1\":{\"41\":1}}],[\"虽名为阻塞队列\",{\"1\":{\"541\":1}}],[\"虽然造成了数据冗余\",{\"1\":{\"1206\":1}}],[\"虽然最慢\",{\"1\":{\"1183\":1}}],[\"虽然支持跨语言的\",{\"1\":{\"1172\":1}}],[\"虽然篇幅不多\",{\"1\":{\"1166\":1}}],[\"虽然它现在叫超文本协议\",{\"1\":{\"1159\":1}}],[\"虽然它也支持非阻塞式获取和新增元素\",{\"1\":{\"535\":1}}],[\"虽然大部分\",{\"1\":{\"1154\":1}}],[\"虽然反熵很简单实用\",{\"1\":{\"1087\":1}}],[\"虽然虚拟线程我很想用\",{\"1\":{\"1062\":1}}],[\"虽然threadlocalmap中使用了黄金分割数来作为hash计算因子\",{\"1\":{\"1033\":1}}],[\"虽然流程上有一定的不同\",{\"1\":{\"1002\":1}}],[\"虽然这从程序员的角度上来说也并无大碍\",{\"1\":{\"974\":1}}],[\"虽然目前面试中问的不多\",{\"1\":{\"912\":1}}],[\"虽然在\",{\"1\":{\"688\":1,\"792\":1}}],[\"虽然元空间仍旧可能溢出\",{\"1\":{\"496\":1}}],[\"虽然我们对各个收集器进行比较\",{\"1\":{\"400\":1}}],[\"虽然改进了标记\",{\"1\":{\"397\":1}}],[\"虽然带来了性能提升\",{\"1\":{\"286\":1}}],[\"虽然说\",{\"1\":{\"266\":1}}],[\"虽然说具有多个版本的数据快照\",{\"1\":{\"141\":1}}],[\"虽然文件事件处理器以单线程方式运行\",{\"1\":{\"265\":1}}],[\"虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决\",{\"1\":{\"233\":1}}],[\"虽然提高了效率\",{\"1\":{\"230\":1}}],[\"虽然\",{\"1\":{\"37\":1,\"176\":1,\"236\":1,\"267\":1,\"407\":1,\"668\":1,\"882\":1,\"974\":1,\"1172\":1}}],[\"理论上可以做到\",{\"1\":{\"1240\":1}}],[\"理论上来说\",{\"1\":{\"564\":1,\"834\":1,\"838\":1,\"987\":1,\"1084\":1}}],[\"理论上来说还是可能会出现数据不一致性的问题\",{\"1\":{\"145\":1}}],[\"理论中\",{\"1\":{\"1079\":1}}],[\"理论中的数据不一致\",{\"1\":{\"1077\":1}}],[\"理论中分区容错性\",{\"1\":{\"1068\":1}}],[\"理论三要素\",{\"0\":{\"1075\":1}}],[\"理论延伸的地方\",{\"1\":{\"1074\":1}}],[\"理论这节我们也说过了\",{\"1\":{\"1074\":1}}],[\"理论本质上是对\",{\"1\":{\"1074\":1}}],[\"理论的核心思想\",{\"0\":{\"1074\":1}}],[\"理论的提出者布鲁尔在提出\",{\"1\":{\"1067\":1}}],[\"理论是对\",{\"1\":{\"1073\":1}}],[\"理论起源于\",{\"1\":{\"1072\":1}}],[\"理论被应用在何方\",{\"1\":{\"1071\":1}}],[\"理论只能满足\",{\"1\":{\"1070\":1}}],[\"理论诞生\",{\"1\":{\"1068\":1}}],[\"理论正式成为分布式领域的定理\",{\"1\":{\"1066\":1}}],[\"理论\",{\"0\":{\"1066\":1,\"1072\":1},\"1\":{\"1066\":1}}],[\"理解成个人电脑了\",{\"1\":{\"1371\":1}}],[\"理解起来其实很简单\",{\"1\":{\"1368\":1}}],[\"理解为\",{\"1\":{\"1315\":1}}],[\"理解为存放在队列中等待消费的消息对象\",{\"1\":{\"1182\":1}}],[\"理解为threadlocal\",{\"1\":{\"883\":1}}],[\"理解\",{\"0\":{\"1008\":1},\"1\":{\"876\":1}}],[\"理解了\",{\"1\":{\"535\":1}}],[\"遍历完成之后\",{\"1\":{\"1038\":1}}],[\"遍历当前key值对应的桶中entry数据为空\",{\"1\":{\"1036\":1}}],[\"遍历散列数组\",{\"1\":{\"1035\":1,\"1037\":1}}],[\"遍历线程信息\",{\"1\":{\"807\":1}}],[\"遍历性能比较\",{\"0\":{\"713\":1}}],[\"遍历方式的性能分析有误\",{\"1\":{\"687\":1}}],[\"遍历到链表最后一个节点\",{\"1\":{\"683\":1}}],[\"遍历链表找到要删除的节点\",{\"1\":{\"731\":1}}],[\"遍历链表找到第一个为\",{\"1\":{\"731\":1}}],[\"遍历链表\",{\"0\":{\"732\":1},\"1\":{\"683\":1}}],[\"遍历等常见操作\",{\"1\":{\"649\":1}}],[\"遍历hashmap\",{\"1\":{\"625\":1}}],[\"遍历以这个元素为头结点的链表\",{\"1\":{\"622\":1}}],[\"遍历指定集合\",{\"1\":{\"592\":1}}],[\"遍历指定位置查找相同\",{\"1\":{\"573\":1}}],[\"遍历查找之\",{\"1\":{\"578\":1}}],[\"遍历查找\",{\"1\":{\"578\":1}}],[\"遍历查找到相同\",{\"1\":{\"573\":1}}],[\"遍历剩余元素\",{\"1\":{\"572\":1}}],[\"遍历结束后\",{\"1\":{\"572\":1}}],[\"遍历老数组\",{\"1\":{\"572\":1}}],[\"遍历\",{\"1\":{\"571\":1,\"730\":1}}],[\"遍历并添加元素到数组中\",{\"1\":{\"534\":1}}],[\"遍历所有对象时\",{\"1\":{\"386\":1,\"495\":1}}],[\"填充到\",{\"1\":{\"533\":2}}],[\"便处理在任务队列中的任务\",{\"1\":{\"888\":1,\"937\":1}}],[\"便限制了执行任务线程的数量\",{\"1\":{\"749\":1}}],[\"便通过倒计时门闩\",{\"1\":{\"531\":1}}],[\"便于软件各部件之间的沟通的软件\",{\"1\":{\"1218\":1}}],[\"便于分析\",{\"1\":{\"483\":1}}],[\"便于我们插入或者修改数据\",{\"1\":{\"33\":1}}],[\"近乎于无限大\",{\"1\":{\"529\":1}}],[\"受检异常\",{\"1\":{\"524\":1}}],[\"受本机可用内存的限制\",{\"1\":{\"496\":1}}],[\"剩余为起始偏移量\",{\"1\":{\"1315\":1}}],[\"剩余的空间大小\",{\"1\":{\"256\":1}}],[\"剩下的服务器是\",{\"1\":{\"1108\":1}}],[\"剩下的\",{\"1\":{\"941\":1,\"1019\":1}}],[\"剩下的就是尽力使程序安全的终止\",{\"1\":{\"524\":1}}],[\"泛型擦除\",{\"1\":{\"522\":1}}],[\"泛型接口和泛型方法\",{\"1\":{\"522\":1}}],[\"泛型的本质是参数化类型\",{\"1\":{\"522\":1}}],[\"泛型\",{\"1\":{\"522\":1}}],[\"泛型以及泛型擦除\",{\"0\":{\"522\":1}}],[\"⽅法都隐式地指定为\",{\"1\":{\"521\":1}}],[\"⽅法\",{\"1\":{\"521\":2}}],[\"抽象\",{\"1\":{\"1130\":1}}],[\"抽象出来的一个概念\",{\"1\":{\"972\":1}}],[\"抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中\",{\"1\":{\"973\":1}}],[\"抽象了线程和主内存之间的关系\",{\"1\":{\"972\":1}}],[\"抽象了\",{\"1\":{\"971\":1}}],[\"抽象类的使用场景\",{\"1\":{\"520\":1}}],[\"抽象类可以定义各种类型的成员变量\",{\"1\":{\"520\":1}}],[\"抽象类只能单继承\",{\"1\":{\"520\":1}}],[\"抽象类只能被继承\",{\"1\":{\"520\":1}}],[\"抽象类有构造方法\",{\"1\":{\"520\":1}}],[\"抽象类不能被实例化\",{\"1\":{\"520\":1}}],[\"抽象类\",{\"1\":{\"520\":1}}],[\"抽象类和接口都可以定义抽象方法\",{\"1\":{\"520\":1}}],[\"抽象类和接口都不能被实例化\",{\"1\":{\"520\":1}}],[\"抽象类和接口\",{\"0\":{\"520\":1}}],[\"抽奖系统\",{\"1\":{\"190\":1,\"259\":1}}],[\"​\\t\\t如ioexception\",{\"1\":{\"524\":1}}],[\"​\",{\"1\":{\"519\":3,\"520\":8,\"521\":11,\"522\":3,\"523\":3,\"524\":3}}],[\"静态方法和\",{\"1\":{\"848\":1}}],[\"静态方法中\",{\"1\":{\"521\":1}}],[\"静态\",{\"1\":{\"848\":1}}],[\"静态工厂方法\",{\"0\":{\"778\":1}}],[\"静态数组\",{\"1\":{\"649\":1}}],[\"静态绑定与动态绑定\",{\"1\":{\"519\":1}}],[\"静态变量都是放在主内存中\",{\"1\":{\"972\":1}}],[\"静态变量等移动到堆中\",{\"1\":{\"342\":1}}],[\"静态变量\",{\"1\":{\"341\":1,\"420\":1,\"445\":1,\"496\":1,\"813\":1}}],[\"丰富的资源库\",{\"1\":{\"515\":1}}],[\"继而提供了可扩展性和功能分离的用法\",{\"1\":{\"1132\":1}}],[\"继续向后进行\",{\"1\":{\"1213\":1}}],[\"继续向前迭代\",{\"1\":{\"1035\":1}}],[\"继续进行后续消息的消费\",{\"1\":{\"1209\":1}}],[\"继续从\",{\"1\":{\"1040\":1}}],[\"继续往后迭代检查\",{\"1\":{\"1037\":1}}],[\"继续往后迭代\",{\"1\":{\"1037\":1}}],[\"继续往下执行说明向后迭代的过程中遇到了entry为null的情况\",{\"1\":{\"1036\":1}}],[\"继续后余动作\",{\"1\":{\"904\":1}}],[\"继续分析\",{\"1\":{\"571\":1}}],[\"继续初始化\",{\"1\":{\"571\":1}}],[\"继续执行后续的操作\",{\"1\":{\"742\":1}}],[\"继续执行\",{\"1\":{\"60\":2,\"1014\":1}}],[\"继承来的\",{\"1\":{\"711\":1}}],[\"继承关系图\",{\"1\":{\"679\":1}}],[\"继承自weakreference\",{\"1\":{\"1029\":1}}],[\"继承自\",{\"1\":{\"619\":1,\"645\":1,\"651\":1,\"670\":1,\"727\":1,\"796\":1}}],[\"继承了具备双向链表特性的\",{\"1\":{\"708\":1}}],[\"继承了\",{\"1\":{\"571\":1,\"600\":1,\"690\":1,\"727\":1,\"748\":1,\"752\":1,\"961\":1}}],[\"继承了阻塞队列\",{\"1\":{\"533\":1}}],[\"继承于\",{\"1\":{\"549\":1}}],[\"继承\",{\"1\":{\"515\":1,\"518\":2,\"706\":1,\"857\":1,\"1299\":1}}],[\"封装请求响应模式\",{\"1\":{\"1130\":1}}],[\"封装多个提供者的路由及负载均衡\",{\"1\":{\"1130\":1}}],[\"封装服务地址的注册与发现\",{\"1\":{\"1130\":1}}],[\"封装成一个延迟的删除任务\",{\"1\":{\"609\":1}}],[\"封装\",{\"1\":{\"515\":1,\"518\":2,\"1130\":1}}],[\"木女孩的回答\",{\"1\":{\"511\":1}}],[\"句柄\",{\"0\":{\"509\":1}}],[\"句柄和直接指针两种方式\",{\"1\":{\"489\":1}}],[\"倍左右\",{\"1\":{\"558\":2}}],[\"倍\",{\"1\":{\"507\":1,\"558\":1,\"616\":1,\"677\":1}}],[\"倍或\",{\"1\":{\"507\":1}}],[\"倍以上\",{\"1\":{\"375\":1}}],[\"块\",{\"1\":{\"820\":1}}],[\"块或者调用\",{\"1\":{\"820\":1}}],[\"块区域\",{\"1\":{\"507\":1}}],[\"块钱\",{\"1\":{\"124\":3}}],[\"布鲁尔定理\",{\"1\":{\"1066\":1}}],[\"布尔型原子类\",{\"1\":{\"762\":1,\"763\":1}}],[\"布洛克\",{\"1\":{\"656\":1,\"724\":1}}],[\"布局和访问的全过程\",{\"1\":{\"500\":1}}],[\"布隆过滤器说某个元素不在\",{\"1\":{\"307\":1}}],[\"布隆过滤器说某个元素存在\",{\"1\":{\"307\":1}}],[\"布隆过滤器是一个非常神奇的数据结构\",{\"1\":{\"307\":1}}],[\"布隆过滤器\",{\"1\":{\"213\":1,\"253\":1,\"307\":1}}],[\"仓库的\",{\"1\":{\"498\":1}}],[\"样例代码\",{\"1\":{\"498\":1}}],[\"知道\",{\"1\":{\"1341\":1}}],[\"知道自己收到了足够的票数\",{\"1\":{\"1105\":1}}],[\"知道这个方法的作用就够了\",{\"1\":{\"710\":1,\"711\":1}}],[\"知乎\",{\"1\":{\"498\":1,\"511\":2}}],[\"知识点\",{\"1\":{\"1020\":1}}],[\"知识点的总结\",{\"1\":{\"35\":1}}],[\"知识星球\",{\"1\":{\"150\":1,\"153\":1}}],[\"容错机制缺陷等等\",{\"1\":{\"1371\":1}}],[\"容错的持久方式存储记录消息流\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"容易产生性能瓶颈\",{\"1\":{\"1285\":1}}],[\"容易造成服务器宕机\",{\"1\":{\"1139\":1}}],[\"容易被传播且传播速度还快\",{\"1\":{\"1084\":1}}],[\"容器中\",{\"1\":{\"1322\":1}}],[\"容器\",{\"1\":{\"1132\":2}}],[\"容量也越小\",{\"1\":{\"1184\":1}}],[\"容量相对较小的内存\",{\"1\":{\"1184\":1}}],[\"容量等于\",{\"1\":{\"798\":1}}],[\"容量迅速增\",{\"1\":{\"798\":1}}],[\"容量大小\",{\"1\":{\"621\":2}}],[\"容量大于扩容阀值\",{\"1\":{\"571\":1}}],[\"容量变为原来的\",{\"1\":{\"616\":1,\"677\":2}}],[\"容量的\",{\"1\":{\"571\":1}}],[\"容量\",{\"1\":{\"557\":1,\"570\":2,\"619\":1}}],[\"容量不能改变\",{\"1\":{\"541\":1,\"797\":1}}],[\"容量为\",{\"1\":{\"498\":1,\"892\":1,\"938\":1}}],[\"容纳的话\",{\"1\":{\"386\":1}}],[\"及以上\",{\"1\":{\"1257\":1}}],[\"及以上的版本提供了一个插件\",{\"1\":{\"1257\":1}}],[\"及以上版本对\",{\"1\":{\"854\":1}}],[\"及以后\",{\"1\":{\"808\":1}}],[\"及以后方法区的实现变成了元空间\",{\"1\":{\"496\":1}}],[\"及之前版本\",{\"1\":{\"686\":1}}],[\"及之前版本的\",{\"1\":{\"685\":1,\"694\":1}}],[\"及之后版本的\",{\"1\":{\"393\":1}}],[\"及之后\",{\"1\":{\"342\":1}}],[\"及其典型实现\",{\"1\":{\"545\":1}}],[\"花太多时间执行垃圾回收并且只能回收很少的堆空间时\",{\"1\":{\"495\":1}}],[\"绝大多数\",{\"1\":{\"1132\":1}}],[\"绝大部分我们使用的集合的\",{\"1\":{\"629\":1}}],[\"绝大部分网关可以提供下面这些功能\",{\"1\":{\"2\":1}}],[\"绝对不会黄\",{\"1\":{\"1240\":1}}],[\"绝对没问题\",{\"1\":{\"1240\":1}}],[\"绝对\",{\"1\":{\"495\":1}}],[\"世界中\",{\"1\":{\"495\":1}}],[\"世界上没有两片相同的树叶\",{\"1\":{\"41\":1}}],[\"若发现\",{\"1\":{\"1388\":1}}],[\"若比自己小的节点中有写请求\",{\"1\":{\"1388\":1}}],[\"若协调者在\",{\"1\":{\"1371\":1}}],[\"若实际业务中预估的消息处理时长不符合预期\",{\"1\":{\"1293\":1}}],[\"若系统出现\",{\"1\":{\"1068\":1}}],[\"若这个对象只被弱引用指向\",{\"1\":{\"1030\":1}}],[\"若通过\",{\"1\":{\"1002\":2}}],[\"若所有线程均在工作\",{\"1\":{\"937\":1}}],[\"若多余一个任务被提交到该线程池\",{\"1\":{\"888\":1,\"937\":1}}],[\"若没有过半机制\",{\"1\":{\"1358\":1}}],[\"若没有\",{\"1\":{\"888\":1,\"937\":1}}],[\"若没有特别配置\",{\"1\":{\"495\":1}}],[\"若刚才读取到的\",{\"1\":{\"840\":1,\"989\":1}}],[\"若干线程之间形成一种头尾相接的循环等待资源关系\",{\"1\":{\"823\":1}}],[\"若要线程安全执行执行count++\",{\"1\":{\"764\":1}}],[\"若存在则断开首节点和后继节点的关系\",{\"1\":{\"712\":1}}],[\"若前驱节点为空\",{\"1\":{\"710\":1}}],[\"若为\",{\"1\":{\"710\":1}}],[\"若为空则直接返回\",{\"1\":{\"710\":1}}],[\"若为空直接返回\",{\"1\":{\"710\":1}}],[\"若为空\",{\"1\":{\"604\":1}}],[\"若accessorder为true\",{\"1\":{\"710\":1}}],[\"若相同就直接使用插入的值p替换掉旧的值e\",{\"1\":{\"622\":1}}],[\"若遇到哈希冲突\",{\"1\":{\"618\":1,\"682\":1}}],[\"若希望元素能够存放到\",{\"1\":{\"610\":1}}],[\"若元素为空\",{\"1\":{\"604\":2}}],[\"若元素不为空且到期了\",{\"1\":{\"604\":2}}],[\"若元素不为空\",{\"1\":{\"604\":1}}],[\"若\",{\"1\":{\"604\":1,\"711\":2,\"1388\":1}}],[\"若不为空\",{\"1\":{\"604\":1}}],[\"若max\",{\"1\":{\"559\":1}}],[\"若mincapacity大\",{\"1\":{\"559\":1}}],[\"若超出了\",{\"1\":{\"553\":1}}],[\"若还是小于最小需要容量\",{\"1\":{\"553\":1,\"558\":1}}],[\"若目标元素为空\",{\"1\":{\"538\":1}}],[\"若时间到了还是空的\",{\"1\":{\"537\":1}}],[\"若时间到还是空的\",{\"1\":{\"537\":1}}],[\"若栈的内存大小不允许动态扩展\",{\"1\":{\"493\":1}}],[\"若row的trx\",{\"1\":{\"141\":4}}],[\"跳过那些已经被丢弃的提案\",{\"1\":{\"1380\":1}}],[\"跳过取消状态的node\",{\"1\":{\"1013\":1}}],[\"跳表是一种利用空间换时间的算法\",{\"1\":{\"800\":1}}],[\"跳表是一种可以用来快速查找的数据结构\",{\"1\":{\"800\":1}}],[\"跳表内的所有链表的元素都是排序的\",{\"1\":{\"800\":1}}],[\"跳表的本质是同时维护了多个链表\",{\"1\":{\"800\":1}}],[\"跳表的时间复杂度也是\",{\"1\":{\"800\":1}}],[\"跳表的实现\",{\"1\":{\"791\":1}}],[\"跳表就不一样了\",{\"1\":{\"800\":1}}],[\"跳出for循环\",{\"1\":{\"1036\":1}}],[\"跳出当前循环的条件是当\",{\"1\":{\"1012\":1}}],[\"跳出循环\",{\"1\":{\"622\":2}}],[\"跳出\",{\"1\":{\"577\":1}}],[\"跳转\",{\"1\":{\"492\":1}}],[\"跳跃表\",{\"1\":{\"174\":1}}],[\"循环的主要作用是遍历\",{\"1\":{\"1142\":1}}],[\"循环向前查找取消节点\",{\"1\":{\"1012\":1}}],[\"循环向后查找\",{\"1\":{\"730\":1}}],[\"循环时间长开销大\",{\"0\":{\"844\":1,\"993\":1},\"1\":{\"995\":1}}],[\"循环栅栏\",{\"0\":{\"754\":1}}],[\"循环改为\",{\"1\":{\"753\":1}}],[\"循环最终会转换成迭代器形式\",{\"1\":{\"732\":1}}],[\"循环来遍历\",{\"1\":{\"732\":1}}],[\"循环里进行元素的\",{\"1\":{\"631\":1}}],[\"循环调用indexof方法判断\",{\"1\":{\"592\":1}}],[\"循环加入新的或者覆盖节点\",{\"1\":{\"577\":1}}],[\"循环是为了把剩余的元素通过头插法插入到指定位置链表\",{\"1\":{\"572\":1}}],[\"循环有疑惑\",{\"1\":{\"572\":1}}],[\"循环等待条件\",{\"1\":{\"823\":1}}],[\"循环等待\",{\"1\":{\"537\":1}}],[\"循环\",{\"1\":{\"492\":2,\"631\":1,\"811\":1}}],[\"五步\",{\"1\":{\"489\":1}}],[\"轻量化函数式计算为一体\",{\"1\":{\"1238\":1}}],[\"轻量\",{\"1\":{\"996\":1}}],[\"轻量级的开源\",{\"1\":{\"1122\":1}}],[\"轻量级动态线程池\",{\"1\":{\"896\":1,\"923\":1}}],[\"轻量级锁状态\",{\"1\":{\"854\":1}}],[\"轻量级锁\",{\"1\":{\"854\":1}}],[\"轻量级锁等技术来减少锁操作的开销\",{\"1\":{\"847\":1}}],[\"轻量级进程\",{\"1\":{\"485\":1}}],[\"轻松引入\",{\"1\":{\"896\":1,\"923\":1}}],[\"轻易实现交集\",{\"1\":{\"188\":1}}],[\"启发式清理\",{\"1\":{\"1042\":1}}],[\"启蒙书\",{\"1\":{\"680\":1}}],[\"启用\",{\"1\":{\"485\":2}}],[\"启动发现集群没有处于\",{\"1\":{\"1380\":1}}],[\"启动了\",{\"1\":{\"1380\":1}}],[\"启动该线程从而执行任务\",{\"1\":{\"941\":2}}],[\"启动线程\",{\"1\":{\"531\":1}}],[\"启动时需要进行系统的\",{\"1\":{\"1380\":1}}],[\"启动时\",{\"1\":{\"456\":1}}],[\"启动类加载器\",{\"1\":{\"353\":1}}],[\"启动的时候\",{\"1\":{\"352\":1}}],[\"启动之后主要是通过单线程的方式完成主要的工作\",{\"1\":{\"227\":1}}],[\"必要前提\",{\"1\":{\"1369\":1}}],[\"必要参数校验\",{\"1\":{\"570\":1}}],[\"必然会出现各节点状态不一致的情况\",{\"1\":{\"1090\":1}}],[\"必读源码系列\",{\"1\":{\"736\":1}}],[\"必选\",{\"1\":{\"483\":1}}],[\"必须\",{\"1\":{\"1128\":3}}],[\"必须删除所有\",{\"1\":{\"1096\":1}}],[\"必须是在\",{\"1\":{\"974\":1}}],[\"必须先执行过了\",{\"1\":{\"972\":1}}],[\"必须要禁止其他节点的读写操作\",{\"1\":{\"1068\":1}}],[\"必须要经历下面\",{\"1\":{\"972\":1}}],[\"必须要保证线程是安全的\",{\"1\":{\"503\":1}}],[\"必须通过主内存来进行\",{\"1\":{\"972\":1}}],[\"必须执行完成后才能开始执行\",{\"1\":{\"781\":1}}],[\"必须首先获得对应的\",{\"1\":{\"690\":1}}],[\"必须使用集合的\",{\"1\":{\"633\":1}}],[\"必须在创建时指定容量大小\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"必须对类进行初始化\",{\"1\":{\"344\":1}}],[\"必须设置过期时间\",{\"1\":{\"307\":1}}],[\"必须保证语句语法和命令都是对的\",{\"1\":{\"283\":1}}],[\"必须事务a执行完成\",{\"1\":{\"132\":1}}],[\"🌰\",{\"1\":{\"478\":1,\"479\":2,\"1271\":1}}],[\"🌈\",{\"1\":{\"353\":1,\"357\":1,\"895\":1,\"922\":1,\"1184\":1}}],[\"翻译成中文是同步的意思\",{\"1\":{\"847\":1}}],[\"翻译成中文是原子的意思\",{\"1\":{\"762\":1}}],[\"翻译过来的意思大概就是\",{\"1\":{\"1096\":1}}],[\"翻译过来的意思就是抽象队列同步器\",{\"1\":{\"740\":1,\"903\":1}}],[\"翻译过来之后的\",{\"1\":{\"693\":1}}],[\"翻译过来大概的意思是\",{\"1\":{\"351\":1,\"356\":1}}],[\"翻译自\",{\"1\":{\"475\":1}}],[\"谢谢\",{\"1\":{\"472\":1}}],[\"希望带大家稍微详细的了解一下\",{\"1\":{\"1341\":1}}],[\"希望对你有帮助\",{\"1\":{\"1315\":1}}],[\"希望对你有所帮助\",{\"1\":{\"472\":1}}],[\"希望小伙伴不单单要理解\",{\"1\":{\"1166\":1}}],[\"希望能够成为大家了解\",{\"1\":{\"1021\":1}}],[\"希望大家能够耐心看完\",{\"1\":{\"133\":1}}],[\"禁用垃圾回收\",{\"0\":{\"467\":1}}],[\"禁止长时间开启\",{\"1\":{\"319\":1}}],[\"禁止驱逐数据\",{\"1\":{\"273\":1}}],[\"反复的睡眠\",{\"1\":{\"1183\":1}}],[\"反序列化\",{\"1\":{\"1159\":1}}],[\"反过来将二进制数组复原成结构体的过程叫\",{\"1\":{\"1159\":1}}],[\"反熵就不太适用了\",{\"1\":{\"1087\":1}}],[\"反熵就是指消除不同节点中数据的差异\",{\"1\":{\"1087\":1}}],[\"反熵伪代码\",{\"1\":{\"1087\":1}}],[\"反熵\",{\"0\":{\"1087\":1},\"1\":{\"1086\":1,\"1089\":1}}],[\"反转\",{\"1\":{\"662\":1,\"696\":1}}],[\"反响不错\",{\"1\":{\"567\":1}}],[\"反之从链表尾开始遍历\",{\"1\":{\"730\":1}}],[\"反之向前查找\",{\"1\":{\"730\":1}}],[\"反之后继节点的前驱指针直接指向前驱节点\",{\"1\":{\"711\":1}}],[\"反之让p的前驱指针指向尾节点\",{\"1\":{\"710\":1}}],[\"反之删除操作也必须等待插入操作\",{\"1\":{\"671\":1}}],[\"反之将我们的线程成为leader\",{\"1\":{\"604\":1}}],[\"反之将元素入队并直接返回true\",{\"1\":{\"536\":1}}],[\"反之\",{\"1\":{\"604\":1}}],[\"反之出队返回元素值\",{\"1\":{\"536\":1}}],[\"反之返回false\",{\"1\":{\"533\":2}}],[\"反之则会抛出异常illegalstateexception\",{\"1\":{\"533\":1}}],[\"反之若队列为空\",{\"1\":{\"531\":1}}],[\"反射最重要的用途就是开发各种通用框架\",{\"1\":{\"523\":1}}],[\"反射首先是能够获取到java中的反射类的字节码\",{\"1\":{\"523\":1}}],[\"反射原理\",{\"1\":{\"523\":1}}],[\"反射原理以及使用场景\",{\"0\":{\"523\":1}}],[\"反正最大堆内存和最小堆内存如果数值不同会导致多次的\",{\"1\":{\"454\":1}}],[\"反正最优解当然就是官方的\",{\"1\":{\"454\":1}}],[\"反馈\",{\"1\":{\"377\":1}}],[\"弹出了一个\",{\"1\":{\"451\":1}}],[\"弹性\",{\"1\":{\"4\":1}}],[\"四段式策略\",{\"1\":{\"1183\":1}}],[\"四层网络协议\",{\"1\":{\"1154\":1}}],[\"四种创建虚拟线程的方法\",{\"0\":{\"1057\":1}}],[\"四者的区别\",{\"0\":{\"640\":1}}],[\"四\",{\"0\":{\"450\":1}}],[\"四两拨千斤\",{\"1\":{\"213\":1}}],[\"校长\",{\"1\":{\"449\":1}}],[\"校验并发级别\",{\"1\":{\"570\":1}}],[\"校验并发级别大小\",{\"1\":{\"570\":1}}],[\"校验和\",{\"1\":{\"234\":1}}],[\"校验机制十分简单有效\",{\"1\":{\"234\":1}}],[\"校验机制是\",{\"1\":{\"234\":1}}],[\"校验机制了解吗\",{\"0\":{\"234\":1}}],[\"校验兑换码是否有效\",{\"1\":{\"19\":1}}],[\"校验码\",{\"1\":{\"19\":2}}],[\"够用的\",{\"1\":{\"449\":1}}],[\"幻象引用的那一套\",{\"1\":{\"446\":1}}],[\"幻读和不可重复读都是指的一个事务范围内的操作受到其他事务的影响了\",{\"1\":{\"130\":1}}],[\"幻读是读取了其他事务新增的数据\",{\"1\":{\"130\":1}}],[\"幻读\",{\"0\":{\"129\":1},\"1\":{\"132\":1}}],[\"弱一致性的升级版\",{\"1\":{\"1078\":1}}],[\"弱一致性\",{\"1\":{\"1078\":1}}],[\"弱\",{\"1\":{\"446\":1}}],[\"弱引用key\",{\"1\":{\"1030\":4}}],[\"弱引用介绍\",{\"1\":{\"884\":1}}],[\"弱引用可以和一个引用队列\",{\"1\":{\"392\":1,\"884\":1}}],[\"弱引用与软引用的区别在于\",{\"1\":{\"392\":1,\"884\":1}}],[\"弱引用\",{\"1\":{\"380\":1,\"392\":2,\"483\":1,\"1030\":2}}],[\"搜索是跳跃式的\",{\"1\":{\"800\":1}}],[\"搜索当一个对象到\",{\"1\":{\"445\":1}}],[\"搜索所走过的路径成为引用链\",{\"1\":{\"445\":1}}],[\"晋升到老年代\",{\"1\":{\"444\":1}}],[\"融合\",{\"1\":{\"443\":1}}],[\"限制了消费逻辑的线程模型\",{\"1\":{\"1292\":1}}],[\"限制元空间大小上限\",{\"1\":{\"443\":1}}],[\"限流降级\",{\"1\":{\"1305\":1}}],[\"限流\",{\"0\":{\"1221\":1},\"1\":{\"5\":1,\"68\":1,\"249\":1,\"314\":1,\"1219\":1}}],[\"替代传统\",{\"1\":{\"1310\":1}}],[\"替代品是一个元空间\",{\"1\":{\"443\":1}}],[\"替换新数据并且交换当前staleslot位置\",{\"1\":{\"1036\":1}}],[\"替换完成后也是进行过期元素清理工作\",{\"1\":{\"1035\":1}}],[\"替换table\",{\"1\":{\"1035\":1}}],[\"替换操作\",{\"0\":{\"697\":1},\"1\":{\"695\":1}}],[\"替换掉旧的数组\",{\"1\":{\"588\":1}}],[\"替换后返回旧值\",{\"1\":{\"571\":1}}],[\"替换为元空间\",{\"1\":{\"496\":1}}],[\"替换成空\",{\"1\":{\"74\":1}}],[\"局部性原理\",{\"1\":{\"1184\":1}}],[\"局部变量\",{\"1\":{\"445\":1}}],[\"局部变量表\",{\"1\":{\"493\":3,\"519\":1}}],[\"局部变量表的\",{\"1\":{\"442\":1}}],[\"局部变量表用于存放方法参数和方法内部所定义的局部变量\",{\"1\":{\"442\":1}}],[\"局部变量的复用\",{\"0\":{\"442\":1}}],[\"局部过滤器\",{\"0\":{\"74\":1},\"1\":{\"73\":1}}],[\"显得非常啰嗦\",{\"1\":{\"1159\":1}}],[\"显式指定永久代\",{\"0\":{\"480\":1}}],[\"显式指定堆内存\",{\"0\":{\"478\":1}}],[\"显式新生代内存\",{\"0\":{\"479\":1}}],[\"显式初始化和静态代码块中语句\",{\"1\":{\"430\":1}}],[\"显示程序的运行时间\",{\"1\":{\"366\":1}}],[\"显示垃圾收集信息\",{\"1\":{\"366\":1}}],[\"显示永久代大小\",{\"1\":{\"366\":1}}],[\"显示老年代的大小\",{\"1\":{\"366\":1}}],[\"显示老年代和永久代的行为统计\",{\"1\":{\"366\":1}}],[\"显示新生代大小与使用情况\",{\"1\":{\"366\":1}}],[\"显示新生代信息\",{\"1\":{\"366\":1}}],[\"显示各个代的容量及使用情况\",{\"1\":{\"366\":1}}],[\"显示与\",{\"1\":{\"366\":1}}],[\"显示\",{\"1\":{\"366\":2}}],[\"显示虚拟机进程以及进程的配置\",{\"1\":{\"377\":1}}],[\"显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一\",{\"1\":{\"365\":1}}],[\"显示虚拟机配置信息\",{\"1\":{\"364\":1}}],[\"显示查询将访问的分区\",{\"1\":{\"120\":1}}],[\"顺利拿到字节\",{\"1\":{\"1177\":1}}],[\"顺利转正\",{\"1\":{\"808\":1}}],[\"顺便还不忘嘲讽一下这群学者\",{\"1\":{\"1096\":1}}],[\"顺便简单总结一下用户线程和内核线程的区别和特点\",{\"1\":{\"808\":1}}],[\"顺序一致性\",{\"1\":{\"1345\":1}}],[\"顺序消息发送必须要设置消息组\",{\"1\":{\"1286\":1}}],[\"顺序消息仅支持使用\",{\"1\":{\"1286\":1}}],[\"顺序消息\",{\"0\":{\"1286\":1}}],[\"顺序消费\",{\"0\":{\"1299\":1},\"1\":{\"1275\":1,\"1316\":1}}],[\"顺序访问等机制来保障数据一致性\",{\"1\":{\"1069\":1}}],[\"顺序执行\",{\"1\":{\"492\":1,\"811\":1}}],[\"顺序执行所有类变量\",{\"1\":{\"430\":1}}],[\"顺带补充一下\",{\"1\":{\"287\":1}}],[\"找出活跃数最小的\",{\"1\":{\"1142\":1}}],[\"找出活跃的对象\",{\"1\":{\"444\":1}}],[\"找其他过期的数据\",{\"1\":{\"1035\":1}}],[\"找不到则返回\",{\"1\":{\"697\":1}}],[\"找一块儿足够大的内存块儿来划分给对象实例\",{\"1\":{\"503\":1}}],[\"找方法就在方法表中找\",{\"1\":{\"425\":1}}],[\"找到消息\",{\"1\":{\"1315\":1}}],[\"找到远程服务的地址\",{\"1\":{\"1166\":1}}],[\"找到了key值相等的entry数据\",{\"1\":{\"1040\":1}}],[\"找到最近一个可以存放entry的位置\",{\"1\":{\"1037\":1}}],[\"找到没有过期的数据\",{\"1\":{\"1036\":1}}],[\"找到可以使用的桶\",{\"1\":{\"1036\":1}}],[\"找到后移动index=\",{\"1\":{\"1037\":1}}],[\"找到后更新entry的值并交换staleslot元素的位置\",{\"1\":{\"1035\":1}}],[\"找到后替换\",{\"1\":{\"571\":1}}],[\"找到队列第一个waitstatus<0的节点\",{\"1\":{\"1014\":1}}],[\"找到第一个\",{\"1\":{\"1013\":1}}],[\"找到第一个满足条件的记录\",{\"1\":{\"117\":1}}],[\"找到下一个\",{\"1\":{\"713\":1}}],[\"找到被调用最多\",{\"1\":{\"377\":1}}],[\"找到发生死锁的线程\",{\"1\":{\"370\":1}}],[\"找到叶子节点就可以将数据库返回\",{\"1\":{\"108\":1}}],[\"找到\",{\"1\":{\"96\":1,\"286\":1,\"425\":1,\"1361\":1}}],[\"马上加载\",{\"1\":{\"425\":1}}],[\"⑤system\",{\"1\":{\"1231\":1}}],[\"⑤\",{\"0\":{\"423\":1}}],[\"④headers\",{\"1\":{\"1231\":1}}],[\"④\",{\"0\":{\"422\":1},\"1\":{\"520\":1}}],[\"③topic\",{\"1\":{\"1231\":1}}],[\"③抽象类可以包含普通方法\",{\"1\":{\"520\":1}}],[\"③\",{\"0\":{\"421\":1},\"1\":{\"520\":1}}],[\"②fanout\",{\"1\":{\"1231\":1}}],[\"②pub\",{\"1\":{\"1231\":1}}],[\"②\",{\"0\":{\"420\":1},\"1\":{\"520\":1,\"622\":1,\"677\":1,\"1362\":1}}],[\"①direct\",{\"1\":{\"1231\":1}}],[\"①peer\",{\"1\":{\"1231\":1}}],[\"①\",{\"0\":{\"419\":1},\"1\":{\"520\":2,\"622\":1,\"677\":1,\"1362\":1}}],[\"案例分析\",{\"1\":{\"1185\":1}}],[\"案例代码概览\",{\"1\":{\"919\":1}}],[\"案例\",{\"1\":{\"412\":2}}],[\"调试\",{\"1\":{\"1062\":1}}],[\"调度程序通过平台线程\",{\"1\":{\"1053\":1}}],[\"调度\",{\"1\":{\"1052\":1}}],[\"调优和监控\",{\"1\":{\"887\":1,\"933\":1}}],[\"调优实践\",{\"1\":{\"486\":1}}],[\"调优策略中很重要的一条经验总结是这样说的\",{\"1\":{\"479\":1}}],[\"调优的一些方面\",{\"0\":{\"450\":1}}],[\"调整标志定义元空间的初始大小如果未指定此标志\",{\"1\":{\"496\":1}}],[\"调整每个线程栈空间的大小\",{\"0\":{\"458\":1},\"1\":{\"458\":1}}],[\"调整新生代和老年代的比值\",{\"0\":{\"452\":1}}],[\"调整最大堆内存和最小堆内存\",{\"0\":{\"451\":1}}],[\"调整\",{\"0\":{\"453\":1},\"1\":{\"449\":1}}],[\"调整过程记得小步快跑\",{\"1\":{\"412\":1}}],[\"调用transferto方法向目标数据传输\",{\"1\":{\"1311\":1}}],[\"调用时会发生切换\",{\"1\":{\"1311\":1}}],[\"调用时间等\",{\"1\":{\"1136\":1}}],[\"调用的时候会发生上下文切换\",{\"1\":{\"1310\":1}}],[\"调用的协议\",{\"1\":{\"1161\":1}}],[\"调用方式\",{\"1\":{\"1154\":1,\"1390\":1}}],[\"调用次数和调用时间监控\",{\"1\":{\"1130\":1}}],[\"调用远程方法的一端\",{\"1\":{\"1166\":1}}],[\"调用远程方法像调用本地的方法一样简单的一个关键\",{\"1\":{\"1130\":1}}],[\"调用远程服务的服务消费方\",{\"1\":{\"1128\":1}}],[\"调用cleansomeslots\",{\"1\":{\"1036\":1}}],[\"调用countdownlatch对象的\",{\"1\":{\"909\":1}}],[\"调用copyonwritearraylist的add\",{\"1\":{\"589\":1}}],[\"调用尚未构造完全的对象的方法可能引发令人疑惑的错误\",{\"1\":{\"934\":1}}],[\"调用完\",{\"1\":{\"924\":1}}],[\"调用执行自己的线程运行任务\",{\"1\":{\"891\":1,\"936\":1}}],[\"调用一个实例对象的非静态\",{\"1\":{\"848\":1}}],[\"调用在发出之后\",{\"1\":{\"815\":1}}],[\"调用对象\",{\"1\":{\"807\":1}}],[\"调用send方法发送消息之后\",{\"1\":{\"1204\":1}}],[\"调用semaphore\",{\"1\":{\"748\":2,\"906\":2}}],[\"调用system\",{\"1\":{\"562\":1}}],[\"调用system提供的arraycopy\",{\"1\":{\"553\":1}}],[\"调用removenode将元素从hashmap的bucket中移除\",{\"1\":{\"712\":1}}],[\"调用插入后置方法\",{\"1\":{\"712\":1}}],[\"调用了method2\",{\"1\":{\"860\":1}}],[\"调用了阻塞类型的系统中断\",{\"1\":{\"821\":1}}],[\"调用了\",{\"1\":{\"711\":1}}],[\"调用父类即\",{\"1\":{\"710\":1}}],[\"调用父加载器\",{\"1\":{\"357\":1,\"359\":1}}],[\"调用indexedbinarysearch\",{\"1\":{\"658\":1}}],[\"调用index尝试查找指定元素\",{\"1\":{\"592\":1}}],[\"调用entry对象中的getkey\",{\"1\":{\"625\":1}}],[\"调用优先队列\",{\"1\":{\"605\":1}}],[\"调用peek方法看看当前队首元素是否就是本次入队的元素\",{\"1\":{\"603\":1}}],[\"调用get\",{\"1\":{\"589\":1}}],[\"调用grow方法进行扩容\",{\"1\":{\"553\":1,\"557\":1}}],[\"调用者可以自由地修改返回的数组\",{\"1\":{\"553\":1}}],[\"调用此方法代表已经开始扩容了\",{\"1\":{\"553\":1}}],[\"调用offer如果失败直接抛出异常\",{\"1\":{\"536\":1}}],[\"调用下方的add\",{\"1\":{\"536\":1}}],[\"调用继承\",{\"1\":{\"533\":1}}],[\"调用不同的方法\",{\"1\":{\"523\":1}}],[\"调用自己的\",{\"1\":{\"357\":1}}],[\"调用\",{\"1\":{\"161\":1,\"535\":1,\"536\":1,\"603\":1,\"604\":1,\"678\":2,\"710\":1,\"712\":1,\"742\":1,\"747\":1,\"777\":1,\"782\":1,\"820\":1,\"827\":2,\"834\":1,\"841\":1,\"905\":1,\"934\":1,\"990\":1,\"1122\":1,\"1130\":1,\"1172\":1,\"1211\":1}}],[\"调用也存在网络开销\",{\"1\":{\"42\":1}}],[\"陈树义\",{\"1\":{\"412\":1,\"486\":1}}],[\"今天我们来尝试重新换个方式讲一讲\",{\"1\":{\"1150\":1}}],[\"今天我小试了一把\",{\"1\":{\"412\":1,\"486\":1}}],[\"今天就来彻底搞懂他\",{\"1\":{\"93\":1}}],[\"掌握\",{\"1\":{\"412\":1}}],[\"学有余力的小伙伴可以抽时间详细研究一下对象监视器\",{\"1\":{\"853\":1}}],[\"学习成本相对也较低\",{\"1\":{\"1172\":1}}],[\"学习者\",{\"1\":{\"1098\":1}}],[\"学习\",{\"1\":{\"1085\":1}}],[\"学习并发编程三大神器\",{\"1\":{\"788\":1}}],[\"学习新知识的时候千万不要一上来就陷入细节\",{\"1\":{\"80\":1}}],[\"学会\",{\"1\":{\"412\":1}}],[\"收发的这些\",{\"1\":{\"1152\":1}}],[\"收到\",{\"1\":{\"1380\":1}}],[\"收到之后发现和自己的一样无需做更改\",{\"1\":{\"1380\":1}}],[\"收到超过半数的\",{\"1\":{\"1374\":1}}],[\"收到消息的参与者会进行事务的提交\",{\"1\":{\"1370\":1}}],[\"收到消息将消息反序列化为\",{\"1\":{\"1166\":1}}],[\"收到了发现自己的投票已经超过半数就把自己设为\",{\"1\":{\"1380\":1}}],[\"收到了\",{\"1\":{\"1380\":1}}],[\"收到了超过半数的\",{\"1\":{\"1374\":1}}],[\"收到了任何一个\",{\"1\":{\"1371\":1}}],[\"收到了多数的成功响应\",{\"1\":{\"1112\":1}}],[\"收到了大量的服务超时告警\",{\"1\":{\"412\":1}}],[\"收到客户端请求后\",{\"1\":{\"1112\":1}}],[\"收尾逻辑\",{\"1\":{\"604\":1}}],[\"收集自网络\",{\"1\":{\"1244\":1}}],[\"收集算法\",{\"1\":{\"402\":1}}],[\"收集算法出现了\",{\"1\":{\"397\":1}}],[\"收集整个\",{\"1\":{\"387\":1}}],[\"收集器成为默认的垃圾收集器\",{\"1\":{\"448\":1}}],[\"收集器在有限时间内可以尽可能高的收集效率\",{\"1\":{\"407\":1}}],[\"收集器在后台维护了一个优先列表\",{\"1\":{\"407\":1}}],[\"收集器仍然可以通过并发的方式让\",{\"1\":{\"407\":1}}],[\"收集器是一种\",{\"1\":{\"406\":1}}],[\"收集器是一种以获取最短回收停顿时间为目标的收集器\",{\"1\":{\"406\":1}}],[\"收集器是\",{\"1\":{\"406\":1}}],[\"收集器是最基本\",{\"1\":{\"401\":1}}],[\"收集器和\",{\"1\":{\"405\":1}}],[\"收集器搭配使用\",{\"1\":{\"404\":1}}],[\"收集器的算法是\",{\"1\":{\"503\":1}}],[\"收集器的详细介绍推荐阅读美团技术团队的\",{\"1\":{\"408\":1}}],[\"收集器的运作大致分为以下几个步骤\",{\"1\":{\"407\":1}}],[\"收集器的后备方案\",{\"1\":{\"404\":1}}],[\"收集器的老年代版本\",{\"1\":{\"404\":1,\"405\":1}}],[\"收集器的多线程版本\",{\"1\":{\"402\":1}}],[\"收集器配合自适应调节策略\",{\"1\":{\"403\":1}}],[\"收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量\",{\"1\":{\"403\":1}}],[\"收集器关注点是吞吐量\",{\"1\":{\"403\":1}}],[\"收集器+\",{\"1\":{\"403\":2}}],[\"收集器也是使用标记\",{\"1\":{\"403\":1}}],[\"收集器外\",{\"1\":{\"402\":1}}],[\"收集器完全一样\",{\"1\":{\"402\":1}}],[\"收集器其实就是\",{\"1\":{\"402\":1}}],[\"收集器对于运行在\",{\"1\":{\"401\":1}}],[\"收集器由于没有线程交互的开销\",{\"1\":{\"401\":1}}],[\"收集器有没有优于其他垃圾收集器的地方呢\",{\"1\":{\"401\":1}}],[\"收集器\",{\"0\":{\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"405\":1,\"406\":1,\"407\":1,\"408\":1},\"1\":{\"380\":1,\"401\":1,\"402\":2,\"404\":1,\"405\":1,\"406\":1,\"407\":1,\"503\":2}}],[\"收集程序的运行时配置\",{\"1\":{\"377\":1}}],[\"收集起来\",{\"1\":{\"23\":1}}],[\"掘金\",{\"1\":{\"412\":1,\"486\":1}}],[\"紧急回滚至上一稳定版本\",{\"1\":{\"412\":1}}],[\"紧接着\",{\"1\":{\"604\":1}}],[\"紧接着的两个字节代表访问标志\",{\"1\":{\"329\":1}}],[\"紧接着主次版本号之后的是常量池\",{\"1\":{\"328\":1}}],[\"紧接着魔数的四个字节存储的是\",{\"1\":{\"327\":1}}],[\"紧接着第4\",{\"1\":{\"141\":1}}],[\"月\",{\"1\":{\"412\":1}}],[\"程语有云\",{\"1\":{\"412\":1}}],[\"程序顺序规则\",{\"1\":{\"975\":1}}],[\"程序运行的时候我们把外存的数据复制到内存\",{\"1\":{\"968\":1}}],[\"程序运行期间的时候\",{\"1\":{\"896\":1,\"923\":1}}],[\"程序运行时比较高效\",{\"1\":{\"324\":1}}],[\"程序入口\",{\"1\":{\"807\":1}}],[\"程序有哪些线程\",{\"1\":{\"807\":1}}],[\"程序天生就是多线程程序\",{\"1\":{\"807\":1}}],[\"程序来说\",{\"1\":{\"772\":1}}],[\"程序来同时监听多个套接字\",{\"1\":{\"265\":1}}],[\"程序使用trycatch进行捕捉处理\",{\"1\":{\"524\":1}}],[\"程序应该从逻辑角度尽可能避免这类异常的发生\",{\"1\":{\"524\":1}}],[\"程序内存更加安全\",{\"1\":{\"517\":2}}],[\"程序通过栈上的\",{\"1\":{\"508\":1}}],[\"程序能访问到这些字段的数据类型所对应的零值\",{\"1\":{\"504\":1}}],[\"程序员追求的是易于理解和编程的强内存模型\",{\"1\":{\"974\":1}}],[\"程序员把内存控制权利交给\",{\"1\":{\"490\":1}}],[\"程序员来说\",{\"1\":{\"490\":1}}],[\"程序员历小冰\",{\"1\":{\"237\":1}}],[\"程序的运行是\",{\"1\":{\"807\":1}}],[\"程序的执行效率就明显提高了\",{\"1\":{\"773\":1,\"899\":1}}],[\"程序的视角来看\",{\"1\":{\"506\":1}}],[\"程序的过程中会把它管理的内存划分成若干个不同的数据区域\",{\"1\":{\"491\":1}}],[\"程序的不正常退出\",{\"1\":{\"446\":1}}],[\"程序的稳定运行\",{\"1\":{\"358\":1}}],[\"程序中使用\",{\"1\":{\"1204\":1}}],[\"程序中通常会有大量的被创建的字符串等待回收\",{\"1\":{\"498\":1}}],[\"程序中该方法的存在\",{\"1\":{\"446\":1}}],[\"程序中的一个重要组成部分\",{\"1\":{\"351\":1}}],[\"程序计数器私有主要是为了线程切换后能恢复到正确的执行位置\",{\"1\":{\"811\":1}}],[\"程序计数器主要有下面两个作用\",{\"1\":{\"811\":1}}],[\"程序计数器为什么是私有的\",{\"0\":{\"811\":1}}],[\"程序计数器是唯一一个不会出现\",{\"1\":{\"492\":1}}],[\"程序计数器是一块较小的内存空间\",{\"1\":{\"492\":1}}],[\"程序计数器用于记录当前线程执行的位置\",{\"1\":{\"492\":1,\"811\":1}}],[\"程序计数器其实就是一个指针\",{\"1\":{\"435\":1}}],[\"程序计数器\",{\"0\":{\"423\":1,\"492\":1},\"1\":{\"491\":1}}],[\"程序继续执行\",{\"1\":{\"407\":1}}],[\"程序如果发现某个虚引用已经被加入到引用队列\",{\"1\":{\"392\":1}}],[\"程序可以通过判断引用队列中是否已经加入了虚引用\",{\"1\":{\"392\":1}}],[\"程序概况\",{\"0\":{\"374\":1},\"1\":{\"374\":1}}],[\"程序启动时加上下面这些参数\",{\"1\":{\"373\":1}}],[\"程序代码\",{\"1\":{\"344\":1}}],[\"程序语义检查\",{\"1\":{\"341\":1}}],[\"程序安全都是第一位\",{\"1\":{\"341\":1}}],[\"程序无须重新编译便可在多种不同操作系统的计算机上运行\",{\"1\":{\"324\":1}}],[\"程序无须对现有\",{\"1\":{\"233\":1}}],[\"程序设计不当\",{\"1\":{\"292\":1}}],[\"程序获取唯一\",{\"1\":{\"42\":2}}],[\"排序规则由comparatator类控制\",{\"1\":{\"697\":1}}],[\"排序操作\",{\"0\":{\"696\":1}}],[\"排序\",{\"1\":{\"695\":1}}],[\"排序的方式有自然排序和定制排序\",{\"1\":{\"665\":1}}],[\"排序等方面发挥了重要作用\",{\"1\":{\"661\":1}}],[\"排查\",{\"1\":{\"412\":1}}],[\"排他锁\",{\"1\":{\"140\":1}}],[\"记得\",{\"1\":{\"455\":1}}],[\"记一次特殊的\",{\"1\":{\"412\":1}}],[\"记一次\",{\"1\":{\"412\":1}}],[\"记录在本地\",{\"1\":{\"1373\":1}}],[\"记录当前获得锁的线程标识\",{\"1\":{\"1019\":1}}],[\"记录当前队列容量\",{\"1\":{\"534\":1}}],[\"记录e的value\",{\"1\":{\"622\":1}}],[\"记录\",{\"1\":{\"570\":2}}],[\"记录段掩码\",{\"1\":{\"570\":1}}],[\"记录段偏移量\",{\"1\":{\"570\":1}}],[\"记录慢查询语句类似\",{\"1\":{\"302\":1}}],[\"记录服务器执行的所有写命令\",{\"1\":{\"162\":1,\"233\":1}}],[\"记录日志等\",{\"1\":{\"785\":1}}],[\"记录日志是在\",{\"1\":{\"160\":1,\"232\":1}}],[\"记录日志不会对命令进行语法检查\",{\"1\":{\"160\":1,\"232\":1}}],[\"记录日志过程\",{\"1\":{\"160\":1,\"232\":1}}],[\"记录事务修改之前版本的数据信息\",{\"1\":{\"138\":1}}],[\"记录了已经提交的操作\",{\"1\":{\"136\":1}}],[\"记录的是这个语句的原始逻辑\",{\"1\":{\"89\":1}}],[\"记录的是\",{\"1\":{\"89\":1}}],[\"记录所有请求的行为日志供后续使用\",{\"1\":{\"2\":1}}],[\"资料\",{\"1\":{\"412\":3}}],[\"资源调度和治理\",{\"1\":{\"1123\":1}}],[\"资源作为支持\",{\"1\":{\"1056\":1}}],[\"资源被浪费\",{\"1\":{\"1012\":1}}],[\"资源共享方式\",{\"0\":{\"743\":1}}],[\"资源敏感\",{\"1\":{\"406\":1}}],[\"资源的场合\",{\"1\":{\"405\":1}}],[\"资源的浪费\",{\"1\":{\"233\":1}}],[\"资源\",{\"1\":{\"370\":2,\"810\":1,\"819\":2,\"823\":2,\"895\":2,\"922\":2}}],[\"资源和内存资源产生影响\",{\"1\":{\"236\":1}}],[\"资源操作\",{\"1\":{\"53\":1}}],[\"现已成为\",{\"1\":{\"1367\":1}}],[\"现代处理器采用了指令级并行技术\",{\"1\":{\"969\":1}}],[\"现代的\",{\"1\":{\"968\":1}}],[\"现象\",{\"1\":{\"412\":4}}],[\"现在我们来简单梳理一下整篇文章的内容\",{\"1\":{\"1391\":1}}],[\"现在我们再来分析一下\",{\"1\":{\"145\":1}}],[\"现在很多数据库都是采用的两阶段提交协议来完成\",{\"1\":{\"1370\":1}}],[\"现在主要场景也就在\",{\"1\":{\"1299\":1}}],[\"现在电脑上装的各种联网软件\",{\"1\":{\"1155\":1}}],[\"现在都是分布式系统统一对外提供服务\",{\"1\":{\"1045\":1}}],[\"现在来回答一下\",{\"1\":{\"1016\":1}}],[\"现在应该是不是很容易就可以搞懂它的原理了呢\",{\"1\":{\"941\":1}}],[\"现在\",{\"1\":{\"941\":2}}],[\"现在的时分\",{\"1\":{\"820\":1}}],[\"现在的系统动不动就要求百万级甚至千万级的并发量\",{\"1\":{\"816\":1}}],[\"现在的\",{\"1\":{\"808\":1}}],[\"现在只需要\",{\"1\":{\"800\":1}}],[\"现在公司一般都是用\",{\"1\":{\"245\":1}}],[\"现在基本没有看过还有项目使用\",{\"1\":{\"244\":1}}],[\"现在就是\",{\"1\":{\"89\":1}}],[\"现在最常用的存储引擎是\",{\"1\":{\"83\":1}}],[\"现在常用的解决方案是为整个系统引入分布式链路跟踪\",{\"1\":{\"21\":1}}],[\"艾小仙\",{\"1\":{\"412\":1}}],[\"筛选回收\",{\"1\":{\"407\":1}}],[\"筛选的条件是此对象是否有必要执行\",{\"1\":{\"391\":1}}],[\"动作使用\",{\"1\":{\"972\":1}}],[\"动作\",{\"1\":{\"407\":1}}],[\"动态替换接口的实现类\",{\"1\":{\"1131\":1}}],[\"动态配置线程池参数最终效果\",{\"1\":{\"896\":1,\"923\":1}}],[\"动态代理\",{\"1\":{\"523\":1}}],[\"动态代理技术运行时动态生成\",{\"1\":{\"340\":1}}],[\"动态绑定过程会首先确定实际类型是子类\",{\"1\":{\"519\":1}}],[\"动态连接\",{\"1\":{\"493\":1,\"519\":1}}],[\"动态链接的作用就是为了将符号引用转换为调用方法的直接引用\",{\"1\":{\"493\":1}}],[\"动态链接\",{\"1\":{\"493\":2,\"494\":1,\"511\":1}}],[\"动态链表\",{\"1\":{\"438\":1}}],[\"动态年龄计算的代码如下\",{\"1\":{\"386\":1,\"495\":1}}],[\"动态生成的等所有代码\",{\"1\":{\"341\":1}}],[\"动态生成一码付的二维码预先绑定用户所选的商品信息和价格\",{\"1\":{\"17\":1}}],[\"动态设置\",{\"1\":{\"267\":1}}],[\"动态点赞等等\",{\"1\":{\"259\":1}}],[\"动态点赞等场景\",{\"1\":{\"190\":1}}],[\"低\",{\"1\":{\"1379\":1}}],[\"低一个数量级\",{\"1\":{\"1240\":1}}],[\"低延时及高可扩展性等流数据存储特性\",{\"1\":{\"1238\":1}}],[\"低停顿\",{\"1\":{\"406\":1}}],[\"低三位保存类型标志\",{\"1\":{\"256\":1}}],[\"远程过程调用\",{\"1\":{\"1154\":1}}],[\"远程调用层\",{\"1\":{\"1130\":1}}],[\"远程调用解决方案\",{\"0\":{\"1046\":1}}],[\"远程进程地址如下\",{\"1\":{\"373\":1}}],[\"远远好于\",{\"1\":{\"791\":1}}],[\"远远比并发标记阶段时间短\",{\"1\":{\"406\":1}}],[\"远离\",{\"1\":{\"412\":1}}],[\"另一个操作\",{\"1\":{\"974\":1}}],[\"另一个比较常用的与之对应的方法是\",{\"1\":{\"749\":1}}],[\"另一个线程不能使用\",{\"1\":{\"688\":1}}],[\"另一个是过期key相关entry的探测式清理\",{\"1\":{\"1036\":1}}],[\"另一个是\",{\"1\":{\"639\":1}}],[\"另一种则会返回特殊值\",{\"1\":{\"667\":1}}],[\"另一种用途是作为\",{\"1\":{\"404\":1}}],[\"另一端删除元素\",{\"1\":{\"667\":1}}],[\"另一部分是类型指针\",{\"1\":{\"507\":1}}],[\"另外还有日志系统\",{\"1\":{\"1284\":1}}],[\"另外还有一个\",{\"1\":{\"949\":1}}],[\"另外其他\",{\"1\":{\"663\":1}}],[\"另外两个构造方法都是基于上述的构造方法\",{\"1\":{\"534\":1}}],[\"另外一个被放在了任务队列中\",{\"1\":{\"919\":1}}],[\"另外一个事务也访问该同一数据\",{\"1\":{\"128\":1}}],[\"另外一个事务也访问这个数据\",{\"1\":{\"127\":1}}],[\"另外一种分类是按照过滤器\",{\"1\":{\"73\":1}}],[\"另外\",{\"1\":{\"1\":1,\"34\":1,\"37\":1,\"38\":1,\"157\":1,\"218\":1,\"219\":1,\"220\":1,\"244\":1,\"267\":1,\"270\":1,\"283\":1,\"285\":1,\"287\":1,\"301\":1,\"307\":1,\"313\":1,\"316\":1,\"319\":1,\"356\":1,\"366\":1,\"479\":1,\"480\":1,\"492\":1,\"493\":1,\"505\":1,\"611\":1,\"645\":1,\"656\":1,\"677\":1,\"724\":1,\"742\":1,\"757\":1,\"765\":1,\"788\":1,\"816\":1,\"851\":1,\"869\":1,\"871\":1,\"873\":1,\"889\":1,\"896\":1,\"904\":1,\"923\":1,\"924\":1,\"969\":2,\"1068\":1,\"1123\":1,\"1126\":2,\"1143\":1,\"1166\":1,\"1184\":1,\"1204\":2,\"1222\":2,\"1341\":2,\"1344\":1,\"1353\":1,\"1359\":1}}],[\"配上失败重试的方式保证更新操作的原子性\",{\"1\":{\"503\":1}}],[\"配合工作\",{\"1\":{\"402\":1}}],[\"配置维护\",{\"1\":{\"1367\":1}}],[\"配置信息\",{\"1\":{\"1281\":1}}],[\"配置中心\",{\"1\":{\"1218\":1}}],[\"配置层\",{\"1\":{\"1130\":1}}],[\"配置合理的参数\",{\"1\":{\"928\":1}}],[\"配置线程池的时候根据当前业务的情况对当前线程池进行配置\",{\"1\":{\"919\":1}}],[\"配置什么值\",{\"1\":{\"480\":1}}],[\"配置文件\",{\"1\":{\"267\":2,\"351\":1}}],[\"配置文件中默认有此下配置\",{\"1\":{\"226\":1}}],[\"配置项设置为\",{\"1\":{\"220\":1}}],[\"配置来决定何时将其同步到硬盘中的\",{\"1\":{\"161\":1}}],[\"配置如下所示\",{\"1\":{\"75\":1}}],[\"配置了两个断言\",{\"1\":{\"71\":1}}],[\"配置了两个路由规则\",{\"1\":{\"70\":1}}],[\"配置了三个断言\",{\"1\":{\"71\":1}}],[\"众说纷纭\",{\"1\":{\"396\":1}}],[\"阶段参与者如未收到协调者发送的提交事务的请求\",{\"1\":{\"1371\":1}}],[\"阶段的工作\",{\"1\":{\"1375\":2}}],[\"阶段的流程图\",{\"1\":{\"1373\":1}}],[\"阶段的\",{\"1\":{\"1371\":1}}],[\"阶段之前\",{\"1\":{\"483\":1}}],[\"阶段\",{\"0\":{\"1373\":1,\"1374\":1},\"1\":{\"396\":1,\"1371\":5,\"1372\":1,\"1374\":1,\"1375\":2}}],[\"清理数据\",{\"1\":{\"1039\":1}}],[\"清理完成之后\",{\"1\":{\"1038\":1}}],[\"清理完成后如果size\",{\"1\":{\"1036\":1}}],[\"清理过期key\",{\"1\":{\"1036\":1}}],[\"清理散列数组中entry的key过期的数据\",{\"1\":{\"1036\":1}}],[\"清理工作主要是有两个方法\",{\"1\":{\"1035\":1}}],[\"清除过程大致是这样的\",{\"1\":{\"396\":1}}],[\"清除\",{\"1\":{\"396\":2,\"398\":1,\"399\":1,\"406\":2,\"407\":1,\"503\":1,\"807\":1}}],[\"清除算法的效率和内存碎片问题\",{\"1\":{\"397\":1}}],[\"清除算法\",{\"0\":{\"396\":1},\"1\":{\"396\":1,\"397\":1}}],[\"清空无效队列\",{\"1\":{\"969\":1}}],[\"清空后的链表\",{\"1\":{\"733\":2}}],[\"清空链表\",{\"1\":{\"733\":1}}],[\"清空慢查询命令\",{\"1\":{\"302\":1}}],[\"清空当前\",{\"1\":{\"266\":1}}],[\"清空所有数据库的所有\",{\"1\":{\"266\":1}}],[\"清空购物车直接删除对应的\",{\"1\":{\"257\":1}}],[\"清空数据库和上面\",{\"1\":{\"166\":1}}],[\"清空数据库\",{\"0\":{\"166\":1}}],[\"错误方式二\",{\"1\":{\"1292\":1}}],[\"错误方式一\",{\"1\":{\"1292\":1}}],[\"错误检测和数据表示等\",{\"1\":{\"1253\":1}}],[\"错误的时钟和极端的消息延迟\",{\"1\":{\"1106\":1}}],[\"错误或者丢失\",{\"1\":{\"818\":1}}],[\"错误出现\",{\"1\":{\"499\":1}}],[\"错误之外\",{\"1\":{\"493\":1}}],[\"错误之前在\",{\"1\":{\"484\":1}}],[\"错误时将\",{\"1\":{\"484\":1}}],[\"错误\",{\"1\":{\"392\":1,\"412\":1,\"493\":2,\"495\":1,\"497\":1}}],[\"强调一句\",{\"1\":{\"1348\":1}}],[\"强调的是多个线程在某一时刻同时开始执行\",{\"1\":{\"753\":1}}],[\"强一致性\",{\"1\":{\"1078\":1}}],[\"强制线程池不允许使用\",{\"1\":{\"937\":1}}],[\"强制在主存中进行读取\",{\"1\":{\"833\":1}}],[\"强烈建议你在使用stampedlock\",{\"1\":{\"873\":1}}],[\"强烈建议小伙伴们多多阅读几遍\",{\"1\":{\"628\":1}}],[\"强烈推荐阅读\",{\"1\":{\"742\":1}}],[\"强烈推荐\",{\"1\":{\"307\":1}}],[\"强大的生态\",{\"1\":{\"515\":1}}],[\"强引用\",{\"1\":{\"392\":1,\"483\":1,\"1030\":1}}],[\"影响定时精度\",{\"1\":{\"1285\":1}}],[\"影响程序的整体性能\",{\"1\":{\"891\":1,\"936\":1}}],[\"影响代码的正常运行\",{\"1\":{\"837\":1,\"986\":1,\"995\":1}}],[\"影响了整体执行效率\",{\"1\":{\"895\":1,\"922\":1}}],[\"影响了\",{\"1\":{\"391\":1}}],[\"影响用户体验的售后体验\",{\"1\":{\"18\":1}}],[\"至少在\",{\"1\":{\"1314\":1}}],[\"至少有\",{\"1\":{\"1206\":1}}],[\"至少要经历两次标记过程\",{\"1\":{\"391\":1}}],[\"至于注册中心也很简单\",{\"1\":{\"1390\":1}}],[\"至于谁希望订阅\",{\"1\":{\"1272\":1}}],[\"至于达到各个节点的状态一致需要多长时间\",{\"1\":{\"1090\":1}}],[\"至于怎么排的我们可以先不关心\",{\"1\":{\"442\":1}}],[\"至于具体选择\",{\"1\":{\"57\":1}}],[\"呢\",{\"0\":{\"1155\":1},\"1\":{\"391\":1,\"496\":1,\"1045\":1,\"1273\":1,\"1275\":4,\"1357\":1,\"1379\":1,\"1380\":1,\"1388\":1}}],[\"死信邮箱\",{\"1\":{\"1256\":1}}],[\"死信交换器\",{\"1\":{\"1256\":1}}],[\"死信队列设置等\",{\"1\":{\"1297\":1}}],[\"死信队列\",{\"1\":{\"1213\":1,\"1261\":1}}],[\"死亡\",{\"1\":{\"1213\":1}}],[\"死亡对象判断方法\",{\"0\":{\"389\":1}}],[\"死机即计划任务将不再运行\",{\"1\":{\"962\":1}}],[\"死锁\",{\"1\":{\"817\":1,\"919\":1}}],[\"死循环\",{\"1\":{\"370\":1}}],[\"尽自己所能地去消息队列中取消息和消费消息\",{\"1\":{\"1273\":1}}],[\"尽管这些交互流程和等待通知的机制实现非常复杂\",{\"1\":{\"530\":1}}],[\"尽管这次\",{\"1\":{\"388\":1}}],[\"尽管它包含了比典型符号表更广泛的数据\",{\"1\":{\"497\":1}}],[\"尽量多分布在不同\",{\"1\":{\"1281\":1}}],[\"尽量复用原有的\",{\"1\":{\"1057\":1}}],[\"尽量避免使用\",{\"0\":{\"785\":1},\"1\":{\"785\":1}}],[\"尽量使用这些原子性的复合操作方法来保证原子性\",{\"1\":{\"694\":1}}],[\"尽量较少碰撞\",{\"1\":{\"684\":1}}],[\"尽量不要使用\",{\"1\":{\"848\":1}}],[\"尽量不适用\",{\"1\":{\"319\":1}}],[\"尽量不使用\",{\"1\":{\"319\":1}}],[\"尽量将无效的\",{\"1\":{\"307\":1}}],[\"尽量也要考虑高可用\",{\"1\":{\"1\":1}}],[\"混合型的存储结构\",{\"1\":{\"1315\":1}}],[\"混合收集\",{\"1\":{\"387\":1}}],[\"混合持久化\",{\"1\":{\"236\":1}}],[\"额外补充说明\",{\"1\":{\"386\":1}}],[\"岁\",{\"1\":{\"386\":2,\"495\":1}}],[\"岁的所有男孩\",{\"1\":{\"117\":1}}],[\"垃圾搜集器内部是根据变量\",{\"1\":{\"480\":1}}],[\"垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源\",{\"1\":{\"451\":1}}],[\"垃圾回收详解\",{\"1\":{\"447\":1}}],[\"垃圾回收算法\",{\"0\":{\"447\":1}}],[\"垃圾回收器将永远不会回收被引用的对象\",{\"1\":{\"1030\":1}}],[\"垃圾回收器\",{\"0\":{\"482\":1}}],[\"垃圾回收器就不会回收它\",{\"1\":{\"392\":1}}],[\"垃圾回收器绝不会回收它\",{\"1\":{\"392\":1}}],[\"垃圾回收器中\",{\"1\":{\"385\":1}}],[\"垃圾回收器会根据\",{\"1\":{\"385\":1}}],[\"垃圾收集相关\",{\"0\":{\"481\":1}}],[\"垃圾收集行为在这个区域是比较少出现的\",{\"1\":{\"480\":1,\"496\":1}}],[\"垃圾收集就是收集这些对象然后交给\",{\"1\":{\"443\":1}}],[\"垃圾收集器成为了默认的垃圾收集器\",{\"1\":{\"407\":1}}],[\"垃圾收集器\",{\"0\":{\"400\":1},\"1\":{\"482\":2}}],[\"垃圾收集算法\",{\"0\":{\"395\":1}}],[\"垃圾收集有哪些算法\",{\"1\":{\"380\":1}}],[\"垃圾收集\",{\"1\":{\"366\":1}}],[\"旨在表彰过去一年里全球个人或公司开发的\",{\"1\":{\"1178\":1}}],[\"旨在避免将大对象放入新生代\",{\"1\":{\"385\":1}}],[\"旨在非常接近已编译的机器代码\",{\"1\":{\"8\":1}}],[\"期望值\",{\"1\":{\"742\":1,\"841\":1,\"904\":1,\"990\":1}}],[\"期间会停止所有线程等待\",{\"1\":{\"444\":1}}],[\"期间虚拟机又发现\",{\"1\":{\"384\":1}}],[\"期限\",{\"1\":{\"19\":1}}],[\"期限限制\",{\"1\":{\"19\":1}}],[\"虚线方块代表等待被写入的\",{\"1\":{\"1315\":1}}],[\"虚拟线程可以大幅提高线程的执行效率\",{\"1\":{\"1062\":1}}],[\"虚拟线程可以简化异步编程\",{\"1\":{\"1055\":1}}],[\"虚拟线程和平台线程性能对比\",{\"0\":{\"1062\":1}}],[\"虚拟线程和平台线程有什么关系\",{\"0\":{\"1053\":1}}],[\"虚拟线程适用于\",{\"1\":{\"1056\":1}}],[\"虚拟线程的资源开销更小\",{\"1\":{\"1055\":1}}],[\"虚拟线程的数量可以远大于操作系统线程的数量\",{\"1\":{\"1052\":1}}],[\"虚拟线程有什么优点和缺点\",{\"0\":{\"1054\":1}}],[\"虚拟线程极简入门\",{\"0\":{\"1051\":1},\"1\":{\"912\":1}}],[\"虚拟线程\",{\"0\":{\"912\":1},\"1\":{\"1052\":1,\"1053\":2,\"1062\":1}}],[\"虚拟线程在\",{\"1\":{\"808\":1,\"912\":1,\"1051\":1}}],[\"虚拟的双向队列即不存在队列实例\",{\"1\":{\"742\":1,\"904\":1}}],[\"虚拟机和容器上\",{\"1\":{\"1235\":1}}],[\"虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中\",{\"1\":{\"972\":1}}],[\"虚拟机团队在\",{\"1\":{\"861\":1}}],[\"虚拟机主要使用的就是这种方式来进行对象访问\",{\"1\":{\"510\":1}}],[\"虚拟机主要的\",{\"1\":{\"424\":1}}],[\"虚拟机通过这个指针来确定这个对象是哪个类的实例\",{\"1\":{\"507\":1}}],[\"虚拟机通过索引定位的方式使用局部变量表\",{\"1\":{\"442\":1}}],[\"虚拟机要对对象进行必要的设置\",{\"1\":{\"505\":1}}],[\"虚拟机需要将分配到的内存空间都初始化为零值\",{\"1\":{\"504\":1}}],[\"虚拟机采用\",{\"1\":{\"503\":1}}],[\"虚拟机采用两种方式来保证线程安全\",{\"1\":{\"503\":1}}],[\"虚拟机遇到一条\",{\"1\":{\"502\":1}}],[\"虚拟机在\",{\"1\":{\"500\":1}}],[\"虚拟机在执行\",{\"1\":{\"491\":1}}],[\"虚拟机方法区的两种实现\",{\"1\":{\"496\":1}}],[\"虚拟机对象探秘\",{\"0\":{\"500\":1}}],[\"虚拟机对虚拟机规范中方法区的两种实现方式\",{\"1\":{\"496\":1}}],[\"虚拟机对方法区的实现为永久代\",{\"1\":{\"393\":1}}],[\"虚拟机实现者可以使用任何垃圾回收算法管理堆\",{\"1\":{\"491\":1}}],[\"虚拟机所管理的内存中最大的一块\",{\"1\":{\"477\":1,\"495\":1}}],[\"虚拟机调用对应的\",{\"1\":{\"445\":1}}],[\"虚拟机堆的概念\",{\"0\":{\"443\":1}}],[\"虚拟机也可以动态扩展\",{\"1\":{\"439\":1}}],[\"虚拟机中字符串常量池的实现是\",{\"1\":{\"498\":1}}],[\"虚拟机中和\",{\"1\":{\"494\":1,\"812\":1}}],[\"虚拟机中\",{\"1\":{\"424\":1,\"507\":1}}],[\"虚拟机中被称为\",{\"1\":{\"356\":1}}],[\"虚拟机的运行时区域相关\",{\"1\":{\"973\":1}}],[\"虚拟机的自动内存管理系统要求对象起始地址必须是\",{\"1\":{\"507\":1}}],[\"虚拟机的对象头包括两部分信息\",{\"1\":{\"507\":1}}],[\"虚拟机的一个重要进化特征\",{\"1\":{\"407\":1}}],[\"虚拟机的设计者们当然知道\",{\"1\":{\"401\":1}}],[\"虚拟机第一款真正意义上的并发收集器\",{\"1\":{\"406\":1}}],[\"虚拟机就不会实现那么多不同的垃圾收集器了\",{\"1\":{\"400\":1}}],[\"虚拟机就会把这个弱引用加入到与之关联的引用队列中\",{\"1\":{\"392\":1,\"884\":1}}],[\"虚拟机就会把这个软引用加入到与之关联的引用队列中\",{\"1\":{\"392\":1}}],[\"虚拟机可以对满足上述\",{\"1\":{\"394\":1}}],[\"虚拟机可以执行低版本编译器生成的\",{\"1\":{\"327\":1}}],[\"虚拟机宁愿抛出\",{\"1\":{\"392\":1}}],[\"虚拟机栈中入栈和出栈的过程\",{\"1\":{\"812\":1}}],[\"虚拟机栈中会存放当前方法调用的栈帧\",{\"1\":{\"519\":1}}],[\"虚拟机栈和本地方法栈是线程私有的\",{\"1\":{\"812\":1}}],[\"虚拟机栈和本地方法栈是线程私有的呢\",{\"1\":{\"810\":1}}],[\"虚拟机栈和本地方法栈为什么是私有的\",{\"0\":{\"812\":1}}],[\"虚拟机栈和本地方法栈\",{\"1\":{\"807\":1}}],[\"虚拟机栈和虚拟机堆\",{\"0\":{\"437\":1}}],[\"虚拟机栈合二为一\",{\"1\":{\"494\":1,\"812\":1}}],[\"虚拟机栈为虚拟机执行\",{\"1\":{\"494\":1,\"812\":1}}],[\"虚拟机栈的最大深度的时候\",{\"1\":{\"493\":2}}],[\"虚拟机栈的执行\",{\"0\":{\"441\":1}}],[\"虚拟机栈的生命周期\",{\"0\":{\"440\":1}}],[\"虚拟机栈的概念\",{\"0\":{\"438\":1}}],[\"虚拟机栈存在的异常\",{\"0\":{\"439\":1}}],[\"虚拟机栈\",{\"0\":{\"493\":1},\"1\":{\"391\":1,\"445\":2,\"491\":1,\"493\":2,\"810\":1,\"812\":1}}],[\"虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间\",{\"1\":{\"388\":1}}],[\"虚拟机给每个对象一个对象年龄\",{\"1\":{\"386\":1}}],[\"虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"429\":1}}],[\"虚拟机将这两种情况视为没有必要执行\",{\"1\":{\"391\":1}}],[\"虚拟机将发起一次\",{\"1\":{\"384\":2}}],[\"虚拟机将拒绝加载它\",{\"1\":{\"326\":1}}],[\"虚拟机进程中的类信息\",{\"1\":{\"366\":1}}],[\"虚拟机各方面的运行数据\",{\"1\":{\"364\":1}}],[\"虚拟机参数等信息\",{\"1\":{\"364\":1}}],[\"虚拟机会维护一个列表\",{\"1\":{\"503\":1}}],[\"虚拟机会耗尽所有可用的系统内存\",{\"1\":{\"480\":1,\"496\":1}}],[\"虚拟机会先初始化这个类\",{\"1\":{\"344\":1}}],[\"虚拟机会自己确保其在多线程环境中的安全性\",{\"1\":{\"344\":1}}],[\"虚拟机严格规范了有且只有\",{\"1\":{\"344\":1}}],[\"虚拟机为每个类都准备了一张方法表来存放类中所有的方法\",{\"1\":{\"343\":1}}],[\"虚拟机原理图解\",{\"1\":{\"334\":1}}],[\"虚拟机\",{\"1\":{\"334\":1,\"342\":2,\"343\":1,\"345\":2,\"360\":1,\"377\":2,\"380\":2,\"386\":1,\"387\":2,\"388\":1,\"409\":1,\"489\":2,\"490\":1,\"496\":1,\"497\":1,\"498\":1,\"511\":2,\"516\":1,\"851\":1,\"876\":1,\"913\":1}}],[\"虚拟机运行时会忽略掉它不认识的属性\",{\"1\":{\"333\":1}}],[\"虚拟机不能执行高版本编译器生成的\",{\"1\":{\"327\":1}}],[\"虚拟机规范对于运行时数据区域的规定是相当宽松的\",{\"1\":{\"491\":1}}],[\"虚拟机规范上面这\",{\"1\":{\"340\":1}}],[\"虚拟机规范\",{\"1\":{\"325\":1,\"341\":1,\"496\":1}}],[\"虚拟机之间的重要桥梁\",{\"1\":{\"324\":1}}],[\"虚拟机之上的编程语言\",{\"1\":{\"324\":1}}],[\"虚拟机之上\",{\"1\":{\"324\":2}}],[\"虚引用中唯一的作用就是用队列接收对象即将死亡的通知\",{\"1\":{\"1030\":1}}],[\"虚引用是最弱的引用\",{\"1\":{\"1030\":1}}],[\"虚引用必须和引用队列\",{\"1\":{\"392\":1}}],[\"虚引用与软引用和弱引用的一个区别在于\",{\"1\":{\"392\":1}}],[\"虚引用与软引用和弱引用的区别\",{\"1\":{\"380\":1}}],[\"虚引用主要用来跟踪对象被垃圾回收的活动\",{\"1\":{\"392\":1}}],[\"虚引用并不会决定对象的生命周期\",{\"1\":{\"392\":1}}],[\"虚引用四种\",{\"1\":{\"392\":1}}],[\"虚引用\",{\"1\":{\"380\":1,\"392\":2,\"483\":1,\"1030\":1}}],[\"软件架构模式\",{\"1\":{\"1132\":1}}],[\"软件也行\",{\"1\":{\"1\":1}}],[\"软状态指允许系统中的数据存在中间状态\",{\"1\":{\"1077\":1}}],[\"软状态\",{\"0\":{\"1077\":1},\"1\":{\"1073\":1}}],[\"软\",{\"1\":{\"446\":1}}],[\"软引用指向的对象在内存要溢出的时候被回收\",{\"1\":{\"1030\":1}}],[\"软引用可以和一个引用队列\",{\"1\":{\"392\":1}}],[\"软引用可用来实现内存敏感的高速缓存\",{\"1\":{\"392\":1}}],[\"软引用\",{\"1\":{\"380\":1,\"392\":2,\"483\":1,\"1030\":1}}],[\"离线程序快照\",{\"1\":{\"377\":1}}],[\"您需要自己在消费者客户端设置时保证同一分组下的消费者的消费行为一致\",{\"1\":{\"1297\":1}}],[\"您可以方便\",{\"1\":{\"377\":1}}],[\"您也可以根据这个规律来查找到请求经过的第一个服务器\",{\"1\":{\"22\":1}}],[\"老王被覆盖\",{\"1\":{\"625\":1}}],[\"老王2\",{\"1\":{\"625\":1}}],[\"老王\",{\"1\":{\"625\":2}}],[\"老容量\",{\"1\":{\"572\":1}}],[\"老数组里的数据移动到新的数组时\",{\"1\":{\"572\":1}}],[\"老生代\",{\"1\":{\"382\":1,\"495\":1}}],[\"老年代=1\",{\"1\":{\"452\":1}}],[\"老年代大小\",{\"1\":{\"449\":1,\"451\":1}}],[\"老年代是存储长期存活的对象的\",{\"1\":{\"444\":1}}],[\"老年代并行\",{\"1\":{\"403\":1}}],[\"老年代串行\",{\"1\":{\"403\":1}}],[\"老年代采用标记\",{\"1\":{\"401\":1,\"402\":1,\"403\":1}}],[\"老年代收集\",{\"1\":{\"387\":1}}],[\"老年代上的空间足够存放\",{\"1\":{\"384\":1}}],[\"老年代\",{\"1\":{\"375\":1,\"387\":1,\"400\":1}}],[\"老大难的\",{\"1\":{\"360\":1}}],[\"休眠结束了都开始企图请求获取对方的资源\",{\"1\":{\"370\":1,\"823\":1}}],[\"休眠\",{\"1\":{\"370\":1,\"823\":1}}],[\"获锁\",{\"1\":{\"1012\":1}}],[\"获得了业界关注\",{\"1\":{\"1178\":1}}],[\"获得了集合的常见操作方法\",{\"1\":{\"533\":1}}],[\"获得大多数选票\",{\"1\":{\"1111\":1}}],[\"获得同意后才会被\",{\"1\":{\"1110\":1}}],[\"获得时间片\",{\"1\":{\"686\":2}}],[\"获得队列所有的操作模板\",{\"1\":{\"533\":1}}],[\"获得\",{\"1\":{\"370\":1,\"425\":1,\"686\":1,\"823\":1}}],[\"获取独占锁\",{\"1\":{\"1388\":1}}],[\"获取节点数据和子节点列表的权限\",{\"1\":{\"1384\":1}}],[\"获取节点的数据内容\",{\"1\":{\"1335\":1,\"1337\":1}}],[\"获取节点的数据\",{\"0\":{\"1327\":1}}],[\"获取某个节点的所有子节点路径\",{\"0\":{\"1338\":1}}],[\"获取所有\",{\"1\":{\"1281\":1}}],[\"获取关于\",{\"1\":{\"1281\":1}}],[\"获取下一次重试的时间间隔\",{\"1\":{\"1210\":1}}],[\"获取下一个未被消费的消息就行了\",{\"1\":{\"1315\":1}}],[\"获取下一个节点\",{\"1\":{\"732\":1}}],[\"获取下一个节点next\",{\"1\":{\"713\":1}}],[\"获取下一个元素next\",{\"1\":{\"713\":1}}],[\"获取下一个node\",{\"1\":{\"713\":2}}],[\"获取消费记录所在的topic和partition\",{\"1\":{\"1210\":1}}],[\"获取新日志和当前的\",{\"1\":{\"1110\":1}}],[\"获取新号段的情况下\",{\"1\":{\"42\":1}}],[\"获取头结点waitstatus\",{\"1\":{\"1014\":1}}],[\"获取头结点\",{\"1\":{\"1014\":1}}],[\"获取头结点的节点状态\",{\"1\":{\"1012\":1}}],[\"获取过滤后的前驱节点的后继节点\",{\"1\":{\"1013\":1}}],[\"获取结果\",{\"1\":{\"987\":1}}],[\"获取线程池中工作的线程的数量\",{\"1\":{\"941\":1}}],[\"获取线程池状态\",{\"1\":{\"941\":2}}],[\"获取线程线程上下文类加载器的代码如下\",{\"1\":{\"359\":1}}],[\"获取多少次就要释放多少次\",{\"1\":{\"904\":1}}],[\"获取多个字段的值\",{\"1\":{\"186\":1}}],[\"获取读锁时如果发现写锁被占用\",{\"1\":{\"868\":1}}],[\"获取后将锁计数器设为\",{\"1\":{\"851\":1}}],[\"获取异步任务的返回值\",{\"1\":{\"785\":1}}],[\"获取异步计算的结果也非常简单\",{\"1\":{\"777\":1}}],[\"获取计算结果的\",{\"1\":{\"774\":1,\"901\":1}}],[\"获取任务执行结果\",{\"1\":{\"773\":2,\"899\":2}}],[\"获取任务时\",{\"1\":{\"601\":1}}],[\"获取用户信息之后\",{\"1\":{\"772\":1}}],[\"获取5个许可\",{\"1\":{\"749\":1}}],[\"获取一个许可\",{\"1\":{\"749\":1}}],[\"获取一个或者多个许可证\",{\"1\":{\"748\":1}}],[\"获取一个或者多个\",{\"1\":{\"206\":1,\"262\":1}}],[\"获取一个或多个指定\",{\"1\":{\"177\":1,\"286\":1}}],[\"获取成功则返回\",{\"1\":{\"748\":1,\"752\":2,\"906\":1}}],[\"获取失败后\",{\"1\":{\"1007\":1}}],[\"获取失败加入等待队列\",{\"1\":{\"752\":1}}],[\"获取失败\",{\"1\":{\"748\":1}}],[\"获取1个许可证\",{\"1\":{\"748\":1,\"906\":1}}],[\"获取1个许可\",{\"1\":{\"747\":1,\"905\":1}}],[\"获取前一个节点\",{\"1\":{\"732\":1}}],[\"获取链表指定位置的元素\",{\"1\":{\"730\":2}}],[\"获取链表的长度\",{\"1\":{\"733\":1}}],[\"获取链表的最后一个元素\",{\"1\":{\"730\":2}}],[\"获取链表的第一个元素\",{\"1\":{\"730\":2}}],[\"获取链表第一个元素的\",{\"1\":{\"712\":1}}],[\"获取链表首部的键值对的key\",{\"1\":{\"712\":1}}],[\"获取链表下一个节点\",{\"1\":{\"571\":1}}],[\"获取键值对\",{\"1\":{\"710\":1}}],[\"获取key的键值对\",{\"1\":{\"710\":1}}],[\"获取双向链表的特性为什么不行呢\",{\"1\":{\"708\":1}}],[\"获取双向链表的特性呢\",{\"1\":{\"708\":1}}],[\"获取map中所有值\",{\"1\":{\"625\":1}}],[\"获取map中的所有键\",{\"1\":{\"625\":1}}],[\"获取元素\",{\"0\":{\"604\":1,\"730\":1}}],[\"获取元素失败也是直接返回空\",{\"1\":{\"536\":1}}],[\"获取数组长度\",{\"1\":{\"592\":1}}],[\"获取可重入锁\",{\"1\":{\"591\":1}}],[\"获取可重入互斥锁\",{\"1\":{\"56\":1}}],[\"获取原来的数组\",{\"1\":{\"588\":1}}],[\"获取不到使用\",{\"1\":{\"571\":1}}],[\"获取不到\",{\"1\":{\"571\":1}}],[\"获取0号\",{\"1\":{\"571\":2}}],[\"获取和新增元素的方法对比\",{\"0\":{\"539\":1}}],[\"获取和释放锁的操作应该快速完成\",{\"1\":{\"61\":1}}],[\"获取当前线程\",{\"1\":{\"1007\":1}}],[\"获取当前请求的线程\",{\"1\":{\"883\":1}}],[\"获取当前请求锁的线程\",{\"1\":{\"56\":1}}],[\"获取当前的值和当前的\",{\"1\":{\"767\":2}}],[\"获取当前的值\",{\"1\":{\"763\":5}}],[\"获取当前节点的前驱节点\",{\"1\":{\"1012\":1,\"1013\":1}}],[\"获取当前节点的前一个节点\",{\"1\":{\"731\":1}}],[\"获取当前节点的下一个节点\",{\"1\":{\"731\":1,\"732\":1,\"1014\":1}}],[\"获取当前节点p\",{\"1\":{\"711\":1}}],[\"获取当前节点\",{\"1\":{\"710\":2,\"711\":1,\"731\":1}}],[\"获取当前array长度\",{\"1\":{\"591\":1}}],[\"获取当前array数组\",{\"1\":{\"591\":1,\"592\":2}}],[\"获取当前数组的引用\",{\"1\":{\"589\":1}}],[\"获取当前队列的元素数组\",{\"1\":{\"538\":1}}],[\"获取但不移除队列头部的元素\",{\"1\":{\"536\":1}}],[\"获取阻塞队列底层的数组\",{\"1\":{\"535\":1}}],[\"获取队列底层的数组\",{\"1\":{\"535\":1}}],[\"获取队列剩余元素个数\",{\"1\":{\"533\":1}}],[\"获取并移除队列头部的元素\",{\"1\":{\"535\":1,\"536\":1}}],[\"获取到的是\",{\"1\":{\"1335\":1}}],[\"获取到节点\",{\"1\":{\"1087\":3}}],[\"获取到当前线程对象后\",{\"1\":{\"883\":1}}],[\"获取到就可以执行了\",{\"1\":{\"824\":1}}],[\"获取到阻塞队列的常见操作并将这些操作实现\",{\"1\":{\"533\":1}}],[\"获取到\",{\"1\":{\"353\":1}}],[\"获取其父\",{\"1\":{\"353\":1}}],[\"获取慢查询日志的内容很简单\",{\"1\":{\"302\":1}}],[\"获取了\",{\"1\":{\"293\":1}}],[\"获取字符串长度的复杂度较低\",{\"1\":{\"256\":1}}],[\"获取\",{\"0\":{\"1337\":1},\"1\":{\"202\":1,\"535\":1,\"539\":1,\"571\":3,\"708\":1,\"766\":4,\"807\":1,\"1006\":1,\"1142\":1}}],[\"获取集合数量\",{\"1\":{\"190\":1}}],[\"获取给定所有集合的差集\",{\"1\":{\"189\":1}}],[\"获取给定所有集合的并集\",{\"1\":{\"189\":1}}],[\"获取给定所有集合的交集\",{\"1\":{\"189\":1}}],[\"获取单个字段的值\",{\"1\":{\"186\":1}}],[\"获取在哈希表中指定\",{\"1\":{\"185\":1}}],[\"获取存储在哈希表中指定字段的值\",{\"1\":{\"185\":1}}],[\"获取列表中元素的个数\",{\"0\":{\"590\":1}}],[\"获取列表\",{\"1\":{\"181\":1}}],[\"获取列表元素数量\",{\"1\":{\"181\":1}}],[\"获取权限\",{\"1\":{\"84\":1}}],[\"获取锁流程仍在继续\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"获取锁流程结束\",{\"1\":{\"1002\":1}}],[\"获取锁的过程中可以被中断\",{\"1\":{\"863\":1}}],[\"获取锁的时候获取所有锁\",{\"1\":{\"53\":1}}],[\"获取锁成功\",{\"1\":{\"1011\":1,\"1012\":1}}],[\"获取锁成功了\",{\"1\":{\"742\":1}}],[\"获取锁成功之后\",{\"1\":{\"56\":2}}],[\"获取锁失败后\",{\"1\":{\"1011\":1}}],[\"获取锁失败的客户端并不会不停地循环去尝试加锁\",{\"1\":{\"55\":1}}],[\"获取锁失败\",{\"1\":{\"53\":1}}],[\"获取锁\",{\"1\":{\"53\":1,\"535\":1,\"536\":1,\"571\":2,\"851\":1,\"1010\":1}}],[\"获取指定索引的元素\",{\"1\":{\"591\":1}}],[\"获取指定位置的元素\",{\"1\":{\"733\":1}}],[\"获取指定位置的\",{\"1\":{\"571\":1}}],[\"获取指定位置范围内的其他元素\",{\"1\":{\"210\":1}}],[\"获取指定位置附近\",{\"1\":{\"210\":1}}],[\"获取指定位置附近的元素等功能\",{\"1\":{\"209\":1}}],[\"获取指定元素的排名\",{\"1\":{\"193\":1}}],[\"获取指定有序集合\",{\"1\":{\"193\":2}}],[\"获取指定有序集合中指定元素的排名\",{\"1\":{\"193\":1}}],[\"获取指定有序集合中指定元素的\",{\"1\":{\"193\":1}}],[\"获取指定有序集合的元素数量\",{\"1\":{\"193\":1}}],[\"获取指定集合的元素数量\",{\"1\":{\"189\":1}}],[\"获取指定集合中的所有元素\",{\"1\":{\"189\":1}}],[\"获取指定哈希表中字段的数量\",{\"1\":{\"185\":1}}],[\"获取指定哈希表中所有的键值对\",{\"1\":{\"185\":1}}],[\"获取指定哈希表中一个或者多个指定字段的值\",{\"1\":{\"185\":1,\"286\":1}}],[\"获取指定哈希表中指定字段的值\",{\"1\":{\"185\":1}}],[\"获取指定\",{\"1\":{\"177\":1,\"202\":1}}],[\"获取指定的分布式锁对象\",{\"1\":{\"49\":1}}],[\"获取指定业务下的批量唯一\",{\"1\":{\"34\":1}}],[\"获取的批量\",{\"1\":{\"34\":1}}],[\"获取速度也慢\",{\"1\":{\"33\":1}}],[\"访问元素3\",{\"1\":{\"705\":1}}],[\"访问元素2\",{\"1\":{\"705\":1}}],[\"访问顺序则为\",{\"1\":{\"705\":1}}],[\"访问顺序遍历\",{\"0\":{\"705\":1}}],[\"访问后回调\",{\"1\":{\"622\":1}}],[\"访问\",{\"1\":{\"369\":1}}],[\"访问标志来辨别一个方法是否声明为同步方法\",{\"1\":{\"852\":1}}],[\"访问标志\",{\"0\":{\"329\":1}}],[\"示例代码如下\",{\"1\":{\"679\":1,\"780\":1,\"782\":1,\"1204\":2}}],[\"示例代码\",{\"0\":{\"940\":1},\"1\":{\"551\":1,\"652\":1}}],[\"示例\",{\"1\":{\"368\":1,\"757\":2,\"944\":2}}],[\"示意图如下\",{\"1\":{\"1249\":1}}],[\"示意图如下所示\",{\"1\":{\"968\":1}}],[\"示意图\",{\"1\":{\"38\":1,\"1249\":3}}],[\"尤其在大数据和流计算领域\",{\"1\":{\"1191\":1}}],[\"尤其在线上的环境特别有用\",{\"1\":{\"367\":1}}],[\"尤其是\",{\"1\":{\"486\":1}}],[\"尤其是社招中大厂的面试\",{\"1\":{\"412\":1}}],[\"尤其是内网访问的情况下\",{\"1\":{\"1\":1}}],[\"行\",{\"1\":{\"1011\":1}}],[\"行后打印指标头部\",{\"1\":{\"366\":1}}],[\"行数据和叶子节点保存在一起\",{\"1\":{\"108\":1}}],[\"行数据和主键索引存储在一起\",{\"1\":{\"106\":1}}],[\"行数据保存在叶子节点上\",{\"1\":{\"106\":1}}],[\"情况下\",{\"1\":{\"1005\":1}}],[\"情况\",{\"1\":{\"366\":1}}],[\"安装\",{\"0\":{\"1320\":1,\"1321\":1}}],[\"安装好\",{\"1\":{\"1237\":1}}],[\"安装目录下的\",{\"1\":{\"364\":1}}],[\"安全服务\",{\"1\":{\"1123\":1}}],[\"安全设计等几大方向上进行了全面升级\",{\"1\":{\"1120\":1}}],[\"安全状态\",{\"1\":{\"824\":1}}],[\"安全的\",{\"1\":{\"553\":1}}],[\"安全的网关服务\",{\"1\":{\"4\":1}}],[\"安全性\",{\"0\":{\"1113\":1},\"1\":{\"515\":1}}],[\"安全问题\",{\"1\":{\"33\":1,\"34\":1}}],[\"安全访问策略\",{\"1\":{\"7\":1}}],[\"安全\",{\"1\":{\"5\":1,\"30\":1,\"68\":1,\"1106\":1}}],[\"安全认证\",{\"1\":{\"1\":1,\"2\":1}}],[\"打印结果\",{\"1\":{\"1028\":1,\"1043\":1}}],[\"打印线程池的状态\",{\"1\":{\"918\":1}}],[\"打印safepoint信息\",{\"1\":{\"483\":1}}],[\"打印stw时间\",{\"1\":{\"483\":1}}],[\"打印reference处理信息\",{\"1\":{\"483\":1}}],[\"打印堆数据\",{\"1\":{\"483\":1}}],[\"打印对象分布\",{\"1\":{\"483\":1}}],[\"打印基本\",{\"1\":{\"483\":1}}],[\"打印\",{\"1\":{\"366\":1}}],[\"打印一次记录\",{\"1\":{\"366\":1}}],[\"打破双亲委派模型的原理\",{\"1\":{\"359\":1}}],[\"打破双亲委派模型方法\",{\"0\":{\"359\":1}}],[\"打扰\",{\"1\":{\"287\":1}}],[\"区间内的数字\",{\"1\":{\"1141\":1}}],[\"区块链系统使用的共识算法需要解决的核心问题是\",{\"1\":{\"1097\":1}}],[\"区和\",{\"0\":{\"453\":1},\"1\":{\"453\":1}}],[\"区占整个年轻代的\",{\"1\":{\"449\":1}}],[\"区交换\",{\"1\":{\"444\":1}}],[\"区并且将\",{\"1\":{\"444\":1}}],[\"区与一个\",{\"1\":{\"449\":1}}],[\"区与\",{\"1\":{\"444\":1,\"449\":1}}],[\"区依旧是满的\",{\"1\":{\"444\":1}}],[\"区现在是满的\",{\"1\":{\"444\":1}}],[\"区满不会触发\",{\"1\":{\"444\":1}}],[\"区满后触发\",{\"1\":{\"444\":1}}],[\"区内存空间满了的时候\",{\"1\":{\"444\":1}}],[\"区内存几乎已经被分配完了\",{\"1\":{\"384\":1}}],[\"区内存几乎已经被分配完全\",{\"1\":{\"384\":1}}],[\"区为空\",{\"1\":{\"444\":1}}],[\"区为空且\",{\"1\":{\"444\":1}}],[\"区域是否达到阈值的\",{\"1\":{\"480\":1}}],[\"区域是空的\",{\"1\":{\"443\":1}}],[\"区域和\",{\"1\":{\"444\":1}}],[\"区域分配\",{\"1\":{\"386\":1,\"495\":1}}],[\"区的一半时\",{\"1\":{\"495\":1}}],[\"区的比例\",{\"0\":{\"470\":1}}],[\"区的比值\",{\"0\":{\"453\":1}}],[\"区的比值为\",{\"1\":{\"449\":1}}],[\"区的对象给清空\",{\"1\":{\"444\":1}}],[\"区的对象一起进行可达性分析\",{\"1\":{\"444\":1}}],[\"区的大小比值\",{\"1\":{\"449\":1}}],[\"区的大小\",{\"1\":{\"412\":1}}],[\"区的\",{\"1\":{\"386\":1}}],[\"区的话\",{\"1\":{\"384\":1}}],[\"区后对象的初始年龄变为\",{\"1\":{\"386\":1,\"495\":1}}],[\"区没有足够空间进行分配时\",{\"1\":{\"384\":2}}],[\"区分这两种状态就没什么意义了\",{\"1\":{\"820\":1}}],[\"区分配一块儿内存\",{\"1\":{\"503\":1}}],[\"区分配内存\",{\"1\":{\"384\":1}}],[\"区分配\",{\"0\":{\"384\":1},\"1\":{\"384\":1}}],[\"区分不同类的方式不仅仅根据类名\",{\"1\":{\"358\":1}}],[\"区等的使用情况\",{\"1\":{\"375\":1}}],[\"区\",{\"1\":{\"375\":1,\"382\":2,\"386\":1,\"444\":4,\"449\":1,\"495\":3}}],[\"区别比较明显的几个点\",{\"1\":{\"1156\":1}}],[\"区别及优缺点\",{\"0\":{\"809\":1}}],[\"区别是\",{\"1\":{\"494\":1,\"812\":1}}],[\"区别\",{\"0\":{\"517\":1,\"552\":1,\"656\":1,\"678\":1,\"679\":1},\"1\":{\"245\":1,\"563\":1,\"825\":1}}],[\"区别于固定的一码付\",{\"1\":{\"17\":1}}],[\"判定一个常量是否是\",{\"1\":{\"394\":1}}],[\"判定对象的存活都与\",{\"1\":{\"392\":1}}],[\"判定两个\",{\"1\":{\"357\":1}}],[\"判断会落在哪个服务提供者的区间\",{\"1\":{\"1141\":1}}],[\"判断日志新旧的方式\",{\"1\":{\"1114\":1}}],[\"判断线程池的状态是否为\",{\"1\":{\"941\":1}}],[\"判断为true了才会跳出while循环\",{\"1\":{\"940\":1}}],[\"判断任务是否已经被执行完成\",{\"1\":{\"774\":1}}],[\"判断任务是否已经执行完成\",{\"1\":{\"773\":2,\"899\":2}}],[\"判断任务是否被取消\",{\"1\":{\"773\":2,\"774\":1,\"899\":2}}],[\"判断下一个节点的下标是否小于链表的大小\",{\"1\":{\"732\":1}}],[\"判断还有没有下一个节点\",{\"1\":{\"732\":1}}],[\"判断待删除节点是否为头节点或尾节点\",{\"1\":{\"731\":1}}],[\"判断尾节点是否为空\",{\"1\":{\"729\":2}}],[\"判断size超过容量时返回true\",{\"1\":{\"706\":1,\"712\":1}}],[\"判断时\",{\"1\":{\"664\":1,\"686\":1}}],[\"判断所有集合内部的元素是否为空\",{\"1\":{\"629\":1}}],[\"判断链表是否被其他线程修改过\",{\"1\":{\"732\":1}}],[\"判断链表中结点的key值与插入的元素的key值是否相等\",{\"1\":{\"622\":1}}],[\"判断链表当前元素\",{\"1\":{\"571\":1}}],[\"判断插入的是否是红黑树节点\",{\"1\":{\"622\":1}}],[\"判断table是否已经初始化\",{\"1\":{\"621\":1}}],[\"判断颜色\",{\"1\":{\"619\":1}}],[\"判断当前节点前驱节点的是否为signal\",{\"1\":{\"1013\":1}}],[\"判断当前数组的长度是否小于\",{\"1\":{\"683\":1}}],[\"判断当前数组容量是否足以存储mincapacity个元素\",{\"1\":{\"557\":1}}],[\"判断当前元素存放的位置\",{\"1\":{\"618\":1,\"682\":1}}],[\"判断元素是否为空\",{\"1\":{\"604\":2}}],[\"判断元素是否存在\",{\"0\":{\"538\":1,\"592\":1}}],[\"判断leader是否为空\",{\"1\":{\"604\":1}}],[\"判断删除的是否是最后一个元素\",{\"1\":{\"591\":1}}],[\"判断不成立\",{\"1\":{\"558\":1}}],[\"判断不会成立\",{\"1\":{\"558\":1}}],[\"判断成立\",{\"1\":{\"558\":1}}],[\"判断是否还有前一个节点\",{\"1\":{\"732\":1}}],[\"判断是否还有下一个节点可以遍历\",{\"1\":{\"732\":1}}],[\"判断是否出现\",{\"1\":{\"686\":1}}],[\"判断是否保证指定集合的全部元素\",{\"1\":{\"592\":2}}],[\"判断是否包含指定元素\",{\"1\":{\"592\":2}}],[\"判断是否需要进行初始化\",{\"1\":{\"577\":1}}],[\"判断是否需要扩容\",{\"1\":{\"553\":1,\"557\":1}}],[\"判断是否为持锁线程\",{\"1\":{\"49\":1}}],[\"判断队列中是否包含指定元素\",{\"1\":{\"533\":1}}],[\"判断的条件是决定这个对象是否有必要执行\",{\"1\":{\"446\":1}}],[\"判断一个对象的死亡至少需要两次标记\",{\"1\":{\"446\":1}}],[\"判断指定元素是否在指定集合中\",{\"1\":{\"189\":1}}],[\"判断指定\",{\"1\":{\"177\":1}}],[\"判断\",{\"1\":{\"69\":1,\"70\":1,\"571\":1,\"686\":1,\"694\":2,\"710\":1,\"712\":1,\"729\":1,\"752\":1}}],[\"判断扫码环境的原理就是根据打开链接浏览器的\",{\"1\":{\"17\":1}}],[\"检测节点是否创建成功\",{\"1\":{\"1335\":1}}],[\"检测数据的不一致时\",{\"1\":{\"1078\":1}}],[\"检测数据的不一致\",{\"1\":{\"1078\":1}}],[\"检测是否有过期的entry数据\",{\"1\":{\"1035\":1}}],[\"检测死锁\",{\"1\":{\"376\":1}}],[\"检查各个节点状态\",{\"1\":{\"1085\":1}}],[\"检查在迭代过程中链表是否被修改过\",{\"1\":{\"732\":1}}],[\"检查是否在迭代过程中链表被修改\",{\"1\":{\"732\":2}}],[\"检查是否\",{\"1\":{\"571\":1}}],[\"检查计算得到的位置的\",{\"1\":{\"571\":1}}],[\"检查给定的索引是否在范围内\",{\"1\":{\"553\":1}}],[\"检查该类是否已经加载过\",{\"1\":{\"357\":1}}],[\"检索消息是非常低效的\",{\"1\":{\"1315\":1}}],[\"检索出表中\",{\"1\":{\"117\":1}}],[\"检索过程\",{\"1\":{\"113\":2,\"114\":1}}],[\"检索的过程都是通过叶子节点内\",{\"1\":{\"107\":1}}],[\"逻辑消费队列\",{\"1\":{\"1315\":1}}],[\"逻辑\",{\"1\":{\"1038\":1}}],[\"逻辑时钟并不度量时间本身\",{\"1\":{\"974\":1}}],[\"逻辑结构\",{\"1\":{\"702\":1}}],[\"逻辑结构如下图所示\",{\"1\":{\"702\":1}}],[\"逻辑比较简单\",{\"1\":{\"604\":1}}],[\"逻辑和\",{\"1\":{\"536\":1}}],[\"逻辑错误指程序的执行结果与预期不符\",{\"1\":{\"524\":1}}],[\"逻辑错误和运行错误\",{\"1\":{\"524\":1}}],[\"逻辑非常清晰\",{\"1\":{\"357\":1}}],[\"逻辑上可以称作\",{\"1\":{\"69\":1}}],[\"国内既然翻译成了双亲委派模型并流传了\",{\"1\":{\"356\":1}}],[\"国内目前已经有很多知名企业\",{\"1\":{\"8\":1}}],[\"⚠️\",{\"1\":{\"356\":1,\"492\":1}}],[\"⚠️注意\",{\"1\":{\"302\":1,\"1099\":1}}],[\"父节点可以创建一个维持了顺序的临时节点\",{\"1\":{\"1382\":1}}],[\"父任务等待子任务执行完成\",{\"1\":{\"919\":1}}],[\"父任务下面有两个子任务\",{\"1\":{\"919\":1}}],[\"父任务\",{\"1\":{\"919\":1}}],[\"父\",{\"1\":{\"619\":1}}],[\"父母这一辈\",{\"1\":{\"356\":1}}],[\"父加载器\",{\"1\":{\"353\":1}}],[\"父类数据\",{\"1\":{\"1043\":3}}],[\"父类索引用于确定这个类的父类的全限定名\",{\"1\":{\"330\":1}}],[\"父类索引和接口索引集合按照顺序排在访问标志之后\",{\"1\":{\"330\":1}}],[\"父类索引和接口索引集合三项确定\",{\"1\":{\"330\":1}}],[\"父类\",{\"0\":{\"330\":1},\"1\":{\"325\":1,\"330\":1}}],[\"拓展一下\",{\"1\":{\"353\":1,\"357\":1,\"895\":1,\"922\":1}}],[\"目的是希望程序员能像调用本地方法那样去调用远端的服务方法\",{\"1\":{\"1161\":1}}],[\"目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置\",{\"1\":{\"1037\":1}}],[\"目的是保证对于提交的任务\",{\"1\":{\"892\":1,\"938\":1}}],[\"目的就是为了来处理runnable不支持的用例\",{\"1\":{\"943\":1}}],[\"目标缓冲区\",{\"1\":{\"1311\":1}}],[\"目标位置元素\",{\"1\":{\"577\":1}}],[\"目标数组中的起始位置\",{\"1\":{\"561\":2}}],[\"目标数组\",{\"1\":{\"561\":2}}],[\"目录\",{\"0\":{\"1027\":1},\"1\":{\"1322\":1}}],[\"目录找到jconsole\",{\"1\":{\"372\":1}}],[\"目录下\",{\"1\":{\"364\":1}}],[\"目录下的节点\",{\"1\":{\"1328\":1}}],[\"目录下的\",{\"1\":{\"353\":1,\"372\":1,\"1131\":1}}],[\"目前\",{\"1\":{\"1253\":1}}],[\"目前也能兼容部分语言\",{\"1\":{\"1172\":1}}],[\"目前已经被淘汰\",{\"1\":{\"1239\":1}}],[\"目前已经捐献给\",{\"1\":{\"1171\":1}}],[\"目前已经有接近\",{\"1\":{\"1122\":1}}],[\"目前已经是\",{\"1\":{\"8\":1}}],[\"目前主流的访问方式有\",{\"1\":{\"508\":1}}],[\"目前主要包括\",{\"1\":{\"90\":1}}],[\"目前来看\",{\"1\":{\"448\":1}}],[\"目前是原生支持\",{\"1\":{\"245\":1}}],[\"目前只有\",{\"1\":{\"103\":1,\"104\":1}}],[\"目前更加推荐使用\",{\"1\":{\"5\":1,\"68\":1}}],[\"源代码我们可以直接阅读\",{\"1\":{\"1240\":1}}],[\"源代码我们发现\",{\"1\":{\"934\":1}}],[\"源代码到\",{\"1\":{\"971\":1,\"973\":1,\"981\":1}}],[\"源代码会经历\",{\"1\":{\"969\":1}}],[\"源代码可以看出thread\",{\"1\":{\"883\":1}}],[\"源于\",{\"1\":{\"720\":1}}],[\"源数组中的起始位置\",{\"1\":{\"561\":2}}],[\"源数组\",{\"1\":{\"561\":2}}],[\"源程序\",{\"1\":{\"351\":1}}],[\"源码级别的研究和定制\",{\"1\":{\"1240\":1}}],[\"源码重新梳理一下\",{\"1\":{\"1208\":1}}],[\"源码的话\",{\"1\":{\"1129\":1}}],[\"源码的话就应该知道\",{\"1\":{\"678\":1}}],[\"源码详解\",{\"0\":{\"1036\":1,\"1041\":1}}],[\"源码详细分析\",{\"1\":{\"720\":1}}],[\"源码对于这个方法的说明\",{\"1\":{\"634\":1}}],[\"源码如下\",{\"1\":{\"603\":1,\"604\":2}}],[\"源码中有一个\",{\"1\":{\"564\":1}}],[\"源码\",{\"1\":{\"561\":1,\"562\":1,\"567\":1,\"577\":1,\"612\":1,\"720\":1,\"788\":1,\"847\":1,\"1012\":1,\"1015\":1}}],[\"源码分析\",{\"0\":{\"527\":1,\"532\":1,\"548\":1,\"567\":1,\"582\":1,\"586\":1,\"596\":1,\"615\":1,\"620\":1,\"701\":1,\"723\":1,\"727\":1,\"736\":1},\"1\":{\"597\":1,\"642\":2,\"644\":2,\"645\":2,\"654\":1,\"693\":1,\"731\":1,\"736\":2,\"792\":1,\"793\":1,\"913\":1}}],[\"源码解析\",{\"0\":{\"600\":1,\"707\":1},\"1\":{\"221\":2}}],[\"源码地址\",{\"1\":{\"56\":1,\"218\":1,\"268\":1}}],[\"肯定比\",{\"1\":{\"1380\":1}}],[\"肯定会提交刚刚\",{\"1\":{\"1380\":1}}],[\"肯定不会被回收\",{\"1\":{\"345\":1}}],[\"肯定是不行的\",{\"1\":{\"34\":1}}],[\"卸载\",{\"0\":{\"431\":1},\"1\":{\"427\":1}}],[\"卸载类需要满足\",{\"1\":{\"345\":1}}],[\"卸载类即该类的\",{\"1\":{\"345\":1}}],[\"卸载这部分内容来自\",{\"1\":{\"345\":1}}],[\"补充内容\",{\"0\":{\"657\":1,\"658\":1},\"1\":{\"503\":2,\"749\":1}}],[\"补充一句\",{\"1\":{\"446\":1}}],[\"补充说明\",{\"1\":{\"444\":1}}],[\"补充完善\",{\"1\":{\"345\":1}}],[\"补充\",{\"1\":{\"344\":1,\"555\":1}}],[\"勘误\",{\"1\":{\"342\":1,\"498\":1}}],[\"版\",{\"1\":{\"342\":2,\"496\":1,\"498\":1}}],[\"版本是第一个将\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"版本引入\",{\"1\":{\"1085\":1}}],[\"版本的\",{\"1\":{\"685\":1,\"1144\":1}}],[\"版本中出现了\",{\"1\":{\"529\":1}}],[\"版本中新增了\",{\"1\":{\"298\":1}}],[\"版本及后续版本中各个类中的\",{\"1\":{\"391\":1}}],[\"版本及\",{\"1\":{\"382\":1,\"495\":1}}],[\"版本保持一致\",{\"1\":{\"327\":1}}],[\"版本和生产环境的\",{\"1\":{\"327\":1}}],[\"版本后增加以下两种\",{\"1\":{\"273\":1}}],[\"版本演进中有多个版本的\",{\"1\":{\"236\":1}}],[\"版本之后引入了多线程来处理网络请求\",{\"1\":{\"264\":1}}],[\"版本之后引入了多线程来执行一些大键值对的异步删除操作\",{\"1\":{\"264\":1}}],[\"版本之后\",{\"1\":{\"233\":1,\"382\":1,\"495\":1}}],[\"版本之前\",{\"1\":{\"233\":1,\"236\":1,\"382\":1,\"495\":1}}],[\"版本以后自带了内存整理\",{\"1\":{\"220\":1}}],[\"版本链比对规则\",{\"1\":{\"141\":1}}],[\"版本就直接将查询缓存的整块功能删掉了\",{\"1\":{\"85\":1}}],[\"版本开始支持执行\",{\"1\":{\"283\":1}}],[\"版本开始成为了默认存储引擎\",{\"1\":{\"83\":1}}],[\"版本开始\",{\"1\":{\"76\":1,\"1206\":1,\"1296\":1}}],[\"版本下生成的\",{\"1\":{\"37\":2}}],[\"版本\",{\"0\":{\"1350\":1},\"1\":{\"37\":8,\"268\":1,\"475\":1,\"529\":4,\"767\":2,\"1296\":1,\"1297\":1}}],[\"版本号机制\",{\"0\":{\"840\":1,\"989\":1}}],[\"版本号\",{\"1\":{\"34\":1,\"1349\":1,\"1382\":1}}],[\"抛开上面的问题不讲\",{\"1\":{\"1275\":1}}],[\"抛开所有东西不谈\",{\"1\":{\"418\":1}}],[\"抛出\",{\"1\":{\"891\":1,\"936\":1}}],[\"抛出异常的任务将被取消\",{\"1\":{\"962\":1}}],[\"抛出异常\",{\"1\":{\"553\":1,\"555\":1,\"667\":2,\"756\":1,\"911\":1,\"1014\":1}}],[\"抛出该异常\",{\"1\":{\"341\":3}}],[\"抛去性能方面的影响\",{\"1\":{\"146\":1}}],[\"元数据可以认为是\",{\"1\":{\"1263\":1}}],[\"元数据验证\",{\"1\":{\"341\":1}}],[\"元素的顺序与它们最初插入的顺序相同\",{\"1\":{\"716\":1}}],[\"元素的插入和取出顺序满足\",{\"1\":{\"665\":1}}],[\"元素\",{\"1\":{\"671\":1}}],[\"元素必须实现comparable接口或者在构造函数中传入comparator对象\",{\"1\":{\"671\":1}}],[\"元素是有序的\",{\"1\":{\"665\":1}}],[\"元素唯一的特性\",{\"1\":{\"632\":1}}],[\"元素请使用\",{\"1\":{\"631\":1}}],[\"元素放在新数组末尾\",{\"1\":{\"588\":1}}],[\"元素本身不被复制\",{\"1\":{\"553\":1}}],[\"元素入队成功则直接返回\",{\"1\":{\"533\":1}}],[\"元素入队成功返回true\",{\"1\":{\"533\":2}}],[\"元素个数\",{\"1\":{\"287\":1}}],[\"元空间里面存放的是类的元数据\",{\"1\":{\"496\":1}}],[\"元空间使用的是本地内存\",{\"1\":{\"480\":1,\"495\":1,\"496\":1}}],[\"元空间使用的是直接内存\",{\"1\":{\"382\":1}}],[\"元空间的大小\",{\"0\":{\"480\":1}}],[\"元空间\",{\"1\":{\"382\":1,\"495\":1}}],[\"怎样获取\",{\"1\":{\"340\":1}}],[\"怎么解决呢\",{\"1\":{\"1299\":1}}],[\"怎么解决这个问题呢\",{\"1\":{\"272\":1}}],[\"怎么实现延迟队列\",{\"0\":{\"1257\":1}}],[\"怎么做\",{\"0\":{\"262\":1}}],[\"怎么执行是最好的结果呢\",{\"1\":{\"86\":1}}],[\"件事情\",{\"1\":{\"340\":1,\"349\":1}}],[\"件商品\",{\"1\":{\"60\":1}}],[\"详解\",{\"0\":{\"739\":1,\"772\":1,\"967\":1,\"1025\":1,\"1034\":1,\"1039\":1},\"1\":{\"758\":1,\"831\":1,\"841\":1,\"857\":1,\"874\":1,\"904\":1,\"913\":2,\"990\":1}}],[\"详细代码见我的这篇文章\",{\"1\":{\"1204\":1}}],[\"详细可以查看string类的api文档\",{\"1\":{\"663\":1}}],[\"详细可以查看\",{\"1\":{\"642\":2,\"644\":2,\"645\":2}}],[\"详细介绍可以查看\",{\"1\":{\"1223\":1}}],[\"详细介绍可以看看阿里开发者的redis\",{\"1\":{\"231\":1}}],[\"详细介绍了\",{\"1\":{\"412\":1}}],[\"详细\",{\"1\":{\"367\":1}}],[\"详见笔主的这篇文章\",{\"1\":{\"659\":1}}],[\"详见\",{\"1\":{\"339\":1,\"495\":1,\"633\":1}}],[\"准备了一个\",{\"1\":{\"1379\":1}}],[\"准备阶段只设置类中的静态变量\",{\"1\":{\"429\":1}}],[\"准备阶段是正式为类变量分配内存并设置类变量初始值的阶段\",{\"1\":{\"342\":1}}],[\"准备和解析这三个阶段可以统称为连接\",{\"1\":{\"338\":1}}],[\"准备\",{\"0\":{\"342\":1},\"1\":{\"338\":1,\"427\":2,\"429\":1}}],[\"准确点来说\",{\"1\":{\"5\":1,\"68\":1}}],[\"验证阶段示意图\",{\"1\":{\"341\":1}}],[\"验证阶段主要由四个检验阶段组成\",{\"1\":{\"341\":1}}],[\"验证阶段也不是必须要执行的阶段\",{\"1\":{\"341\":1}}],[\"验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的\",{\"1\":{\"341\":1}}],[\"验证是连接阶段的第一步\",{\"1\":{\"341\":1}}],[\"验证\",{\"0\":{\"341\":1},\"1\":{\"338\":2,\"339\":1,\"349\":1,\"427\":1,\"429\":1}}],[\"入门\",{\"0\":{\"1341\":1},\"1\":{\"1329\":1}}],[\"入门以及网关安全实战\",{\"1\":{\"6\":1}}],[\"入队的原子操作\",{\"1\":{\"1014\":1}}],[\"入队\",{\"1\":{\"535\":1,\"897\":1}}],[\"入栈和出栈\",{\"1\":{\"438\":1}}],[\"入自己定义的属性信息\",{\"1\":{\"333\":1}}],[\"修复错误\",{\"1\":{\"1213\":1}}],[\"修复自己副本中的熵\",{\"1\":{\"1087\":1}}],[\"修复对方副本中的熵\",{\"1\":{\"1087\":1}}],[\"修复数据的不一致性\",{\"1\":{\"1078\":1}}],[\"修正\",{\"1\":{\"359\":1,\"386\":1,\"393\":1,\"444\":1,\"480\":1,\"495\":1,\"687\":1,\"708\":1,\"762\":1,\"968\":1,\"1007\":1,\"1069\":1}}],[\"修饰方法的的情况\",{\"0\":{\"852\":1}}],[\"修饰么\",{\"0\":{\"849\":1}}],[\"修饰代码块\",{\"1\":{\"848\":2}}],[\"修饰静态方法\",{\"1\":{\"848\":2}}],[\"修饰实例方法\",{\"1\":{\"848\":2}}],[\"修饰类时\",{\"1\":{\"521\":1}}],[\"修饰的对象被称为弱引用\",{\"1\":{\"1030\":1}}],[\"修饰的对象被称为软引用\",{\"1\":{\"1030\":1}}],[\"修饰的\",{\"1\":{\"742\":1,\"904\":1,\"1006\":2,\"1018\":1}}],[\"修饰的方法并没有\",{\"1\":{\"852\":1,\"853\":1}}],[\"修饰的方法\",{\"1\":{\"445\":1}}],[\"修饰的方法就是本地方法\",{\"1\":{\"435\":1}}],[\"修饰的成员变量\",{\"1\":{\"430\":1}}],[\"修饰\",{\"1\":{\"344\":1,\"677\":1,\"742\":1,\"833\":1,\"904\":1}}],[\"修饰符\",{\"1\":{\"331\":2,\"768\":1}}],[\"修改其中的run\",{\"1\":{\"1047\":1}}],[\"修改开始探测式清理过期数据的下标为当前循环的\",{\"1\":{\"1036\":1}}],[\"修改共享资源\",{\"1\":{\"1007\":1}}],[\"修改之前的值还是修改后的值并不确定\",{\"1\":{\"972\":1}}],[\"修改指定位置的元素\",{\"1\":{\"733\":1}}],[\"修改指针\",{\"1\":{\"732\":1}}],[\"修改链表长度\",{\"1\":{\"731\":1}}],[\"修改的时候必定会牵连着每个生产者和消费者\",{\"1\":{\"1281\":1}}],[\"修改的情况\",{\"1\":{\"693\":2}}],[\"修改的话\",{\"1\":{\"280\":1}}],[\"修改\",{\"1\":{\"649\":1}}],[\"修改数组元素的值\",{\"1\":{\"649\":1}}],[\"修改操作不会立即反映到最终结果中\",{\"1\":{\"585\":1}}],[\"修改完之后再将修改后的数组赋值回去\",{\"1\":{\"585\":1,\"793\":1}}],[\"修改这个arraylist实例的容量是列表的当前大小\",{\"1\":{\"553\":1}}],[\"修改失败\",{\"1\":{\"280\":1}}],[\"长连接\",{\"1\":{\"1353\":1,\"1383\":1}}],[\"长期存储\",{\"1\":{\"1238\":1}}],[\"长期存活的对象将进入老年代\",{\"0\":{\"386\":1}}],[\"长与云\",{\"1\":{\"1236\":1}}],[\"长链接进行数据交互\",{\"1\":{\"1158\":1}}],[\"长时间阻塞的线程依然无法访问到\",{\"1\":{\"797\":1}}],[\"长整形数组原子类\",{\"1\":{\"766\":1}}],[\"长整型数组原子类\",{\"1\":{\"762\":1}}],[\"长整型原子类\",{\"1\":{\"762\":1,\"763\":1}}],[\"长整型字面量\",{\"1\":{\"328\":1}}],[\"长度为\",{\"1\":{\"633\":1}}],[\"长度为8字节\",{\"1\":{\"110\":1}}],[\"长度和内容不同\",{\"1\":{\"333\":1}}],[\"浮点型字面量\",{\"1\":{\"328\":1}}],[\"浮点数和字符串字面量\",{\"1\":{\"497\":1}}],[\"浮点数\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"描述的是执行多个\",{\"1\":{\"1097\":1}}],[\"描述的是多节点之间如何就某个值\",{\"1\":{\"1097\":1}}],[\"描述符索引\",{\"1\":{\"332\":1}}],[\"描述\",{\"1\":{\"328\":1,\"1006\":1,\"1007\":1}}],[\"声明为\",{\"1\":{\"328\":1}}],[\"项常量空出来是有特殊考虑的\",{\"1\":{\"328\":1}}],[\"项目\",{\"1\":{\"1343\":1}}],[\"项目的那篇文章\",{\"1\":{\"1178\":1}}],[\"项目代码注释详细\",{\"1\":{\"1173\":1}}],[\"项目间调用的关系可以通过\",{\"1\":{\"1045\":1}}],[\"项目地址\",{\"1\":{\"929\":1}}],[\"项目中使用\",{\"1\":{\"1178\":1}}],[\"项目中使用实战\",{\"0\":{\"1044\":1}}],[\"项目中threadlocal使用情况\",{\"1\":{\"1026\":1}}],[\"项目中\",{\"1\":{\"77\":1}}],[\"项目上线一个月之后\",{\"1\":{\"29\":1}}],[\"跨平台\",{\"1\":{\"1231\":1}}],[\"跨平台很重要的一个原因\",{\"1\":{\"324\":1}}],[\"跨语言特性\",{\"1\":{\"1231\":1}}],[\"跨语言\",{\"1\":{\"1231\":1}}],[\"跨度\",{\"1\":{\"21\":1}}],[\"控制的\",{\"1\":{\"1211\":1}}],[\"控制线程创建数量\",{\"1\":{\"917\":1}}],[\"控制着多线程之间的存和取\",{\"1\":{\"535\":1}}],[\"控制了\",{\"1\":{\"496\":1}}],[\"控制发生gc\",{\"1\":{\"443\":1}}],[\"控制堆内存的最大大小\",{\"1\":{\"412\":1}}],[\"控制参数\",{\"1\":{\"402\":1}}],[\"控制\",{\"1\":{\"319\":1,\"412\":1}}],[\"控制大小版本号的自增来实现的\",{\"1\":{\"23\":1}}],[\"扩散速度比一个主节点向其他节点传播信息要更快\",{\"1\":{\"1090\":1}}],[\"扩大两倍\",{\"1\":{\"572\":1}}],[\"扩容后的tab的大小为oldlen\",{\"1\":{\"1038\":1}}],[\"扩容逻辑往后看\",{\"1\":{\"1036\":1}}],[\"扩容时会造成死循环和数据丢失的问题\",{\"1\":{\"686\":1}}],[\"扩容时会讲到这一点内容\",{\"1\":{\"555\":1}}],[\"扩容导致死循环问题\",{\"1\":{\"685\":1}}],[\"扩容的阈值\",{\"1\":{\"576\":1}}],[\"扩容\",{\"0\":{\"572\":1},\"1\":{\"624\":1}}],[\"扩容阀值是\",{\"1\":{\"570\":1}}],[\"扩容机制\",{\"0\":{\"556\":1,\"1038\":1}}],[\"扩容机制分析\",{\"0\":{\"554\":1},\"1\":{\"659\":1}}],[\"扩容都会发生\",{\"1\":{\"480\":1}}],[\"扩容缩容期间可以提供服务吗\",{\"1\":{\"318\":1}}],[\"扩展性\",{\"1\":{\"1237\":2,\"1245\":1,\"1246\":1}}],[\"扩展性极高的动态\",{\"1\":{\"6\":1}}],[\"扩展机制\",{\"1\":{\"1132\":1}}],[\"扩展了\",{\"1\":{\"667\":2}}],[\"扩展类加载器被改名为平台类加载器\",{\"1\":{\"353\":1}}],[\"扩展类加载器\",{\"1\":{\"353\":1}}],[\"扩展\",{\"1\":{\"249\":1}}],[\"哨兵集群\",{\"1\":{\"318\":1}}],[\"水滴与银弹\",{\"1\":{\"316\":1}}],[\"治标不治本\",{\"1\":{\"316\":1}}],[\"小明说我是对的\",{\"1\":{\"1375\":1}}],[\"小花欣喜若狂告诉了周围的人\",{\"1\":{\"1368\":1}}],[\"小时前的数据\",{\"1\":{\"1306\":1}}],[\"小伙伴们应该也不会陌生\",{\"1\":{\"1143\":1}}],[\"小节\",{\"1\":{\"1016\":2}}],[\"小节中提出了一些问题\",{\"1\":{\"1016\":1}}],[\"小节中解答\",{\"1\":{\"1002\":1}}],[\"小结\",{\"0\":{\"1016\":1}}],[\"小红说我才是对的\",{\"1\":{\"1375\":1}}],[\"小红\",{\"1\":{\"663\":2}}],[\"小于最大容量\",{\"1\":{\"571\":3}}],[\"小总结\",{\"0\":{\"424\":1,\"455\":1}}],[\"小声\",{\"1\":{\"316\":1}}],[\"小概率会误判\",{\"1\":{\"307\":1}}],[\"摧枯拉朽之势\",{\"1\":{\"313\":1}}],[\"哈哈哈\",{\"1\":{\"1191\":1}}],[\"哈哈\",{\"1\":{\"313\":1}}],[\"哈希并不会保存元素的顺序\",{\"1\":{\"800\":1}}],[\"哈希值\",{\"1\":{\"619\":1}}],[\"哈希码\",{\"1\":{\"507\":1}}],[\"哈希槽分区\",{\"1\":{\"286\":1}}],[\"哈希槽\",{\"1\":{\"286\":2,\"287\":1,\"288\":1}}],[\"哈希\",{\"0\":{\"183\":1},\"1\":{\"163\":1}}],[\"哈希索引是一种基于哈希表实现的索引\",{\"1\":{\"103\":1}}],[\"哈希索引\",{\"1\":{\"103\":1}}],[\"哈希表结构\",{\"1\":{\"883\":1}}],[\"哈希表中字段的数量\",{\"1\":{\"293\":1}}],[\"哈希表\",{\"1\":{\"174\":1}}],[\"哈希表这种结构适用于只有等值查询的场景\",{\"1\":{\"96\":1}}],[\"哈希表示意图\",{\"1\":{\"96\":1}}],[\"哈希表是一种以键\",{\"1\":{\"96\":1}}],[\"哈希的思路很简单\",{\"1\":{\"96\":1}}],[\"人多了容易吵架\",{\"1\":{\"1375\":1}}],[\"人家本来最开始就不是为了作为消息队列滴\",{\"1\":{\"1191\":1}}],[\"人的职场进阶\",{\"1\":{\"412\":1}}],[\"人\",{\"1\":{\"307\":1}}],[\"差异性\",{\"1\":{\"1087\":1}}],[\"差不多\",{\"1\":{\"536\":1,\"895\":1,\"922\":1}}],[\"差不多是下面这样的\",{\"1\":{\"307\":1}}],[\"差集+交集\",{\"1\":{\"190\":1,\"259\":1}}],[\"差集是由所有属于\",{\"1\":{\"189\":1}}],[\"差集的操作\",{\"1\":{\"188\":1}}],[\"差集\",{\"1\":{\"157\":1,\"190\":4,\"259\":2,\"301\":1}}],[\"慢慢成为\",{\"1\":{\"351\":1}}],[\"慢日志查询\",{\"1\":{\"302\":1}}],[\"慢查询日志中的每个条目都由以下六个值组成\",{\"1\":{\"302\":1}}],[\"慢查询统计的是命令执行这一步骤的耗时\",{\"1\":{\"301\":1}}],[\"慢查询命令也就是那些命令执行时间较长的命令\",{\"1\":{\"301\":1}}],[\"慢查询命令\",{\"0\":{\"300\":1}}],[\"条消息的时候\",{\"1\":{\"1202\":1}}],[\"条消息的话\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"条即可\",{\"1\":{\"975\":1}}],[\"条\",{\"1\":{\"975\":1}}],[\"条数据的耗时\",{\"1\":{\"713\":1}}],[\"条字节码指令时\",{\"1\":{\"344\":1}}],[\"条的的慢查询命令\",{\"1\":{\"302\":1}}],[\"条耗时命令\",{\"1\":{\"302\":1}}],[\"条件\",{\"1\":{\"120\":1}}],[\"此限制也是保持\",{\"1\":{\"1362\":1}}],[\"此角色于\",{\"1\":{\"1355\":1}}],[\"此话一出\",{\"1\":{\"1343\":1}}],[\"此接口有两个实现类\",{\"1\":{\"1182\":1}}],[\"此线程对锁释放\",{\"1\":{\"1018\":1}}],[\"此线程被\",{\"1\":{\"816\":1}}],[\"此策略为我们提供可伸缩队列\",{\"1\":{\"936\":1}}],[\"此策略将丢弃最早的未处理的任务请求\",{\"1\":{\"891\":1,\"936\":1}}],[\"此后\",{\"1\":{\"904\":1}}],[\"此方法作为基于数组和基于集合的api之间的桥梁\",{\"1\":{\"634\":1}}],[\"此方法充当基于阵列和基于集合的api之间的桥梁\",{\"1\":{\"553\":1}}],[\"此作法主要的优点是如果调用者没有修改该资源\",{\"1\":{\"585\":1}}],[\"此参数默认用于\",{\"1\":{\"485\":1}}],[\"此内存区域的唯一目的就是存放对象实例\",{\"1\":{\"477\":1,\"495\":1}}],[\"此处设置的是\",{\"1\":{\"451\":1}}],[\"此处的大小是\",{\"1\":{\"449\":1}}],[\"此值最好配置与处理器数目相等\",{\"1\":{\"449\":1}}],[\"此值对系统性能影响较大\",{\"1\":{\"449\":1,\"450\":1}}],[\"此文旨在提及而不深究\",{\"1\":{\"416\":1}}],[\"此类的属性表中的属性数\",{\"1\":{\"325\":1,\"333\":1}}],[\"此外\",{\"1\":{\"297\":1,\"668\":1,\"719\":1,\"962\":1,\"1179\":1}}],[\"此时你可以通过让等待的节点只监听他们前面的节点\",{\"1\":{\"1388\":1}}],[\"此时它肯定会作为\",{\"1\":{\"1380\":1}}],[\"此时肯定要重新进行\",{\"1\":{\"1380\":1}}],[\"此时同意了提案\",{\"1\":{\"1380\":1}}],[\"此时提案者\",{\"1\":{\"1375\":1}}],[\"此时执行提案内容但不提交\",{\"1\":{\"1374\":1}}],[\"此时上下文会从用户态切换到内核态\",{\"1\":{\"1308\":1}}],[\"此时发生一次上下文从用户态到内核态的切换\",{\"1\":{\"1308\":1}}],[\"此时如果消息消费失败\",{\"1\":{\"1292\":2}}],[\"此时消息数据并不会立即被删除\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"此时消费者就会被唤醒等待\",{\"1\":{\"535\":1}}],[\"此时消费者就会被唤醒到队列中使用\",{\"1\":{\"535\":1}}],[\"此时服务端会等待消费者完成消费并提交消费结果\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"此时有一万的请求进入购票系统\",{\"1\":{\"1273\":1}}],[\"此时有两种情况\",{\"1\":{\"1111\":1}}],[\"此时都会用到应用层协议\",{\"1\":{\"1155\":1}}],[\"此时直接返回该\",{\"1\":{\"1142\":1}}],[\"此时entry\",{\"1\":{\"1040\":1}}],[\"此时以新计算出来正确的槽位位置往后迭代\",{\"1\":{\"1037\":1}}],[\"此时桶的位置离正确的位置index=4更近了\",{\"1\":{\"1037\":1}}],[\"此时说明这里是一个添加的逻辑\",{\"1\":{\"1036\":1}}],[\"此时table中没有key值相同的entry\",{\"1\":{\"1035\":1}}],[\"此时就会从内核态切换到用户态\",{\"1\":{\"1308\":1}}],[\"此时就会执行replacestaleentry\",{\"1\":{\"1035\":1}}],[\"此时就会线性向后查找\",{\"1\":{\"1033\":1}}],[\"此时就发生了超卖问题\",{\"1\":{\"60\":1}}],[\"此时队列中有元素\",{\"1\":{\"1011\":1}}],[\"此时会收到彼此的投票信息\",{\"1\":{\"1380\":1}}],[\"此时会创建一个\",{\"1\":{\"906\":1}}],[\"此时会将\",{\"1\":{\"444\":1}}],[\"此时这个对象锁还没有释放\",{\"1\":{\"860\":1}}],[\"此时由于提交数据版本等于数据库记录当前版本\",{\"1\":{\"840\":1,\"989\":1}}],[\"此时将其读出\",{\"1\":{\"840\":1,\"989\":1}}],[\"此时处于\",{\"1\":{\"820\":1}}],[\"此时可以通过它将所有步骤组合起来\",{\"1\":{\"774\":2,\"901\":1}}],[\"此时先前执行任务的线程继续执行\",{\"1\":{\"749\":1}}],[\"此时链表只有一个元素\",{\"1\":{\"729\":1}}],[\"此时存储了7个元素\",{\"1\":{\"653\":1}}],[\"此时只需要将其作为新的数组容量\",{\"1\":{\"624\":1}}],[\"此时为\",{\"1\":{\"557\":1}}],[\"此时那些等待非满的生产者就会被唤醒等待获取\",{\"1\":{\"535\":1}}],[\"此时挂起的生产者就会等待\",{\"1\":{\"535\":1}}],[\"此时又是把申请的内存释放掉的结果\",{\"1\":{\"451\":1}}],[\"此时又触发了\",{\"1\":{\"444\":1}}],[\"此时我们就用一个消息队列在中间进行解耦\",{\"1\":{\"1272\":1}}],[\"此时我们手动执行了一次\",{\"1\":{\"451\":1}}],[\"此时我们再跑一下这个代码\",{\"1\":{\"451\":1}}],[\"此时还在选举阶段所以整个集群处于\",{\"1\":{\"1380\":1}}],[\"此时还在系统内核缓存区未同步到磁盘\",{\"1\":{\"229\":1}}],[\"此时还会把\",{\"1\":{\"444\":1}}],[\"此时准备阶段时的那个\",{\"1\":{\"430\":1}}],[\"此时并没有同步到磁盘\",{\"1\":{\"230\":1}}],[\"此时缓存中无数据\",{\"1\":{\"145\":1}}],[\"此时最小事务id为100\",{\"1\":{\"141\":1}}],[\"此时\",{\"1\":{\"89\":1,\"393\":1,\"451\":2,\"557\":3,\"622\":1,\"634\":1,\"686\":1,\"834\":1,\"958\":1,\"1011\":1,\"1281\":1,\"1379\":1,\"1380\":1}}],[\"此时新的\",{\"1\":{\"51\":1}}],[\"热度和排名有所下降\",{\"1\":{\"1122\":1}}],[\"热点数据\",{\"1\":{\"309\":1,\"311\":1}}],[\"热\",{\"0\":{\"295\":1},\"1\":{\"296\":1}}],[\"热门帖子\",{\"1\":{\"207\":1}}],[\"热门网站每日\",{\"1\":{\"207\":1}}],[\"工程师面试突击第\",{\"1\":{\"1240\":1}}],[\"工厂方法\",{\"1\":{\"634\":2}}],[\"工具类中的方法如图所示\",{\"1\":{\"888\":1,\"937\":1}}],[\"工具类常用方法\",{\"1\":{\"695\":1}}],[\"工具类\",{\"0\":{\"695\":1},\"1\":{\"943\":1}}],[\"工具\",{\"1\":{\"455\":1}}],[\"工具分析\",{\"1\":{\"412\":2}}],[\"工具都不会逊色多少\",{\"1\":{\"377\":1}}],[\"工具可以直接拿来使用\",{\"1\":{\"293\":1}}],[\"工作模式\",{\"1\":{\"1259\":1}}],[\"工作量证明\",{\"1\":{\"1097\":1}}],[\"工作线程是否启动成功\",{\"1\":{\"941\":1}}],[\"工作线程\",{\"1\":{\"941\":1}}],[\"工作线程集合\",{\"1\":{\"941\":1}}],[\"工作线程阻塞\",{\"1\":{\"292\":1}}],[\"工作基本流程\",{\"1\":{\"230\":1}}],[\"工作基本流程是怎样的\",{\"0\":{\"230\":1}}],[\"工作流程图如下\",{\"1\":{\"230\":1}}],[\"工作流程的详细介绍可以查看\",{\"1\":{\"161\":1}}],[\"流转\",{\"1\":{\"1276\":1}}],[\"流处理\",{\"1\":{\"1236\":1}}],[\"流\",{\"1\":{\"1236\":1}}],[\"流式处理平台具有三个关键功能\",{\"1\":{\"1235\":1}}],[\"流式处理平台\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"流式调用\",{\"1\":{\"779\":1}}],[\"流平台具有三个关键功能\",{\"1\":{\"1190\":1}}],[\"流向\",{\"1\":{\"1114\":1}}],[\"流行病协议\",{\"1\":{\"1084\":1}}],[\"流言蜚语有什么特点呢\",{\"1\":{\"1084\":1}}],[\"流言蜚语的意思\",{\"1\":{\"1084\":1}}],[\"流程比较简单\",{\"1\":{\"578\":1}}],[\"流程就用到了这个功能\",{\"1\":{\"571\":1}}],[\"流程\",{\"1\":{\"571\":1,\"1012\":1}}],[\"流水线被清空\",{\"1\":{\"844\":1,\"993\":1}}],[\"流水线\",{\"1\":{\"287\":1}}],[\"流量治理\",{\"1\":{\"1168\":1}}],[\"流量监控等\",{\"1\":{\"73\":1}}],[\"流量监控\",{\"1\":{\"73\":1}}],[\"流量控制\",{\"1\":{\"1\":2,\"2\":1}}],[\"涉及到三个操作数\",{\"1\":{\"841\":1,\"990\":1}}],[\"涉及上下文切换\",{\"1\":{\"285\":1}}],[\"涉及发布者\",{\"1\":{\"251\":1}}],[\"往后清理\",{\"1\":{\"1042\":1}}],[\"往后迭代\",{\"1\":{\"1040\":1}}],[\"往后迭代的过程中如果没有找到k\",{\"1\":{\"1036\":1}}],[\"往后查找离index=4最近的entry=null的节点\",{\"1\":{\"1037\":1}}],[\"往后遍历过程中\",{\"1\":{\"1035\":3}}],[\"往threadlocalmap中set数据\",{\"1\":{\"1035\":1}}],[\"往列表末尾插入元素的时间复杂度是\",{\"1\":{\"653\":1}}],[\"往返时间\",{\"1\":{\"285\":1}}],[\"往下游服务传递\",{\"1\":{\"21\":1}}],[\"真恶心\",{\"1\":{\"1271\":1}}],[\"真实调用过程依赖代理类\",{\"1\":{\"1130\":1}}],[\"真的很快\",{\"1\":{\"1179\":1}}],[\"真的不错\",{\"1\":{\"882\":1}}],[\"真的扯了很久这东西\",{\"1\":{\"472\":1}}],[\"真的变慢了吗\",{\"1\":{\"284\":1}}],[\"真正的第一个有数据的节点\",{\"1\":{\"1011\":1}}],[\"真正的生成订单\",{\"1\":{\"17\":1}}],[\"真正意义上的并发收集器\",{\"1\":{\"402\":1}}],[\"严格顺序看起来虽好\",{\"1\":{\"1299\":1}}],[\"严格顺序消息\",{\"1\":{\"1299\":1}}],[\"严格顺序\",{\"1\":{\"1299\":1,\"1314\":1}}],[\"严格限制了消息同步处理及每条消息的处理超时时间\",{\"1\":{\"1292\":1}}],[\"严格来说的话\",{\"1\":{\"283\":1}}],[\"严重影响系统性能\",{\"1\":{\"1290\":1}}],[\"严重的情况下甚至会直接把\",{\"1\":{\"236\":1}}],[\"严重的时候会触发集群内的故障转移\",{\"1\":{\"167\":1}}],[\"堆外内存就是把内存对象分配在堆\",{\"1\":{\"499\":1}}],[\"堆外内存\",{\"1\":{\"499\":1}}],[\"堆之间来回复制数据\",{\"1\":{\"499\":1}}],[\"堆或方法区中分配的\",{\"1\":{\"499\":1}}],[\"堆这里最容易出现的就是\",{\"1\":{\"495\":1}}],[\"堆还可以细分为\",{\"1\":{\"495\":1}}],[\"堆可以是连续空间\",{\"1\":{\"491\":1}}],[\"堆空闲的最大百分比\",{\"1\":{\"485\":1}}],[\"堆空间的大小减小\",{\"1\":{\"485\":1}}],[\"堆空间的基本结构\",{\"0\":{\"382\":1}}],[\"堆空间实际占用非常少\",{\"1\":{\"456\":1}}],[\"堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定\",{\"1\":{\"503\":1}}],[\"堆是否规整决定\",{\"1\":{\"503\":1}}],[\"堆是所有线程共享的一块内存区域\",{\"1\":{\"477\":1,\"495\":1}}],[\"堆是垃圾收集器管理的主要区域\",{\"1\":{\"382\":1,\"495\":1}}],[\"堆大小\",{\"1\":{\"451\":1}}],[\"堆最小值\",{\"1\":{\"451\":1}}],[\"堆最大值\",{\"1\":{\"451\":1}}],[\"堆的限制\",{\"1\":{\"499\":1}}],[\"堆的大小可以固定\",{\"1\":{\"491\":1}}],[\"堆的较大页面大小\",{\"1\":{\"485\":1}}],[\"堆的\",{\"1\":{\"450\":1,\"455\":1}}],[\"堆管存储\",{\"1\":{\"437\":1}}],[\"堆都为线程共享区域\",{\"1\":{\"424\":1}}],[\"堆分为新生代和老年代\",{\"1\":{\"399\":1}}],[\"堆和\",{\"1\":{\"499\":1}}],[\"堆和方法区是所有线程共享的资源\",{\"1\":{\"813\":1}}],[\"堆和方法区则不一样\",{\"1\":{\"445\":1}}],[\"堆和方法区\",{\"1\":{\"387\":1}}],[\"堆和永久代的详细信息\",{\"1\":{\"368\":1}}],[\"堆内存是否规整\",{\"1\":{\"503\":2}}],[\"堆内存不规整的情况下\",{\"1\":{\"503\":1}}],[\"堆内存规整\",{\"1\":{\"503\":1}}],[\"堆内存相关\",{\"0\":{\"477\":1}}],[\"堆内存\",{\"1\":{\"448\":1}}],[\"堆内存中的空间不足以存放新创建的对象\",{\"1\":{\"495\":1}}],[\"堆内存中存放的是对象\",{\"1\":{\"443\":1}}],[\"堆内存中也会划分为年轻代和老年代\",{\"1\":{\"443\":1}}],[\"堆内存中\",{\"1\":{\"429\":1}}],[\"堆内存结构\",{\"1\":{\"382\":1,\"495\":1}}],[\"堆内存被通常分为下面三部分\",{\"1\":{\"382\":1,\"495\":1}}],[\"堆被划分为了几个不同的区域\",{\"1\":{\"382\":1}}],[\"堆\",{\"0\":{\"421\":1,\"495\":1},\"1\":{\"377\":1,\"382\":2,\"393\":1,\"407\":1,\"421\":1,\"491\":1,\"495\":1,\"892\":1,\"938\":1,\"961\":1}}],[\"堆转储\",{\"1\":{\"368\":1}}],[\"堆中将会划分出一块内存来作为句柄池\",{\"1\":{\"509\":1}}],[\"堆中划分出来\",{\"1\":{\"503\":1}}],[\"堆中对象分配\",{\"1\":{\"500\":1}}],[\"堆中的\",{\"1\":{\"499\":1}}],[\"堆中增大年轻代后\",{\"1\":{\"450\":1}}],[\"堆中不存在该类的任何实例\",{\"1\":{\"394\":1}}],[\"堆中几乎放着所有的对象实例\",{\"1\":{\"389\":1}}],[\"堆中\",{\"1\":{\"342\":2,\"498\":1}}],[\"堆积在内存里\",{\"1\":{\"272\":1}}],[\"堆栈等的开销\",{\"1\":{\"219\":1}}],[\"懒汉式删除\",{\"1\":{\"272\":1,\"289\":1}}],[\"定时时间到达后才会被投递给消费者\",{\"1\":{\"1285\":1}}],[\"定时时刻到达后\",{\"1\":{\"1285\":1}}],[\"定时中\",{\"1\":{\"1285\":1}}],[\"定时消息的实现逻辑需要先经过定时存储等待触发\",{\"1\":{\"1285\":1}}],[\"定时消息生命周期\",{\"1\":{\"1285\":1}}],[\"定时消息仅支持在\",{\"1\":{\"1285\":1}}],[\"定时消息\",{\"0\":{\"1285\":1}}],[\"定时从\",{\"1\":{\"1281\":1}}],[\"定时任务详解\",{\"1\":{\"962\":1}}],[\"定理逐步演化而来的\",{\"1\":{\"1073\":1}}],[\"定理简化\",{\"1\":{\"1071\":1}}],[\"定理\",{\"1\":{\"1067\":1,\"1368\":1}}],[\"定理又被称作\",{\"1\":{\"1066\":1}}],[\"定理起源于\",{\"1\":{\"1066\":1}}],[\"定制排序后\",{\"1\":{\"662\":2}}],[\"定制排序的用法\",{\"1\":{\"662\":1}}],[\"定制排序\",{\"0\":{\"662\":1},\"1\":{\"696\":1}}],[\"定位出的\",{\"1\":{\"577\":1}}],[\"定期删除执行过程中\",{\"1\":{\"289\":1}}],[\"定期删除+惰性\",{\"1\":{\"272\":1,\"289\":1}}],[\"定期删除对内存更加友好\",{\"1\":{\"272\":1}}],[\"定期删除\",{\"1\":{\"272\":1}}],[\"定义这个的原因也是为了顺序性\",{\"1\":{\"1379\":1}}],[\"定义接口和数据类型还挺繁琐的\",{\"1\":{\"1170\":1}}],[\"定义了五种不同的消息正文格式以及调用的消息类型\",{\"1\":{\"1226\":1}}],[\"定义了可重入锁的释放锁机制\",{\"1\":{\"1014\":1}}],[\"定义了\",{\"1\":{\"973\":1}}],[\"定义了排序模式\",{\"1\":{\"705\":1}}],[\"定义一系列规范来解决这个问题\",{\"1\":{\"968\":1}}],[\"定义一些策略\",{\"1\":{\"891\":1,\"936\":1}}],[\"定义一个节点元素保存\",{\"1\":{\"729\":1}}],[\"定义两种资源共享方式\",{\"1\":{\"743\":1}}],[\"定义的是\",{\"1\":{\"1210\":1}}],[\"定义的并发编程相关的一组规范\",{\"1\":{\"971\":1,\"981\":1}}],[\"定义的\",{\"1\":{\"727\":1}}],[\"定义\",{\"1\":{\"99\":1,\"325\":1,\"1231\":1}}],[\"惰性删除对\",{\"1\":{\"272\":1}}],[\"惰性删除\",{\"1\":{\"272\":1,\"289\":1,\"294\":1}}],[\"天然支持的\",{\"1\":{\"1390\":1}}],[\"天然具有跨平台\",{\"1\":{\"1231\":1}}],[\"天一次的优化过程\",{\"1\":{\"486\":1}}],[\"天到\",{\"1\":{\"486\":1}}],[\"天内有效\",{\"1\":{\"270\":1}}],[\"天每天有运营活动\",{\"1\":{\"19\":1}}],[\"外卖商家端\",{\"1\":{\"788\":1}}],[\"外卖订单\",{\"1\":{\"60\":1}}],[\"外网访问\",{\"1\":{\"373\":1}}],[\"外部实现的\",{\"1\":{\"353\":1}}],[\"外\",{\"1\":{\"270\":1,\"330\":1,\"934\":1,\"1355\":1}}],[\"问问\",{\"1\":{\"1379\":1}}],[\"问\",{\"1\":{\"267\":1}}],[\"问题就来了\",{\"1\":{\"1303\":1}}],[\"问题是可以解决\",{\"1\":{\"1278\":1}}],[\"问题是乐观锁最常见的问题\",{\"1\":{\"842\":1,\"991\":1}}],[\"问题上\",{\"1\":{\"1070\":1}}],[\"问题中\",{\"1\":{\"796\":1}}],[\"问题案例来啦\",{\"1\":{\"412\":1,\"486\":1}}],[\"问题的\",{\"1\":{\"843\":1,\"992\":1}}],[\"问题的解决思路是在变量前面追加上版本号或者时间戳\",{\"1\":{\"843\":1,\"992\":1}}],[\"问题的解决思路与方式探索\",{\"1\":{\"320\":1}}],[\"问题的环境上\",{\"1\":{\"483\":1}}],[\"问题的排查思路\",{\"1\":{\"412\":1}}],[\"问题排查\",{\"1\":{\"412\":1}}],[\"问题分析与解决\",{\"1\":{\"412\":1,\"486\":1}}],[\"问题分析\",{\"1\":{\"412\":1}}],[\"问题太多比如性能太差\",{\"1\":{\"62\":1}}],[\"问题\",{\"0\":{\"843\":1,\"992\":1},\"1\":{\"35\":1,\"37\":1,\"38\":1,\"299\":1,\"412\":1,\"443\":1,\"486\":1,\"762\":3,\"767\":2,\"841\":1,\"843\":1,\"990\":1,\"992\":1,\"995\":1,\"1184\":1}}],[\"甚至出库后\",{\"1\":{\"1220\":1}}],[\"甚至连grpc底层都直接用的http2\",{\"1\":{\"1159\":1}}],[\"甚至是\",{\"1\":{\"1157\":1}}],[\"甚至是否被执行也不确定\",{\"1\":{\"446\":1}}],[\"甚至分不清哪个应用要在哪个应用之前启动\",{\"1\":{\"1123\":1}}],[\"甚至会导致线程池崩溃或者程序假死\",{\"1\":{\"925\":1}}],[\"甚至会出现任务队列满了之后任务\",{\"1\":{\"895\":1,\"922\":1}}],[\"甚至会影响性能\",{\"1\":{\"266\":1}}],[\"甚至完全不进行垃圾收集也是可以的\",{\"1\":{\"491\":1}}],[\"甚至有不同线程中调用\",{\"1\":{\"446\":1}}],[\"甚至最高能达到\",{\"1\":{\"246\":1}}],[\"闭\",{\"1\":{\"265\":1}}],[\"添加积分等一些操作都依赖于上面的\",{\"1\":{\"1272\":1}}],[\"添加成功就返回true否则返回false\",{\"1\":{\"941\":1}}],[\"添加新的工作线程到线程池\",{\"1\":{\"941\":1}}],[\"添加锁和释放锁的大部分操作实际上都是在\",{\"1\":{\"857\":1}}],[\"添加事件\",{\"1\":{\"807\":1}}],[\"添加前的最后一个元素\",{\"1\":{\"729\":1}}],[\"添加元素满了之后会自动扩容原来容量的\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"添加元素然后进行遍历\",{\"1\":{\"704\":1}}],[\"添加元素到链表末尾\",{\"1\":{\"733\":1}}],[\"添加元素到\",{\"1\":{\"649\":1}}],[\"添加元素的方法无论是\",{\"1\":{\"603\":1}}],[\"添加元素\",{\"0\":{\"603\":1},\"1\":{\"688\":2}}],[\"添加大量元素之前使用ensurecapacity\",{\"1\":{\"564\":1}}],[\"添加大量元素之前用\",{\"1\":{\"564\":1}}],[\"添加第\",{\"1\":{\"557\":1,\"706\":2}}],[\"添加的参数\",{\"1\":{\"384\":1}}],[\"添加到自己的日志后面\",{\"1\":{\"1112\":1}}],[\"添加到自己的日志末尾后\",{\"1\":{\"1112\":1}}],[\"添加到自己的\",{\"1\":{\"1110\":1}}],[\"添加到该线程中\",{\"1\":{\"941\":2}}],[\"添加到\",{\"1\":{\"262\":1}}],[\"添加一个或多个元素对应的经纬度信息到\",{\"1\":{\"210\":1}}],[\"添加一个或多个元素到\",{\"1\":{\"206\":1,\"262\":1}}],[\"添加一个或多个元素\",{\"1\":{\"181\":2}}],[\"音频\",{\"1\":{\"256\":1}}],[\"音乐推荐\",{\"1\":{\"190\":1,\"259\":1}}],[\"音乐\",{\"1\":{\"19\":1}}],[\"音乐年卡的兑换码\",{\"1\":{\"19\":1}}],[\"音乐年卡\",{\"1\":{\"19\":1}}],[\"属性进行匹配\",{\"1\":{\"1252\":1}}],[\"属性的初始化值\",{\"1\":{\"756\":2,\"911\":2}}],[\"属性的\",{\"1\":{\"705\":1}}],[\"属性值\",{\"1\":{\"589\":1}}],[\"属性\",{\"1\":{\"325\":1}}],[\"属性表集合的限制稍微宽松一些\",{\"1\":{\"333\":1}}],[\"属性表集合几项\",{\"1\":{\"332\":1}}],[\"属性表集合\",{\"0\":{\"333\":1},\"1\":{\"325\":1,\"333\":1}}],[\"属性判断字符串是否结束\",{\"1\":{\"256\":1}}],[\"属性即可\",{\"1\":{\"256\":1}}],[\"属性检查空间大小是否满足要求\",{\"1\":{\"256\":1}}],[\"属于一种\",{\"1\":{\"1218\":1}}],[\"属于消息服务领域权威组织所做的相关的标准\",{\"1\":{\"1192\":1}}],[\"属于消费型接口\",{\"1\":{\"779\":1}}],[\"属于线性探测清理\",{\"1\":{\"1042\":1}}],[\"属于计算机系统中的一个概念\",{\"1\":{\"29\":1}}],[\"属于后来者\",{\"1\":{\"10\":1}}],[\"属于\",{\"1\":{\"5\":1,\"68\":1,\"847\":1,\"1196\":1}}],[\"节\",{\"1\":{\"1214\":1}}],[\"节约开销\",{\"1\":{\"934\":1}}],[\"节省了资源\",{\"1\":{\"558\":1}}],[\"节省网络流量\",{\"1\":{\"255\":1}}],[\"节第三版对符号引用和直接引用的解释如下\",{\"1\":{\"343\":1,\"497\":1}}],[\"节点也挂了\",{\"1\":{\"1388\":1}}],[\"节点数据内容的长度\",{\"1\":{\"1382\":1}}],[\"节点数量比较多的情况下\",{\"1\":{\"1090\":1}}],[\"节点名称\",{\"1\":{\"1382\":1}}],[\"节点状态和watcher\",{\"1\":{\"1387\":1}}],[\"节点状态中包含了很多节点的属性比如\",{\"1\":{\"1382\":1}}],[\"节点状态\",{\"1\":{\"1382\":1,\"1387\":1}}],[\"节点状态的产生和变化已经有了大致的了解\",{\"1\":{\"1013\":1}}],[\"节点在一开始都处于选举阶段\",{\"1\":{\"1356\":1}}],[\"节点创建时为\",{\"1\":{\"1349\":1}}],[\"节点创建时间\",{\"1\":{\"1349\":1}}],[\"节点存放的数据的具体内容\",{\"1\":{\"1349\":1}}],[\"节点路径标识方式和\",{\"1\":{\"1348\":1}}],[\"节点都有这个\",{\"1\":{\"1263\":1}}],[\"节点都维护了一份集群的状态信息\",{\"1\":{\"1085\":1}}],[\"节点可以组成一个集群\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"节点可用\",{\"1\":{\"51\":1}}],[\"节点不够分散\",{\"1\":{\"1143\":1}}],[\"节点崩溃\",{\"0\":{\"1115\":1}}],[\"节点类型\",{\"0\":{\"1108\":1},\"1\":{\"1382\":1}}],[\"节点类源码\",{\"1\":{\"619\":1}}],[\"节点过多或者节点动态变化的话\",{\"1\":{\"1087\":1}}],[\"节点通过\",{\"1\":{\"1085\":1}}],[\"节点标记为\",{\"1\":{\"1085\":1}}],[\"节点发送一条\",{\"1\":{\"1085\":1}}],[\"节点发起\",{\"1\":{\"286\":1}}],[\"节点多的时候不光同步消息的效率低\",{\"1\":{\"1083\":1}}],[\"节点间的网络连接通信正常的话\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"节点之间的数据同步\",{\"1\":{\"1069\":1}}],[\"节点产生过程中断开\",{\"1\":{\"1014\":1}}],[\"节点入队并不是原子操作\",{\"1\":{\"1014\":1}}],[\"节点入队不是原子操作\",{\"1\":{\"1011\":1}}],[\"节点和当前\",{\"1\":{\"1013\":1}}],[\"节点线程等待唤醒\",{\"1\":{\"1005\":1}}],[\"节点加入阻塞队列\",{\"1\":{\"906\":1}}],[\"节点加入等待队列\",{\"1\":{\"748\":1}}],[\"节点前驱的后继引用指向新节点\",{\"1\":{\"729\":1}}],[\"节点前驱引用\",{\"1\":{\"729\":1}}],[\"节点值\",{\"1\":{\"727\":1}}],[\"节点所走过的路径称为引用链\",{\"1\":{\"391\":1}}],[\"节点上的线程间\",{\"1\":{\"1181\":1}}],[\"节点上执行\",{\"1\":{\"1085\":1}}],[\"节点上\",{\"1\":{\"299\":1}}],[\"节点如何变化\",{\"1\":{\"108\":1}}],[\"节点\",{\"1\":{\"54\":4,\"286\":1,\"318\":1,\"708\":1,\"712\":1,\"1069\":1,\"1085\":3,\"1087\":7,\"1097\":1,\"1263\":1,\"1325\":2,\"1335\":4,\"1349\":4,\"1382\":1}}],[\"节点的版本号\",{\"1\":{\"1350\":1,\"1382\":1}}],[\"节点的内容\",{\"1\":{\"1349\":1}}],[\"节点的新位置都是相同的\",{\"1\":{\"572\":1}}],[\"节点的特性之外\",{\"1\":{\"54\":2,\"1335\":2,\"1349\":2}}],[\"节点的\",{\"1\":{\"51\":1,\"1349\":1,\"1382\":1}}],[\"节点出现问题\",{\"1\":{\"51\":1}}],[\"既可以为客户端提供写服务又能提供读服务\",{\"1\":{\"1355\":1}}],[\"既可以用\",{\"1\":{\"1213\":1}}],[\"既可以保证多个线程同时读的效率\",{\"1\":{\"865\":1,\"866\":1}}],[\"既超过这个最大执行次数后才会停止重试\",{\"1\":{\"1210\":1}}],[\"既充分利用了现代\",{\"1\":{\"1184\":1}}],[\"既要支持网页版\",{\"1\":{\"1155\":1}}],[\"既想约束子类具有共同的行为\",{\"1\":{\"520\":1}}],[\"既不存在于缓存中\",{\"1\":{\"311\":1}}],[\"既能单播又能广播\",{\"1\":{\"251\":1}}],[\"既然这样\",{\"1\":{\"1272\":1}}],[\"既然有了\",{\"0\":{\"1174\":1}}],[\"既然有\",{\"1\":{\"1155\":1}}],[\"既然要相互通信就要遵循一致的通信协议\",{\"1\":{\"1085\":1}}],[\"既然要释放当前线程占有的对象锁并让其进入\",{\"1\":{\"826\":1}}],[\"既然说到了排队等候机制\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"既然运行时常量池是方法区的一部分\",{\"1\":{\"497\":1}}],[\"既然虚拟机采用了分代收集的思想来管理内存\",{\"1\":{\"386\":1}}],[\"既然是map结构\",{\"1\":{\"1032\":1}}],[\"既然是内存就会受到本机总内存大小以及处理器寻址空间的限制\",{\"1\":{\"499\":1}}],[\"既然是单线程\",{\"1\":{\"265\":1}}],[\"既然是一种编解码规则\",{\"1\":{\"19\":1}}],[\"既然只依靠\",{\"1\":{\"89\":1}}],[\"频率和停顿时间\",{\"1\":{\"412\":1}}],[\"频道\",{\"1\":{\"251\":1}}],[\"频繁修改\",{\"1\":{\"218\":1}}],[\"频繁需要排序的字段\",{\"1\":{\"119\":1}}],[\"频繁更新的字段不适合作为索引\",{\"1\":{\"119\":1}}],[\"带超时的等待策略\",{\"1\":{\"1183\":1}}],[\"带给你不一样的思考\",{\"1\":{\"1071\":1}}],[\"带着非公平锁的这些问题\",{\"1\":{\"1002\":1}}],[\"带你了解下\",{\"1\":{\"913\":1}}],[\"带你走一遍整个执行流程\",{\"1\":{\"83\":1}}],[\"带来了什么好处\",{\"0\":{\"1197\":1}}],[\"带来非常大的执行开销\",{\"1\":{\"844\":1,\"993\":1}}],[\"带来的效益是一样的\",{\"1\":{\"1380\":1}}],[\"带来的队列有序特性来保证消息有序性了\",{\"1\":{\"1299\":1}}],[\"带来的好处就是\",{\"1\":{\"1032\":1}}],[\"带来的不良用户体验\",{\"1\":{\"401\":1}}],[\"带来的潜在问题是非常多的\",{\"1\":{\"292\":1}}],[\"带大家看看\",{\"1\":{\"772\":1}}],[\"带权图的遍历等\",{\"1\":{\"669\":1}}],[\"带初始容量参数的构造函数\",{\"1\":{\"553\":1,\"555\":1}}],[\"带有超时时间的等待\",{\"1\":{\"752\":1}}],[\"带有超时时间的\",{\"1\":{\"537\":2}}],[\"带\",{\"1\":{\"251\":1}}],[\"消费重试策略\",{\"1\":{\"1297\":1}}],[\"消费重试策略是一致的\",{\"1\":{\"1297\":1}}],[\"消费重复消息会带来更大的麻烦\",{\"1\":{\"1275\":1}}],[\"消费类型\",{\"1\":{\"1293\":1}}],[\"消费处理完成后\",{\"1\":{\"1293\":1}}],[\"消费普通消息\",{\"1\":{\"1293\":1}}],[\"消费示例\",{\"1\":{\"1293\":1}}],[\"消费状态提交以及消费重试都是通过消费者业务逻辑主动发起调用完成\",{\"1\":{\"1293\":1}}],[\"消费状态提交以及消费重试都通过\",{\"1\":{\"1292\":1}}],[\"消费监听器提前返回消费结果\",{\"1\":{\"1292\":1}}],[\"消费提交\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消费中\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消费位移\",{\"1\":{\"1280\":1}}],[\"消费超时等情况导致的消息被\",{\"1\":{\"1213\":1}}],[\"消费异常会进行重试\",{\"1\":{\"1210\":1}}],[\"消费失败会怎么样\",{\"0\":{\"1209\":1}}],[\"消费消息仅仅通过消费监听器监听并返回结果\",{\"1\":{\"1292\":1}}],[\"消费消息不就好了么\",{\"1\":{\"1281\":1}}],[\"消费消息时只消费消息体\",{\"1\":{\"1254\":1}}],[\"消费消息\",{\"1\":{\"1254\":1}}],[\"消费消息服务做幂等校验\",{\"1\":{\"1207\":1}}],[\"消费消息的一方\",{\"1\":{\"1196\":1,\"1248\":1}}],[\"消费顺序\",{\"0\":{\"1201\":1}}],[\"消费的时候\",{\"1\":{\"1199\":1}}],[\"消费\",{\"1\":{\"779\":2}}],[\"消费是takelock\",{\"1\":{\"542\":1,\"672\":1}}],[\"消费者可以自动切换到从节点进行消费\",{\"1\":{\"1314\":1}}],[\"消费者可以从队列中获取消息并消费\",{\"1\":{\"1250\":1}}],[\"消费者可以从队列中获取值了\",{\"1\":{\"535\":1}}],[\"消费者收到的\",{\"1\":{\"1299\":1}}],[\"消费者分组中的订阅关系\",{\"1\":{\"1297\":1}}],[\"消费者分组不是具体实体而是一个逻辑资源\",{\"1\":{\"1297\":1}}],[\"消费者分组是多个消费行为一致的消费者的负载均衡分组\",{\"1\":{\"1297\":1}}],[\"消费者分组\",{\"0\":{\"1297\":1}}],[\"消费者分组和生产者分组\",{\"0\":{\"1295\":1}}],[\"消费者分类\",{\"0\":{\"1291\":1}}],[\"消费者仍然可以回溯消息重新消费\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消费者仍然能够继续消费后续的消息\",{\"1\":{\"1209\":1}}],[\"消费者完成消费处理\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消费者通过\",{\"1\":{\"1281\":1,\"1299\":1}}],[\"消费者和生产者就从\",{\"1\":{\"1281\":1}}],[\"消费者从\",{\"1\":{\"1281\":1}}],[\"消费者组中的消费者个数和主题中队列个数相同\",{\"1\":{\"1280\":1}}],[\"消费者组\",{\"1\":{\"1280\":2}}],[\"消费者组和生产者组的介绍\",{\"1\":{\"1267\":1}}],[\"消费者只需要关注从指定主题中拉取消息\",{\"1\":{\"1272\":1}}],[\"消费者类型\",{\"1\":{\"1267\":1}}],[\"消费者与\",{\"1\":{\"1260\":1}}],[\"消费者才能拿到这个消息进行消费\",{\"1\":{\"1257\":1}}],[\"消费者连接到\",{\"1\":{\"1254\":1}}],[\"消费者负责处理消息\",{\"1\":{\"1218\":1}}],[\"消费者会尝试处理它\",{\"1\":{\"1213\":1}}],[\"消费者会自动提交了\",{\"1\":{\"1205\":1}}],[\"消费者在默认配置下会进行最多\",{\"1\":{\"1210\":1}}],[\"消费者在本地缓存了提供者列表\",{\"1\":{\"1137\":1}}],[\"消费者消费时\",{\"1\":{\"1292\":1}}],[\"消费者消费消息失败时的重试策略\",{\"1\":{\"1297\":1}}],[\"消费者消费消息\",{\"1\":{\"251\":1}}],[\"消费者消代码\",{\"1\":{\"1209\":1}}],[\"消费者丢失消息的情况\",{\"0\":{\"1205\":1}}],[\"消费者线程会被阻塞\",{\"1\":{\"796\":1}}],[\"消费者线程会调用\",{\"1\":{\"544\":2}}],[\"消费者\",{\"0\":{\"1248\":1},\"1\":{\"535\":1,\"796\":1,\"1196\":1,\"1218\":1,\"1222\":2,\"1248\":2,\"1254\":1,\"1262\":3}}],[\"消费者取出元素\",{\"1\":{\"531\":11}}],[\"消费者此时就可以进来消费\",{\"1\":{\"530\":1}}],[\"消费者模型中\",{\"1\":{\"670\":1}}],[\"消费者模型的设计\",{\"1\":{\"535\":1}}],[\"消费者模型\",{\"1\":{\"530\":1,\"535\":1}}],[\"消费者模式实现的并发容器\",{\"1\":{\"529\":1}}],[\"消耗在垃圾收集上的时间不得超过\",{\"1\":{\"407\":1}}],[\"消耗的内存约是\",{\"1\":{\"255\":1}}],[\"消息后\",{\"1\":{\"1370\":1}}],[\"消息广播模式\",{\"0\":{\"1379\":1}}],[\"消息广播\",{\"1\":{\"1361\":1,\"1378\":1,\"1379\":1,\"1391\":1}}],[\"消息本身大小\",{\"1\":{\"1315\":1}}],[\"消息大小\",{\"1\":{\"1315\":1}}],[\"消息消费是针对主题进行的\",{\"1\":{\"1315\":1}}],[\"消息消费队列\",{\"1\":{\"1315\":1}}],[\"消息消费的角色\",{\"1\":{\"1281\":1}}],[\"消息主要是顺序写入日志文件\",{\"1\":{\"1315\":1}}],[\"消息主体以及元数据的存储主体\",{\"1\":{\"1315\":1}}],[\"消息内容不是定长的\",{\"1\":{\"1315\":1}}],[\"消息存储架构中的三大角色\",{\"1\":{\"1315\":1}}],[\"消息写入主节点之后就直接返回写入成功\",{\"1\":{\"1314\":1}}],[\"消息刷盘采用后台异步线程提交的方式进行\",{\"1\":{\"1313\":1}}],[\"消息仍然需要保留\",{\"1\":{\"1306\":1}}],[\"消息超过\",{\"1\":{\"1302\":1}}],[\"消息过大\",{\"0\":{\"1302\":1}}],[\"消息处理时长不可控\",{\"1\":{\"1293\":1}}],[\"消息处理时间可预估\",{\"1\":{\"1292\":1}}],[\"消息还未处理完成\",{\"1\":{\"1292\":1}}],[\"消息删除\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消息在保存时间到期或存储空间不足被删除前\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消息在被追加到\",{\"1\":{\"1202\":1}}],[\"消息发布的角色\",{\"1\":{\"1281\":1}}],[\"消息发送者将消息发送至分布式消息队列即结束对消息的处理\",{\"1\":{\"1222\":1}}],[\"消息发送者\",{\"1\":{\"1222\":1}}],[\"消息量都比较均匀的情况下\",{\"1\":{\"1281\":1}}],[\"消息量很大\",{\"1\":{\"1281\":1}}],[\"消息的获取\",{\"1\":{\"1292\":1,\"1293\":1}}],[\"消息的消费者称为\",{\"1\":{\"1279\":1}}],[\"消息的生产者称为\",{\"1\":{\"1279\":1}}],[\"消息的顺序性\",{\"0\":{\"1262\":1}}],[\"消息中间件的队列模型就真的只是一个队列\",{\"1\":{\"1278\":1}}],[\"消息中间件的服务节点\",{\"0\":{\"1251\":1}}],[\"消息队``列算是作为后端程序员的一个必备技能吧\",{\"1\":{\"1269\":1}}],[\"消息队列带来的一系列问题\",{\"1\":{\"1316\":1}}],[\"消息队列带来的异步确实可以提高系统响应速度\",{\"1\":{\"1224\":1}}],[\"消息队列出现的原因\",{\"1\":{\"1316\":1}}],[\"消息队列没收到积分系统的回应会不会尝试重发这个消息\",{\"1\":{\"1303\":1}}],[\"消息队列发送给订单系统\",{\"1\":{\"1303\":1}}],[\"消息队列发展历程\",{\"1\":{\"251\":1}}],[\"消息队列为什么要叫消息队列\",{\"1\":{\"1277\":1}}],[\"消息队列为什么会出现\",{\"0\":{\"1269\":1},\"1\":{\"1268\":1}}],[\"消息队列可以进行削峰操作\",{\"1\":{\"1275\":1}}],[\"消息队列也有它的副作用\",{\"1\":{\"1275\":1}}],[\"消息队列能带来什么好处\",{\"0\":{\"1274\":1}}],[\"消息队列能用来干什么\",{\"0\":{\"1270\":1},\"1\":{\"1268\":1}}],[\"消息队列会带来副作用吗\",{\"0\":{\"1275\":1},\"1\":{\"1268\":1}}],[\"消息队列顾名思义就是存放消息的队列\",{\"1\":{\"1268\":1}}],[\"消息队列扫盲\",{\"0\":{\"1268\":1}}],[\"消息队列的两种消息模型\",{\"1\":{\"1316\":1}}],[\"消息队列的作用\",{\"1\":{\"1316\":1}}],[\"消息队列的运转过程\",{\"1\":{\"1251\":1}}],[\"消息队列的使用场景是什么样的\",{\"1\":{\"1241\":1}}],[\"消息队列就是一个使用队列来通信的组件\",{\"1\":{\"1245\":1}}],[\"消息队列需要把消息存储起来\",{\"1\":{\"1232\":1}}],[\"消息队列是单向引入中间载体的网络通讯\",{\"1\":{\"1232\":1}}],[\"消息队列主要用来降低系统耦合性\",{\"1\":{\"1232\":1}}],[\"消息队列使用发布\",{\"1\":{\"1222\":1}}],[\"消息队列有什么用\",{\"0\":{\"1219\":1}}],[\"消息队列在系统设计中有了更大的发挥空间\",{\"1\":{\"1218\":1}}],[\"消息队列基础知识总结\",{\"0\":{\"1217\":1}}],[\"消息队列其实很简单\",{\"1\":{\"1192\":1}}],[\"消息队列\",{\"0\":{\"1250\":1},\"1\":{\"182\":1,\"249\":1,\"1190\":2,\"1235\":1,\"1249\":3,\"1250\":1,\"1262\":4,\"1271\":1},\"2\":{\"1187\":1,\"1216\":1,\"1243\":1,\"1266\":1,\"1318\":1}}],[\"消息需要同步到所有机器上\",{\"1\":{\"1263\":1}}],[\"消息需要通过多个传播的轮次才能传播到整个网络中\",{\"1\":{\"1090\":1}}],[\"消息补偿机制\",{\"1\":{\"1261\":1}}],[\"消息到\",{\"1\":{\"1261\":1}}],[\"消息怎么传输\",{\"0\":{\"1260\":1}}],[\"消息被消费者获取\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消息被发送到服务端\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消息被发送以后\",{\"1\":{\"1257\":1}}],[\"消息被生产者构建并完成初始化\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"消息被拒\",{\"1\":{\"1256\":1}}],[\"消息生产者\",{\"1\":{\"1254\":1}}],[\"消息代理服务器中用于把消息路由到队列的组件\",{\"1\":{\"1253\":1}}],[\"消息只会路由到\",{\"1\":{\"1252\":1}}],[\"消息一般包含两个部分\",{\"1\":{\"1254\":1}}],[\"消息一般由\",{\"1\":{\"1248\":1}}],[\"消息一直在队列里面\",{\"1\":{\"1250\":1}}],[\"消息会被路由到对应的队列中\",{\"1\":{\"1249\":1}}],[\"消息会被发送到对应的死信队列中\",{\"1\":{\"1213\":1}}],[\"消息并不是直接被投递到\",{\"1\":{\"1249\":1}}],[\"消息类型\",{\"1\":{\"1231\":1}}],[\"消息服务更加可靠以及异步性\",{\"1\":{\"1226\":1}}],[\"消息服务\",{\"1\":{\"1226\":2}}],[\"消息对象\",{\"1\":{\"1222\":1}}],[\"消息对比\",{\"1\":{\"1152\":1}}],[\"消息接受者对消息进行过滤\",{\"1\":{\"1222\":1}}],[\"消息接受者从分布式消息队列获取该消息后进行后续处理\",{\"1\":{\"1222\":1}}],[\"消息可靠性来说是一种不错的保障\",{\"1\":{\"1313\":1}}],[\"消息可以发送到死信队列中\",{\"1\":{\"1213\":1}}],[\"消息可能因为网络问题并没有发送过去\",{\"1\":{\"1204\":1}}],[\"消息将被视为消费失败\",{\"1\":{\"1210\":1}}],[\"消息投递失败\",{\"1\":{\"1210\":1}}],[\"消息实际上并没有被消费\",{\"1\":{\"1205\":1}}],[\"消息模型\",{\"0\":{\"1194\":1}}],[\"消息体是不透明的\",{\"1\":{\"1248\":1}}],[\"消息体也可以称为\",{\"1\":{\"1248\":1}}],[\"消息体长度\",{\"1\":{\"1159\":1}}],[\"消息体\",{\"1\":{\"1152\":1,\"1248\":1,\"1254\":1}}],[\"消息头压缩等功能\",{\"1\":{\"1170\":1}}],[\"消息头里写清楚一个完整的包长度是多少\",{\"1\":{\"1152\":1}}],[\"消息头\",{\"1\":{\"1152\":2,\"1159\":1,\"1248\":1}}],[\"消息边界长度标志\",{\"1\":{\"1152\":1}}],[\"消息边界\",{\"1\":{\"1152\":1,\"1161\":1}}],[\"消息\",{\"0\":{\"1283\":1},\"1\":{\"1085\":3,\"1236\":1,\"1256\":1,\"1304\":2}}],[\"消息持久化\",{\"1\":{\"251\":1}}],[\"消息堆积的问题\",{\"1\":{\"1275\":1}}],[\"消息堆积\",{\"1\":{\"251\":1,\"1316\":1}}],[\"消息丢失和重复消费\",{\"0\":{\"1201\":1}}],[\"消息丢失\",{\"1\":{\"251\":1,\"1240\":1}}],[\"消息也只能被消费一次\",{\"1\":{\"251\":1}}],[\"延时很低\",{\"1\":{\"1240\":2}}],[\"延时队列的小九九\",{\"1\":{\"612\":1}}],[\"延时队列\",{\"1\":{\"249\":1}}],[\"延伸面试问题\",{\"1\":{\"399\":1}}],[\"延迟阻塞队列\",{\"1\":{\"889\":1,\"892\":1,\"937\":1,\"938\":1,\"961\":1}}],[\"延迟的时间取决于具体实现的版本\",{\"1\":{\"844\":1,\"993\":1}}],[\"延迟队列指的是存储对应的延迟消息\",{\"1\":{\"1257\":1}}],[\"延迟队列\",{\"1\":{\"671\":1}}],[\"延迟队列的构造方法比较简单\",{\"1\":{\"602\":1}}],[\"延迟队列的任务只有到期之后才会执行\",{\"1\":{\"601\":1}}],[\"延迟队列要求元素按照到期时间进行升序排列\",{\"1\":{\"601\":1}}],[\"延迟队列底层存储数据的集合\",{\"1\":{\"601\":1}}],[\"延迟队列需要到期时间升序入队\",{\"1\":{\"599\":1}}],[\"延迟任务\",{\"1\":{\"599\":2}}],[\"延迟问题全面排障指南\",{\"1\":{\"320\":1}}],[\"延迟释放\",{\"1\":{\"289\":1,\"294\":1}}],[\"延迟写\",{\"1\":{\"230\":1}}],[\"延迟\",{\"1\":{\"49\":1}}],[\"核\",{\"1\":{\"246\":1}}],[\"核心概念的时候详细介绍到\",{\"1\":{\"1237\":1}}],[\"核心概念\",{\"0\":{\"1195\":1,\"1247\":1}}],[\"核心概念有哪些\",{\"0\":{\"1182\":1}}],[\"核心功能看作是下面\",{\"1\":{\"1166\":1}}],[\"核心系统提供系统所需核心能力\",{\"1\":{\"1132\":1}}],[\"核心系统\",{\"1\":{\"1132\":1}}],[\"核心还是\",{\"1\":{\"1097\":1}}],[\"核心方法\",{\"1\":{\"1036\":1}}],[\"核心池大小\",{\"1\":{\"928\":1}}],[\"核心在任意时刻只能被一个线程使用\",{\"1\":{\"895\":1,\"922\":1}}],[\"核心的个数\",{\"1\":{\"895\":1,\"922\":1}}],[\"核心线程外的线程不会立即销毁\",{\"1\":{\"936\":1}}],[\"核心线程数为\",{\"1\":{\"940\":1}}],[\"核心线程数线程数定义了最小可以同时运行的线程数量\",{\"1\":{\"896\":1,\"923\":1}}],[\"核心线程数和最大线程数都是\",{\"1\":{\"892\":1,\"938\":1}}],[\"核心线程数和最大线程数相等\",{\"1\":{\"892\":1,\"938\":1}}],[\"核心线程会超时并被销毁\",{\"1\":{\"888\":1}}],[\"核心数多出来的一个线程是为了防止线程偶发的缺页中断\",{\"1\":{\"895\":1,\"922\":1}}],[\"核心数\",{\"1\":{\"816\":1,\"895\":4,\"922\":4}}],[\"核心数据结构\",{\"1\":{\"742\":2}}],[\"核心被利用到\",{\"1\":{\"816\":1}}],[\"核心思想是异步调用\",{\"1\":{\"773\":1,\"899\":1}}],[\"核心思想是\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"核心思想\",{\"0\":{\"742\":1}}],[\"核心成员变量\",{\"0\":{\"601\":1}}],[\"核心源码解读\",{\"0\":{\"553\":1}}],[\"核心技术\",{\"1\":{\"612\":1}}],[\"核心技术面试精讲\",{\"1\":{\"472\":1}}],[\"核心技术与实战\",{\"1\":{\"221\":1,\"1214\":1}}],[\"核心\",{\"1\":{\"407\":1,\"816\":1}}],[\"核心库提供的\",{\"1\":{\"359\":1}}],[\"核心原理与应用实践\",{\"1\":{\"213\":1}}],[\"核心都在于\",{\"1\":{\"47\":1}}],[\"核心架构\",{\"1\":{\"4\":1}}],[\"核心架构如下\",{\"1\":{\"4\":1}}],[\"复制自己的日志来处理日志的不一致\",{\"1\":{\"1112\":1}}],[\"复制和重新排序\",{\"1\":{\"1106\":1}}],[\"复制状态机架构\",{\"1\":{\"1106\":1}}],[\"复制数据等操作\",{\"1\":{\"619\":1}}],[\"复制数组\",{\"1\":{\"561\":1}}],[\"复制底层数组\",{\"1\":{\"588\":1}}],[\"复制性能会变得很差\",{\"1\":{\"397\":1}}],[\"复制\",{\"1\":{\"397\":1,\"399\":1,\"407\":1}}],[\"复制算法内存也是规整的\",{\"1\":{\"503\":1}}],[\"复制算法的多线程收集器\",{\"1\":{\"403\":1}}],[\"复制算法\",{\"0\":{\"397\":1},\"1\":{\"397\":1,\"401\":1,\"402\":1,\"403\":1,\"408\":1}}],[\"复杂的类型可序列化后发送\",{\"1\":{\"1231\":1}}],[\"复杂度上升\",{\"1\":{\"1275\":1}}],[\"复杂度\",{\"1\":{\"293\":1}}],[\"复杂业务场景\",{\"1\":{\"249\":1}}],[\"复用模型\",{\"1\":{\"245\":1}}],[\"复用的网络模型\",{\"1\":{\"245\":1}}],[\"复合操作的原子性呢\",{\"1\":{\"694\":1}}],[\"复合操作是指由多个基本操作\",{\"1\":{\"694\":1}}],[\"复合类型\",{\"1\":{\"163\":1,\"291\":1}}],[\"复合索引使用时遵循最左匹配原则\",{\"1\":{\"116\":1}}],[\"冷热混合存储版架构揭秘\",{\"1\":{\"244\":1}}],[\"名\",{\"1\":{\"1122\":1}}],[\"名称索引\",{\"1\":{\"332\":1}}],[\"名为\",{\"1\":{\"244\":1}}],[\"名字第一个字是张\",{\"1\":{\"117\":1}}],[\"名字空间\",{\"1\":{\"37\":2}}],[\"兼容\",{\"1\":{\"244\":1,\"1230\":1}}],[\"兼具可读性的同时\",{\"1\":{\"18\":1}}],[\"出去呀\",{\"1\":{\"1379\":1}}],[\"出来的rpc\",{\"1\":{\"1155\":1}}],[\"出来的对象就是强引用类型\",{\"1\":{\"1030\":1}}],[\"出来的\",{\"1\":{\"1011\":1}}],[\"出队\",{\"1\":{\"535\":1}}],[\"出口信息\",{\"1\":{\"494\":1}}],[\"出堆\",{\"1\":{\"455\":1}}],[\"出生并经过第一次\",{\"1\":{\"386\":1}}],[\"出现问题的时候我们势必需要重新选举\",{\"1\":{\"1380\":1}}],[\"出现非预期失败\",{\"1\":{\"1292\":1}}],[\"出现消息重复消费的原因\",{\"1\":{\"1207\":1}}],[\"出现的要早\",{\"1\":{\"1161\":1}}],[\"出现的原因主要是某个热点数据访问量暴增\",{\"1\":{\"296\":1}}],[\"出现内存泄漏\",{\"1\":{\"1030\":1}}],[\"出现这种问题的原因还是对于线程池认识不够\",{\"1\":{\"927\":1}}],[\"出现时给我们报个信\",{\"1\":{\"455\":1}}],[\"出现了锁资源不释放等等的问题\",{\"1\":{\"1305\":1}}],[\"出现了\",{\"1\":{\"375\":1}}],[\"出错之前执行的命令是无法被撤销的\",{\"1\":{\"283\":1}}],[\"出错之后的命令是不会被执行的\",{\"1\":{\"283\":1}}],[\"出自\",{\"1\":{\"243\":1}}],[\"出一条子线程来将文件重写\",{\"1\":{\"162\":1}}],[\"出一个子进程\",{\"1\":{\"158\":1,\"227\":1}}],[\"少数机器宕机\",{\"1\":{\"1240\":1}}],[\"少部分命令无法使用\",{\"1\":{\"242\":1}}],[\"少打了开头的字母\",{\"1\":{\"86\":1}}],[\"部署在了\",{\"1\":{\"1358\":1}}],[\"部署在两台不同的机器上\",{\"1\":{\"1165\":1}}],[\"部署\",{\"1\":{\"242\":1}}],[\"部分\",{\"1\":{\"1330\":1}}],[\"部分组成\",{\"1\":{\"1248\":1,\"1349\":1}}],[\"部分其他收集器原本需要停顿\",{\"1\":{\"407\":1}}],[\"部分收集\",{\"1\":{\"387\":1}}],[\"部分是压缩格式不再是\",{\"1\":{\"235\":1}}],[\"部分地方政府发放的消费券\",{\"1\":{\"19\":1}}],[\"部分可读\",{\"1\":{\"18\":1}}],[\"许多与会话相关的运行机制都是基于这个\",{\"1\":{\"1353\":1}}],[\"许多虚拟线程共享同一个操作系统线程\",{\"1\":{\"1052\":1}}],[\"许多高级编程语言都内置了链表的实现比如\",{\"1\":{\"180\":1}}],[\"许可\",{\"1\":{\"242\":1}}],[\"综上所述\",{\"1\":{\"1014\":1,\"1184\":1}}],[\"综上\",{\"1\":{\"236\":1,\"251\":1,\"292\":1,\"343\":1,\"679\":1,\"1172\":1,\"1357\":1}}],[\"恢复后需要重新消费\",{\"1\":{\"1306\":1}}],[\"恢复执行自己的任务\",{\"1\":{\"753\":1}}],[\"恢复大数据集的时候\",{\"1\":{\"236\":1}}],[\"恢复出来的这一行\",{\"1\":{\"89\":2}}],[\"速度越快\",{\"1\":{\"1184\":1}}],[\"速度相对较快\",{\"1\":{\"1090\":1}}],[\"速度很快\",{\"1\":{\"406\":1}}],[\"速度非常慢\",{\"1\":{\"236\":1}}],[\"速度非常快\",{\"1\":{\"236\":1}}],[\"速度更快\",{\"1\":{\"115\":1,\"236\":1}}],[\"灾难恢复\",{\"1\":{\"236\":1}}],[\"满足生产者与消费者模式\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"满足不同的业务需求\",{\"1\":{\"781\":1}}],[\"满足用户数据回档等需求\",{\"1\":{\"233\":1}}],[\"满足min\",{\"1\":{\"141\":1}}],[\"彻底解决内存和\",{\"1\":{\"233\":1}}],[\"企业版在最初也遇到了这个问题\",{\"1\":{\"233\":1}}],[\"变得更容易被理解以及工程实现\",{\"1\":{\"1097\":1,\"1099\":1}}],[\"变得太大时\",{\"1\":{\"233\":1,\"236\":1}}],[\"变成\",{\"1\":{\"752\":1}}],[\"变成了现在的\",{\"1\":{\"691\":1}}],[\"变成了显式初始化的\",{\"1\":{\"430\":1}}],[\"变为了正常状态\",{\"1\":{\"1380\":1}}],[\"变为\",{\"1\":{\"708\":1,\"1380\":2}}],[\"变量的读操作\",{\"1\":{\"975\":1}}],[\"变量的写操作的结果对于发生于其后的任何操作都是可见的\",{\"1\":{\"975\":1}}],[\"变量的写操作\",{\"1\":{\"975\":1}}],[\"变量的那段代码用到了\",{\"1\":{\"882\":1}}],[\"变量规则\",{\"1\":{\"975\":1}}],[\"变量才会被解锁\",{\"1\":{\"972\":1}}],[\"变量也会被重用\",{\"1\":{\"929\":1}}],[\"变量自增完之后\",{\"1\":{\"835\":1}}],[\"变量作为计数器\",{\"1\":{\"756\":1,\"911\":1}}],[\"变量由\",{\"1\":{\"742\":1,\"904\":1}}],[\"变量\",{\"1\":{\"521\":1,\"523\":1,\"742\":1,\"765\":1,\"883\":2}}],[\"变量在方法区中分配内存空间\",{\"1\":{\"429\":1}}],[\"变量在准备阶段的初始值就是\",{\"1\":{\"342\":1}}],[\"变量加上了\",{\"1\":{\"342\":1}}],[\"变化不频繁的情况\",{\"1\":{\"307\":1}}],[\"变化而来\",{\"1\":{\"231\":1}}],[\"变体的\",{\"1\":{\"1016\":1}}],[\"变体的虚拟双向队列\",{\"1\":{\"1004\":1}}],[\"变体队列中的节点\",{\"1\":{\"1005\":1}}],[\"变体\",{\"1\":{\"37\":2}}],[\"顾名思义仅仅窥探一下队列中的元素\",{\"1\":{\"605\":1}}],[\"顾名思义\",{\"1\":{\"231\":1,\"392\":1,\"779\":1,\"886\":1,\"933\":1}}],[\"选主\",{\"0\":{\"1387\":1},\"1\":{\"1387\":1}}],[\"选举等等\",{\"1\":{\"1381\":1}}],[\"选举方式之后我们再来了解一下\",{\"1\":{\"1380\":1}}],[\"选举可以分为两个不同的阶段\",{\"1\":{\"1380\":1}}],[\"选举算法\",{\"1\":{\"1380\":1}}],[\"选举的过半机制防止脑裂\",{\"0\":{\"1358\":1}}],[\"选举阶段\",{\"1\":{\"1356\":1}}],[\"选举过程\",{\"0\":{\"1356\":1},\"1\":{\"1355\":1,\"1356\":1}}],[\"选举过程中是无法提供服务的\",{\"1\":{\"1314\":1}}],[\"选举过程中的临时角色\",{\"1\":{\"1108\":1}}],[\"选举过程中或者半数以上的机器不可用的时候服务就是不可用的\",{\"1\":{\"1069\":1}}],[\"选举\",{\"1\":{\"1344\":1,\"1346\":1,\"1356\":1,\"1391\":1}}],[\"选举超时时间\",{\"1\":{\"1116\":1}}],[\"选举限制\",{\"0\":{\"1114\":1}}],[\"选举机制\",{\"1\":{\"318\":1}}],[\"选\",{\"0\":{\"1068\":1},\"1\":{\"1068\":1}}],[\"选择队列后会与\",{\"1\":{\"1301\":1}}],[\"选择队列时优先选择消息延时小的队列\",{\"1\":{\"1299\":1}}],[\"选择大奖\",{\"1\":{\"1178\":2}}],[\"选择使用\",{\"1\":{\"1159\":1}}],[\"选择性通知\",{\"1\":{\"544\":1,\"862\":1}}],[\"选择的\",{\"1\":{\"544\":1,\"862\":1}}],[\"选择以上两种方式中的哪一种\",{\"1\":{\"503\":1}}],[\"选择哪种分配方式由\",{\"1\":{\"503\":1}}],[\"选择\",{\"1\":{\"492\":1,\"811\":1,\"1068\":1}}],[\"选择正确的垃圾收集算法至关重要\",{\"1\":{\"482\":1}}],[\"选择让系统设计变得更加复杂的话\",{\"1\":{\"316\":1}}],[\"选择单线程模型\",{\"1\":{\"266\":1}}],[\"选项解释很类似\",{\"1\":{\"449\":1}}],[\"选项\",{\"1\":{\"231\":1}}],[\"选用\",{\"1\":{\"47\":1,\"668\":1}}],[\"仅支持\",{\"1\":{\"1231\":2}}],[\"仅支持非阻塞式获取和新增元素\",{\"1\":{\"543\":1}}],[\"仅是在路由机制上做了更详细的划分\",{\"1\":{\"1231\":1}}],[\"仅是被告知失败\",{\"1\":{\"841\":1,\"990\":1}}],[\"仅有\",{\"1\":{\"1112\":1}}],[\"仅区分事件发生的前后顺序\",{\"1\":{\"974\":1}}],[\"仅打印线程\",{\"1\":{\"807\":1}}],[\"仅获取线程和线程堆栈信息\",{\"1\":{\"807\":1}}],[\"仅限于单机模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"仅存在结点之间的关联关系\",{\"1\":{\"742\":1,\"904\":1}}],[\"仅存储对象\",{\"1\":{\"678\":1}}],[\"仅保留此列表中包含在指定集合中的元素\",{\"1\":{\"553\":1}}],[\"仅仅需要发送该提案的编号\",{\"1\":{\"1374\":1}}],[\"仅仅在头尾插入或者删除元素的时候时间复杂度近似\",{\"1\":{\"656\":1,\"724\":1}}],[\"仅仅起占位作用\",{\"1\":{\"507\":1}}],[\"仅仅通过给\",{\"1\":{\"272\":1}}],[\"仅仅是消费\",{\"1\":{\"1314\":1}}],[\"仅仅是追加命令到\",{\"1\":{\"236\":1}}],[\"仅仅是写到缓冲区\",{\"1\":{\"230\":1}}],[\"仅用于加速查询\",{\"1\":{\"104\":1}}],[\"向客户端发送事件通知\",{\"1\":{\"1385\":1}}],[\"向其他节点并发发送消息的平均响应时间\",{\"1\":{\"1116\":1}}],[\"向所有的节点广播该\",{\"1\":{\"1112\":1}}],[\"向后遍历过程中\",{\"1\":{\"1035\":1}}],[\"向后迭代\",{\"1\":{\"1035\":1}}],[\"向后查找\",{\"1\":{\"730\":1,\"1036\":1}}],[\"向前迭代\",{\"1\":{\"1035\":1}}],[\"向前迭代查找\",{\"1\":{\"1035\":1,\"1036\":1}}],[\"向前移一位的操作\",{\"1\":{\"552\":1,\"656\":1}}],[\"向\",{\"1\":{\"678\":1,\"1281\":1}}],[\"向列表中添加元素\",{\"1\":{\"593\":1}}],[\"向队列中添加元素\",{\"1\":{\"531\":3}}],[\"向硬盘做同步操作\",{\"1\":{\"230\":1}}],[\"向指定有序集合添加一个或多个元素\",{\"1\":{\"193\":1}}],[\"向指定集合添加一个或多个元素\",{\"1\":{\"189\":1,\"260\":1,\"286\":1}}],[\"策略来进行权限控制\",{\"1\":{\"1351\":1}}],[\"策略\",{\"1\":{\"230\":1,\"236\":1,\"289\":1,\"298\":2,\"1355\":2}}],[\"注解就好了\",{\"1\":{\"1275\":1}}],[\"注解本身仅仅是起到标记作用\",{\"1\":{\"523\":1}}],[\"注明\",{\"1\":{\"1027\":1,\"1033\":1}}],[\"注重独一无二的性质\",{\"1\":{\"640\":1}}],[\"注\",{\"1\":{\"639\":1,\"1012\":1}}],[\"注册\",{\"1\":{\"1199\":2,\"1385\":1}}],[\"注册中心等等\",{\"1\":{\"1391\":1}}],[\"注册中心就是用来解决这个问题的\",{\"1\":{\"1281\":1}}],[\"注册中心和监控中心都是可选的\",{\"1\":{\"1137\":1}}],[\"注册中心和监控中心都宕机的话\",{\"0\":{\"1137\":1}}],[\"注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机\",{\"1\":{\"1390\":1}}],[\"注册中心会立即推送事件通知消费者\",{\"1\":{\"1135\":1}}],[\"注册中心会做什么\",{\"0\":{\"1135\":1}}],[\"注册中心会返回服务提供者地址列表给消费者\",{\"1\":{\"1128\":1}}],[\"注册中心的作用了解么\",{\"0\":{\"1134\":1}}],[\"注册中心层\",{\"1\":{\"1130\":1}}],[\"注册中心不转发请求\",{\"1\":{\"1069\":1}}],[\"注册中心负责服务地址的注册与查找\",{\"1\":{\"1069\":1,\"1134\":1}}],[\"注册中心\",{\"1\":{\"1069\":1,\"1281\":2,\"1390\":1}}],[\"注册中心来做\",{\"1\":{\"72\":1}}],[\"注册到内核中并监听每个事件是否发生\",{\"1\":{\"265\":1}}],[\"注意是子节点的\",{\"1\":{\"1382\":1}}],[\"注意是并行性\",{\"1\":{\"753\":1}}],[\"注意锁可以升级不可降级\",{\"1\":{\"854\":1}}],[\"注意list必须是有序的\",{\"1\":{\"697\":1}}],[\"注意这里不是初始化阈值\",{\"1\":{\"621\":1}}],[\"注意这里的无界并不是指可以添加任务数量的元素\",{\"1\":{\"529\":1}}],[\"注意这个不等于数组的长度\",{\"1\":{\"619\":1}}],[\"注意=和==的区别\",{\"1\":{\"553\":1}}],[\"注意双向链表和双向循环链表的区别\",{\"1\":{\"552\":1,\"656\":1}}],[\"注意引用对象一定是在内存进行\",{\"1\":{\"429\":1}}],[\"注意\",{\"1\":{\"230\":1,\"270\":1,\"332\":1,\"356\":1,\"429\":1,\"430\":1,\"449\":1,\"451\":1,\"492\":1,\"557\":1,\"604\":1,\"742\":1,\"904\":1,\"922\":1,\"934\":1,\"1062\":1,\"1261\":1,\"1335\":1}}],[\"磁盘机器就宕机了\",{\"1\":{\"229\":1}}],[\"磁盘io操作次数更少\",{\"1\":{\"101\":1}}],[\"某提案后\",{\"1\":{\"1373\":1}}],[\"某种意义上的无界队列\",{\"1\":{\"798\":1}}],[\"某一线程在开始运行前等待\",{\"1\":{\"753\":1}}],[\"某些节点之间不连通了\",{\"1\":{\"1067\":1}}],[\"某些场景下\",{\"1\":{\"531\":1}}],[\"某些情况下用户请求要获取的响应内容可能会来自于多个业务服务\",{\"1\":{\"2\":1}}],[\"某个线程获取锁失败的后续流程是什么呢\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"某个黑客故意制造一些非法的\",{\"1\":{\"306\":1}}],[\"某个时间点\",{\"1\":{\"226\":1}}],[\"爱可生开源社区\",{\"1\":{\"219\":1}}],[\"爱奇艺\",{\"1\":{\"8\":1}}],[\"故消费端无法消费\",{\"1\":{\"1304\":1}}],[\"故直接将后继节点\",{\"1\":{\"710\":1}}],[\"故将后继节点设置为首节点\",{\"1\":{\"710\":1}}],[\"故将这两个线程存入等待队列中\",{\"1\":{\"604\":1}}],[\"故当前线程\",{\"1\":{\"604\":1}}],[\"故\",{\"1\":{\"604\":1,\"1315\":1}}],[\"故障处理外\",{\"1\":{\"377\":1}}],[\"故障分析\",{\"1\":{\"219\":1}}],[\"故不用执行删除缓存操作\",{\"1\":{\"145\":1}}],[\"附近的人\",{\"1\":{\"210\":1,\"211\":1}}],[\"附加信息\",{\"1\":{\"120\":1}}],[\"权益证明\",{\"1\":{\"1097\":1}}],[\"权衡的结果\",{\"1\":{\"1073\":1}}],[\"权重参数\",{\"1\":{\"210\":1}}],[\"权限控制\",{\"0\":{\"1351\":1}}],[\"权限校验\",{\"1\":{\"73\":1,\"90\":1}}],[\"权限认证\",{\"1\":{\"1\":1}}],[\"果不其然\",{\"1\":{\"210\":1}}],[\"简而言之就是\",{\"1\":{\"1068\":1}}],[\"简化异步编程\",{\"1\":{\"1055\":1}}],[\"简洁高效需多\",{\"1\":{\"713\":1}}],[\"简介\",{\"0\":{\"549\":1,\"583\":1,\"597\":1,\"616\":1,\"702\":1,\"724\":1,\"796\":1,\"1067\":1,\"1073\":1}}],[\"简称为\",{\"1\":{\"999\":1}}],[\"简称\",{\"1\":{\"209\":1,\"212\":1,\"585\":2,\"1213\":1}}],[\"简单使用\",{\"0\":{\"1332\":1}}],[\"简单模式\",{\"1\":{\"1259\":1}}],[\"简单介绍\",{\"1\":{\"1171\":1}}],[\"简单花几分钟时间看一下\",{\"1\":{\"1141\":1}}],[\"简单地说就是内核缓冲区和应用缓冲区共享\",{\"1\":{\"1310\":1}}],[\"简单地说\",{\"1\":{\"799\":1}}],[\"简单举一个例子\",{\"1\":{\"781\":1}}],[\"简单理解就是\",{\"1\":{\"773\":1,\"899\":1}}],[\"简单了解即可\",{\"1\":{\"864\":1,\"870\":1,\"974\":1}}],[\"简单了解阻塞队列的基于两个条件的交互流程之后\",{\"1\":{\"535\":1}}],[\"简单了解了阻塞队列的历史之后\",{\"1\":{\"531\":1}}],[\"简单总结一下\",{\"1\":{\"1210\":1}}],[\"简单总结一下我了解的使用线程池的时候应该注意的东西\",{\"1\":{\"916\":1}}],[\"简单总结一下程序运行中栈可能会出现两种错误\",{\"1\":{\"493\":1}}],[\"简单总结一下双亲委派模型的执行流程\",{\"1\":{\"357\":1}}],[\"简单点来说\",{\"1\":{\"451\":1}}],[\"简单的客户端\",{\"1\":{\"1238\":1}}],[\"简单的代码例子\",{\"0\":{\"425\":1}}],[\"简单的介绍一下强引用\",{\"1\":{\"380\":1}}],[\"简单回顾一下类加载过程\",{\"1\":{\"349\":1}}],[\"简单说两个解决方案\",{\"1\":{\"316\":1}}],[\"简单限流可以用到\",{\"1\":{\"178\":1,\"254\":1}}],[\"简单动态字符串\",{\"1\":{\"174\":1,\"176\":1,\"256\":1}}],[\"简单画了一张图帮助大家理解读的步骤\",{\"1\":{\"145\":1,\"146\":1}}],[\"简单画了一张图帮助大家理解写的步骤\",{\"1\":{\"145\":1,\"146\":1}}],[\"简单来说就是微内核架构\",{\"1\":{\"1132\":1}}],[\"简单来说就是一个主节点同时共享最新信息给其他所有节点\",{\"1\":{\"1083\":1}}],[\"简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行\",{\"1\":{\"969\":1,\"981\":1}}],[\"简单来说就是\",{\"1\":{\"281\":1,\"1122\":1}}],[\"简单来说\",{\"1\":{\"28\":1,\"41\":1,\"124\":1,\"291\":1,\"351\":1,\"1129\":1,\"1165\":1,\"1218\":1,\"1367\":1}}],[\"简单易用\",{\"1\":{\"10\":1,\"37\":1}}],[\"地位\",{\"1\":{\"1111\":1}}],[\"地理空间索引\",{\"1\":{\"209\":1,\"212\":1}}],[\"地理位置\",{\"0\":{\"208\":1},\"1\":{\"253\":1}}],[\"地址是相同的\",{\"1\":{\"1011\":1}}],[\"地址和端口等信息记录到该节点中去\",{\"1\":{\"1199\":1}}],[\"地址和端口\",{\"1\":{\"302\":1,\"1157\":1}}],[\"地址泄露\",{\"1\":{\"37\":1}}],[\"地址生成\",{\"1\":{\"37\":1}}],[\"地址表示方式\",{\"1\":{\"22\":1}}],[\"地址\",{\"1\":{\"4\":1,\"5\":1,\"6\":1,\"7\":1,\"8\":1,\"9\":1,\"28\":1,\"37\":2,\"49\":1,\"68\":1,\"373\":2,\"811\":1,\"1140\":1,\"1157\":1,\"1178\":1}}],[\"百万级\",{\"1\":{\"1240\":1}}],[\"百万\",{\"1\":{\"207\":1}}],[\"百度\",{\"0\":{\"40\":1}}],[\"百度的\",{\"1\":{\"38\":1}}],[\"算的是比较优秀的国产开源项目了\",{\"1\":{\"1168\":1}}],[\"算出对应的唯一计数\",{\"1\":{\"206\":1}}],[\"算法这些一致性框架的原理和实现\",{\"1\":{\"1391\":1}}],[\"算法等等\",{\"1\":{\"1369\":1}}],[\"算法那样\",{\"1\":{\"1359\":1}}],[\"算法应该可以说是\",{\"1\":{\"1359\":1}}],[\"算法保证在给定的一个任期最少要有一个\",{\"1\":{\"1109\":1}}],[\"算法将时间划分为任意长度的任期\",{\"1\":{\"1109\":1}}],[\"算法就是\",{\"1\":{\"1099\":1}}],[\"算法还具备容错性\",{\"1\":{\"1098\":1}}],[\"算法改进而来\",{\"1\":{\"1097\":1}}],[\"算法改进的\",{\"1\":{\"1097\":1}}],[\"算法和\",{\"1\":{\"1097\":1,\"1372\":1}}],[\"算法都是基于\",{\"1\":{\"1097\":2}}],[\"算法之外\",{\"1\":{\"1097\":1}}],[\"算法更易理解和实现的共识算法\",{\"1\":{\"1097\":1}}],[\"算法在国际上被公认的非常难以理解和实现\",{\"1\":{\"1097\":1}}],[\"算法主要包含\",{\"1\":{\"1097\":2}}],[\"算法真心简单\",{\"1\":{\"1096\":1}}],[\"算法刚好可以解决他们的部分需求\",{\"1\":{\"1096\":1}}],[\"算法是基于消息传递且具有高度容错特性的一致性算法\",{\"1\":{\"1372\":1}}],[\"算法是兰伯特在\",{\"1\":{\"1097\":1}}],[\"算法是第一个被证明完备的分布式系统共识算法\",{\"1\":{\"1097\":1}}],[\"算法是\",{\"1\":{\"1096\":1}}],[\"算法是根据老年代的特点提出的一种标记算法\",{\"1\":{\"398\":1}}],[\"算法详解\",{\"0\":{\"1095\":1,\"1103\":1},\"1\":{\"1361\":2}}],[\"算法来说\",{\"1\":{\"1090\":1}}],[\"算法后\",{\"1\":{\"1035\":1}}],[\"算法相对来说更多一些\",{\"1\":{\"839\":1,\"988\":1,\"995\":1}}],[\"算法实现\",{\"1\":{\"839\":1,\"988\":1,\"995\":1}}],[\"算法实现的收集器\",{\"1\":{\"407\":1}}],[\"算法实现的\",{\"1\":{\"406\":1,\"407\":1}}],[\"算法时\",{\"1\":{\"708\":1}}],[\"算法不同\",{\"1\":{\"407\":1}}],[\"算法会导致收集结束时会有大量空间碎片产生\",{\"1\":{\"406\":1}}],[\"算法一样\",{\"1\":{\"398\":1}}],[\"算法分为\",{\"1\":{\"396\":1}}],[\"算法计算得出的数字\",{\"1\":{\"234\":1}}],[\"算法转换成了一个整数\",{\"1\":{\"210\":1}}],[\"算法生成的\",{\"1\":{\"38\":1}}],[\"算法进行回收\",{\"1\":{\"443\":1}}],[\"算法进行垃圾收集\",{\"1\":{\"399\":1}}],[\"算法进行简单的改造比如加入业务\",{\"1\":{\"38\":1}}],[\"算法进行改造\",{\"1\":{\"38\":1}}],[\"算法进行了优化\",{\"1\":{\"38\":1}}],[\"算法的死循环问题\",{\"0\":{\"1375\":1},\"1\":{\"1375\":1}}],[\"算法的\",{\"1\":{\"1367\":1}}],[\"算法的仅能就单个值达成共识\",{\"1\":{\"1099\":1}}],[\"算法的定义做一个总结\",{\"1\":{\"1097\":1}}],[\"算法的那篇论文在当时并没有被成功发表\",{\"1\":{\"1096\":1}}],[\"算法的原理讲解以及\",{\"1\":{\"205\":1}}],[\"算法的思想是让客户端向\",{\"1\":{\"51\":1}}],[\"算法的优缺点\",{\"1\":{\"38\":1}}],[\"算法的开源实现比如美团\",{\"1\":{\"38\":1}}],[\"算法的话\",{\"1\":{\"38\":1}}],[\"算法\",{\"0\":{\"36\":1,\"841\":1,\"990\":1,\"1032\":1,\"1098\":1,\"1359\":1,\"1372\":1},\"1\":{\"51\":2,\"298\":2,\"399\":1,\"405\":1,\"838\":1,\"987\":1,\"1026\":1,\"1084\":1,\"1096\":3,\"1097\":3,\"1099\":1,\"1359\":1,\"1361\":1,\"1371\":1},\"2\":{\"1094\":1,\"1102\":1,\"1119\":1}}],[\"合适\",{\"1\":{\"1207\":1}}],[\"合适的才是最好\",{\"1\":{\"895\":1,\"922\":1}}],[\"合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击\",{\"1\":{\"1221\":1}}],[\"合理使用它们\",{\"1\":{\"19\":1}}],[\"合理组合多个异步任务\",{\"0\":{\"787\":1}}],[\"合并之后就没有必要额外的设置这么一个永久代的地方了\",{\"1\":{\"496\":1}}],[\"合并\",{\"1\":{\"496\":1}}],[\"合并到\",{\"1\":{\"206\":1}}],[\"稠密矩阵\",{\"1\":{\"205\":1}}],[\"稀疏矩阵\",{\"1\":{\"205\":1}}],[\"稀疏索引\",{\"0\":{\"107\":1}}],[\"特定的主题\",{\"1\":{\"1272\":1}}],[\"特点\",{\"0\":{\"1246\":1,\"1345\":1}}],[\"特指的是现在主流使用的\",{\"1\":{\"1159\":1}}],[\"特烦恼\",{\"1\":{\"1152\":2}}],[\"特别注意\",{\"1\":{\"392\":1}}],[\"特别适合用于存储对象\",{\"1\":{\"184\":1,\"195\":1}}],[\"特别适合微服务系统下的\",{\"1\":{\"8\":1}}],[\"特殊情况处理\",{\"0\":{\"1300\":1}}],[\"特殊情况\",{\"1\":{\"342\":1}}],[\"特性概览\",{\"0\":{\"1001\":1}}],[\"特性之外\",{\"1\":{\"774\":2,\"901\":1}}],[\"特性是\",{\"1\":{\"289\":1,\"294\":1}}],[\"特性\",{\"1\":{\"283\":1}}],[\"特有的\",{\"1\":{\"205\":1}}],[\"活跃数是通过\",{\"1\":{\"1142\":1}}],[\"活跃数\",{\"1\":{\"1142\":1}}],[\"活跃节点会周期性地联系其他节点向其发送新数据\",{\"1\":{\"1088\":1}}],[\"活跃的\",{\"1\":{\"941\":1}}],[\"活跃线程数\",{\"1\":{\"918\":1}}],[\"活跃用户情况\",{\"1\":{\"203\":1}}],[\"活动上\",{\"1\":{\"19\":1}}],[\"朋友圈的微信步数排行榜\",{\"1\":{\"194\":1,\"258\":1}}],[\"适应性自旋锁\",{\"1\":{\"847\":1,\"854\":1}}],[\"适用于以下场景\",{\"1\":{\"1292\":1,\"1293\":1}}],[\"适用于实际系统的共识算法通常具有以下特性\",{\"1\":{\"1106\":1}}],[\"适用于封装\",{\"1\":{\"702\":1}}],[\"适用于读多写少的场景\",{\"1\":{\"588\":1}}],[\"适用于频繁的查找工作\",{\"1\":{\"550\":1,\"650\":1}}],[\"适用于大部分场景\",{\"1\":{\"103\":1}}],[\"适用场合\",{\"1\":{\"503\":2}}],[\"适当通过\",{\"1\":{\"479\":1}}],[\"适合什么场景\",{\"0\":{\"866\":1,\"873\":1}}],[\"适合在对性能要求相对较高\",{\"1\":{\"794\":1}}],[\"适合老年代这种垃圾回收频率不是很高的场景\",{\"1\":{\"398\":1}}],[\"适合做数据的备份\",{\"1\":{\"236\":1}}],[\"适合允许重复中奖的场景\",{\"1\":{\"190\":1,\"260\":1}}],[\"适合不允许重复中奖的场景\",{\"1\":{\"190\":1,\"260\":1}}],[\"订票\",{\"1\":{\"1272\":1}}],[\"订阅关系\",{\"1\":{\"1297\":1}}],[\"订阅消息\",{\"1\":{\"1222\":1}}],[\"订阅\",{\"0\":{\"1229\":1},\"1\":{\"1218\":1,\"1229\":1,\"1231\":1,\"1272\":1,\"1344\":1,\"1346\":3}}],[\"订阅模型在功能层面上是可以兼容队列模型的\",{\"1\":{\"1194\":1}}],[\"订阅模型中\",{\"1\":{\"1194\":1}}],[\"订阅模型主要是为了解决队列模型存在的问题\",{\"1\":{\"1194\":1}}],[\"订阅模型\",{\"0\":{\"1194\":1},\"1\":{\"1194\":1}}],[\"订阅模式的\",{\"1\":{\"1222\":1}}],[\"订阅模式工作\",{\"1\":{\"1222\":2}}],[\"订阅模式\",{\"1\":{\"251\":1,\"1222\":2}}],[\"订阅者需要\",{\"1\":{\"1279\":1}}],[\"订阅者\",{\"1\":{\"1279\":1}}],[\"订阅者可以订阅一个或者多个\",{\"1\":{\"251\":1}}],[\"订阅者通过subscribe订阅它关心的\",{\"1\":{\"251\":1}}],[\"订阅号推荐\",{\"1\":{\"190\":1,\"259\":1}}],[\"订单数据写入消息队列\",{\"1\":{\"1220\":1}}],[\"订单\",{\"1\":{\"28\":1}}],[\"订单核销\",{\"1\":{\"18\":1}}],[\"订单号的设计通常都会适当携带一些允许公开的对使用场景有帮助的信息\",{\"1\":{\"18\":1}}],[\"订单号在实际的业务过程中作为一个订单的唯一标识码存在\",{\"1\":{\"18\":1}}],[\"订单号\",{\"0\":{\"18\":1}}],[\"订单系统是不是以为积分系统消息接收失败了\",{\"1\":{\"1370\":1}}],[\"订单系统\",{\"0\":{\"16\":1}}],[\"好好的通信为什么中间非要插一个消息队列呢\",{\"1\":{\"1271\":1}}],[\"好在\",{\"1\":{\"530\":1}}],[\"好了\",{\"1\":{\"418\":1}}],[\"好\",{\"1\":{\"417\":1}}],[\"好友推荐\",{\"1\":{\"190\":1,\"259\":1}}],[\"好像效率更低了\",{\"1\":{\"108\":1}}],[\"统计服务的调用次数和调用时间的监控中心\",{\"1\":{\"1128\":1}}],[\"统计平台线程数\",{\"1\":{\"1062\":1}}],[\"统计创建的系统线程中部分为后台线程\",{\"1\":{\"1062\":1}}],[\"统计target在list中第一次出现的索引\",{\"1\":{\"697\":1}}],[\"统计元素出现次数\",{\"1\":{\"697\":1}}],[\"统计指定页面的\",{\"1\":{\"262\":1}}],[\"统计页面\",{\"0\":{\"262\":1},\"1\":{\"262\":1,\"294\":1}}],[\"统计活跃用户的话\",{\"1\":{\"261\":1}}],[\"统计活跃用户怎么做\",{\"0\":{\"261\":1}}],[\"统计活跃用户\",{\"1\":{\"249\":1}}],[\"统计被被设置为\",{\"1\":{\"202\":1}}],[\"统计\",{\"1\":{\"190\":1,\"207\":1,\"259\":1,\"261\":2}}],[\"求第\",{\"1\":{\"669\":1}}],[\"求你了\",{\"1\":{\"486\":1}}],[\"求差集\",{\"1\":{\"189\":1,\"193\":2}}],[\"求并集\",{\"1\":{\"189\":1,\"193\":2}}],[\"求交集\",{\"1\":{\"189\":1,\"193\":1}}],[\"模型的三大组件\",{\"1\":{\"1253\":1}}],[\"模型更像是一种交换机模型\",{\"1\":{\"1247\":1}}],[\"模型没有太大差别\",{\"1\":{\"1231\":1}}],[\"模型\",{\"0\":{\"1228\":1,\"1229\":1},\"1\":{\"1218\":1,\"1229\":1}}],[\"模拟出延迟队列的功能\",{\"1\":{\"1257\":1}}],[\"模拟业务处理\",{\"1\":{\"1062\":1}}],[\"模拟请求的耗时操作\",{\"1\":{\"749\":2}}],[\"模拟对象数据存储\",{\"1\":{\"185\":1}}],[\"模板设计模式通过钩子方法控制固定步骤的实现\",{\"1\":{\"744\":1}}],[\"模板方法模式很经典的一个应用\",{\"1\":{\"744\":1}}],[\"模板方法的细节中\",{\"1\":{\"533\":1}}],[\"模式下的读请求不会触发各个\",{\"1\":{\"1069\":1}}],[\"模式下的\",{\"1\":{\"1069\":1}}],[\"模式下的虚拟机的首要选择\",{\"1\":{\"402\":1}}],[\"模式下的虚拟机来说是个不错的选择\",{\"1\":{\"401\":1}}],[\"模式开发了自己的网络事件处理器\",{\"1\":{\"265\":1}}],[\"模式不愧是高性能\",{\"1\":{\"265\":1}}],[\"模式\",{\"1\":{\"265\":1,\"773\":1,\"899\":1,\"1005\":1,\"1069\":1,\"1132\":1,\"1200\":1,\"1235\":1,\"1344\":1,\"1354\":1}}],[\"模式的话\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"模式的\",{\"1\":{\"245\":1}}],[\"模式设计开发了一套高效的事件处理模型\",{\"1\":{\"243\":1,\"265\":1}}],[\"模块之前的通信\",{\"1\":{\"1218\":1}}],[\"模块\",{\"1\":{\"6\":1}}],[\"负责提出\",{\"1\":{\"1373\":1}}],[\"负责投票的发起和决议\",{\"1\":{\"1355\":1}}],[\"负责的是订单\",{\"1\":{\"1314\":1}}],[\"负责发起心跳\",{\"1\":{\"1108\":1}}],[\"负责对提议者的提案进行投票\",{\"1\":{\"1098\":1}}],[\"负责加载当前应用\",{\"1\":{\"353\":1}}],[\"负责加载\",{\"1\":{\"345\":1,\"1128\":1}}],[\"负担要比进程小得多\",{\"1\":{\"807\":1}}],[\"负数表示失败\",{\"1\":{\"744\":1,\"1007\":1}}],[\"负数为减\",{\"1\":{\"185\":1}}],[\"负载\",{\"1\":{\"1183\":1}}],[\"负载平衡通常涉及专用软件或硬件\",{\"1\":{\"1139\":1}}],[\"负载平衡旨在优化资源使用\",{\"1\":{\"1139\":1}}],[\"负载因子为\",{\"1\":{\"619\":1}}],[\"负载因子是控制数组存放数据的疏密程度\",{\"1\":{\"619\":1}}],[\"负载因子\",{\"1\":{\"570\":1,\"619\":3,\"621\":2}}],[\"负载均衡策略\",{\"1\":{\"1143\":1}}],[\"负载均衡就是为了避免单个服务器响应同一请求\",{\"1\":{\"1139\":1}}],[\"负载均衡改善了跨多个计算资源\",{\"1\":{\"1139\":1}}],[\"负载均衡以及服务监控的需求也迫在眉睫\",{\"1\":{\"1123\":1}}],[\"负载均衡等等\",{\"1\":{\"7\":1}}],[\"负载均衡\",{\"1\":{\"1\":1,\"2\":1,\"42\":1,\"75\":1,\"1123\":1,\"1197\":1,\"1199\":1,\"1245\":1,\"1281\":2,\"1344\":1,\"1346\":1}}],[\"正好要用来进行分布式环境的协调一一于是\",{\"1\":{\"1343\":1}}],[\"正式介绍\",{\"1\":{\"1343\":1}}],[\"正式发布\",{\"1\":{\"912\":1,\"1051\":1}}],[\"正因为这个没有任何边界的特点\",{\"1\":{\"1152\":1}}],[\"正是由于\",{\"1\":{\"1122\":1,\"1168\":1}}],[\"正是因为链表的特性\",{\"1\":{\"529\":1}}],[\"正是因为\",{\"1\":{\"490\":1,\"1132\":1}}],[\"正如\",{\"1\":{\"1084\":1}}],[\"正如我们上面给出的类关系图显示的一样\",{\"1\":{\"934\":1}}],[\"正确示例\",{\"1\":{\"1290\":1}}],[\"正确地传递数据的并发算法\",{\"1\":{\"1182\":1}}],[\"正确的slot位置应该是\",{\"1\":{\"1040\":1}}],[\"正确配置线程池参数\",{\"0\":{\"921\":1}}],[\"正确声明线程池\",{\"0\":{\"917\":1}}],[\"正确使用\",{\"1\":{\"787\":1}}],[\"正确使用索引\",{\"0\":{\"119\":1}}],[\"正确进行异常处理\",{\"0\":{\"786\":1}}],[\"正数表示成功\",{\"1\":{\"744\":1,\"1007\":1}}],[\"正数为加\",{\"1\":{\"185\":1}}],[\"正在排队中的任务数等等\",{\"1\":{\"918\":1}}],[\"正在等待执行一个优先级比当前元素还高的元素到期\",{\"1\":{\"604\":1}}],[\"正在进行初始化\",{\"1\":{\"576\":1}}],[\"正常情况下只有\",{\"1\":{\"1358\":1}}],[\"正常情况下\",{\"1\":{\"412\":1,\"835\":1,\"1076\":2}}],[\"正常处理命令请求造成影响\",{\"1\":{\"233\":1}}],[\"域\",{\"1\":{\"185\":1}}],[\"域名后面拼接新产生的数字类型\",{\"1\":{\"24\":1}}],[\"右\",{\"1\":{\"619\":1}}],[\"右移\",{\"1\":{\"558\":1}}],[\"右移一位相当于除\",{\"1\":{\"558\":1}}],[\"右移一位\",{\"1\":{\"553\":1,\"558\":1}}],[\"右边淡绿色背景的为服务提供方使用的接口\",{\"1\":{\"1130\":1}}],[\"右边\",{\"1\":{\"181\":1}}],[\"右子树的节点均大于根节点的值\",{\"1\":{\"97\":1}}],[\"队列和主题模式\",{\"1\":{\"1316\":1}}],[\"队列是以什么样的形式存在的\",{\"1\":{\"1312\":1,\"1315\":1}}],[\"队列是一个虚拟的双向队列\",{\"1\":{\"904\":1}}],[\"队列我就不解释了\",{\"1\":{\"1268\":1}}],[\"队列满了\",{\"1\":{\"1256\":1}}],[\"队列满时处理方式\",{\"1\":{\"539\":1}}],[\"队列可以在集群中的机器上设置镜像\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"队列模型和主题模型是什么\",{\"0\":{\"1277\":1}}],[\"队列模型就不好解决了\",{\"1\":{\"1193\":1}}],[\"队列模型存在的问题\",{\"1\":{\"1193\":1}}],[\"队列模型\",{\"0\":{\"1193\":1,\"1278\":1},\"1\":{\"1193\":1,\"1228\":1,\"1276\":1,\"1277\":1}}],[\"队列模型了解吗\",{\"0\":{\"1192\":1}}],[\"队列名字\",{\"1\":{\"1179\":1}}],[\"队列来完成资源获取的排队工作\",{\"1\":{\"1004\":1}}],[\"队列的关系\",{\"1\":{\"1281\":1}}],[\"队列的变体实现的\",{\"1\":{\"1004\":1}}],[\"队列的容量为\",{\"1\":{\"951\":1}}],[\"队列永远不会被放满\",{\"1\":{\"949\":1}}],[\"队列以及拒绝策略等\",{\"1\":{\"934\":1}}],[\"队列程度\",{\"1\":{\"928\":1}}],[\"队列进行线程的管理\",{\"1\":{\"874\":1}}],[\"队列为无界队列\",{\"1\":{\"799\":1}}],[\"队列为空时获取的元素为\",{\"1\":{\"541\":1}}],[\"队列为空则在规定时间内等待\",{\"1\":{\"537\":1}}],[\"队列为空\",{\"1\":{\"537\":1}}],[\"队列结构\",{\"1\":{\"742\":1}}],[\"队列结构如下图所示\",{\"1\":{\"742\":1,\"904\":1}}],[\"队列锁\",{\"1\":{\"904\":1}}],[\"队列锁中\",{\"1\":{\"742\":1}}],[\"队列锁的一个结点\",{\"1\":{\"742\":1}}],[\"队列首元素是否为空\",{\"1\":{\"604\":1}}],[\"队列空时处理方式\",{\"1\":{\"539\":1}}],[\"队列已满\",{\"1\":{\"537\":1}}],[\"队列已满直接返回false\",{\"1\":{\"536\":1}}],[\"队列长度减1\",{\"1\":{\"535\":1}}],[\"队列长度+1\",{\"1\":{\"535\":1}}],[\"队列就会通知生产者队列非满\",{\"1\":{\"530\":1}}],[\"队列就会通知消费者队列非空\",{\"1\":{\"530\":1}}],[\"队列中的消息又是如何进行存储持久化的呢\",{\"1\":{\"1312\":1,\"1315\":1}}],[\"队列中的对象进行二次标记\",{\"1\":{\"446\":1}}],[\"队列中了\",{\"1\":{\"752\":1}}],[\"队列中\",{\"1\":{\"446\":1,\"604\":1}}],[\"队列\",{\"0\":{\"1255\":1},\"1\":{\"180\":1,\"742\":2,\"1004\":1,\"1005\":1,\"1231\":1,\"1250\":1,\"1253\":2,\"1277\":2,\"1280\":1,\"1298\":1,\"1379\":1}}],[\"栈信息等\",{\"1\":{\"821\":1}}],[\"栈上分配\",{\"1\":{\"495\":1}}],[\"栈还可能会出现outofmemoryerror错误\",{\"1\":{\"493\":1}}],[\"栈帧内部结构\",{\"1\":{\"511\":1}}],[\"栈帧随着方法调用而创建\",{\"1\":{\"493\":1}}],[\"栈帧中的本地方法表\",{\"1\":{\"445\":1}}],[\"栈帧中的局部变量表\",{\"1\":{\"391\":1}}],[\"栈空间虽然不是无限的\",{\"1\":{\"493\":1}}],[\"栈由一个个栈帧组成\",{\"1\":{\"493\":1}}],[\"栈绝对算的上是\",{\"1\":{\"493\":1}}],[\"栈会先弹出\",{\"1\":{\"441\":1}}],[\"栈中的数据都是以栈帧的格式存在\",{\"1\":{\"441\":1}}],[\"栈的生命周期和所处的线程是一致的\",{\"1\":{\"440\":1}}],[\"栈的空间自然就会释放了\",{\"1\":{\"440\":1}}],[\"栈的操作\",{\"1\":{\"438\":1}}],[\"栈管运行\",{\"1\":{\"437\":1}}],[\"栈两大块进行\",{\"1\":{\"424\":1}}],[\"栈和本地方法栈和计数器都是独享区域\",{\"1\":{\"424\":1}}],[\"栈\",{\"0\":{\"422\":1},\"1\":{\"180\":1,\"422\":2}}],[\"线性往后查找\",{\"1\":{\"1035\":1}}],[\"线性数据结构\",{\"1\":{\"180\":1}}],[\"线上项目刚启动完使用\",{\"1\":{\"412\":1}}],[\"线上某个服务有接口非常慢\",{\"1\":{\"412\":1}}],[\"线上问题排查和性能调优也是面试常问的一个问题\",{\"1\":{\"412\":1}}],[\"线程睡眠\",{\"1\":{\"1062\":1}}],[\"线程所在节点的状态会变成取消状态\",{\"1\":{\"1016\":1}}],[\"线程获取锁的时候\",{\"1\":{\"1011\":1}}],[\"线程加入等待队列\",{\"0\":{\"1009\":1}}],[\"线程两种锁的模式\",{\"1\":{\"1005\":1}}],[\"线程继续等待\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"线程启动规则\",{\"1\":{\"975\":1}}],[\"线程启动失败\",{\"1\":{\"941\":1}}],[\"线程名字前缀\",{\"1\":{\"928\":1}}],[\"线程空闲时间\",{\"1\":{\"928\":1}}],[\"线程计算时间所占比例越高\",{\"1\":{\"895\":1,\"922\":1}}],[\"线程计算时间\",{\"1\":{\"895\":2,\"922\":2}}],[\"线程工厂\",{\"1\":{\"890\":1,\"894\":1,\"920\":1,\"936\":1}}],[\"线程持有读锁还能获取写锁吗\",{\"0\":{\"868\":1}}],[\"线程试图获取锁也就是获取\",{\"1\":{\"851\":1}}],[\"线程可以把变量保存\",{\"1\":{\"972\":1}}],[\"线程可以不停地执行\",{\"1\":{\"838\":1,\"987\":1}}],[\"线程可以比作是轻量级的进程\",{\"1\":{\"816\":1}}],[\"线程下的普通方法去执行\",{\"1\":{\"827\":1}}],[\"线程会自动苏醒\",{\"1\":{\"825\":1}}],[\"线程会从占用\",{\"1\":{\"821\":1}}],[\"线程不会自动苏醒\",{\"1\":{\"825\":1}}],[\"线程不安全则表示在多线程环境下\",{\"1\":{\"818\":1}}],[\"线程不安全等等\",{\"1\":{\"817\":1}}],[\"线程不安全\",{\"1\":{\"421\":1,\"550\":1,\"650\":1}}],[\"线程已获得的资源在未使用完之前不能被其他线程强行剥夺\",{\"1\":{\"823\":1}}],[\"线程死锁示意图\",{\"1\":{\"823\":1}}],[\"线程死锁描述的是这样一种情况\",{\"1\":{\"823\":1}}],[\"线程切换意味着需要保存当前线程的上下文\",{\"1\":{\"821\":1}}],[\"线程切换的如此之快\",{\"1\":{\"820\":1}}],[\"线程的变量副本\",{\"1\":{\"1026\":1}}],[\"线程的几种状态你真的了解么\",{\"1\":{\"820\":1}}],[\"线程的本质其实就是操作系统的线程\",{\"1\":{\"808\":1}}],[\"线程将会返回到\",{\"1\":{\"820\":1}}],[\"线程将继承其父线程的上下文类加载器\",{\"1\":{\"359\":1}}],[\"线程进入了新建状态\",{\"1\":{\"827\":1}}],[\"线程进入\",{\"1\":{\"820\":1}}],[\"线程运行怎么有第六种状态\",{\"1\":{\"820\":1}}],[\"线程有\",{\"1\":{\"820\":1}}],[\"线程这时候处于\",{\"1\":{\"820\":1}}],[\"线程创建之后它将处于\",{\"1\":{\"820\":1}}],[\"线程状态变迁图\",{\"1\":{\"820\":2}}],[\"线程在等待资源的过程中被唤醒\",{\"1\":{\"1015\":1}}],[\"线程在执行过程中会有自己的运行条件和状态\",{\"1\":{\"821\":1}}],[\"线程在执行完了\",{\"1\":{\"820\":1}}],[\"线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换\",{\"1\":{\"820\":1}}],[\"线程在运行的生命周期中的指定时刻只可能处于下面\",{\"1\":{\"820\":1}}],[\"线程被阻塞\",{\"1\":{\"821\":1}}],[\"线程被调用了\",{\"1\":{\"820\":1}}],[\"线程被创建出来但没有被调用\",{\"1\":{\"820\":1}}],[\"线程被加入到等待队列也就是\",{\"1\":{\"752\":1}}],[\"线程间的切换和调度的成本远远小于进程\",{\"1\":{\"816\":1}}],[\"线程对应一个系统内核线程\",{\"1\":{\"808\":1}}],[\"线程对象可以注册在指定的condition中\",{\"1\":{\"544\":1,\"862\":1}}],[\"线程采用的是一对一的线程模型\",{\"1\":{\"808\":1,\"1053\":1}}],[\"线程改为基于原生线程\",{\"1\":{\"808\":1}}],[\"线程是稀缺资源\",{\"1\":{\"887\":1,\"933\":1}}],[\"线程是进程划分成的更小的运行单位\",{\"1\":{\"810\":1}}],[\"线程是基于绿色线程\",{\"1\":{\"808\":1}}],[\"线程是否安全\",{\"1\":{\"677\":1}}],[\"线程和进程最大的不同在于基本上各进程是独立的\",{\"1\":{\"810\":1}}],[\"线程和操作系统线程的关系\",{\"1\":{\"808\":1}}],[\"线程和操作系统的线程有啥区别\",{\"0\":{\"808\":1}}],[\"线程和多个其他线程同时运行\",{\"1\":{\"807\":1}}],[\"线程管理\",{\"1\":{\"807\":1}}],[\"线程也被称为轻量级进程\",{\"1\":{\"807\":1}}],[\"线程与进程相似\",{\"1\":{\"807\":1}}],[\"线程池异步调用\",{\"0\":{\"1047\":1}}],[\"线程池就会去拿新的任务执行\",{\"1\":{\"941\":1}}],[\"线程池就是管理一系列线程的资源池\",{\"1\":{\"886\":1,\"933\":1}}],[\"线程池大小变为\",{\"1\":{\"941\":1}}],[\"线程池处于\",{\"1\":{\"941\":1}}],[\"线程池处理任务的流程了解吗\",{\"0\":{\"893\":1}}],[\"线程池首先会先执行\",{\"1\":{\"941\":1}}],[\"线程池原理分析\",{\"0\":{\"939\":1,\"941\":1}}],[\"线程池创建两种方式\",{\"0\":{\"937\":1}}],[\"线程池实现类\",{\"1\":{\"935\":1}}],[\"线程池实现原理及其在美团业务中的实践\",{\"1\":{\"896\":1,\"923\":1}}],[\"线程池一般用于执行多个不相关联的耗时任务\",{\"1\":{\"933\":1}}],[\"线程池介绍\",{\"0\":{\"933\":1}}],[\"线程池改进完善得到的自定义线程池\",{\"1\":{\"929\":1}}],[\"线程池和\",{\"0\":{\"929\":1},\"1\":{\"929\":1}}],[\"线程池是可以复用的\",{\"1\":{\"927\":1}}],[\"线程池使用的一些小坑\",{\"0\":{\"926\":1}}],[\"线程池使用不当导致死锁\",{\"1\":{\"919\":1}}],[\"线程池本身的目的是为了提高任务执行效率\",{\"1\":{\"925\":1}}],[\"线程池尽量不要放耗时任务\",{\"0\":{\"925\":1}}],[\"线程池未能在5分钟内完全关闭\",{\"1\":{\"924\":1}}],[\"线程池会返回一个\",{\"1\":{\"944\":1}}],[\"线程池会终止当前正在运行的任务\",{\"1\":{\"924\":1,\"945\":1}}],[\"线程池会首先判断当前工作线程数是否大于corepoolsize\",{\"1\":{\"896\":1,\"923\":1}}],[\"线程池不再接受新任务了\",{\"1\":{\"924\":1,\"945\":1}}],[\"线程池提供了两个关闭方法\",{\"1\":{\"924\":1}}],[\"线程池提供了一种限制和管理资源\",{\"1\":{\"887\":1}}],[\"线程池运用不当的一次线上事故\",{\"1\":{\"919\":1}}],[\"线程池对象\",{\"1\":{\"918\":1}}],[\"线程池必须手动通过\",{\"1\":{\"917\":1}}],[\"线程池最佳实践这篇文章总结了一些使用线程池的时候应该注意的东西\",{\"1\":{\"963\":1}}],[\"线程池最佳实践\",{\"0\":{\"916\":1,\"963\":1}}],[\"线程池详解\",{\"0\":{\"932\":1},\"1\":{\"896\":1}}],[\"线程池常用的阻塞队列总结\",{\"0\":{\"938\":1}}],[\"线程池常用的阻塞队列有哪些\",{\"0\":{\"892\":1}}],[\"线程池常见参数有哪些\",{\"0\":{\"890\":1}}],[\"线程池各个参数的关系\",{\"1\":{\"890\":1,\"936\":1}}],[\"线程池回收线程时\",{\"1\":{\"890\":1}}],[\"线程池中的线程执行完\",{\"1\":{\"950\":1}}],[\"线程池中的线程数量大于\",{\"1\":{\"890\":1,\"936\":1}}],[\"线程池中若有空闲线程\",{\"1\":{\"888\":1,\"937\":1}}],[\"线程池的线程数量不确定\",{\"1\":{\"937\":1}}],[\"线程池的状态变为\",{\"1\":{\"924\":2,\"945\":2}}],[\"线程池的饱和策略有哪些\",{\"0\":{\"891\":1}}],[\"线程池的最大线程数\",{\"1\":{\"890\":1,\"936\":1}}],[\"线程池的核心线程数量\",{\"1\":{\"890\":1,\"936\":1}}],[\"线程池\",{\"0\":{\"885\":1},\"1\":{\"779\":1,\"887\":1,\"932\":1,\"941\":1,\"961\":1}}],[\"线程才得以通过执行\",{\"1\":{\"756\":1,\"911\":1}}],[\"线程尝试释放许可证\",{\"1\":{\"748\":1,\"906\":1}}],[\"线程尝试获取许可证\",{\"1\":{\"748\":1,\"906\":1}}],[\"线程自己是可以重复获取此锁的\",{\"1\":{\"742\":1,\"904\":1}}],[\"线程等待队列\",{\"1\":{\"904\":1}}],[\"线程等待时间所占比例越高\",{\"1\":{\"895\":1,\"922\":1}}],[\"线程等待时间\",{\"1\":{\"895\":2,\"922\":2}}],[\"线程等待\",{\"1\":{\"742\":1}}],[\"线程为空\",{\"1\":{\"604\":1}}],[\"线程时提到的等待唤醒操作的交互就是通过\",{\"1\":{\"601\":1}}],[\"线程执行完当前的任务后\",{\"1\":{\"954\":1}}],[\"线程执行完手头的延迟任务后唤醒它\",{\"1\":{\"601\":1}}],[\"线程执行开销小\",{\"1\":{\"810\":1}}],[\"线程执行\",{\"1\":{\"807\":1}}],[\"线程执行的\",{\"1\":{\"407\":1}}],[\"线程安全指的是在多线程环境下\",{\"1\":{\"818\":1}}],[\"线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述\",{\"1\":{\"818\":1}}],[\"线程安全原理简单分析\",{\"0\":{\"765\":1}}],[\"线程安全实现方式\",{\"1\":{\"692\":1}}],[\"线程安全的\",{\"1\":{\"698\":4,\"791\":2}}],[\"线程安全的具体实现方式\",{\"0\":{\"689\":1}}],[\"线程安全的核心在于其采用了\",{\"1\":{\"584\":1,\"588\":1,\"793\":1}}],[\"线程安全\",{\"1\":{\"550\":1,\"650\":1,\"834\":1}}],[\"线程阻塞\",{\"1\":{\"539\":2}}],[\"线程私有\",{\"1\":{\"492\":1}}],[\"线程私有的\",{\"1\":{\"491\":1}}],[\"线程恢复等功能都需要依赖这个计数器来完成\",{\"1\":{\"492\":1}}],[\"线程共享的\",{\"1\":{\"491\":1}}],[\"线程共享区域\",{\"1\":{\"421\":1}}],[\"线程独享\",{\"1\":{\"423\":1}}],[\"线程开始对未标记的区域做清扫\",{\"1\":{\"406\":1}}],[\"线程无法保证可达性分析的实时性\",{\"1\":{\"406\":1}}],[\"线程监控\",{\"0\":{\"376\":1},\"1\":{\"376\":1}}],[\"线程出现停顿的时候通过jstack来查看各个线程的调用堆栈\",{\"1\":{\"370\":1}}],[\"线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合\",{\"1\":{\"364\":1,\"370\":1}}],[\"线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里\",{\"1\":{\"359\":1}}],[\"线程上下文类加载器\",{\"1\":{\"359\":1}}],[\"线程上下文切换等问题\",{\"1\":{\"266\":1}}],[\"线程数1000\",{\"1\":{\"1062\":2}}],[\"线程数500\",{\"1\":{\"1062\":2}}],[\"线程数2000\",{\"1\":{\"1062\":2}}],[\"线程数200\",{\"1\":{\"1062\":2}}],[\"线程数可以设置为\",{\"1\":{\"895\":1,\"922\":1}}],[\"线程数更严谨的计算的方法应该是\",{\"1\":{\"895\":1,\"922\":1}}],[\"线程数量过多的影响也是和我们分配多少人做事情一样\",{\"1\":{\"895\":1,\"922\":1}}],[\"线程数\",{\"1\":{\"267\":1}}],[\"线程模型是用户线程和内核线程之间的关联方式\",{\"1\":{\"808\":1}}],[\"线程模型\",{\"0\":{\"264\":1}}],[\"线程模式后面会详细介绍到\",{\"1\":{\"243\":1}}],[\"线程\",{\"1\":{\"60\":5,\"161\":3,\"231\":2,\"370\":14,\"377\":1,\"445\":1,\"589\":3,\"604\":2,\"686\":6,\"694\":10,\"742\":1,\"807\":2,\"808\":2,\"823\":10,\"824\":9,\"834\":1,\"835\":4,\"841\":1,\"904\":2,\"972\":5,\"990\":1,\"1011\":2,\"1062\":1}}],[\"利用这个特性\",{\"1\":{\"1387\":1}}],[\"利用好多线程机制可以大大提高系统整体的并发能力以及性能\",{\"1\":{\"816\":1}}],[\"利用了二叉堆的数据结构来实现的\",{\"1\":{\"669\":1}}],[\"利用\",{\"1\":{\"178\":1,\"249\":1,\"254\":1,\"577\":1,\"835\":1,\"894\":1,\"920\":1,\"1019\":1,\"1387\":1}}],[\"利用数据页\",{\"1\":{\"94\":1}}],[\"计数为\",{\"1\":{\"1019\":1}}],[\"计数比如用户单位时间的请求数\",{\"1\":{\"254\":1}}],[\"计数达到某个阈值的时候\",{\"1\":{\"205\":1}}],[\"计数较少的时候\",{\"1\":{\"205\":1}}],[\"计数器变为\",{\"1\":{\"753\":1}}],[\"计数器的值只能在构造方法中初始化一次\",{\"1\":{\"751\":1,\"907\":1}}],[\"计数器等于\",{\"1\":{\"445\":1}}],[\"计数器就减\",{\"1\":{\"390\":1}}],[\"计数器就加\",{\"1\":{\"390\":1}}],[\"计数器\",{\"1\":{\"177\":1,\"386\":1,\"756\":1,\"911\":1}}],[\"计算框架\",{\"1\":{\"1238\":1}}],[\"计算该数据位置是否偏移\",{\"1\":{\"1037\":1}}],[\"计算后应该落到index=4的桶中\",{\"1\":{\"1037\":1}}],[\"计算后应该落入槽位\",{\"1\":{\"1033\":1}}],[\"计算机学科中还有一个相似的概念\",{\"1\":{\"1367\":1}}],[\"计算机集群\",{\"1\":{\"1139\":1}}],[\"计算机在执行程序代码的时候\",{\"1\":{\"969\":1,\"981\":1}}],[\"计算机基于这些规则生成的\",{\"1\":{\"37\":1}}],[\"计算得出的结果\",{\"1\":{\"943\":1}}],[\"计算得到\",{\"1\":{\"573\":2}}],[\"计算结果\",{\"1\":{\"943\":1}}],[\"计算耗费时间相比于等待\",{\"1\":{\"895\":1,\"922\":1}}],[\"计算能力的任务比如你在内存中对大量数据进行排序\",{\"1\":{\"895\":1,\"922\":1}}],[\"计算是否到期\",{\"1\":{\"597\":1}}],[\"计算出索引的全局位置\",{\"1\":{\"1315\":1}}],[\"计算出\",{\"1\":{\"577\":1}}],[\"计算新的位置\",{\"1\":{\"572\":1}}],[\"计算\",{\"1\":{\"571\":1,\"678\":1}}],[\"计算要put的数据位置\",{\"1\":{\"571\":1}}],[\"计算要\",{\"1\":{\"571\":1}}],[\"计算扩容阀值\",{\"1\":{\"571\":1}}],[\"计算过程中产生的临时变量也会放在操作数栈中\",{\"1\":{\"493\":1}}],[\"计算的时候会把最后一行保存校验和的内容给忽略点\",{\"1\":{\"234\":1}}],[\"计算多个\",{\"1\":{\"157\":1,\"301\":1}}],[\"请先将下面的依赖添加进你的项目\",{\"1\":{\"1332\":1}}],[\"请停止呼叫数据库\",{\"1\":{\"1071\":1}}],[\"请继续往后看\",{\"1\":{\"1035\":1}}],[\"请大家点点关注+在看\",{\"1\":{\"1026\":1}}],[\"请简要描述线程与进程的关系\",{\"0\":{\"809\":1}}],[\"请你说一下自己对于\",{\"1\":{\"741\":1}}],[\"请看我写的这篇文章\",{\"1\":{\"792\":1,\"793\":1}}],[\"请看这篇文章\",{\"1\":{\"630\":1,\"1174\":1}}],[\"请看下面的例子\",{\"1\":{\"367\":1}}],[\"请注意\",{\"1\":{\"485\":1,\"1380\":1}}],[\"请参见此处\",{\"1\":{\"482\":1}}],[\"请查看\",{\"1\":{\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1}}],[\"请求后则会进行事务的提交工作\",{\"1\":{\"1371\":1}}],[\"请求就挂了\",{\"1\":{\"1370\":1}}],[\"请求来获取消息数据\",{\"1\":{\"1281\":1}}],[\"请求重发\",{\"1\":{\"1275\":1}}],[\"请求和响应\",{\"1\":{\"1167\":1}}],[\"请求数\",{\"1\":{\"1062\":2}}],[\"请求数据库写数据到缓存之前\",{\"1\":{\"310\":1}}],[\"请求无法处理的情况\",{\"1\":{\"895\":1,\"922\":1}}],[\"请求需要处理\",{\"1\":{\"895\":1,\"922\":1}}],[\"请求与保持条件\",{\"1\":{\"823\":1}}],[\"请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因\",{\"1\":{\"370\":1}}],[\"请求次数更少\",{\"1\":{\"287\":1}}],[\"请求获取数据\",{\"1\":{\"286\":1}}],[\"请求之前不在缓存中的话\",{\"1\":{\"145\":1}}],[\"请求消耗\",{\"1\":{\"42\":1}}],[\"请求向发号器服务申请唯一\",{\"1\":{\"42\":1}}],[\"请求代理或者分流到下一个实例处理\",{\"1\":{\"23\":1}}],[\"请求会一直携带\",{\"1\":{\"21\":1}}],[\"请求要调用的多个服务\",{\"1\":{\"21\":1}}],[\"请求从网关流入\",{\"1\":{\"21\":1}}],[\"请求的提案\",{\"1\":{\"1380\":1}}],[\"请求的时候会执行前面执行的事务的\",{\"1\":{\"1370\":1}}],[\"请求的数量\",{\"1\":{\"749\":1,\"753\":1,\"757\":2}}],[\"请求的\",{\"1\":{\"17\":1,\"309\":1,\"311\":2}}],[\"请求响应循环的生命周期中被执行\",{\"1\":{\"7\":1}}],[\"请求\",{\"1\":{\"7\":1,\"145\":9,\"1111\":1,\"1370\":4,\"1371\":2,\"1380\":1}}],[\"请求声明周期\",{\"1\":{\"4\":1}}],[\"请求过滤\",{\"1\":{\"1\":1,\"69\":1}}],[\"请求转发\",{\"1\":{\"1\":1,\"2\":1}}],[\"序列化方式等等方面\",{\"1\":{\"1165\":1}}],[\"序列化和反序列化\",{\"1\":{\"1159\":1}}],[\"序列化\",{\"1\":{\"1159\":2,\"1166\":2}}],[\"序列化由于性能问题\",{\"1\":{\"1147\":1}}],[\"序列化协议开发\",{\"1\":{\"1170\":1}}],[\"序列化协议的性能对比\",{\"1\":{\"1147\":1}}],[\"序列化协议\",{\"0\":{\"1145\":1}}],[\"序列化后的对象\",{\"1\":{\"176\":1,\"178\":1,\"195\":1,\"254\":2}}],[\"序列为安全序列\",{\"1\":{\"824\":1}}],[\"序列号\",{\"1\":{\"619\":1}}],[\"序列号为自增值\",{\"1\":{\"38\":1}}],[\"新创建一个线程并执行\",{\"1\":{\"941\":1}}],[\"新手也能看懂的线程池学习总结\",{\"1\":{\"923\":1}}],[\"新任务将在无界队列中等待\",{\"1\":{\"951\":1}}],[\"新任务就会被存放在队列中\",{\"1\":{\"890\":1,\"892\":1,\"896\":1,\"923\":1,\"936\":1,\"938\":1}}],[\"新任务来的时候会先判断当前运行的线程数量是否达到核心线程数\",{\"1\":{\"890\":1,\"892\":1,\"936\":1,\"938\":1}}],[\"新建一个线程\",{\"1\":{\"941\":2}}],[\"新建一个运行时类型的数组\",{\"1\":{\"553\":1}}],[\"新建线程将会使当前运行的线程超出最大线程数\",{\"1\":{\"893\":1,\"941\":1}}],[\"新建\",{\"1\":{\"820\":1}}],[\"新生成结点放入桶中\",{\"1\":{\"622\":1,\"686\":1}}],[\"新生代+老年代+永久代\",{\"1\":{\"499\":1}}],[\"新生代和老年代\",{\"1\":{\"495\":1}}],[\"新生代占整个堆栈的\",{\"1\":{\"479\":1}}],[\"新生代分配\",{\"1\":{\"479\":2}}],[\"新生代采用\",{\"1\":{\"449\":1}}],[\"新生代采用标记\",{\"1\":{\"401\":1,\"402\":1,\"403\":1}}],[\"新生代收集\",{\"1\":{\"387\":1}}],[\"新生代也会使用\",{\"1\":{\"384\":1}}],[\"新生代内存\",{\"1\":{\"382\":1,\"479\":1,\"495\":1}}],[\"新生代\",{\"1\":{\"375\":1,\"400\":1,\"448\":1,\"452\":1}}],[\"新数组长度为旧数组长度\",{\"1\":{\"591\":1}}],[\"新元素\",{\"1\":{\"571\":1}}],[\"新容量\",{\"1\":{\"572\":1}}],[\"新容量没有大于数组最大\",{\"1\":{\"558\":1}}],[\"新容量大小则为\",{\"1\":{\"553\":1,\"558\":1,\"559\":1}}],[\"新一代垃圾回收器\",{\"1\":{\"408\":1}}],[\"新加入的默认方法\",{\"1\":{\"344\":1}}],[\"新写入操作会报错\",{\"1\":{\"273\":1}}],[\"新特性概览\",{\"1\":{\"808\":1}}],[\"新特性总结\",{\"1\":{\"630\":1}}],[\"新特性的话\",{\"1\":{\"630\":1}}],[\"新特性\",{\"1\":{\"267\":1}}],[\"新的零售金融交易平台\",{\"1\":{\"1178\":1}}],[\"新的位置只可能是不便或者是老的位置+老的容量\",{\"1\":{\"572\":2}}],[\"新的掩码\",{\"1\":{\"572\":1}}],[\"新的扩容阀值\",{\"1\":{\"572\":1}}],[\"新的\",{\"1\":{\"236\":1,\"1379\":1}}],[\"新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致\",{\"1\":{\"1090\":1}}],[\"新增加的一个数据结构\",{\"1\":{\"182\":1,\"251\":1}}],[\"新增或者更新数据\",{\"1\":{\"1035\":1}}],[\"新增元素\",{\"1\":{\"539\":1}}],[\"新增了\",{\"1\":{\"283\":1}}],[\"新增\",{\"1\":{\"224\":1,\"282\":1}}],[\"新增100条数据\",{\"1\":{\"129\":1}}],[\"新版本的发布\",{\"1\":{\"174\":1}}],[\"未清理到任何数据\",{\"1\":{\"1036\":1,\"1038\":1}}],[\"未执行\",{\"1\":{\"951\":1}}],[\"未初始化\",{\"1\":{\"621\":1}}],[\"未被消费的消息在队列中保留直到被消费或超时\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"未被\",{\"1\":{\"344\":1}}],[\"未及时清理垃圾数据\",{\"1\":{\"292\":1}}],[\"未来随着\",{\"1\":{\"174\":1}}],[\"未提交的事务id数组为\",{\"1\":{\"141\":1}}],[\"未提交事务的原子性\",{\"1\":{\"138\":1}}],[\"未提交变更对其他事务也是不可见的\",{\"1\":{\"132\":1}}],[\"未提交\",{\"1\":{\"127\":1}}],[\"底层其实只提供了两个功能\",{\"1\":{\"1362\":1}}],[\"底层连接形式\",{\"0\":{\"1158\":1}}],[\"底层也是基于\",{\"1\":{\"865\":1}}],[\"底层做了哪些优化\",{\"0\":{\"854\":1}}],[\"底层原理在面试中遇到的概率非常小\",{\"1\":{\"874\":1}}],[\"底层原理分析\",{\"1\":{\"874\":1}}],[\"底层原理了解吗\",{\"0\":{\"850\":1}}],[\"底层原理和实战\",{\"1\":{\"545\":1}}],[\"底层依赖于一条\",{\"1\":{\"841\":1,\"990\":1}}],[\"底层具体实现\",{\"0\":{\"689\":1}}],[\"底层都用到了红黑树\",{\"1\":{\"683\":1}}],[\"底层采用数组来实现\",{\"1\":{\"797\":1}}],[\"底层采用数组实现\",{\"1\":{\"541\":1}}],[\"底层采用\",{\"1\":{\"643\":1,\"688\":1}}],[\"底层的节点类\",{\"1\":{\"708\":1}}],[\"底层的行为都是给\",{\"1\":{\"624\":1}}],[\"底层的数组\",{\"1\":{\"535\":1}}],[\"底层元素的存取都是通过这个优先队列\",{\"1\":{\"601\":1}}],[\"底层数组\",{\"1\":{\"589\":1}}],[\"底层数据结构不同又导致这三者的应用场景不同\",{\"1\":{\"665\":1}}],[\"底层数据结构是红黑树\",{\"1\":{\"665\":1}}],[\"底层数据结构是链表\",{\"1\":{\"655\":1,\"726\":1}}],[\"底层数据结构分析\",{\"0\":{\"617\":1}}],[\"底层数据结构\",{\"1\":{\"552\":1,\"656\":1,\"677\":1,\"688\":1}}],[\"底层使用可变长的数组来存储数据\",{\"1\":{\"669\":1}}],[\"底层使用的是\",{\"1\":{\"552\":2,\"656\":2}}],[\"底层使用object\",{\"1\":{\"550\":1,\"650\":1}}],[\"底层使用\",{\"1\":{\"550\":1,\"650\":1}}],[\"底层实现\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"底层实现是\",{\"1\":{\"174\":1}}],[\"底层会通过限制删除操作执行的时长和频率来减少删除操作对\",{\"1\":{\"272\":1}}],[\"底层是链表\",{\"1\":{\"658\":1}}],[\"底层是数组\",{\"1\":{\"658\":1}}],[\"底层是使用优先队列\",{\"1\":{\"607\":1}}],[\"底层是一个基于\",{\"1\":{\"597\":1}}],[\"底层是\",{\"1\":{\"210\":1,\"618\":1,\"682\":1}}],[\"底层就是基于\",{\"1\":{\"678\":1}}],[\"底层就是\",{\"1\":{\"210\":1}}],[\"底层基于单向链表实现的阻塞队列\",{\"1\":{\"798\":1}}],[\"底层基于\",{\"1\":{\"5\":1,\"68\":1,\"536\":2}}],[\"压力越大\",{\"1\":{\"1281\":1}}],[\"压力较小\",{\"1\":{\"1069\":1}}],[\"压缩\",{\"1\":{\"503\":1}}],[\"压缩列表\",{\"1\":{\"174\":1}}],[\"压测结果近\",{\"1\":{\"41\":1}}],[\"整形数组原子类\",{\"1\":{\"766\":1}}],[\"整形字面量\",{\"1\":{\"328\":1}}],[\"整型数组原子类\",{\"1\":{\"762\":1}}],[\"整型原子类\",{\"1\":{\"762\":1,\"763\":1}}],[\"整句运算式的结果就是将新容量更新为旧容量的1\",{\"1\":{\"553\":1,\"558\":1}}],[\"整体上是一个生产者与消费者模型\",{\"1\":{\"1247\":1}}],[\"整体步骤为\",{\"1\":{\"711\":1}}],[\"整体步骤如下\",{\"1\":{\"604\":1}}],[\"整体执行步骤为\",{\"1\":{\"535\":1}}],[\"整体设计\",{\"0\":{\"533\":1}}],[\"整理\",{\"1\":{\"398\":1,\"399\":1,\"405\":1,\"407\":1,\"503\":1}}],[\"整理算法\",{\"0\":{\"398\":1},\"1\":{\"398\":1,\"401\":1,\"402\":1,\"403\":1}}],[\"整堆收集\",{\"1\":{\"387\":1}}],[\"整数\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"整数集合\",{\"1\":{\"174\":1}}],[\"整个服务器就从\",{\"1\":{\"1380\":1}}],[\"整个调用链中\",{\"1\":{\"1370\":1}}],[\"整个消息存储的结构\",{\"1\":{\"1315\":1}}],[\"整个过程发生了\",{\"1\":{\"1308\":1}}],[\"整个过程会分为如下几步\",{\"1\":{\"1308\":1}}],[\"整个过程分为四个步骤\",{\"1\":{\"406\":1}}],[\"整个系统的复杂度是不是上升了\",{\"1\":{\"1275\":1}}],[\"整个系统的数据量将越来越大\",{\"1\":{\"29\":1}}],[\"整个流程的时长是没变的\",{\"1\":{\"1271\":1}}],[\"整个时间就变成了\",{\"1\":{\"1271\":1}}],[\"整个分区就无法正常工作了\",{\"1\":{\"1206\":1}}],[\"整个分析流程用到了较多工作\",{\"1\":{\"412\":1}}],[\"整个网络就分成了几块区域\",{\"1\":{\"1067\":1}}],[\"整个看起来就像是优化过且线程安全的\",{\"1\":{\"688\":1,\"792\":1}}],[\"整个永久代有一个\",{\"1\":{\"496\":1}}],[\"整个堆大小=年轻代大小\",{\"1\":{\"449\":1}}],[\"整个标记\",{\"1\":{\"396\":1}}],[\"整个步骤的简化版如下\",{\"1\":{\"286\":1}}],[\"整个事务都不会被执行\",{\"1\":{\"280\":1}}],[\"整个可重入锁的实现逻辑非常简单\",{\"1\":{\"56\":1}}],[\"双端队列\",{\"1\":{\"1016\":1}}],[\"双端链表的头结点是一个无参构造函数的头结点\",{\"1\":{\"1011\":1}}],[\"双重校验锁实现对象单例\",{\"1\":{\"834\":1}}],[\"双向迭代器\",{\"1\":{\"732\":1}}],[\"双向循环链表\",{\"1\":{\"657\":2}}],[\"双向链表中\",{\"1\":{\"1011\":1}}],[\"双向链表和双向循环链表\",{\"0\":{\"657\":1}}],[\"双向链表\",{\"1\":{\"174\":1,\"180\":1,\"552\":1,\"642\":1,\"656\":1,\"657\":2,\"724\":1}}],[\"双亲委派机制\",{\"0\":{\"433\":1}}],[\"双亲委派模型可以保证加载的是\",{\"1\":{\"358\":1}}],[\"双亲委派模型保证了\",{\"1\":{\"358\":1}}],[\"双亲委派模型的好处\",{\"0\":{\"358\":1}}],[\"双亲委派模型的实现代码非常简单\",{\"1\":{\"357\":1}}],[\"双亲委派模型的执行流程已经解释了\",{\"1\":{\"359\":1}}],[\"双亲委派模型的执行流程\",{\"0\":{\"357\":1}}],[\"双亲委派模型并不是一种强制性的约束\",{\"1\":{\"356\":1}}],[\"双亲委派模型要求除了顶层的启动类加载器外\",{\"1\":{\"356\":1}}],[\"双亲委派模型介绍\",{\"0\":{\"356\":1}}],[\"双亲委派模型也是非常重要的知识点\",{\"1\":{\"340\":1}}],[\"双亲委派模型\",{\"0\":{\"355\":1},\"1\":{\"340\":1,\"356\":1}}],[\"双精度浮点型字面量\",{\"1\":{\"328\":1}}],[\"双号段缓存\",{\"1\":{\"42\":1}}],[\"竞争较少\",{\"1\":{\"838\":1,\"987\":1}}],[\"竞争激烈\",{\"1\":{\"838\":1,\"987\":1}}],[\"竞争会越来越激烈效率越低\",{\"1\":{\"688\":1}}],[\"竞争\",{\"0\":{\"169\":1}}],[\"防止无限循环浪费资源\",{\"1\":{\"1012\":1}}],[\"防止占用过多物理内存\",{\"1\":{\"443\":1}}],[\"防止这种问题拖垮整个系统\",{\"1\":{\"412\":1}}],[\"防止内存溢出\",{\"1\":{\"392\":1}}],[\"防止极端情况\",{\"1\":{\"168\":1}}],[\"防止重复\",{\"1\":{\"19\":1}}],[\"确实也不是特别清楚\",{\"1\":{\"1349\":1}}],[\"确实是麻烦点\",{\"1\":{\"1262\":1}}],[\"确实可以\",{\"1\":{\"694\":1}}],[\"确定\",{\"1\":{\"1380\":1}}],[\"确定元素存放在哪个桶中\",{\"1\":{\"622\":1,\"686\":1}}],[\"确定性\",{\"1\":{\"37\":1}}],[\"确保已经被\",{\"1\":{\"1380\":2}}],[\"确保在非拜占庭条件\",{\"1\":{\"1106\":1}}],[\"确保异步任务有足够的时间完成\",{\"1\":{\"781\":1}}],[\"确保当存放的元素超过容器容量时\",{\"1\":{\"706\":1}}],[\"确保单位时间内只有一个线程可以操作延迟队列\",{\"1\":{\"607\":1}}],[\"确保元素按照到期时间升序排列\",{\"1\":{\"601\":1}}],[\"确保内部容量达到指定的最小容量\",{\"1\":{\"553\":1,\"557\":1}}],[\"确保插入的元素不为null\",{\"1\":{\"535\":1,\"536\":1}}],[\"确保可以排查现场问题\",{\"1\":{\"455\":1}}],[\"确保加载的类符合\",{\"1\":{\"429\":1}}],[\"确保写磁盘操作结束才会返回\",{\"1\":{\"230\":1}}],[\"确保所有\",{\"1\":{\"168\":1}}],[\"识别的特殊方法\",{\"1\":{\"430\":1}}],[\"识别\",{\"1\":{\"168\":1}}],[\"识别成\",{\"1\":{\"86\":2}}],[\"迁移所有操作都是同步操作\",{\"1\":{\"167\":1}}],[\"空实现\",{\"1\":{\"711\":1}}],[\"空指针异常\",{\"1\":{\"630\":1}}],[\"空位都以0补齐\",{\"1\":{\"618\":1,\"682\":1}}],[\"空数组\",{\"1\":{\"553\":1}}],[\"空闲列表\",{\"1\":{\"503\":2}}],[\"空闲内存为\",{\"1\":{\"451\":1}}],[\"空闲内存块链表操作时间就会增加\",{\"1\":{\"165\":1}}],[\"空余堆内存大于\",{\"1\":{\"449\":1,\"451\":1}}],[\"空余堆内存小于\",{\"1\":{\"449\":1,\"451\":1}}],[\"空间换时间\",{\"1\":{\"838\":1,\"987\":1}}],[\"空间的比例\",{\"1\":{\"485\":1}}],[\"空间中使用适当的命令\",{\"1\":{\"484\":1}}],[\"空间满了之后\",{\"1\":{\"444\":1}}],[\"空间整合\",{\"1\":{\"407\":1}}],[\"空间问题\",{\"1\":{\"396\":1}}],[\"空间分配担保是为了确保在\",{\"1\":{\"388\":1}}],[\"空间分配担保\",{\"0\":{\"388\":1}}],[\"空间\",{\"1\":{\"384\":1,\"386\":1,\"444\":1}}],[\"空间成本\",{\"1\":{\"119\":1}}],[\"空间索引是一种用于地理空间数据查询的特殊索引\",{\"1\":{\"103\":1}}],[\"空间索引\",{\"1\":{\"103\":1}}],[\"空间固定会用完\",{\"1\":{\"89\":1}}],[\"操作逻辑如下\",{\"1\":{\"1037\":1}}],[\"操作锁定\",{\"1\":{\"972\":1}}],[\"操作初始化变量的值\",{\"1\":{\"972\":1}}],[\"操作可以被同一条线程重复执行多次\",{\"1\":{\"972\":1}}],[\"操作之前\",{\"1\":{\"972\":1}}],[\"操作从工作内存中得到的变量的值放入主内存的变量中\",{\"1\":{\"972\":1}}],[\"操作从主内存中得到的变量值放入工作内存的变量的副本中\",{\"1\":{\"972\":1}}],[\"操作使用\",{\"1\":{\"972\":1}}],[\"操作配对成功\",{\"1\":{\"958\":1}}],[\"操作与空闲线程执行的\",{\"1\":{\"958\":1}}],[\"操作就会误认为它从来没有被修改过\",{\"1\":{\"843\":1,\"992\":1}}],[\"操作一个变量时\",{\"1\":{\"841\":1,\"990\":1}}],[\"操作失败\",{\"1\":{\"841\":1,\"990\":1}}],[\"操作员\",{\"1\":{\"840\":6,\"989\":6}}],[\"操作完成上\",{\"1\":{\"895\":1,\"922\":1}}],[\"操作完成的时间来说很少\",{\"1\":{\"895\":1,\"922\":1}}],[\"操作完成的\",{\"1\":{\"576\":1}}],[\"操作完毕后\",{\"1\":{\"835\":1}}],[\"操作实现\",{\"1\":{\"794\":1}}],[\"操作实现元素的添加和移除操作\",{\"1\":{\"598\":1}}],[\"操作设置\",{\"1\":{\"767\":1}}],[\"操作更新\",{\"1\":{\"752\":1}}],[\"操作去修改\",{\"1\":{\"748\":2,\"906\":2}}],[\"操作去写对应的\",{\"1\":{\"490\":1}}],[\"操作导致\",{\"1\":{\"686\":1}}],[\"操作会导致线程不安全\",{\"1\":{\"686\":1}}],[\"操作中如果除数是\",{\"1\":{\"684\":1}}],[\"操作方法\",{\"1\":{\"649\":1}}],[\"操作直接调用的是集合自己的方法\",{\"1\":{\"631\":1}}],[\"操作这里没有介绍\",{\"1\":{\"571\":1}}],[\"操作栈\",{\"1\":{\"519\":1}}],[\"操作数栈\",{\"1\":{\"493\":2,\"494\":1,\"812\":1}}],[\"操作字节流了\",{\"1\":{\"341\":1}}],[\"操作的权限\",{\"1\":{\"1351\":1}}],[\"操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同\",{\"1\":{\"1303\":1}}],[\"操作的原理\",{\"1\":{\"1039\":1}}],[\"操作的原子性的话\",{\"1\":{\"835\":1}}],[\"操作的话\",{\"1\":{\"968\":1}}],[\"操作的过程中\",{\"1\":{\"840\":1,\"989\":1}}],[\"操作的\",{\"1\":{\"281\":1,\"843\":1,\"992\":1}}],[\"操作\",{\"1\":{\"272\":1,\"490\":1,\"631\":1,\"684\":1,\"686\":2,\"742\":1,\"841\":1,\"845\":1,\"941\":1,\"972\":6,\"974\":2,\"978\":1,\"990\":1,\"994\":1,\"1012\":1,\"1019\":1,\"1030\":1,\"1036\":1,\"1310\":1,\"1371\":1}}],[\"操作缓存就是直接操作内存\",{\"1\":{\"246\":1}}],[\"操作轻量\",{\"1\":{\"236\":1}}],[\"操作系统或计算机网络用语范畴\",{\"1\":{\"1344\":1}}],[\"操作系统通过\",{\"1\":{\"968\":1}}],[\"操作系统也就同样需要解决内存缓存不一致性问题\",{\"1\":{\"968\":1}}],[\"操作系统屏蔽了底层硬件的操作细节\",{\"1\":{\"968\":1}}],[\"操作系统架构通常都是用所谓的\",{\"1\":{\"820\":1}}],[\"操作系统实际分配给\",{\"1\":{\"219\":1}}],[\"操作系统为你分配了\",{\"1\":{\"217\":1}}],[\"操作系统需要把释放掉的内存块插入一个空闲内存块的链表\",{\"1\":{\"165\":1}}],[\"操作发生阻塞\",{\"1\":{\"161\":1}}],[\"删除子节点的权限\",{\"1\":{\"1384\":1}}],[\"删除一个节点以及其下的所有子节点\",{\"1\":{\"1336\":1}}],[\"删除一个子节点\",{\"1\":{\"1336\":1}}],[\"删除一个或多个哈希表字段\",{\"1\":{\"185\":1}}],[\"删除节点\",{\"0\":{\"1331\":1,\"1336\":1}}],[\"删除第一个出现的指定元素\",{\"1\":{\"733\":1}}],[\"删除链表指定位置的元素\",{\"1\":{\"731\":1}}],[\"删除链表中首次出现的指定元素\",{\"1\":{\"731\":2}}],[\"删除指定位置的元素\",{\"1\":{\"733\":1}}],[\"删除指定索引处的元素\",{\"1\":{\"731\":1}}],[\"删除指定的\",{\"1\":{\"177\":1}}],[\"删除并返回链表的最后一个元素\",{\"1\":{\"731\":2}}],[\"删除并返回链表的第一个元素\",{\"1\":{\"731\":2}}],[\"删除后\",{\"1\":{\"711\":1}}],[\"删除队尾\",{\"1\":{\"667\":1}}],[\"删除队首\",{\"1\":{\"667\":2}}],[\"删除操作\",{\"1\":{\"654\":2,\"725\":2}}],[\"删除操作的本质是要释放键值对占用的内存空间\",{\"1\":{\"165\":1}}],[\"删除索引为1的位置的元素\",{\"1\":{\"653\":1}}],[\"删除数组中的元素\",{\"1\":{\"649\":1}}],[\"删除数据后\",{\"1\":{\"221\":1}}],[\"删除list中的所有偶数\",{\"1\":{\"631\":1}}],[\"删除结果\",{\"1\":{\"593\":1}}],[\"删除此列表中首次出现的指定元素\",{\"1\":{\"591\":1}}],[\"删除元素的能力\",{\"1\":{\"649\":1}}],[\"删除元素\",{\"0\":{\"591\":1,\"731\":1},\"1\":{\"711\":1}}],[\"删除该列表中指定位置的元素\",{\"1\":{\"553\":1}}],[\"删除\",{\"1\":{\"549\":1,\"586\":1,\"649\":2,\"654\":4,\"725\":4,\"727\":1,\"729\":1}}],[\"删除我们指定的对象\",{\"1\":{\"533\":1}}],[\"删除即可\",{\"1\":{\"316\":1}}],[\"删除等操作\",{\"1\":{\"298\":1}}],[\"删除商品就是删除\",{\"1\":{\"257\":1}}],[\"删除最新命令并重启即可恢复之前的状态\",{\"1\":{\"236\":1}}],[\"删除也是同样道理\",{\"1\":{\"166\":1}}],[\"删除大\",{\"0\":{\"165\":1},\"1\":{\"163\":1,\"165\":1,\"292\":1}}],[\"查找过程中\",{\"1\":{\"1036\":1}}],[\"查找时\",{\"1\":{\"800\":1}}],[\"查找\",{\"0\":{\"697\":1},\"1\":{\"695\":1,\"800\":1}}],[\"查找之\",{\"1\":{\"578\":1}}],[\"查找到指定位置\",{\"1\":{\"578\":1}}],[\"查找等操作\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"查找大\",{\"0\":{\"164\":1}}],[\"查单表\",{\"1\":{\"412\":1}}],[\"查看节点信息和状态\",{\"0\":{\"1330\":1}}],[\"查看节点状态\",{\"0\":{\"1329\":1}}],[\"查看某个目录下的子节点\",{\"0\":{\"1328\":1}}],[\"查看常用命令\",{\"0\":{\"1324\":1}}],[\"查看任务是否执行完成以及获取任务执行结果的方法\",{\"1\":{\"900\":1}}],[\"查看链表首节点是否存在\",{\"1\":{\"712\":1}}],[\"查看链表长度\",{\"1\":{\"181\":1}}],[\"查看源码我们发现实际上\",{\"1\":{\"658\":1}}],[\"查看元素\",{\"0\":{\"605\":1}}],[\"查看队列第一个元素\",{\"1\":{\"604\":3}}],[\"查看当前任务还有多久到期\",{\"1\":{\"599\":1}}],[\"查看当前\",{\"1\":{\"367\":1}}],[\"查看所有\",{\"0\":{\"365\":1}}],[\"查看类的访问标志\",{\"1\":{\"329\":1}}],[\"查看的\",{\"1\":{\"325\":1}}],[\"查看数据还有多久过期\",{\"1\":{\"270\":1}}],[\"查看\",{\"0\":{\"374\":1},\"1\":{\"185\":1,\"324\":1,\"374\":1,\"1322\":1}}],[\"查看指定哈希表中指定的字段是否存在\",{\"1\":{\"185\":1}}],[\"查看对应下标范围的列表元素\",{\"1\":{\"181\":1}}],[\"查看是否是因为高算法复杂度或者过度的内存优化问题\",{\"1\":{\"169\":1}}],[\"查询的时候\",{\"1\":{\"1037\":1}}],[\"查询队尾元素\",{\"1\":{\"667\":1}}],[\"查询队首元素\",{\"1\":{\"667\":2}}],[\"查询购物车信息就是遍历对应的\",{\"1\":{\"257\":1}}],[\"查询\",{\"1\":{\"168\":1}}],[\"查询账户余额为2000元\",{\"1\":{\"127\":1}}],[\"查询操作的时间复杂度为o\",{\"1\":{\"97\":1}}],[\"查询语句的执行流程如下\",{\"1\":{\"90\":1}}],[\"查询缓存简单来说就是以key\",{\"1\":{\"85\":1}}],[\"查询缓存\",{\"0\":{\"85\":1},\"1\":{\"82\":1,\"90\":1}}],[\"查询用户已经抢购的数量\",{\"1\":{\"60\":1}}],[\"查询效率更高\",{\"1\":{\"101\":1}}],[\"查询效率\",{\"1\":{\"18\":1}}],[\"占有\",{\"1\":{\"1011\":1}}],[\"占\",{\"0\":{\"470\":1}}],[\"占年轻代的\",{\"1\":{\"453\":1}}],[\"占满时就会触发我们最常听说的\",{\"1\":{\"444\":1}}],[\"占用过期桶\",{\"1\":{\"1036\":1}}],[\"占用部分资源的线程进一步申请其他资源时\",{\"1\":{\"824\":1}}],[\"占用没必要的内存空间\",{\"1\":{\"708\":1}}],[\"占用了超过\",{\"1\":{\"412\":1}}],[\"占用内存最大的\",{\"1\":{\"293\":1}}],[\"占用的内存空间\",{\"1\":{\"268\":1}}],[\"占用的内存就越多\",{\"1\":{\"163\":1,\"291\":1}}],[\"占用\",{\"1\":{\"205\":1}}],[\"占用空间很小\",{\"1\":{\"205\":1}}],[\"占用空间非常非常小\",{\"1\":{\"205\":1,\"212\":1}}],[\"占空间\",{\"1\":{\"19\":1}}],[\"集\",{\"1\":{\"1246\":1}}],[\"集消息\",{\"1\":{\"1238\":1}}],[\"集中式发散消息\",{\"1\":{\"1083\":1}}],[\"集中过期问题\",{\"0\":{\"289\":1}}],[\"集成三方中间件线程池管理\",{\"1\":{\"896\":1,\"923\":1}}],[\"集合常见面试题总结\",{\"1\":{\"724\":1}}],[\"集合提高了数据的存储和处理灵活性\",{\"1\":{\"647\":1}}],[\"集合提供了更灵活\",{\"1\":{\"647\":1}}],[\"集合的优势在于它们的大小可变\",{\"1\":{\"647\":1}}],[\"集合就派上用场了\",{\"1\":{\"647\":1}}],[\"集合框架中的\",{\"1\":{\"719\":1}}],[\"集合框架中的各种集合类和接口可以存储不同类型和数量的对象\",{\"1\":{\"647\":1}}],[\"集合框架中\",{\"1\":{\"715\":1}}],[\"集合框架底层数据结构总结\",{\"0\":{\"641\":1}}],[\"集合框架概览\",{\"1\":{\"639\":1}}],[\"集合框架如下图所示\",{\"1\":{\"639\":1}}],[\"集合概览\",{\"0\":{\"639\":1}}],[\"集合概述\",{\"0\":{\"638\":1}}],[\"集合去重\",{\"0\":{\"632\":1}}],[\"集合进行修改的时候\",{\"1\":{\"631\":1}}],[\"集合遍历\",{\"0\":{\"631\":1}}],[\"集合时\",{\"1\":{\"630\":1}}],[\"集合转数组\",{\"0\":{\"633\":1}}],[\"集合转\",{\"0\":{\"630\":1}}],[\"集合判空\",{\"0\":{\"629\":1}}],[\"集合之一\",{\"1\":{\"616\":1}}],[\"集合是支持\",{\"1\":{\"549\":1,\"586\":1}}],[\"集合元素数量\",{\"1\":{\"293\":1}}],[\"集合中的下标\",{\"1\":{\"1142\":1}}],[\"集合中的元素没有先后顺序但都唯一\",{\"1\":{\"188\":1,\"195\":1,\"259\":1}}],[\"集合中包含元素的个数\",{\"1\":{\"205\":1}}],[\"集合内的重要接口\",{\"1\":{\"188\":1}}],[\"集合\",{\"0\":{\"187\":1},\"1\":{\"163\":1,\"174\":1,\"253\":1,\"446\":1,\"634\":1,\"639\":1}}],[\"集群不也是加机器吗\",{\"1\":{\"1367\":1}}],[\"集群在宕掉几个\",{\"1\":{\"1357\":1}}],[\"集群为啥最好奇数台\",{\"0\":{\"1357\":1}}],[\"集群才能正式对外提供事务服务\",{\"1\":{\"1356\":1}}],[\"集群角色\",{\"0\":{\"1355\":1}}],[\"集群间通过\",{\"1\":{\"1354\":1}}],[\"集群架构\",{\"1\":{\"1354\":1}}],[\"集群整体对外提供服务\",{\"1\":{\"1354\":1}}],[\"集群了\",{\"1\":{\"1354\":1}}],[\"集群管理和注册中心\",{\"0\":{\"1390\":1}}],[\"集群管理\",{\"1\":{\"1344\":1,\"1346\":1,\"1367\":1,\"1390\":1}}],[\"集群模式下消息只会发送给一个消费者\",{\"1\":{\"1281\":1}}],[\"集群消费模式下\",{\"1\":{\"1280\":1}}],[\"集群包括若干服务器\",{\"1\":{\"1108\":1}}],[\"集群仍能正常工作\",{\"1\":{\"1098\":1}}],[\"集群服务了\",{\"1\":{\"1085\":1}}],[\"集群处于\",{\"1\":{\"1069\":1}}],[\"集群详解\",{\"1\":{\"286\":1,\"318\":1,\"1085\":1}}],[\"集群的时候\",{\"1\":{\"1341\":1}}],[\"集群的节点之间远程写数据的时候\",{\"1\":{\"1078\":1}}],[\"集群的主从节点通过\",{\"1\":{\"224\":1}}],[\"集群的话会更高\",{\"1\":{\"246\":1}}],[\"集群的话\",{\"1\":{\"220\":1}}],[\"集群可以进行节点的动态扩容缩容\",{\"1\":{\"167\":1}}],[\"集群扩容\",{\"0\":{\"167\":1}}],[\"集群\",{\"0\":{\"318\":1,\"1354\":1,\"1356\":1},\"1\":{\"153\":1,\"314\":1,\"1069\":1,\"1261\":1,\"1298\":1,\"1367\":2}}],[\"集群宕机\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"集群主从切换导致的锁丢失问题\",{\"1\":{\"51\":1}}],[\"集群操作的\",{\"1\":{\"51\":1}}],[\"集群中\",{\"1\":{\"1378\":1}}],[\"集群中角色\",{\"1\":{\"1355\":1}}],[\"集群中只要有一台机器不可用\",{\"1\":{\"1299\":1}}],[\"集群中节点\",{\"1\":{\"1246\":1}}],[\"集群中的服务器状态有下面几种\",{\"1\":{\"1356\":1}}],[\"集群中的所有机器通过一个\",{\"1\":{\"1355\":1}}],[\"集群中的节点等\",{\"1\":{\"1237\":1}}],[\"集群中的节点在\",{\"1\":{\"1115\":1}}],[\"集群中的节点\",{\"1\":{\"1087\":1}}],[\"集群中的多个独立的\",{\"1\":{\"51\":1}}],[\"集群中选择出\",{\"1\":{\"318\":1}}],[\"集群中有半数以上的\",{\"1\":{\"51\":1}}],[\"集群数据同步到各个节点时是异步的\",{\"1\":{\"51\":1}}],[\"集群下\",{\"1\":{\"51\":1}}],[\"集群方案codis\",{\"1\":{\"35\":1}}],[\"集群解决方案\",{\"1\":{\"35\":1}}],[\"步没有发送成功\",{\"1\":{\"1304\":1}}],[\"步开始的\",{\"1\":{\"1304\":1}}],[\"步骤\",{\"1\":{\"958\":1}}],[\"步耗费时间之和称为\",{\"1\":{\"285\":1}}],[\"步和第\",{\"1\":{\"285\":1}}],[\"步\",{\"1\":{\"230\":1,\"285\":1,\"301\":1,\"605\":1,\"941\":1}}],[\"步的过程中\",{\"1\":{\"162\":1}}],[\"步之后\",{\"1\":{\"86\":1}}],[\"阻塞问题\",{\"1\":{\"1370\":1}}],[\"阻塞调用栈\",{\"1\":{\"1012\":1}}],[\"阻塞和唤醒线程功能以及队列模型的简单框架\",{\"1\":{\"999\":1}}],[\"阻塞状态\",{\"1\":{\"820\":1}}],[\"阻塞则整个进程被阻塞\",{\"1\":{\"816\":1}}],[\"阻塞获取最先到期的任务\",{\"1\":{\"599\":1}}],[\"阻塞获取锁\",{\"1\":{\"571\":1}}],[\"阻塞等到只到获取到锁\",{\"1\":{\"571\":1}}],[\"阻塞nanos时间\",{\"1\":{\"537\":1}}],[\"阻塞式获取和新增元素的方法为\",{\"1\":{\"535\":1}}],[\"阻塞式获取和新增元素对应的就是生产者\",{\"1\":{\"535\":1}}],[\"阻塞式获取和新增元素\",{\"0\":{\"535\":1}}],[\"阻塞队列可以通过加锁来实现\",{\"1\":{\"794\":1}}],[\"阻塞队列\",{\"1\":{\"670\":1,\"796\":1,\"913\":1}}],[\"阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互\",{\"1\":{\"530\":1}}],[\"阻塞队列就是典型的生产者\",{\"1\":{\"530\":1}}],[\"阻塞队列的思想\",{\"0\":{\"530\":1}}],[\"阻塞队列的历史可以追溯到\",{\"1\":{\"529\":1}}],[\"阻塞队列的历史\",{\"0\":{\"529\":1}}],[\"阻塞队列简介\",{\"0\":{\"528\":1}}],[\"阻塞的线程才能继续执行\",{\"1\":{\"749\":1}}],[\"阻塞的\",{\"1\":{\"171\":1}}],[\"阻塞的情况\",{\"1\":{\"156\":1,\"317\":1}}],[\"阻塞\",{\"0\":{\"317\":1},\"1\":{\"170\":1,\"171\":1,\"816\":1,\"820\":1}}],[\"阻塞工作线程\",{\"1\":{\"163\":1}}],[\"阻塞就是出现在第\",{\"1\":{\"162\":1}}],[\"让其他不是\",{\"1\":{\"1387\":1}}],[\"让其成为一个它会读二进制文件的\",{\"1\":{\"418\":1}}],[\"让多个客户端创建一个指定的节点\",{\"1\":{\"1387\":1}}],[\"让你可以以一种轻量级的方式来使用\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"让生产者发送多份\",{\"1\":{\"1193\":1}}],[\"让更多的请求落到权重更大的服务提供者上\",{\"1\":{\"1144\":1}}],[\"让大家可以更加平滑的使用\",{\"1\":{\"1057\":1}}],[\"让性能最大化\",{\"1\":{\"974\":1}}],[\"让我们在回到示例代码\",{\"1\":{\"941\":1}}],[\"让它们尽己所能地去优化性能\",{\"1\":{\"974\":1}}],[\"让它变为可变的\",{\"1\":{\"896\":1,\"923\":1}}],[\"让它尝试去获取锁\",{\"1\":{\"55\":1}}],[\"让所有线程通过\",{\"1\":{\"756\":1,\"911\":1}}],[\"让一组线程到达一个屏障\",{\"1\":{\"755\":1,\"910\":1}}],[\"让当前节点\",{\"1\":{\"711\":1}}],[\"让head指针指向后继节点a即可\",{\"1\":{\"711\":1}}],[\"让需要用到链表特性的节点去实现需要的逻辑\",{\"1\":{\"708\":1}}],[\"让出\",{\"1\":{\"576\":1,\"1183\":1}}],[\"让线程\",{\"1\":{\"370\":1,\"823\":1}}],[\"让用户可以在浏览器上查看分析结果\",{\"1\":{\"364\":1,\"369\":1}}],[\"让应用逆向使用类加载器\",{\"1\":{\"359\":1}}],[\"让程序自动决定触发时机\",{\"1\":{\"233\":1}}],[\"让\",{\"1\":{\"231\":1,\"742\":1,\"1374\":1,\"1379\":1}}],[\"让操作系统决定何时进行同步\",{\"1\":{\"161\":1,\"231\":1,\"282\":1}}],[\"刷盘\",{\"1\":{\"161\":1,\"231\":2}}],[\"刷盘阻塞\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"立即会调用\",{\"1\":{\"161\":1,\"231\":1}}],[\"范围从\",{\"1\":{\"480\":1}}],[\"范围为\",{\"1\":{\"442\":1}}],[\"范围内的其他元素\",{\"1\":{\"210\":1}}],[\"范围内的所有元素\",{\"1\":{\"157\":1,\"301\":1}}],[\"范围查询和前缀匹配\",{\"1\":{\"103\":1}}],[\"阿里出品\",{\"1\":{\"1240\":1}}],[\"阿里巴巴开源了一个transmittablethreadlocal组件就可以解决这个问题\",{\"1\":{\"1043\":1}}],[\"阿里巴巴中间件\",{\"1\":{\"868\":1}}],[\"阿里巴巴\",{\"1\":{\"628\":1,\"629\":1,\"630\":1,\"631\":1,\"632\":1,\"633\":1,\"634\":1,\"889\":2,\"937\":1}}],[\"阿里开发者\",{\"1\":{\"251\":1,\"284\":1}}],[\"阿里云官方文档\",{\"1\":{\"486\":2}}],[\"阿里云\",{\"1\":{\"319\":1}}],[\"阿里云key分析\",{\"1\":{\"293\":1,\"298\":1}}],[\"阿里云企业版\",{\"1\":{\"233\":1}}],[\"阿里云的\",{\"1\":{\"233\":1}}],[\"阿\",{\"1\":{\"156\":1}}],[\"点以后\",{\"1\":{\"1264\":1}}],[\"点到点\",{\"0\":{\"1228\":1}}],[\"点开\",{\"1\":{\"533\":1}}],[\"点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息\",{\"1\":{\"376\":1}}],[\"点击右边的\",{\"1\":{\"375\":1}}],[\"点击链接即可查看详细介绍以及加入方法\",{\"1\":{\"13\":1,\"65\":1,\"150\":1,\"153\":1,\"736\":1}}],[\"点并不具体\",{\"1\":{\"340\":1}}],[\"点\",{\"1\":{\"243\":1,\"266\":1}}],[\"点赞量\",{\"1\":{\"147\":1}}],[\"视为缓存已满\",{\"1\":{\"718\":1}}],[\"视为主要数据存储\",{\"1\":{\"146\":1}}],[\"视频等等文件资源\",{\"1\":{\"351\":1}}],[\"视频\",{\"1\":{\"256\":1}}],[\"视图等\",{\"1\":{\"82\":1}}],[\"首次请求数据一定不在\",{\"1\":{\"145\":1}}],[\"首先肯定是如何获取锁\",{\"1\":{\"1388\":1}}],[\"首先也会给自己投票\",{\"1\":{\"1380\":1}}],[\"首先毫无疑问的是剩下的两个\",{\"1\":{\"1380\":1}}],[\"首先它会比较\",{\"1\":{\"1380\":1}}],[\"首先我画一张图\",{\"1\":{\"1280\":1}}],[\"首先我问一个问题\",{\"1\":{\"1277\":1}}],[\"首先我们先来看看\",{\"1\":{\"533\":1}}],[\"首先我们要有一个持久节点\",{\"1\":{\"53\":1}}],[\"首先要向某个服务器发起请求\",{\"1\":{\"1157\":1}}],[\"首先要提取关键字\",{\"1\":{\"86\":1}}],[\"首先是将tab\",{\"1\":{\"1037\":1}}],[\"首先执行\",{\"1\":{\"958\":1}}],[\"首先执行前会校验该用户有没有权限\",{\"1\":{\"88\":1}}],[\"首先判断当前线程池中执行的任务数量是否小于\",{\"1\":{\"941\":1}}],[\"首先创建一个\",{\"1\":{\"940\":1}}],[\"首先切换到类的对应目录执行\",{\"1\":{\"851\":1}}],[\"首先获得到\",{\"1\":{\"824\":1}}],[\"首先获取待删除节点\",{\"1\":{\"731\":1}}],[\"首先将数据分为一段一段\",{\"1\":{\"690\":1}}],[\"首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用\",{\"1\":{\"502\":1}}],[\"首先会把key和value封装到\",{\"1\":{\"625\":1}}],[\"首先会查看\",{\"1\":{\"604\":1}}],[\"首先需要释放对这个元素的引用\",{\"1\":{\"604\":1}}],[\"首先在\",{\"1\":{\"503\":1}}],[\"首先必须要提到的是一个名叫\",{\"1\":{\"446\":1}}],[\"首先标记出所有不需要回收的对象\",{\"1\":{\"396\":1}}],[\"首先通过辅助键索引找到对应id\",{\"1\":{\"106\":1}}],[\"首先\",{\"1\":{\"96\":1,\"357\":1,\"604\":1,\"630\":1,\"1003\":1,\"1315\":1}}],[\"缺乏一系列配套的服务化组件和服务治理功能的支撑\",{\"1\":{\"1172\":1}}],[\"缺陷\",{\"1\":{\"145\":2,\"1090\":1}}],[\"缺点\",{\"0\":{\"1056\":1},\"1\":{\"33\":1,\"34\":1,\"35\":2,\"37\":1,\"38\":1}}],[\"答案是可以的\",{\"1\":{\"1388\":1}}],[\"答案是不会的\",{\"1\":{\"1314\":1}}],[\"答案是\",{\"1\":{\"1280\":1,\"1379\":1}}],[\"答案就是\",{\"1\":{\"272\":1}}],[\"答案\",{\"1\":{\"145\":2}}],[\"么\",{\"0\":{\"909\":1},\"1\":{\"145\":1}}],[\"旁路缓存模式\",{\"0\":{\"145\":1},\"1\":{\"316\":1}}],[\"搞懂\",{\"1\":{\"144\":1}}],[\"种权限\",{\"1\":{\"1384\":1}}],[\"种消息模型\",{\"1\":{\"1222\":1}}],[\"种级别\",{\"1\":{\"1078\":1}}],[\"种同步操作之外\",{\"1\":{\"972\":1}}],[\"种情况\",{\"1\":{\"969\":1}}],[\"种情况下\",{\"1\":{\"344\":1}}],[\"种\",{\"1\":{\"848\":1,\"1335\":2,\"1351\":1}}],[\"种不同状态的其中一个状态\",{\"1\":{\"820\":1}}],[\"种不同的值\",{\"1\":{\"37\":1}}],[\"种不同的\",{\"1\":{\"37\":1}}],[\"种遍历方式与性能分析\",{\"1\":{\"687\":1}}],[\"种延时队列的实现方法\",{\"1\":{\"612\":1}}],[\"种表有一个共同的特点\",{\"1\":{\"328\":1}}],[\"种类型\",{\"1\":{\"256\":1,\"1249\":1}}],[\"种基础数据类型\",{\"1\":{\"253\":1}}],[\"种基础数据类型和\",{\"1\":{\"252\":1}}],[\"种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存\",{\"1\":{\"440\":1}}],[\"种基本的数据类型之外\",{\"1\":{\"199\":1}}],[\"种基本数据类型对应的底层数据结构实现如下表所示\",{\"1\":{\"174\":1}}],[\"种基本数据类型\",{\"1\":{\"174\":1}}],[\"种基本数据类型详解\",{\"0\":{\"174\":1},\"1\":{\"252\":1,\"254\":1}}],[\"种常见的\",{\"1\":{\"412\":1,\"486\":1}}],[\"种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的\",{\"1\":{\"144\":1}}],[\"种常用的缓存读写策略详解\",{\"1\":{\"247\":1}}],[\"种持久化方式的主要区别在于\",{\"1\":{\"231\":1}}],[\"种持久化方式\",{\"1\":{\"224\":1,\"282\":1}}],[\"种特殊数据类型\",{\"1\":{\"253\":1}}],[\"种特殊数据类型的详细介绍请看下面这两篇文章以及\",{\"1\":{\"252\":1}}],[\"种特殊数据类型详解\",{\"0\":{\"199\":1},\"1\":{\"252\":1}}],[\"种特殊的数据类型\",{\"1\":{\"199\":1}}],[\"种数据淘汰策略\",{\"1\":{\"273\":1}}],[\"种数据结构\",{\"1\":{\"174\":1}}],[\"种数据类型是直接提供给用户使用的\",{\"1\":{\"174\":1}}],[\"种读写策略\",{\"1\":{\"144\":1}}],[\"熟练使用缓存\",{\"1\":{\"144\":1}}],[\"纵轴为时间\",{\"1\":{\"141\":1}}],[\"横轴为不同客户端开启的事务\",{\"1\":{\"141\":1}}],[\"假如购票系统处理需要\",{\"1\":{\"1271\":1}}],[\"假如这两条消息的消费顺序不一样造成的最终结果就会截然不同\",{\"1\":{\"1202\":1}}],[\"假如有两个提供相同服务的服务器\",{\"1\":{\"1141\":1}}],[\"假如现在一共有\",{\"1\":{\"1105\":1}}],[\"假如synchronized是不可重入锁的话\",{\"1\":{\"860\":1}}],[\"假如我们有\",{\"1\":{\"1357\":1}}],[\"假如我们的集群中有\",{\"1\":{\"1357\":1}}],[\"假如我们存在这样一种情况\",{\"1\":{\"1193\":1}}],[\"假如我们需要调用一个远程方法\",{\"1\":{\"1129\":1}}],[\"假如我们需要实现一个优先级任务线程池的话\",{\"1\":{\"897\":1}}],[\"假如我们线程池的核心线程数为\",{\"1\":{\"919\":1}}],[\"假如我们不做任何措施的话\",{\"1\":{\"884\":1}}],[\"假如我们要计算一个复杂的任务\",{\"1\":{\"816\":1}}],[\"假如我们要删除节点\",{\"1\":{\"654\":1}}],[\"假如我们再为\",{\"1\":{\"384\":1}}],[\"假如\",{\"1\":{\"604\":1,\"1139\":1,\"1206\":1}}],[\"假如线程\",{\"1\":{\"601\":1}}],[\"假如在创建新的对象时\",{\"1\":{\"495\":1}}],[\"假如在字符串常量池中存在字符串\",{\"1\":{\"393\":1}}],[\"假如用户第一次访问数据库中的某些数据的话\",{\"1\":{\"246\":1}}],[\"假如此时有一张表account表\",{\"1\":{\"141\":1}}],[\"假设如果需要对文件的内容进行修改之后再传输\",{\"1\":{\"1311\":1}}],[\"假设服务器因停止而发生故障\",{\"1\":{\"1106\":1}}],[\"假设多位拜占庭将军中没有叛军\",{\"1\":{\"1105\":1}}],[\"假设两个线程从\",{\"1\":{\"968\":1}}],[\"假设两个线程的读锁都想升级写锁\",{\"1\":{\"869\":1}}],[\"假设不存在\",{\"1\":{\"841\":1,\"990\":1}}],[\"假设不使用顺序节点的话\",{\"1\":{\"54\":1}}],[\"假设数据库中帐户信息表中有一个\",{\"1\":{\"840\":1,\"989\":1}}],[\"假设只运行了一个\",{\"1\":{\"816\":1}}],[\"假设线程\",{\"1\":{\"742\":1}}],[\"假设笔者最后新插入了一个不存在的节点\",{\"1\":{\"712\":1}}],[\"假设获得\",{\"1\":{\"686\":1}}],[\"假设我们集群中有\",{\"1\":{\"1380\":1}}],[\"假设我们需要在\",{\"1\":{\"1151\":1}}],[\"假设我们现在有\",{\"1\":{\"604\":1}}],[\"假设我们的重写了\",{\"1\":{\"712\":1}}],[\"假设我们的代码消费者先启动\",{\"1\":{\"535\":1}}],[\"假设我们的项目中有\",{\"1\":{\"359\":1}}],[\"假设为\",{\"1\":{\"396\":1}}],[\"假设主键为bigint\",{\"1\":{\"110\":1}}],[\"假设b+树高度为2\",{\"1\":{\"110\":1}}],[\"假设\",{\"1\":{\"96\":2,\"444\":1,\"712\":1,\"1264\":1,\"1380\":3}}],[\"假设在未来的某个时刻\",{\"1\":{\"777\":1}}],[\"假设在\",{\"1\":{\"89\":1}}],[\"假设当前\",{\"1\":{\"89\":1}}],[\"假设现在有\",{\"1\":{\"60\":1}}],[\"假设客户端\",{\"1\":{\"53\":1}}],[\"假设一个\",{\"1\":{\"23\":1}}],[\"假设上限为\",{\"1\":{\"19\":1}}],[\"那能不能使用\",{\"1\":{\"1388\":1}}],[\"那怎么解决呢\",{\"1\":{\"1380\":1}}],[\"那怎么监听大量的客户端连接呢\",{\"1\":{\"265\":1}}],[\"那也就是说\",{\"1\":{\"1389\":1}}],[\"那也就意味着我们需要两台以上同意\",{\"1\":{\"1380\":1}}],[\"那也是在说虚拟机栈\",{\"1\":{\"438\":1}}],[\"那个回复消息没有发送成功\",{\"1\":{\"1370\":1}}],[\"那些中间件只不过照着这个标准去实现而已\",{\"1\":{\"1280\":1}}],[\"那些因为获取元素而阻塞的线程可以继续工作了\",{\"1\":{\"535\":1}}],[\"那如果我的消费者如果消费很慢或者生产者生产消息很快\",{\"1\":{\"1275\":1}}],[\"那如何保证\",{\"1\":{\"694\":1}}],[\"那后来\",{\"1\":{\"1271\":1}}],[\"那我加几台服务器也\",{\"1\":{\"1367\":1}}],[\"那我如果再加一个发送邮件呢\",{\"1\":{\"1271\":1}}],[\"那我们就可以使用\",{\"1\":{\"1299\":1}}],[\"那我们就能说明它的值没有被其他线程修改过了吗\",{\"1\":{\"843\":1,\"992\":1}}],[\"那我们如何扩展\",{\"1\":{\"1131\":1}}],[\"那我们如何正确的将数组转换为\",{\"1\":{\"634\":1}}],[\"那我们的垃圾回收自然就不会去动这些内存\",{\"1\":{\"442\":1}}],[\"那我们的\",{\"1\":{\"418\":1}}],[\"那它和队列模型就基本是一样的了\",{\"1\":{\"1194\":1}}],[\"那它将会第一次标记并且进行一次筛选\",{\"1\":{\"446\":1}}],[\"那面试中就很可能会被问到\",{\"1\":{\"1177\":1}}],[\"那时候很多公司内部的\",{\"1\":{\"1160\":1}}],[\"那时间复杂度就接近是\",{\"1\":{\"632\":1}}],[\"那服务器只用同一套就够了\",{\"1\":{\"1155\":1}}],[\"那既然有\",{\"0\":{\"1155\":1}}],[\"那是不是就够了\",{\"1\":{\"1151\":1}}],[\"那是不是就类似于一个文本文件\",{\"1\":{\"418\":1}}],[\"那该服务部署在多台服务器的意义就不复存在了\",{\"1\":{\"1139\":1}}],[\"那该接口要在其之前被初始化\",{\"1\":{\"344\":1}}],[\"那实现最终一致性的具体方式是什么呢\",{\"1\":{\"1078\":1}}],[\"那可以考虑使用\",{\"1\":{\"897\":1}}],[\"那当前线程就要阻塞等待\",{\"1\":{\"851\":1}}],[\"那样考虑锁得不到释放的问题了\",{\"1\":{\"1388\":1}}],[\"那样考虑各种浏览器行为\",{\"1\":{\"1159\":1}}],[\"那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况\",{\"1\":{\"1069\":1}}],[\"那样一直等待\",{\"1\":{\"820\":1}}],[\"那样有着较多的约束\",{\"1\":{\"529\":1}}],[\"那里直接取出任务执行结果\",{\"1\":{\"773\":1,\"899\":1}}],[\"那种遍历整个\",{\"1\":{\"713\":1}}],[\"那必须先执行相应的类加载过程\",{\"1\":{\"502\":1}}],[\"那就没有顺序性可言了\",{\"1\":{\"1314\":1}}],[\"那就是无法保证\",{\"1\":{\"1314\":1}}],[\"那就是\",{\"1\":{\"1279\":1}}],[\"那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了\",{\"1\":{\"246\":1}}],[\"那就再走一遍\",{\"1\":{\"1142\":1}}],[\"那就再重派一个信使\",{\"1\":{\"1105\":1}}],[\"那就和\",{\"1\":{\"1068\":1}}],[\"那就一直往前遍历\",{\"1\":{\"1013\":1}}],[\"那就唤醒当前节点的后继节点\",{\"1\":{\"1013\":1}}],[\"那就证明任务还没有执行完毕\",{\"1\":{\"752\":1,\"908\":1}}],[\"那就类似于可有可无的生活用品\",{\"1\":{\"392\":2,\"884\":1}}],[\"那就类似于必不可少的生活用品\",{\"1\":{\"392\":1}}],[\"那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小\",{\"1\":{\"388\":1}}],[\"那\",{\"1\":{\"266\":1,\"444\":1,\"781\":1,\"843\":1,\"992\":1}}],[\"那用户购物车信息的维护具体应该怎么操作呢\",{\"1\":{\"257\":1}}],[\"那这样是不是要保证\",{\"1\":{\"1275\":1}}],[\"那这就是第二个坑了\",{\"1\":{\"1264\":1}}],[\"那这就要从它们之间的区别开始说起\",{\"1\":{\"1155\":1}}],[\"那这几种消息队列中\",{\"1\":{\"1240\":1}}],[\"那这么说的话\",{\"1\":{\"1155\":1}}],[\"那这里有几个问题大家可以思考一下\",{\"1\":{\"1026\":1}}],[\"那这时就要改为进行一次\",{\"1\":{\"388\":1}}],[\"那这一次\",{\"1\":{\"388\":1}}],[\"那这两个类就必定不相同\",{\"1\":{\"357\":1}}],[\"那这部分数据就算丢失了\",{\"1\":{\"229\":1}}],[\"那这多余出来的\",{\"1\":{\"217\":1}}],[\"那这个指针就不工作了\",{\"1\":{\"435\":1}}],[\"那这个\",{\"1\":{\"163\":1,\"291\":1,\"296\":2,\"418\":1}}],[\"那肯定是不行的\",{\"1\":{\"145\":1}}],[\"那图1的每一行数据row跟图2比较\",{\"1\":{\"141\":1}}],[\"那么跳过那些已经被丢弃的提案又是什么意思呢\",{\"1\":{\"1380\":1}}],[\"那么跳表就是你不二的选择\",{\"1\":{\"800\":1}}],[\"那么肯定会产生数据不一致性\",{\"1\":{\"1380\":1}}],[\"那么肯定会觉得是null\",{\"1\":{\"1030\":1}}],[\"那么说完了\",{\"1\":{\"1380\":1}}],[\"那么说明整个班级系统出现了数据不一致的问题\",{\"1\":{\"1368\":1}}],[\"那么说明产生了hash冲突\",{\"1\":{\"1037\":1}}],[\"那么说明这个值在布隆过滤器中\",{\"1\":{\"307\":1}}],[\"那么此时\",{\"1\":{\"1374\":1}}],[\"那么此时协调者将会给所有参与者发送\",{\"1\":{\"1370\":1}}],[\"那么协调者将会给所有参与者发送\",{\"1\":{\"1371\":1}}],[\"那么协调者将向所有参与者发送\",{\"1\":{\"1371\":1}}],[\"那么新加入的服务器就会自觉地进入数据恢复模式\",{\"1\":{\"1361\":1}}],[\"那么新增模块或者修改模块就对其他模块影响较小\",{\"1\":{\"1222\":1}}],[\"那么整个集群会如何重新选举\",{\"1\":{\"1380\":1}}],[\"那么整个服务框架就可以进入消息广播模式了\",{\"1\":{\"1361\":1}}],[\"那么整个处理流程的时间消耗就是\",{\"1\":{\"1271\":1}}],[\"那么最大允许宕掉\",{\"1\":{\"1357\":2}}],[\"那么最终\",{\"1\":{\"835\":1}}],[\"那么最终的结果是\",{\"1\":{\"694\":1}}],[\"那么也就是剩下的服务数必须大于\",{\"1\":{\"1357\":1}}],[\"那么也就意味着\",{\"1\":{\"1370\":1}}],[\"那么也就意味着整个系统不能再生产了\",{\"1\":{\"1314\":1}}],[\"那么也就意味着我们同时也会出现一万调用发短信服务的请求\",{\"1\":{\"1273\":1}}],[\"那么之前创建的会话仍然有效\",{\"1\":{\"1353\":1}}],[\"那么本文将带你回顾一下\",{\"1\":{\"1341\":1}}],[\"那么本文将会是你进入\",{\"1\":{\"1341\":1}}],[\"那么消息被一个消费者组消费完之后是不会删除的\",{\"1\":{\"1280\":1}}],[\"那么消息会路由到\",{\"1\":{\"1252\":1}}],[\"那么有没有好的方法去解决这一个问题呢\",{\"1\":{\"1279\":1}}],[\"那么你觉得现在这个短信系统能承受这一万的峰值么\",{\"1\":{\"1273\":1}}],[\"那么你就无法区分这个值是否是真正存储在\",{\"1\":{\"693\":1}}],[\"那么你就无法区分这个键是否存在于\",{\"1\":{\"693\":1}}],[\"那么我\",{\"1\":{\"1275\":1}}],[\"那么我这个时候不要发邮件这个服务了呢\",{\"1\":{\"1272\":1}}],[\"那么我们可以使用在其父节点绑定的\",{\"1\":{\"1390\":1}}],[\"那么我们的订单系统怎么能知道积分系统的收到消息的情况呢\",{\"1\":{\"1370\":1}}],[\"那么我们的\",{\"1\":{\"400\":1,\"1379\":1}}],[\"那么我们就可以很放心地将该用户访问的数据存在缓存中\",{\"1\":{\"246\":1}}],[\"那么我们就认为\",{\"1\":{\"51\":1}}],[\"那么第二步\",{\"1\":{\"1272\":1}}],[\"那么第一个操作的执行结果将对第二个操作可见\",{\"1\":{\"974\":1}}],[\"那么第一个事务两次读到的的数据可能是不一样的\",{\"1\":{\"128\":1}}],[\"那么那个实例会从\",{\"1\":{\"1263\":1}}],[\"那么问题又来了\",{\"1\":{\"1159\":1}}],[\"那么问题来了\",{\"1\":{\"136\":1}}],[\"那么可能会无限重复下去\",{\"1\":{\"1111\":1}}],[\"那么可以简单地说系统整体效率只有\",{\"1\":{\"816\":1}}],[\"那么可以表示的空间范围为\",{\"1\":{\"19\":1}}],[\"那么会拒绝该请求并让该节点更新\",{\"1\":{\"1111\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"616\":1,\"645\":1,\"677\":1,\"683\":3}}],[\"那么他会更新到较大的\",{\"1\":{\"1109\":1}}],[\"那么学习者就需要接受这个提议\",{\"1\":{\"1098\":1}}],[\"那么强一致性和可用性只能\",{\"1\":{\"1068\":1}}],[\"那么threadlocalmap当然也要实现自己的hash算法来解决散列表数组冲突问题\",{\"1\":{\"1032\":1}}],[\"那么又有新问题了\",{\"1\":{\"1012\":1}}],[\"那么设置\",{\"1\":{\"1011\":1}}],[\"那么设计时就需要考虑兑换码的字符数\",{\"1\":{\"19\":1}}],[\"那么另外的线程都是立即可以看到修改后的最新值\",{\"1\":{\"979\":1}}],[\"那么主线程执行\",{\"1\":{\"958\":1}}],[\"那么当积分系统收到消息后返回给订单系统一个\",{\"1\":{\"1370\":1}}],[\"那么当\",{\"1\":{\"1281\":1}}],[\"那么当前线程是可以获取资源的\",{\"1\":{\"1011\":1}}],[\"那么当前任务会被拒绝\",{\"1\":{\"893\":1,\"941\":1}}],[\"那么当线程请求栈的深度超过当前\",{\"1\":{\"493\":2}}],[\"那么访问这个变量的每个线程都会有这个变量的本地副本\",{\"1\":{\"881\":1}}],[\"那么选择\",{\"1\":{\"862\":1}}],[\"那么开很多线程会提高效率\",{\"1\":{\"819\":1}}],[\"那么开很多线程会影响效率\",{\"1\":{\"819\":1}}],[\"那么多个线程同时运行可以利用\",{\"1\":{\"819\":1}}],[\"那么多个线程同时运行会导致频繁的线程切换\",{\"1\":{\"819\":1}}],[\"那么多余的线程将会被放入等待队列\",{\"1\":{\"749\":1}}],[\"那么程序计数器记录的是\",{\"1\":{\"811\":1}}],[\"那么程序运行的时候\",{\"1\":{\"358\":1}}],[\"那么任务\",{\"1\":{\"781\":1}}],[\"那么自旋的线程便会判断成功\",{\"1\":{\"749\":1}}],[\"那么线程\",{\"1\":{\"742\":2}}],[\"那么调用iteratorbinarysearch\",{\"1\":{\"658\":1}}],[\"那么建议这种方式\",{\"1\":{\"625\":1}}],[\"那么返回true\",{\"1\":{\"592\":1}}],[\"那么添加该元素\",{\"1\":{\"588\":1}}],[\"那么频繁的插入会导致频繁的拷贝\",{\"1\":{\"553\":1}}],[\"那么非空条件就会将这个线程挂起\",{\"1\":{\"535\":1}}],[\"那么需要安装jdk就行了\",{\"1\":{\"516\":1}}],[\"那么需要约定编码空间\",{\"1\":{\"19\":1}}],[\"那么对数据准确性会造成极其轻微的影响\",{\"1\":{\"1240\":1}}],[\"那么对象可以直接在栈上分配内存\",{\"1\":{\"495\":1}}],[\"那么对于一些非唯一索引列\",{\"1\":{\"118\":1}}],[\"那么排查错误将会是一个非常艰巨的任务\",{\"1\":{\"490\":1}}],[\"那么只能被回收了\",{\"1\":{\"446\":1}}],[\"那么二次标记时则会将它移出\",{\"1\":{\"446\":1}}],[\"那么垃圾收集器就是内存回收的具体实现\",{\"1\":{\"400\":1}}],[\"那么如何解决呢\",{\"1\":{\"1375\":1}}],[\"那么如何给业务实现幂等呢\",{\"1\":{\"1303\":1}}],[\"那么如何判断一个类是无用的类的呢\",{\"1\":{\"394\":1}}],[\"那么如果这个峰值太大了导致消息堆积在队列中怎么办呢\",{\"1\":{\"1305\":1}}],[\"那么如果此时我有几个消息分别是同一个订单的创建\",{\"1\":{\"1299\":1}}],[\"那么如果被中断过的话\",{\"1\":{\"1015\":1}}],[\"那么如果索引列上存在null值\",{\"1\":{\"118\":1}}],[\"那么就\",{\"1\":{\"1374\":1}}],[\"那么就要从\",{\"1\":{\"1206\":1}}],[\"那么就要考虑对数组的扩增了\",{\"1\":{\"619\":1}}],[\"那么就将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"1004\":1}}],[\"那么就将计数器减\",{\"1\":{\"756\":1,\"911\":1}}],[\"那么就一定会有某种队列形成\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"那么就把该任务放入到任务队列里等待执行\",{\"1\":{\"893\":1,\"941\":1}}],[\"那么就把最小需要容量当作数组的新容量\",{\"1\":{\"553\":1,\"558\":1}}],[\"那么就会进行中断请求的发送\",{\"1\":{\"1371\":1}}],[\"那么就会中断事务\",{\"1\":{\"1371\":1}}],[\"那么就会出现一个问题\",{\"1\":{\"1369\":1}}],[\"那么就会被回收\",{\"1\":{\"1030\":1}}],[\"那么就会新建一个线程来执行任务\",{\"1\":{\"893\":1,\"941\":1}}],[\"那么就会阻塞\",{\"1\":{\"163\":1,\"292\":1}}],[\"那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制\",{\"1\":{\"742\":1,\"904\":1}}],[\"那么就可以在所引用的对象的内存被回收之前采取必要的行动\",{\"1\":{\"392\":1}}],[\"那么它将会将\",{\"1\":{\"1374\":1}}],[\"那么它这个时候会向所有的\",{\"1\":{\"1374\":1}}],[\"那么它们前面的\",{\"1\":{\"1112\":1}}],[\"那么它们一定有相同的\",{\"1\":{\"1112\":1}}],[\"那么它会一直保持为\",{\"1\":{\"1111\":1}}],[\"那么它会拒绝此次请求\",{\"1\":{\"1109\":1}}],[\"那么它会抛出一个\",{\"1\":{\"357\":1}}],[\"那么它的存储结构和实现原理是怎么样的呢\",{\"1\":{\"567\":1}}],[\"那么它有什么特别之处呢\",{\"1\":{\"403\":1}}],[\"那么它就和没有任何引用一样\",{\"1\":{\"392\":1}}],[\"那么内存回收时就必须能识别哪些对象应放在新生代\",{\"1\":{\"386\":1}}],[\"那么该类是通过\",{\"1\":{\"353\":1}}],[\"那么准备阶段\",{\"1\":{\"342\":1}}],[\"那么虚拟机是如何加载这些\",{\"1\":{\"339\":1}}],[\"那么这三阶段又分别是什么呢\",{\"1\":{\"1371\":1}}],[\"那么这时候就会产生数据不一致性问题\",{\"1\":{\"1370\":1}}],[\"那么这些资源都不会再释放了\",{\"1\":{\"1370\":1}}],[\"那么这些服务器就可以看作完全功能可用的\",{\"1\":{\"1106\":1}}],[\"那么这里会有个问题\",{\"1\":{\"1207\":1}}],[\"那么这两个操作就没有顺序的保障\",{\"1\":{\"975\":1}}],[\"那么这个节点必须无子节点才行\",{\"1\":{\"1331\":1}}],[\"那么这个可用性的问题能否解决呢\",{\"1\":{\"1314\":1}}],[\"那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费\",{\"1\":{\"1275\":1}}],[\"那么这个\",{\"1\":{\"1210\":1,\"1281\":2}}],[\"那么这个消息理论上就会被消费两次\",{\"1\":{\"1205\":1}}],[\"那么这个方法有什么作用呢\",{\"1\":{\"564\":1}}],[\"那么这个变量的\",{\"1\":{\"442\":1}}],[\"那么这个元素一定不在\",{\"1\":{\"307\":1}}],[\"那么这种策略就是一种特殊的编解码策略\",{\"1\":{\"19\":1}}],[\"那么校验和也会随之改变\",{\"1\":{\"234\":1}}],[\"那么每秒会产生\",{\"1\":{\"163\":1,\"292\":1}}],[\"那么索引也会失效\",{\"1\":{\"118\":4}}],[\"那么索引就会失效\",{\"1\":{\"118\":2}}],[\"那么查询就会使用到索引\",{\"1\":{\"116\":1}}],[\"那么一棵高度为\",{\"1\":{\"110\":1}}],[\"那么聚簇索引的优势在哪\",{\"1\":{\"108\":1}}],[\"那么直接返回结果\",{\"1\":{\"85\":1}}],[\"那么在条件允许的情况下\",{\"1\":{\"1389\":1}}],[\"那么在threadlocal\",{\"1\":{\"1030\":1}}],[\"那么在\",{\"1\":{\"23\":1,\"752\":1,\"1026\":1}}],[\"那么\",{\"1\":{\"23\":2,\"98\":1,\"117\":1,\"128\":1,\"272\":1,\"342\":1,\"393\":1,\"509\":1,\"604\":1,\"619\":1,\"677\":1,\"881\":1,\"974\":1,\"975\":1,\"1002\":1,\"1030\":1,\"1139\":1,\"1144\":1,\"1272\":1,\"1275\":4,\"1299\":2,\"1303\":1,\"1304\":2,\"1306\":1,\"1314\":1,\"1354\":1,\"1362\":1}}],[\"那么为什么有些单号那么长\",{\"1\":{\"16\":1}}],[\"那么必须考虑使用\",{\"1\":{\"2\":1}}],[\"要获取共享锁\",{\"1\":{\"1388\":1}}],[\"要\",{\"1\":{\"1380\":1}}],[\"要解决一致性问题还需要靠\",{\"1\":{\"1371\":1}}],[\"要学会参考资料的嘛\",{\"1\":{\"1349\":1}}],[\"要连接的服务器列表\",{\"1\":{\"1333\":1}}],[\"要提供一种机制\",{\"1\":{\"1306\":1}}],[\"要提示一下\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"要保证消息的顺序性需要单一生产者串行发送\",{\"1\":{\"1286\":1}}],[\"要实现延迟消息\",{\"1\":{\"1257\":1}}],[\"要实现rc隔离级别\",{\"1\":{\"141\":1}}],[\"要实现rr隔离级别\",{\"1\":{\"141\":1}}],[\"要不就是无锁无界\",{\"1\":{\"1179\":1}}],[\"要发数据的时候就从池里取一条连接出来\",{\"1\":{\"1158\":1}}],[\"要求至少消息复制到半数以上的节点之后\",{\"1\":{\"1314\":1}}],[\"要求其他服务器复制这条\",{\"1\":{\"1112\":1}}],[\"要求编译器和处理器必须禁止这种重排序\",{\"1\":{\"974\":1}}],[\"要注意的是\",{\"1\":{\"1070\":1}}],[\"要执行\",{\"1\":{\"941\":1}}],[\"要修改变量\",{\"1\":{\"841\":1,\"990\":1}}],[\"要更新的变量值\",{\"1\":{\"841\":1,\"990\":1}}],[\"要更新数据值时\",{\"1\":{\"840\":1,\"989\":1}}],[\"要视实际情况而定\",{\"1\":{\"838\":1,\"987\":1}}],[\"要想搞懂\",{\"1\":{\"1199\":1}}],[\"要想理解透彻\",{\"1\":{\"967\":1}}],[\"要想让\",{\"1\":{\"897\":1}}],[\"要想原子地更新对象的属性需要两步\",{\"1\":{\"768\":1}}],[\"要想获取\",{\"1\":{\"368\":1}}],[\"要与线程个数一致\",{\"1\":{\"742\":1,\"904\":1}}],[\"要通过\",{\"1\":{\"708\":1}}],[\"要比十万级甚至是百万级的\",{\"1\":{\"1240\":1}}],[\"要比\",{\"1\":{\"677\":1}}],[\"要尽量避免\",{\"1\":{\"624\":1}}],[\"要复制的长度\",{\"1\":{\"562\":1}}],[\"要复制的数组\",{\"1\":{\"562\":1}}],[\"要复制的数组元素的数量\",{\"1\":{\"561\":2}}],[\"要大\",{\"1\":{\"557\":1}}],[\"要分配的最大数组大小\",{\"1\":{\"553\":1,\"558\":1}}],[\"要真正宣告一个对象死亡\",{\"1\":{\"391\":1}}],[\"要结合图1和图2一起来看\",{\"1\":{\"141\":1}}],[\"要么整个集群中所有的机器都成功应用了某一个事务\",{\"1\":{\"1345\":1}}],[\"要么都没有应用\",{\"1\":{\"1345\":1}}],[\"要么都执行要么都不执行\",{\"1\":{\"1304\":1}}],[\"要么都不执行\",{\"1\":{\"978\":1}}],[\"要么中断\",{\"1\":{\"1012\":1}}],[\"要么获取锁\",{\"1\":{\"1012\":1}}],[\"要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断\",{\"1\":{\"978\":1}}],[\"要么是共享方式\",{\"1\":{\"1007\":1}}],[\"要么是共享\",{\"1\":{\"743\":1}}],[\"要么变为\",{\"1\":{\"572\":1}}],[\"要么没有\",{\"1\":{\"331\":1}}],[\"要么有某个修饰符\",{\"1\":{\"331\":1}}],[\"要么完全不起作用\",{\"1\":{\"281\":1}}],[\"要么全部不完成\",{\"1\":{\"125\":1}}],[\"要么全部完成\",{\"1\":{\"125\":1}}],[\"要么全部失败\",{\"1\":{\"124\":1}}],[\"要么全部成功\",{\"1\":{\"124\":1}}],[\"要么就是先写完\",{\"1\":{\"89\":1}}],[\"又因为能在分布式的情况下\",{\"1\":{\"1388\":1}}],[\"又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者\",{\"1\":{\"1280\":1}}],[\"又重新恢复了\",{\"1\":{\"1380\":1}}],[\"又广播了一个请求\",{\"1\":{\"1379\":1}}],[\"又自增进入\",{\"1\":{\"1375\":1}}],[\"又批准了新的\",{\"1\":{\"1375\":1}}],[\"又是什么呢\",{\"1\":{\"1312\":1}}],[\"又带来一系列的重复消费\",{\"1\":{\"1275\":1}}],[\"又如何\",{\"1\":{\"1275\":2}}],[\"又\",{\"1\":{\"1275\":2}}],[\"又得重启应用\",{\"1\":{\"1272\":1}}],[\"又译中间件\",{\"1\":{\"1218\":1}}],[\"又或者你是不懂消息队列的新手\",{\"1\":{\"1217\":1}}],[\"又存在于\",{\"1\":{\"1202\":1}}],[\"又避免了常见的并发问题和性能瓶颈\",{\"1\":{\"1184\":1}}],[\"又好像没看的感觉\",{\"1\":{\"1150\":1}}],[\"又有新的任务提交\",{\"1\":{\"937\":1}}],[\"又有修改请求时必须有一种措施来进行并发控制\",{\"1\":{\"140\":1}}],[\"又实现了\",{\"1\":{\"934\":1}}],[\"又读取了\",{\"1\":{\"835\":1}}],[\"又继承自\",{\"1\":{\"796\":1}}],[\"又继承于\",{\"1\":{\"727\":1}}],[\"又要保证\",{\"1\":{\"708\":1}}],[\"又能拥有实例变量\",{\"1\":{\"520\":1}}],[\"又想拥有缺省的方法\",{\"1\":{\"520\":1}}],[\"又让我涨姿势了\",{\"1\":{\"412\":1}}],[\"又会动态缩小不过不会小于\",{\"1\":{\"451\":1}}],[\"又会委托给\",{\"1\":{\"358\":1}}],[\"又会影响到性能\",{\"1\":{\"48\":1}}],[\"又可以很好地与\",{\"1\":{\"265\":1}}],[\"又不希望出现重复数据时\",{\"1\":{\"188\":1}}],[\"又叫做\",{\"1\":{\"140\":2,\"1154\":1}}],[\"他发送给了\",{\"1\":{\"1380\":1}}],[\"他说分布式不就是加机器吗\",{\"1\":{\"1367\":1}}],[\"他直接\",{\"1\":{\"1315\":1}}],[\"他要求在写入消息的时候\",{\"1\":{\"1314\":1}}],[\"他是可以修改内核缓冲区的数据的\",{\"1\":{\"1311\":1}}],[\"他就像一个无头苍蝇一样\",{\"1\":{\"1304\":1}}],[\"他会立即退回成\",{\"1\":{\"1109\":1}}],[\"他虚拟了一个叫做\",{\"1\":{\"1096\":1}}],[\"他们也会比较自己的投票和收到的投票\",{\"1\":{\"1380\":1}}],[\"他们也只需实现tryacquire\",{\"1\":{\"743\":1}}],[\"他们可能\",{\"1\":{\"1152\":1}}],[\"他们可以使用\",{\"1\":{\"881\":1}}],[\"他们就给兰伯特说\",{\"1\":{\"1096\":1}}],[\"他们会开始执行事务\",{\"1\":{\"1370\":1}}],[\"他们会随着竞争的激烈而逐渐升级\",{\"1\":{\"854\":1}}],[\"他们会共同获取相同的指针指向相同的资源\",{\"1\":{\"585\":1}}],[\"他们同时都想申请对方的资源\",{\"1\":{\"823\":1}}],[\"他们已经完成了各自的任务\",{\"1\":{\"753\":1}}],[\"他们的值是\",{\"1\":{\"570\":1}}],[\"他正好跟前面所说的重做日志所记录的相反\",{\"1\":{\"137\":1}}],[\"他认为这是一个很差的分布式锁实现\",{\"1\":{\"51\":1}}],[\"叫做回滚日志\",{\"1\":{\"137\":1}}],[\"缓刑阶段\",{\"1\":{\"391\":1}}],[\"缓冲区数据拷贝至网卡\",{\"1\":{\"1308\":1}}],[\"缓冲区的状态\",{\"1\":{\"230\":1}}],[\"缓冲区的数据写入到\",{\"1\":{\"230\":1}}],[\"缓冲区根据对应的持久化方式\",{\"1\":{\"230\":1}}],[\"缓冲区中\",{\"1\":{\"230\":1}}],[\"缓冲区\",{\"1\":{\"161\":1,\"229\":1,\"1308\":1,\"1310\":1,\"1311\":1}}],[\"缓冲池\",{\"1\":{\"136\":1}}],[\"缓存命中\",{\"1\":{\"1184\":1}}],[\"缓存是通过将最近使用的数据存储在高速缓存中来实现更快的读取速度\",{\"1\":{\"1184\":1}}],[\"缓存结构的特点\",{\"1\":{\"1184\":1}}],[\"缓存行\",{\"1\":{\"1184\":1}}],[\"缓存内部是按照\",{\"1\":{\"1184\":1}}],[\"缓存的局部性原理\",{\"1\":{\"1184\":1}}],[\"缓存的是内存数据用于解决\",{\"1\":{\"968\":1}}],[\"缓存一致性协议\",{\"1\":{\"968\":1}}],[\"缓存则是为了解决\",{\"1\":{\"968\":1}}],[\"缓存模型非常相似\",{\"1\":{\"972\":1}}],[\"缓存模型\",{\"1\":{\"969\":1}}],[\"缓存模型示意图\",{\"1\":{\"968\":1,\"1184\":1}}],[\"缓存模型绘图不严谨的地方进行完善\",{\"1\":{\"968\":1}}],[\"缓存模型说起\",{\"0\":{\"968\":1}}],[\"缓存模型和指令重排序\",{\"1\":{\"967\":1}}],[\"缓存容量有限\",{\"1\":{\"706\":1}}],[\"缓存工具\",{\"1\":{\"702\":1}}],[\"缓存和数据库一致性问题\",{\"1\":{\"316\":1}}],[\"缓存失效时间变短\",{\"1\":{\"316\":1}}],[\"缓存永不失效\",{\"1\":{\"314\":1}}],[\"缓存服务宕机也会导致缓存雪崩现象\",{\"1\":{\"313\":1}}],[\"缓存在同一时间大面积的失效\",{\"1\":{\"313\":1}}],[\"缓存雪崩和缓存击穿比较像\",{\"1\":{\"315\":1}}],[\"缓存雪崩和缓存击穿有什么区别\",{\"0\":{\"315\":1}}],[\"缓存雪崩描述的就是这样一个简单的场景\",{\"1\":{\"313\":1}}],[\"缓存雪崩\",{\"0\":{\"312\":1},\"1\":{\"313\":1}}],[\"缓存中的某个秒杀商品的数据突然过期\",{\"1\":{\"309\":1}}],[\"缓存击穿导致的原因主要是某个热点数据不存在与缓存中\",{\"1\":{\"315\":1}}],[\"缓存击穿中\",{\"1\":{\"309\":1,\"311\":1}}],[\"缓存击穿\",{\"0\":{\"308\":1},\"1\":{\"309\":1}}],[\"缓存空对象\",{\"1\":{\"307\":1}}],[\"缓存为空\",{\"1\":{\"307\":1}}],[\"缓存无效\",{\"1\":{\"307\":1}}],[\"缓存穿透中\",{\"1\":{\"311\":1}}],[\"缓存穿透和缓存击穿有什么区别\",{\"0\":{\"311\":1}}],[\"缓存穿透说简单点就是大量请求的\",{\"1\":{\"306\":1}}],[\"缓存穿透\",{\"0\":{\"305\":1},\"1\":{\"306\":1}}],[\"缓存相同数量的对象数据\",{\"1\":{\"255\":1}}],[\"缓存之后很容易达到\",{\"1\":{\"246\":1}}],[\"缓存\",{\"0\":{\"706\":1,\"718\":1},\"1\":{\"178\":1,\"706\":1,\"718\":1,\"833\":1}}],[\"缓存基础\",{\"1\":{\"150\":1}}],[\"缓存基础常见面试题总结\",{\"0\":{\"150\":1}}],[\"缓存常用的\",{\"1\":{\"144\":1}}],[\"缓存策略等\",{\"1\":{\"6\":1}}],[\"吞吐量\",{\"1\":{\"1240\":1}}],[\"吞吐量低\",{\"1\":{\"132\":1}}],[\"吞吐量大大提高\",{\"1\":{\"872\":1}}],[\"吞吐量大\",{\"1\":{\"22\":1}}],[\"串之间是\",{\"1\":{\"1152\":1}}],[\"串\",{\"1\":{\"1152\":1,\"1159\":3}}],[\"串行垃圾收集器\",{\"1\":{\"482\":1}}],[\"串行\",{\"1\":{\"401\":1,\"909\":1}}],[\"串行化\",{\"1\":{\"132\":2}}],[\"串联性以及后续数据库可以自发性地完成预定的工作\",{\"1\":{\"125\":1}}],[\"隔离型是怎么实现的等等\",{\"1\":{\"133\":1}}],[\"隔离级别\",{\"0\":{\"132\":1}}],[\"隔离性的目的也是为了保障数据的一致性\",{\"1\":{\"133\":1}}],[\"隔离性来实现的\",{\"1\":{\"133\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"125\":1}}],[\"隔离性之后\",{\"1\":{\"125\":1}}],[\"隔离性\",{\"1\":{\"125\":2,\"281\":2}}],[\"例子1\",{\"1\":{\"129\":1}}],[\"例如著名的\",{\"1\":{\"1343\":1}}],[\"例如由于\",{\"1\":{\"1306\":1}}],[\"例如抛异常等行为\",{\"1\":{\"1292\":1}}],[\"例如根据不同的错误类型\",{\"1\":{\"1212\":1}}],[\"例如计算机\",{\"1\":{\"1139\":1}}],[\"例如已完成任务的数量\",{\"1\":{\"887\":1,\"933\":1}}],[\"例如先判断某个键是否存在containskey\",{\"1\":{\"694\":1}}],[\"例如提交\",{\"1\":{\"599\":1}}],[\"例如这个对象是哪个类的实例\",{\"1\":{\"505\":1}}],[\"例如对索引列进行加减乘除等操作\",{\"1\":{\"118\":1}}],[\"例如在\",{\"1\":{\"296\":1}}],[\"例如在索引列上使用了upper\",{\"1\":{\"118\":1}}],[\"例如在索引列上使用函数操作或者使用了自定义函数\",{\"1\":{\"118\":1}}],[\"例如在一个字符串类型的索引列上执行了数值比较\",{\"1\":{\"118\":2}}],[\"例如在最坏情况下\",{\"1\":{\"97\":1}}],[\"例如ceil\",{\"1\":{\"99\":1}}],[\"例如修改响应内容或响应头\",{\"1\":{\"73\":1}}],[\"例如参数校验\",{\"1\":{\"73\":1}}],[\"例如服务名称\",{\"1\":{\"72\":1}}],[\"例如商品库存\",{\"1\":{\"60\":1}}],[\"例如原来很长的网址通过短网址服务即可生成相应的短网址\",{\"1\":{\"24\":1}}],[\"例如双\",{\"1\":{\"19\":1}}],[\"例如限流\",{\"1\":{\"7\":1}}],[\"例如\",{\"1\":{\"2\":1,\"5\":1,\"68\":1,\"128\":1,\"157\":2,\"287\":1,\"294\":2,\"301\":2,\"359\":2,\"429\":1,\"445\":1,\"452\":1,\"453\":1,\"484\":1,\"485\":1,\"535\":1,\"541\":1,\"651\":1,\"694\":1,\"781\":1,\"834\":1}}],[\"惊奇的发现这些数据已经存在了\",{\"1\":{\"129\":1}}],[\"备注\",{\"1\":{\"127\":1,\"128\":1,\"129\":1,\"1222\":1}}],[\"余额被更改为3000元\",{\"1\":{\"127\":1}}],[\"余额被更改为1000元\",{\"1\":{\"127\":1}}],[\"余额变更为2000元\",{\"1\":{\"127\":1}}],[\"读请求监听比自己小的最后一个写请求节点\",{\"1\":{\"1388\":1}}],[\"读者可以自己去了解一下\",{\"1\":{\"1374\":1}}],[\"读者可以自己去了解\",{\"1\":{\"1314\":1}}],[\"读者可自行参阅源码及注释\",{\"1\":{\"604\":1}}],[\"读者可自行参阅\",{\"1\":{\"603\":1,\"604\":1}}],[\"读时修复\",{\"1\":{\"1078\":1}}],[\"读出来的就是什么\",{\"1\":{\"1078\":1}}],[\"读也是以threadlocal作为引用\",{\"1\":{\"1029\":1}}],[\"读读不互斥\",{\"1\":{\"865\":1}}],[\"读读互斥\",{\"1\":{\"865\":1}}],[\"读操作的性能就可以大幅度提升\",{\"1\":{\"584\":1,\"793\":1}}],[\"读数据\",{\"1\":{\"145\":1}}],[\"读取到的是线程\",{\"1\":{\"972\":1}}],[\"读取到就直接返回\",{\"1\":{\"145\":1,\"146\":1}}],[\"读取变量\",{\"1\":{\"972\":1}}],[\"读取值之前\",{\"1\":{\"969\":1}}],[\"读取元素\",{\"0\":{\"589\":1}}],[\"读取操作往往是远大于写入操作的\",{\"1\":{\"584\":1,\"793\":1}}],[\"读取一个静态字段\",{\"1\":{\"344\":1}}],[\"读取\",{\"1\":{\"265\":1,\"267\":1,\"835\":1,\"972\":1,\"1362\":1}}],[\"读取不到的话\",{\"1\":{\"146\":1}}],[\"读取未提交数据\",{\"0\":{\"127\":1}}],[\"读\",{\"1\":{\"145\":1,\"146\":1,\"265\":1,\"788\":1,\"1344\":2,\"1362\":2}}],[\"读写其实就变成\",{\"1\":{\"1310\":1}}],[\"读写其实就是\",{\"1\":{\"1308\":1}}],[\"读写互斥\",{\"1\":{\"584\":1,\"793\":1,\"865\":2}}],[\"读写分离\",{\"1\":{\"299\":1}}],[\"读写性能\",{\"1\":{\"264\":1,\"267\":1}}],[\"读写穿透\",{\"0\":{\"146\":1}}],[\"读写不冲突\",{\"1\":{\"141\":1}}],[\"读写锁的源码分析\",{\"1\":{\"868\":1}}],[\"读写锁的设计思想非常类似\",{\"1\":{\"584\":1,\"793\":1}}],[\"读写锁进行并发控制的规则\",{\"1\":{\"865\":1}}],[\"读写锁+mvcc\",{\"1\":{\"133\":1}}],[\"读写锁\",{\"1\":{\"50\":1,\"140\":1,\"996\":1}}],[\"读锁为什么不能升级为写锁\",{\"0\":{\"869\":1}}],[\"读锁可以被同时读\",{\"1\":{\"865\":1}}],[\"读锁是共享锁\",{\"1\":{\"865\":1}}],[\"读锁是可以共享的\",{\"1\":{\"140\":1}}],[\"读锁\",{\"1\":{\"140\":1,\"865\":1,\"871\":3}}],[\"读已提交\",{\"1\":{\"132\":2}}],[\"读未提交\",{\"1\":{\"132\":2}}],[\"读提交\",{\"1\":{\"125\":1}}],[\"包装后\",{\"1\":{\"1222\":1}}],[\"包丢失\",{\"1\":{\"1106\":1}}],[\"包已经支持所谓的平台线程\",{\"1\":{\"1053\":1}}],[\"包它有一个compare\",{\"1\":{\"661\":1}}],[\"包下\",{\"1\":{\"773\":1,\"899\":1}}],[\"包下面\",{\"1\":{\"740\":1,\"903\":1}}],[\"包下的并发集合\",{\"1\":{\"695\":1,\"698\":1}}],[\"包下的某些集合\",{\"1\":{\"629\":1}}],[\"包下常见并发容器的总结\",{\"1\":{\"583\":1}}],[\"包中\",{\"1\":{\"791\":1}}],[\"包中引入了新的时间类\",{\"1\":{\"598\":1}}],[\"包中的原子类分为\",{\"1\":{\"762\":1}}],[\"包中的一部分\",{\"1\":{\"598\":1}}],[\"包中的类时不管是哪个加载器加载\",{\"1\":{\"433\":1}}],[\"包\",{\"1\":{\"359\":1,\"365\":1,\"432\":2,\"529\":1,\"583\":1,\"597\":1,\"793\":1}}],[\"包和类以及被\",{\"1\":{\"353\":1}}],[\"包和类\",{\"1\":{\"353\":2}}],[\"包的方法对类进行反射调用时如\",{\"1\":{\"344\":1}}],[\"包括事务\",{\"1\":{\"1349\":1}}],[\"包括重试次数\",{\"1\":{\"1297\":1}}],[\"包括消费成功和失败\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"包括c++\",{\"1\":{\"1171\":1}}],[\"包括网络延迟\",{\"1\":{\"1106\":1}}],[\"包括在线状态\",{\"1\":{\"1085\":1}}],[\"包括任务执行机制的核心接口\",{\"1\":{\"934\":1}}],[\"包括其他类\",{\"1\":{\"895\":1,\"922\":1}}],[\"包括执行一个任务\",{\"1\":{\"887\":1}}],[\"包括三步\",{\"1\":{\"835\":1}}],[\"包括自己编写的\",{\"1\":{\"341\":1}}],[\"包括\",{\"1\":{\"329\":1,\"449\":1,\"551\":1,\"652\":1,\"860\":1,\"969\":1}}],[\"包括下面三类常量\",{\"1\":{\"328\":1}}],[\"包括读写\",{\"1\":{\"298\":1}}],[\"包括读未提交\",{\"1\":{\"125\":1}}],[\"包括原子性是怎么实现的\",{\"1\":{\"133\":1}}],[\"包含<index\",{\"1\":{\"1112\":1}}],[\"包含要修改field的对象\",{\"1\":{\"841\":1,\"990\":1}}],[\"包含一个\",{\"1\":{\"690\":1}}],[\"包含两个指针\",{\"1\":{\"657\":1}}],[\"包含另一个\",{\"1\":{\"621\":1}}],[\"包含抽象方法的类\",{\"1\":{\"520\":1}}],[\"包含元素最多的复合数据类型\",{\"1\":{\"293\":1}}],[\"包含的元素超过\",{\"1\":{\"163\":1,\"291\":1}}],[\"包含锁的信息和加锁的次数\",{\"1\":{\"56\":1}}],[\"包含\",{\"1\":{\"37\":1,\"344\":1,\"353\":1,\"524\":1,\"1263\":1}}],[\"回答了消息队列副作用的解决方案\",{\"1\":{\"1316\":1}}],[\"回溯消费是指\",{\"1\":{\"1306\":1}}],[\"回想一下\",{\"1\":{\"1271\":1}}],[\"回应开头的那个问题\",{\"1\":{\"1030\":1}}],[\"回到最初同步调用的过程\",{\"1\":{\"1272\":1}}],[\"回到最初的源码\",{\"1\":{\"1012\":1}}],[\"回到最开始\",{\"1\":{\"1210\":1}}],[\"回到上边的代码\",{\"1\":{\"1011\":1}}],[\"回复\",{\"1\":{\"835\":1}}],[\"回收场景\",{\"1\":{\"1030\":1}}],[\"回收过程才会停止\",{\"1\":{\"890\":1}}],[\"回收\",{\"1\":{\"711\":1,\"712\":1,\"731\":3,\"732\":1,\"884\":1}}],[\"回收效率太低\",{\"1\":{\"498\":1}}],[\"回收新生代停顿长达\",{\"1\":{\"448\":1}}],[\"回收器回收同样大小的新生代只停顿\",{\"1\":{\"448\":1}}],[\"回收器回收他们\",{\"1\":{\"390\":1}}],[\"回收器停顿时间最短而且没有明显缺点\",{\"1\":{\"448\":1}}],[\"回收策略等等\",{\"1\":{\"402\":1}}],[\"回收速度一般也比较快\",{\"1\":{\"375\":1}}],[\"回顾一下类加载过程\",{\"0\":{\"349\":1}}],[\"回顾一下字节码\",{\"0\":{\"324\":1}}],[\"回滚它在第一阶段所做的事务处理\",{\"1\":{\"1370\":1}}],[\"回滚事务的\",{\"1\":{\"1370\":1}}],[\"回滚\",{\"0\":{\"125\":1}}],[\"回表查询\",{\"0\":{\"112\":1}}],[\"取模法\",{\"1\":{\"1299\":1}}],[\"取已经失败的消费记录集合\",{\"1\":{\"1210\":1}}],[\"取得代之的确实是\",{\"1\":{\"852\":1,\"853\":1}}],[\"取得元素后唤醒\",{\"1\":{\"604\":1}}],[\"取当前值和\",{\"1\":{\"767\":2}}],[\"取余\",{\"1\":{\"684\":1}}],[\"取余的操作来实现\",{\"1\":{\"684\":1}}],[\"取出\",{\"1\":{\"883\":1}}],[\"取出任务并执行\",{\"1\":{\"599\":1}}],[\"取出队头的元素并返回\",{\"1\":{\"533\":1}}],[\"取消状态的节点会从队列中释放\",{\"1\":{\"1016\":1}}],[\"取消任务执行\",{\"1\":{\"773\":1,\"899\":1}}],[\"取消任务\",{\"1\":{\"773\":1,\"899\":1}}],[\"取消了\",{\"1\":{\"691\":1}}],[\"取消了循环\",{\"1\":{\"552\":1,\"642\":1,\"656\":1}}],[\"取消续期\",{\"1\":{\"49\":1}}],[\"取而代之是元空间\",{\"1\":{\"480\":1,\"496\":1}}],[\"取而代之\",{\"1\":{\"393\":1}}],[\"取这个年龄和\",{\"1\":{\"386\":1,\"495\":1}}],[\"取值\",{\"1\":{\"332\":2}}],[\"取决你的负载均衡策略\",{\"1\":{\"1299\":1}}],[\"取决于线程的类型和任务的性质\",{\"1\":{\"819\":1}}],[\"取决于\",{\"1\":{\"503\":2}}],[\"取决\",{\"1\":{\"236\":1}}],[\"取代\",{\"1\":{\"174\":1,\"382\":1,\"495\":1}}],[\"取代的重要原因之一\",{\"1\":{\"124\":1}}],[\"取款操作发生未知错误\",{\"1\":{\"127\":1}}],[\"取款1000元\",{\"1\":{\"127\":1}}],[\"被监听的节点上\",{\"1\":{\"1346\":1}}],[\"被多个线程共享\",{\"1\":{\"1260\":1}}],[\"被点号\",{\"1\":{\"1252\":1}}],[\"被看作是云原生时代实时消息流传输\",{\"1\":{\"1238\":1}}],[\"被越来越多的人认可\",{\"1\":{\"1237\":1}}],[\"被更新为\",{\"1\":{\"1035\":1}}],[\"被回收\",{\"1\":{\"1030\":1}}],[\"被阻塞条件\",{\"1\":{\"1012\":1}}],[\"被放入等待队列\",{\"1\":{\"1012\":1}}],[\"被初始化的时候的默认值\",{\"1\":{\"1005\":1}}],[\"被解除锁定状态的变量才能被其他线程锁定\",{\"1\":{\"972\":1}}],[\"被设置为空\",{\"1\":{\"957\":1}}],[\"被设置为同一个值\",{\"1\":{\"951\":1}}],[\"被线程执行\",{\"1\":{\"943\":1}}],[\"被拒绝的任务\",{\"1\":{\"891\":1,\"936\":1}}],[\"被类的所有实例共享\",{\"1\":{\"848\":1}}],[\"被终止或结束运行\",{\"1\":{\"821\":1}}],[\"被广泛应用于互联网\",{\"1\":{\"1236\":1}}],[\"被广泛应用于各大框架中\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"被广泛应用于分布式缓存方向\",{\"1\":{\"242\":1}}],[\"被广泛使用在\",{\"1\":{\"796\":1}}],[\"被唤醒的线程会重新尝试去修改\",{\"1\":{\"748\":1,\"906\":1}}],[\"被treebin包装\",{\"1\":{\"688\":1}}],[\"被创建了\",{\"1\":{\"1362\":1}}],[\"被创建之后就不能改变它的长度了\",{\"1\":{\"649\":1}}],[\"被创建\",{\"1\":{\"585\":1}}],[\"被通知的线程是由\",{\"1\":{\"544\":1,\"862\":1}}],[\"被称为可重用固定线程数的线程池\",{\"1\":{\"949\":1}}],[\"被称为动态分派\",{\"1\":{\"519\":1}}],[\"被称为静态分派\",{\"1\":{\"519\":1}}],[\"被彻底移除了\",{\"1\":{\"480\":1,\"496\":1}}],[\"被视为\",{\"1\":{\"407\":1}}],[\"被判定为需要执行的对象将会被放在一个队列中进行第二次标记\",{\"1\":{\"391\":1}}],[\"被同一个虚拟机加载\",{\"1\":{\"357\":1}}],[\"被修改的操作发生在事务内部\",{\"1\":{\"280\":1}}],[\"被修改时\",{\"1\":{\"256\":1}}],[\"被删除元素的数量\",{\"1\":{\"157\":1,\"301\":1}}],[\"被\",{\"1\":{\"124\":1,\"174\":1,\"280\":1,\"342\":1,\"344\":1,\"820\":1}}],[\"被嵌入到了\",{\"1\":{\"8\":1}}],[\"事\",{\"1\":{\"876\":1,\"1002\":1,\"1022\":1}}],[\"事实上\",{\"1\":{\"667\":1,\"895\":1,\"922\":1}}],[\"事件通知\",{\"1\":{\"1353\":1}}],[\"事件驱动\",{\"1\":{\"1284\":1}}],[\"事件\",{\"1\":{\"1236\":1}}],[\"事件消费者如何等待新事件的到来\",{\"1\":{\"1182\":1,\"1183\":1}}],[\"事件的生产和消费需要用到\",{\"1\":{\"1182\":1}}],[\"事件工厂用于生产事件\",{\"1\":{\"1182\":1}}],[\"事件机制详解\",{\"1\":{\"265\":1}}],[\"事件处理器\",{\"1\":{\"265\":1}}],[\"事件监听器\",{\"0\":{\"1352\":1},\"1\":{\"53\":1,\"55\":1,\"1352\":2}}],[\"事务发起者首先向协调者发起事务请求\",{\"1\":{\"1370\":1}}],[\"事务反查机制\",{\"1\":{\"1304\":1}}],[\"事务大家都知道吧\",{\"1\":{\"1304\":1}}],[\"事务消息的做法是\",{\"1\":{\"1304\":1}}],[\"事务消息加上事务反查机制\",{\"1\":{\"1304\":1}}],[\"事务消息\",{\"0\":{\"1287\":1}}],[\"事务机制和\",{\"1\":{\"1261\":2}}],[\"事务允许事件流应用将消费\",{\"1\":{\"1223\":1}}],[\"事务可以看作是一个原子操作\",{\"1\":{\"287\":1}}],[\"事务中每个命令都需要发送到服务端\",{\"1\":{\"287\":1}}],[\"事务中的每条命令都会与\",{\"1\":{\"279\":1}}],[\"事务支持持久性吗\",{\"0\":{\"282\":1}}],[\"事务支持原子性吗\",{\"0\":{\"281\":1}}],[\"事务不满足原子性的问题\",{\"1\":{\"281\":1}}],[\"事务其实是不满足原子性的\",{\"1\":{\"281\":1}}],[\"事务是原子操作\",{\"1\":{\"287\":1}}],[\"事务是不支持回滚\",{\"1\":{\"281\":1}}],[\"事务是不建议在日常开发中使用的\",{\"1\":{\"279\":1}}],[\"事务是最小的执行单位\",{\"1\":{\"281\":1}}],[\"事务外部修改\",{\"1\":{\"280\":1}}],[\"事务内部修改\",{\"1\":{\"280\":1}}],[\"事务实现的功能比较鸡肋\",{\"1\":{\"319\":1}}],[\"事务实现的原理\",{\"0\":{\"133\":1}}],[\"事务实际开发中使用的非常少\",{\"1\":{\"279\":1}}],[\"事务提供了一种将多个命令请求打包的功能\",{\"1\":{\"279\":1}}],[\"事务提交操作\",{\"1\":{\"125\":1}}],[\"事务提交\",{\"0\":{\"125\":1}}],[\"事务等功能\",{\"1\":{\"245\":1}}],[\"事务里每次执行查询操作read\",{\"1\":{\"141\":2}}],[\"事务里的任何sql查询结果需要从对应的undo日志版本链里的最新数据开始逐条跟read\",{\"1\":{\"141\":1}}],[\"事务300已经提交\",{\"1\":{\"141\":1}}],[\"事务最终目的是要保障数据的可靠性\",{\"1\":{\"133\":1}}],[\"事务的对比\",{\"1\":{\"287\":1}}],[\"事务的缺陷\",{\"0\":{\"283\":1}}],[\"事务的持久性也是没办法保证的\",{\"1\":{\"282\":1}}],[\"事务的持久性性是通过redolog来实现的\",{\"1\":{\"133\":1}}],[\"事务的原子性确保动作要么全部完成\",{\"1\":{\"281\":1}}],[\"事务的原子性是通过undolog来实现的\",{\"1\":{\"133\":1}}],[\"事务的终极大\",{\"1\":{\"133\":1}}],[\"事务的隔离性是通过\",{\"1\":{\"133\":1}}],[\"事务的目的是保障数据的一致性\",{\"1\":{\"125\":1}}],[\"事务隔离性\",{\"0\":{\"131\":1}}],[\"事务隔离分为不同级别\",{\"1\":{\"125\":1}}],[\"事务在运行错误的情况下\",{\"1\":{\"281\":1}}],[\"事务在插入已经检查过不存在的记录时\",{\"1\":{\"129\":1}}],[\"事务在执行过程中发生错误\",{\"1\":{\"125\":1}}],[\"事务b只能排队等待\",{\"1\":{\"132\":1}}],[\"事务b\",{\"1\":{\"127\":1,\"128\":1,\"129\":1}}],[\"事务a在操作数据库时\",{\"1\":{\"132\":1}}],[\"事务a和事务b\",{\"1\":{\"132\":1}}],[\"事务a多次读取数据总量之后才释放该锁\",{\"1\":{\"130\":1}}],[\"事务a多次读取操作完成后才释放该锁\",{\"1\":{\"130\":1}}],[\"事务a前后两次读取到的数据总量应该一致\",{\"1\":{\"129\":1}}],[\"事务a前后两次读取到的数据应该一致\",{\"1\":{\"128\":1}}],[\"事务a\",{\"1\":{\"127\":1,\"128\":1,\"129\":1}}],[\"事务处理结束后\",{\"1\":{\"125\":1}}],[\"事务四大特性\",{\"1\":{\"125\":1}}],[\"事务回滚\",{\"1\":{\"127\":1}}],[\"事务回滚后\",{\"1\":{\"125\":1}}],[\"事务回滚操作\",{\"1\":{\"125\":1}}],[\"事务就是要保证一组数据库操作\",{\"1\":{\"124\":1}}],[\"事务\",{\"0\":{\"278\":1,\"279\":1,\"280\":1},\"1\":{\"124\":1,\"125\":1,\"280\":2,\"319\":1,\"1223\":1},\"2\":{\"143\":1}}],[\"事务简介\",{\"0\":{\"124\":1}}],[\"联想一下病毒传播\",{\"1\":{\"1084\":1}}],[\"联系\",{\"1\":{\"563\":1}}],[\"联接类型\",{\"1\":{\"120\":1}}],[\"联合使用才能最终生效\",{\"1\":{\"1249\":1}}],[\"联合使用\",{\"1\":{\"392\":3,\"884\":1}}],[\"联合查询\",{\"1\":{\"120\":1}}],[\"联合索引要正确使用需满足最左匹配原则\",{\"1\":{\"118\":1}}],[\"联合索引\",{\"1\":{\"104\":1}}],[\"联合商品\",{\"1\":{\"19\":1}}],[\"联合商品兑换券码\",{\"1\":{\"16\":1}}],[\"预提交请求\",{\"1\":{\"1371\":1}}],[\"预期值\",{\"1\":{\"841\":1,\"990\":1}}],[\"预示着他除了运行监视\",{\"1\":{\"377\":1}}],[\"预防内存交换的方法\",{\"1\":{\"168\":1}}],[\"预计要读取的行数\",{\"1\":{\"120\":1}}],[\"预先生成\",{\"1\":{\"19\":1}}],[\"预先生成的券码具备以下特性\",{\"1\":{\"19\":1}}],[\"键和\",{\"1\":{\"677\":1}}],[\"键不能重复\",{\"1\":{\"625\":1}}],[\"键\",{\"1\":{\"271\":1,\"619\":1}}],[\"键值对数据\",{\"1\":{\"242\":1}}],[\"键值对\",{\"1\":{\"184\":1,\"195\":1}}],[\"键是null\",{\"1\":{\"120\":1}}],[\"键自增\",{\"1\":{\"24\":1}}],[\"子线程并没有办法获取到父线程threadlocal存储的数据\",{\"1\":{\"1047\":1}}],[\"子线程获取父类inheritablethreadlocal数据\",{\"1\":{\"1043\":2}}],[\"子线程获取父类threadlocal数据\",{\"1\":{\"1043\":2}}],[\"子类\",{\"1\":{\"520\":1}}],[\"子类扩展新的数据域或功能\",{\"1\":{\"518\":1}}],[\"子类加载器才会自行尝试加载\",{\"1\":{\"433\":1}}],[\"子类加载器可以在委派给父类加载器之前\",{\"1\":{\"359\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"357\":1}}],[\"子进程写入\",{\"1\":{\"236\":1}}],[\"子进程执行\",{\"1\":{\"158\":1,\"227\":1}}],[\"子查询等\",{\"1\":{\"120\":1}}],[\"子节点\",{\"1\":{\"1351\":1,\"1382\":1}}],[\"子节点的版本\",{\"1\":{\"1350\":1}}],[\"子节点的名称还具有顺序性\",{\"1\":{\"54\":2,\"1335\":2,\"1349\":2}}],[\"子节点版本号\",{\"1\":{\"1349\":1}}],[\"子节点内容变更不会更新\",{\"1\":{\"1349\":1}}],[\"子节点列表\",{\"1\":{\"1330\":1}}],[\"子节点删除就意味着锁被释放\",{\"1\":{\"53\":1}}],[\"普通顺序模式\",{\"1\":{\"1299\":1}}],[\"普通顺序消息在\",{\"1\":{\"1299\":1}}],[\"普通顺序\",{\"1\":{\"1299\":1}}],[\"普通消息生命周期\",{\"1\":{\"1284\":1}}],[\"普通消息一般应用于微服务解耦\",{\"1\":{\"1284\":1}}],[\"普通消息\",{\"0\":{\"1284\":1}}],[\"普通集群模式\",{\"1\":{\"1263\":2}}],[\"普通模式\",{\"1\":{\"1261\":1}}],[\"普通人一般无脑选\",{\"1\":{\"1151\":1}}],[\"普通查询\",{\"1\":{\"120\":1}}],[\"普通索引\",{\"1\":{\"104\":1}}],[\"加个连接池\",{\"1\":{\"1158\":1}}],[\"加权轮询就是在轮询的基础上\",{\"1\":{\"1144\":1}}],[\"加权轮询负载均衡\",{\"1\":{\"1144\":1}}],[\"加\",{\"1\":{\"835\":1}}],[\"加元素之前\",{\"1\":{\"557\":1}}],[\"加锁解锁时\",{\"1\":{\"1007\":1}}],[\"加锁过程\",{\"1\":{\"1006\":1}}],[\"加锁过程中与\",{\"1\":{\"1002\":1}}],[\"加锁加入节点\",{\"1\":{\"577\":1}}],[\"加锁\",{\"1\":{\"535\":1,\"536\":1,\"538\":1,\"588\":2,\"591\":1,\"941\":1,\"1007\":1,\"1179\":2}}],[\"加锁的次数\",{\"1\":{\"56\":1}}],[\"加锁的锁名\",{\"1\":{\"48\":1}}],[\"加快编译速度\",{\"0\":{\"465\":1},\"1\":{\"465\":1}}],[\"加快排序查询时间\",{\"1\":{\"119\":1}}],[\"加在年轻代即被回收的概率\",{\"1\":{\"464\":1}}],[\"加入\",{\"1\":{\"1224\":1}}],[\"加入等待队列\",{\"1\":{\"1011\":1}}],[\"加入到等待队列中去\",{\"1\":{\"1010\":1}}],[\"加入队列的时机\",{\"0\":{\"1010\":1}}],[\"加入阻塞代码thread\",{\"1\":{\"687\":1}}],[\"加入某个年龄段\",{\"1\":{\"444\":1}}],[\"加入布隆过滤器之后的缓存处理流程图\",{\"1\":{\"307\":1}}],[\"加入布隆过滤器之后的缓存处理流程图如下\",{\"1\":{\"307\":1}}],[\"加上自定义的告警等操作\",{\"1\":{\"1212\":1}}],[\"加上了一把大锁\",{\"1\":{\"583\":1,\"793\":1}}],[\"加上\",{\"1\":{\"366\":1}}],[\"加上其关注度并不高\",{\"1\":{\"244\":1}}],[\"加载位于\",{\"1\":{\"433\":1}}],[\"加载扩展的\",{\"1\":{\"432\":1}}],[\"加载一个\",{\"1\":{\"432\":1}}],[\"加载完\",{\"1\":{\"425\":1}}],[\"加载该类的\",{\"1\":{\"394\":1}}],[\"加载指定二进制名称的类\",{\"1\":{\"354\":1}}],[\"加载的呢\",{\"1\":{\"353\":1}}],[\"加载的\",{\"1\":{\"353\":1}}],[\"加载时再利用自定义的类加载器对其解密\",{\"1\":{\"353\":1}}],[\"加载类\",{\"1\":{\"351\":1}}],[\"加载是类加载过程的第一步\",{\"1\":{\"349\":1}}],[\"加载阶段尚未结束\",{\"1\":{\"340\":1}}],[\"加载阶段与连接阶段的部分动作\",{\"1\":{\"340\":1}}],[\"加载阶段获取类的二进制字节流的动作\",{\"1\":{\"340\":1}}],[\"加载这一步主要是通过我们后面要讲到的\",{\"1\":{\"340\":1}}],[\"加载\",{\"0\":{\"340\":1,\"428\":1},\"1\":{\"146\":1,\"338\":1,\"339\":1,\"349\":1,\"359\":4,\"427\":1}}],[\"符号引用比如我现在\",{\"1\":{\"429\":1}}],[\"符号引用和直接引用\",{\"1\":{\"343\":1,\"497\":1}}],[\"符号引用验证的主要目的是确保解析阶段能正常执行\",{\"1\":{\"341\":1}}],[\"符号引用验证发生在类加载过程中的解析阶段\",{\"1\":{\"341\":1}}],[\"符号引用验证\",{\"1\":{\"341\":1}}],[\"符号位\",{\"1\":{\"38\":1}}],[\"符合第一列才会继续判断后面的字段\",{\"1\":{\"118\":1}}],[\"隐式类型转换\",{\"1\":{\"118\":1}}],[\"函数通过\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"函数返回\",{\"1\":{\"904\":1}}],[\"函数所在的线程就是这个进程中的一个线程\",{\"1\":{\"806\":1}}],[\"函数时其实就是启动了一个\",{\"1\":{\"806\":1}}],[\"函数时也会被阻塞\",{\"1\":{\"161\":1}}],[\"函数计算出的插入下标是相同的\",{\"1\":{\"686\":1}}],[\"函数库直接分配堆外内存\",{\"1\":{\"499\":1}}],[\"函数也可以创建新的\",{\"1\":{\"445\":1}}],[\"函数的方式\",{\"1\":{\"445\":1}}],[\"函数的时候\",{\"1\":{\"433\":1}}],[\"函数的参数\",{\"1\":{\"365\":1}}],[\"函数等信息\",{\"1\":{\"325\":1}}],[\"函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘\",{\"1\":{\"268\":1}}],[\"函数同步\",{\"1\":{\"161\":2,\"231\":1}}],[\"函数\",{\"1\":{\"118\":1,\"161\":1,\"230\":1,\"231\":1,\"1210\":2,\"1212\":1}}],[\"函数操作\",{\"1\":{\"118\":1}}],[\"函数和工具库预编译并缓存\",{\"1\":{\"6\":1}}],[\"次拷贝和两次切换\",{\"1\":{\"1311\":1}}],[\"次数据的拷贝\",{\"1\":{\"1308\":1}}],[\"次上下文切换和\",{\"1\":{\"1308\":1,\"1310\":1}}],[\"次重试后仍然无法成功消费消息\",{\"1\":{\"1210\":1}}],[\"次一下子就重试完了\",{\"1\":{\"1204\":1}}],[\"次都被\",{\"1\":{\"1144\":1}}],[\"次被\",{\"1\":{\"1144\":1}}],[\"次会被\",{\"1\":{\"1144\":1}}],[\"次请求有\",{\"1\":{\"1144\":1}}],[\"次请求\",{\"1\":{\"1144\":1}}],[\"次操作\",{\"1\":{\"835\":1}}],[\"次即可\",{\"1\":{\"800\":1}}],[\"次方\",{\"1\":{\"558\":1,\"570\":1,\"684\":1}}],[\"次存放时\",{\"1\":{\"531\":1}}],[\"次存放到队列的结果为\",{\"1\":{\"531\":1}}],[\"次停止\",{\"1\":{\"366\":1}}],[\"次\",{\"1\":{\"117\":2,\"296\":2,\"444\":1,\"486\":1,\"531\":1,\"618\":1,\"682\":1,\"800\":1,\"1210\":2,\"1213\":1,\"1310\":1}}],[\"张图\",{\"1\":{\"1026\":1}}],[\"张三\",{\"1\":{\"625\":1,\"663\":2}}],[\"张\",{\"1\":{\"117\":3}}],[\"页精简了不少\",{\"1\":{\"1096\":1}}],[\"页面大小越大\",{\"1\":{\"485\":1}}],[\"页面单位时间的访问数\",{\"1\":{\"178\":1,\"254\":1}}],[\"页\",{\"1\":{\"110\":1,\"1096\":1}}],[\"页可以用来存储数据也可以用来存储key和指针\",{\"1\":{\"109\":1}}],[\"页page\",{\"0\":{\"109\":1}}],[\"减\",{\"1\":{\"904\":1}}],[\"减1\",{\"1\":{\"756\":1}}],[\"减小这个值能生成更多的线程\",{\"1\":{\"449\":1,\"458\":1}}],[\"减去\",{\"1\":{\"219\":1}}],[\"减少同步阻塞的时间\",{\"1\":{\"1371\":1}}],[\"减少网络资源的占用\",{\"1\":{\"1302\":1}}],[\"减少响应所需时间\",{\"0\":{\"1220\":1},\"1\":{\"1219\":1}}],[\"减少线程资源的创建以及上下文切换\",{\"1\":{\"1062\":1}}],[\"减少资源开销\",{\"1\":{\"1055\":1}}],[\"减少可重入次数\",{\"1\":{\"1014\":1}}],[\"减少了线程饥饿的问题\",{\"1\":{\"872\":1}}],[\"减少了当出现行移动或者数据页分裂时辅助索引的维护工作\",{\"1\":{\"108\":1}}],[\"减少其索引\",{\"1\":{\"553\":1}}],[\"减少数据库的压力\",{\"1\":{\"310\":1}}],[\"减少\",{\"1\":{\"256\":1}}],[\"减少内存分配次数\",{\"1\":{\"256\":1}}],[\"减少回表次数\",{\"1\":{\"117\":1}}],[\"减轻业务服务的负担\",{\"1\":{\"2\":1}}],[\"保持连接状态\",{\"1\":{\"1383\":1}}],[\"保持长连接\",{\"1\":{\"1281\":1}}],[\"保持跟入参\",{\"1\":{\"286\":1}}],[\"保存了指定\",{\"1\":{\"1315\":1}}],[\"保存锁重复持有的次数\",{\"1\":{\"1019\":1}}],[\"保存arraylist数据的数组\",{\"1\":{\"553\":1}}],[\"保存状态信息\",{\"1\":{\"294\":1}}],[\"保存\",{\"1\":{\"294\":1}}],[\"保存着键的过期时间\",{\"1\":{\"271\":1}}],[\"保存着数据库中所有键值对\",{\"1\":{\"271\":1}}],[\"保存着某个时间点的数据集\",{\"1\":{\"236\":1}}],[\"保存的\",{\"1\":{\"1142\":1}}],[\"保存的是字符串\",{\"1\":{\"498\":1}}],[\"保存的数据丢失一些也没什么影响的话\",{\"1\":{\"236\":1}}],[\"保存的地址找到对应的数据行\",{\"1\":{\"107\":1}}],[\"保存多份数据文件\",{\"1\":{\"141\":1}}],[\"保证顺序性\",{\"1\":{\"1379\":1}}],[\"保证可用性的同时\",{\"1\":{\"1358\":1}}],[\"保证消息均匀分布\",{\"1\":{\"1299\":1}}],[\"保证消息传递的顺序性等等问题\",{\"1\":{\"1224\":1}}],[\"保证其超高吞吐量\",{\"1\":{\"1240\":1}}],[\"保证其唯一性\",{\"1\":{\"33\":1}}],[\"保证以下两个性质\",{\"1\":{\"1112\":1}}],[\"保证即使大部分节点挂掉也不会影响正常提供服务\",{\"1\":{\"1069\":1}}],[\"保证的则是\",{\"1\":{\"1069\":1}}],[\"保证的是\",{\"1\":{\"1069\":1}}],[\"保证上面程序执行完成\",{\"1\":{\"835\":1}}],[\"保证子线程完全执行结束\",{\"1\":{\"757\":1}}],[\"保证线程安全\",{\"1\":{\"692\":1}}],[\"保证被校验类的方法在运行时不会做出危害虚拟机的事件\",{\"1\":{\"429\":1}}],[\"保证这些信息被当作代码运行后不会危害虚拟机自身的安全\",{\"1\":{\"341\":1}}],[\"保证只有一个请求会落到数据库上\",{\"1\":{\"310\":1}}],[\"保证了消息的发送顺序性\",{\"1\":{\"1379\":1}}],[\"保证了信道私有性\",{\"1\":{\"1260\":1}}],[\"保证了业务的正常进行\",{\"1\":{\"1209\":1}}],[\"保证了同步\",{\"1\":{\"588\":1}}],[\"保证了\",{\"1\":{\"407\":1}}],[\"保证了操作不会被其他指令插入或打扰\",{\"1\":{\"283\":1,\"288\":1}}],[\"保证了数据持久化\",{\"1\":{\"230\":1}}],[\"保证机器充足的可用内存\",{\"1\":{\"168\":1}}],[\"保证高性能的一个重要前提是所有的数据在内存中\",{\"1\":{\"168\":1}}],[\"保证程序的正确性和稳定性\",{\"1\":{\"60\":1}}],[\"保证内存中始终有可用号段\",{\"1\":{\"42\":1}}],[\"辅助键索引只存储辅助键和主键\",{\"1\":{\"106\":1}}],[\"辅助索引的叶子节点存储的是主键值和索引字段值\",{\"1\":{\"112\":1}}],[\"辅助索引的叶子节点保存主键的指针\",{\"1\":{\"108\":1}}],[\"辅助索引树都不受影响\",{\"1\":{\"108\":1}}],[\"辅助索引\",{\"0\":{\"114\":1},\"1\":{\"105\":1}}],[\"聚合操作\",{\"1\":{\"193\":1}}],[\"聚合码的本质就是一个链接地址\",{\"1\":{\"17\":1}}],[\"聚集索引\",{\"1\":{\"105\":1}}],[\"聚簇索引的叶子节点存储行记录\",{\"1\":{\"112\":1}}],[\"聚簇索引需要经过两次检索\",{\"1\":{\"108\":1}}],[\"聚簇索引\",{\"0\":{\"106\":1},\"1\":{\"105\":1}}],[\"换行\",{\"1\":{\"625\":2}}],[\"换句话说就是对一个变量实施\",{\"1\":{\"972\":1}}],[\"换句话说就是对象的大小必须是\",{\"1\":{\"507\":1}}],[\"换句话说使用扰动函数之后可以减少碰撞\",{\"1\":{\"618\":1,\"682\":1}}],[\"换句话说\",{\"1\":{\"553\":2}}],[\"换句话说查询列要被所建的索引覆盖\",{\"1\":{\"104\":1}}],[\"换算成一个确定的位置\",{\"1\":{\"96\":1}}],[\"全路径\",{\"1\":{\"1389\":1}}],[\"全部顺序存储到了\",{\"1\":{\"1315\":1}}],[\"全称为\",{\"1\":{\"1256\":1}}],[\"全称java\",{\"1\":{\"516\":2}}],[\"全文共\",{\"1\":{\"1026\":1}}],[\"全文索引是一种用于文本数据模糊查询的特殊索引\",{\"1\":{\"103\":1,\"104\":1}}],[\"全文索引\",{\"1\":{\"103\":1,\"104\":1}}],[\"全记是不可能的\",{\"1\":{\"975\":1}}],[\"全世界有非常多的网站使用到了\",{\"1\":{\"242\":1}}],[\"全量数据\",{\"1\":{\"233\":1}}],[\"全局单调递增的事务\",{\"1\":{\"1379\":1}}],[\"全局\",{\"1\":{\"1069\":1}}],[\"全局锁\",{\"1\":{\"941\":1}}],[\"全局扫描\",{\"1\":{\"298\":1}}],[\"全局异常处理\",{\"1\":{\"78\":1}}],[\"全局过滤器最常见的用法是进行负载均衡\",{\"1\":{\"75\":1}}],[\"全局过滤器\",{\"0\":{\"75\":1},\"1\":{\"73\":1}}],[\"全局唯一\",{\"1\":{\"30\":1}}],[\"效率才会更高\",{\"1\":{\"1037\":1}}],[\"效率更好\",{\"1\":{\"934\":1}}],[\"效率更高\",{\"1\":{\"120\":1}}],[\"效率低下\",{\"1\":{\"847\":1}}],[\"效率非常低\",{\"1\":{\"698\":1}}],[\"效率非常低下\",{\"1\":{\"688\":1}}],[\"效率大幅提升\",{\"1\":{\"691\":1}}],[\"效率\",{\"1\":{\"677\":1}}],[\"效率问题\",{\"1\":{\"396\":1}}],[\"效率高一点\",{\"1\":{\"677\":1}}],[\"效率高\",{\"1\":{\"390\":1}}],[\"效率较低\",{\"1\":{\"103\":2,\"104\":1}}],[\"效率比较稳定\",{\"1\":{\"101\":1}}],[\"扫描阶段清除的就是标记位为\",{\"1\":{\"396\":1}}],[\"扫描全表数据速度更快\",{\"1\":{\"101\":1}}],[\"扫码后\",{\"1\":{\"17\":1}}],[\"到消费者\",{\"1\":{\"1261\":1}}],[\"到消费过程中搞丢\",{\"1\":{\"1261\":1}}],[\"到这里第三个问题已经解决了\",{\"1\":{\"1315\":1}}],[\"到这里\",{\"1\":{\"1154\":1}}],[\"到这里就很简单了\",{\"1\":{\"573\":1}}],[\"到核心应用\",{\"1\":{\"1132\":1}}],[\"到index=7的元素时\",{\"1\":{\"1037\":1}}],[\"到队首\",{\"1\":{\"1014\":1}}],[\"到主存中读取对应的共享变量的值\",{\"1\":{\"972\":1}}],[\"到主键索引上找出数据行\",{\"1\":{\"117\":1}}],[\"到链表尾部\",{\"1\":{\"710\":1}}],[\"到了这个阶段\",{\"1\":{\"1356\":1}}],[\"到了\",{\"1\":{\"688\":1,\"792\":1,\"1097\":1}}],[\"到期后取出元素并返回\",{\"1\":{\"604\":1}}],[\"到期的任务\",{\"1\":{\"599\":2}}],[\"到底有啥用不\",{\"1\":{\"1341\":1}}],[\"到底有什么厉害之处\",{\"0\":{\"584\":1}}],[\"到底是个什么东西\",{\"1\":{\"1341\":1}}],[\"到底是如何实现的呢\",{\"1\":{\"1280\":1}}],[\"到底是怎么实现的呢\",{\"1\":{\"1280\":1}}],[\"到底是怎么实现\",{\"1\":{\"210\":1}}],[\"到底层基础数据\",{\"1\":{\"1003\":1}}],[\"到第\",{\"1\":{\"557\":1}}],[\"到下一个位置\",{\"1\":{\"535\":1}}],[\"到此\",{\"1\":{\"533\":1}}],[\"到大约\",{\"1\":{\"480\":1}}],[\"到释放内存总共有\",{\"1\":{\"427\":1}}],[\"到\",{\"1\":{\"351\":1,\"448\":1,\"684\":1,\"904\":1,\"1210\":1,\"1343\":1,\"1349\":1,\"1363\":1}}],[\"到事务开始前的状态\",{\"1\":{\"125\":1}}],[\"到叶子节点\",{\"1\":{\"101\":1}}],[\"到达链表的尾部\",{\"1\":{\"622\":1}}],[\"到达\",{\"1\":{\"22\":1}}],[\"紫色块之间有链指针连接\",{\"1\":{\"100\":1}}],[\"叶子节点只有key和value\",{\"1\":{\"99\":1}}],[\"叶子节点的高度相同\",{\"1\":{\"99\":1}}],[\"根目录下的\",{\"1\":{\"1349\":1}}],[\"根结点可能会被它原来的子节点替换掉\",{\"1\":{\"688\":1}}],[\"根本没收到所以会丢弃\",{\"1\":{\"1380\":1}}],[\"根本没有得到充分利用\",{\"1\":{\"895\":1,\"922\":1}}],[\"根本没有经过缓存这一层\",{\"1\":{\"306\":1}}],[\"根本原因\",{\"1\":{\"1207\":1}}],[\"根本不存在于缓存中\",{\"1\":{\"306\":1}}],[\"根节点节点指针数量\",{\"1\":{\"110\":1}}],[\"根节点至少包含两个孩子\",{\"1\":{\"99\":1}}],[\"根据事务状态来决定是提交或回滚消息\",{\"1\":{\"1304\":1}}],[\"根据生产者组获取一个服务提供者发送回查事务状态请求\",{\"1\":{\"1304\":1}}],[\"根据特定场景使用特定的解决方案\",{\"1\":{\"1303\":1}}],[\"根据任务的优先级把消息发送到对应的队列\",{\"1\":{\"1252\":1}}],[\"根据会员等级计算订单价格\",{\"1\":{\"1202\":1}}],[\"根据rpcrequest中的类\",{\"1\":{\"1166\":1}}],[\"根据这个长度可以继续接收数据\",{\"1\":{\"1152\":1}}],[\"根据权重随机选择\",{\"1\":{\"1141\":1}}],[\"根据维基百科\",{\"1\":{\"1087\":1}}],[\"根据论文标题\",{\"1\":{\"1084\":1}}],[\"根据上述第二条\",{\"1\":{\"1013\":1}}],[\"根据上面的对分代收集算法的介绍回答\",{\"1\":{\"399\":1}}],[\"根据上面的比对规则就可得出\",{\"1\":{\"141\":1}}],[\"根据上面的描述可以知道\",{\"1\":{\"23\":1}}],[\"根据当前节点的位置\",{\"1\":{\"1013\":1}}],[\"根据需要创建新线程\",{\"1\":{\"957\":1}}],[\"根据操作的数据类型\",{\"1\":{\"762\":1}}],[\"根据定制排序\",{\"1\":{\"697\":1}}],[\"根据元素的自然顺序\",{\"1\":{\"697\":1}}],[\"根据给定的\",{\"1\":{\"694\":1}}],[\"根据给定的最小容量和当前数组元素来计算所需容量\",{\"1\":{\"553\":1,\"557\":1}}],[\"根据构造函数可知\",{\"1\":{\"621\":1}}],[\"根据注解标记去调用注解解释器\",{\"1\":{\"523\":1}}],[\"根据一个类的全限定名来构建class对象\",{\"1\":{\"523\":1}}],[\"根据虚拟机当前运行状态的不同\",{\"1\":{\"505\":1}}],[\"根据oracle\",{\"1\":{\"479\":1}}],[\"根据实际事情调整新生代和幸存代的大小\",{\"1\":{\"455\":1}}],[\"根据刚刚涉及的\",{\"1\":{\"450\":1}}],[\"根据应用的线程所需内存大小进行\",{\"1\":{\"449\":1}}],[\"根据类的二进制名称来查找类\",{\"1\":{\"354\":1}}],[\"根据得到的哈希值\",{\"1\":{\"307\":1}}],[\"根据业务情况提前预估\",{\"1\":{\"298\":1}}],[\"根据进程号查询内存交换信息\",{\"1\":{\"168\":1}}],[\"根据具体的业务场景选择适合自己的缓存读写模式\",{\"1\":{\"144\":1}}],[\"根据身份证号算出来的值都是\",{\"1\":{\"96\":1}}],[\"根据项目需求定制化\",{\"1\":{\"359\":1}}],[\"根据项目\",{\"1\":{\"41\":1}}],[\"根据用户所选的商品动态更新\",{\"1\":{\"17\":1}}],[\"根据\",{\"1\":{\"10\":1,\"325\":1,\"425\":1,\"577\":1,\"578\":1,\"667\":1,\"1007\":1,\"1122\":1,\"1142\":1,\"1178\":1}}],[\"根据官方\",{\"1\":{\"351\":1}}],[\"根据官方介绍\",{\"1\":{\"6\":1}}],[\"根据官网介绍\",{\"1\":{\"8\":1,\"201\":1,\"356\":1,\"1236\":1}}],[\"根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡\",{\"1\":{\"2\":1}}],[\"红黑二叉树\",{\"1\":{\"688\":1,\"691\":1}}],[\"红黑树有序关联起来\",{\"1\":{\"702\":1}}],[\"红黑树的情况需要使用\",{\"1\":{\"688\":1}}],[\"红黑树转换\",{\"1\":{\"683\":1}}],[\"红黑树就是为了解决二叉查找树的缺陷\",{\"1\":{\"683\":1}}],[\"红黑树\",{\"1\":{\"575\":1,\"577\":1,\"579\":1,\"643\":1,\"645\":1,\"688\":1}}],[\"红黑树等\",{\"1\":{\"98\":1}}],[\"红色字体描述有误\",{\"1\":{\"384\":1}}],[\"红锁\",{\"1\":{\"50\":1}}],[\"叉\",{\"1\":{\"98\":1}}],[\"万一在消息的传播过程中积分系统宕机了\",{\"1\":{\"1369\":1}}],[\"万一被哪个小家伙给劫持篡改了呢\",{\"1\":{\"1369\":1}}],[\"万一它又给\",{\"1\":{\"1303\":1}}],[\"万一我发送方发送失败了\",{\"1\":{\"1275\":1}}],[\"万一我再加一个番茄牛腩\",{\"1\":{\"1271\":1}}],[\"万一消息的真正消费者并没有正确消费消息怎么办\",{\"1\":{\"1224\":1}}],[\"万个订单积压在\",{\"1\":{\"1264\":1}}],[\"万级的\",{\"1\":{\"1240\":1}}],[\"万级别以上\",{\"1\":{\"19\":1}}],[\"万亿级吞吐保证\",{\"1\":{\"1236\":1}}],[\"万不可将两者混为一谈\",{\"1\":{\"1232\":1}}],[\"万订单\",{\"1\":{\"1178\":1}}],[\"万行的表\",{\"1\":{\"98\":1}}],[\"万节点的平衡二叉树\",{\"1\":{\"98\":1}}],[\"斜树\",{\"1\":{\"97\":1}}],[\"导致机房间网络不通\",{\"1\":{\"1358\":1}}],[\"导致消息分布不均匀\",{\"1\":{\"1299\":1}}],[\"导致消息分发延迟\",{\"1\":{\"1285\":1}}],[\"导致网络带宽压力和消耗很重\",{\"1\":{\"1263\":1}}],[\"导致的死信的几种原因\",{\"1\":{\"1256\":1}}],[\"导致传输成本加大\",{\"1\":{\"1147\":1}}],[\"导致没有\",{\"1\":{\"1111\":1}}],[\"导致不同的客户端视图上看到的结果不同\",{\"1\":{\"1069\":1}}],[\"导致\",{\"1\":{\"838\":1,\"987\":1,\"995\":1,\"1030\":1}}],[\"导致其他线程或者进程饿死\",{\"1\":{\"821\":1}}],[\"导致性能下降或者饥饿\",{\"1\":{\"784\":1}}],[\"导致性能非常低下\",{\"1\":{\"583\":1,\"793\":1}}],[\"导致结果不符合预期\",{\"1\":{\"694\":1}}],[\"导致栈空间过深\",{\"1\":{\"493\":1}}],[\"导致频繁触发\",{\"1\":{\"412\":1}}],[\"导致它们的引用计数器都不为\",{\"1\":{\"390\":1}}],[\"导致所有的请求都落到了数据库上\",{\"1\":{\"313\":1}}],[\"导致大量的请求都直接落到了数据库上\",{\"1\":{\"313\":1}}],[\"导致大量请求落到数据库\",{\"1\":{\"306\":1}}],[\"导致查询效率急剧下降\",{\"1\":{\"97\":1}}],[\"导致商品被多卖了一份\",{\"1\":{\"60\":1}}],[\"树形结构\",{\"1\":{\"1389\":1}}],[\"树形数据模型之后\",{\"1\":{\"1349\":1}}],[\"树型\",{\"1\":{\"1382\":1}}],[\"树节点类源码\",{\"1\":{\"619\":1}}],[\"树的区别\",{\"0\":{\"101\":1}}],[\"树高\",{\"1\":{\"98\":1}}],[\"树\",{\"0\":{\"98\":1,\"99\":1},\"1\":{\"98\":3}}],[\"树会退化成线性链表\",{\"1\":{\"97\":1}}],[\"树叶\",{\"1\":{\"41\":1}}],[\"然而发现这个里面并没有\",{\"1\":{\"433\":1}}],[\"然而\",{\"1\":{\"97\":1,\"293\":1,\"485\":1,\"749\":1,\"1314\":1}}],[\"然后没有获取到锁的客户端也像上面选主的非主节点创建一个\",{\"1\":{\"1388\":1}}],[\"然后要发给\",{\"1\":{\"1380\":1}}],[\"然后广播出去\",{\"1\":{\"1380\":1}}],[\"然后广播给其他\",{\"1\":{\"1380\":1}}],[\"然后也广播给其他\",{\"1\":{\"1380\":1}}],[\"然后才收到了请求\",{\"1\":{\"1379\":1}}],[\"然后参与者收到\",{\"1\":{\"1370\":1}}],[\"然后协调者会给所有参与者发送\",{\"1\":{\"1370\":1}}],[\"然后小红小明谈恋爱的消息在班级里传播起来了\",{\"1\":{\"1368\":1}}],[\"然后我将这些子服务都部署在不同的服务器上\",{\"1\":{\"1367\":1}}],[\"然后我们又转过头干其他事情了\",{\"1\":{\"1271\":1}}],[\"然后我们就可以在饭桌上安心的玩手机了\",{\"1\":{\"1271\":1}}],[\"然后一起参与到消息广播流程中去\",{\"1\":{\"1361\":1}}],[\"然后一般这些方法都会放到一个叫做本地方法栈的区域\",{\"1\":{\"435\":1}}],[\"然后它挂了\",{\"1\":{\"1314\":1}}],[\"然后它就会认为此时没有可用的\",{\"1\":{\"1111\":1}}],[\"然后数据被拷贝到内核缓冲区\",{\"1\":{\"1310\":1}}],[\"然后队列再把维护的消费位移加一\",{\"1\":{\"1280\":1}}],[\"然后执行重试\",{\"1\":{\"1275\":1}}],[\"然后执行javap\",{\"1\":{\"851\":1}}],[\"然后消费者订阅了这个主题\",{\"1\":{\"1272\":1}}],[\"然后消费者拿着\",{\"1\":{\"535\":1}}],[\"然后大妈帮我们打饭配菜\",{\"1\":{\"1271\":1}}],[\"然后大家都知道了\",{\"1\":{\"1084\":1}}],[\"然后重新灌入\",{\"1\":{\"1264\":1}}],[\"然后重写\",{\"1\":{\"359\":1}}],[\"然后等过了高峰期以后\",{\"1\":{\"1264\":1}}],[\"然后每个\",{\"1\":{\"1380\":1}}],[\"然后每个队列去对应每一个消费者\",{\"1\":{\"1278\":1}}],[\"然后每个服务\",{\"1\":{\"1126\":1}}],[\"然后每次你写消息到\",{\"1\":{\"1263\":1}}],[\"然后分发给底层不同的\",{\"1\":{\"1262\":1}}],[\"然后可以定制自己公司的\",{\"1\":{\"1240\":1}}],[\"然后后端服务再慢慢根据自己的能力去消费这些消息\",{\"1\":{\"1221\":1}}],[\"然后服务端执行完之后再把返回结果通过网络传输给你传输回来\",{\"1\":{\"1166\":1}}],[\"然后选择追加或者拒绝\",{\"1\":{\"1115\":1}}],[\"然后删除\",{\"1\":{\"1112\":1}}],[\"然后他会向所有节点发起\",{\"1\":{\"1111\":1}}],[\"然后派信使传递选举投票的信息给将军\",{\"1\":{\"1105\":1}}],[\"然后定时重传\",{\"1\":{\"1078\":1}}],[\"然后该slot位置中的entry\",{\"1\":{\"1040\":1}}],[\"然后放到新的tab数组中\",{\"1\":{\"1038\":1}}],[\"然后遍历老的散列表\",{\"1\":{\"1038\":1}}],[\"然后size\",{\"1\":{\"1037\":1}}],[\"然后设置size\",{\"1\":{\"1037\":1}}],[\"然后接着往后探测\",{\"1\":{\"1037\":1}}],[\"然后以当前key对应的桶的位置向后查找\",{\"1\":{\"1036\":1}}],[\"然后开始进行过期entry的清理工作\",{\"1\":{\"1035\":1}}],[\"然后更新过期数据起始扫描下标slottoexpunge\",{\"1\":{\"1035\":1}}],[\"然后经过第二层进行锁的获取\",{\"1\":{\"1003\":1}}],[\"然后这个\",{\"1\":{\"1262\":1}}],[\"然后这些任务有任务被执行完的话\",{\"1\":{\"941\":1}}],[\"然后这两个线程就会陷入互相等待的状态\",{\"1\":{\"370\":1,\"823\":1}}],[\"然后主调用线程就会从\",{\"1\":{\"904\":1}}],[\"然后主线程就能通过\",{\"1\":{\"753\":1}}],[\"然后又改回\",{\"1\":{\"843\":1,\"992\":1}}],[\"然后自动执行\",{\"1\":{\"827\":1}}],[\"然后线程\",{\"1\":{\"824\":2}}],[\"然后当前线程被阻塞\",{\"1\":{\"756\":1,\"911\":1}}],[\"然后同时开跑\",{\"1\":{\"753\":1}}],[\"然后树节点\",{\"1\":{\"708\":1}}],[\"然后按照次序先后添加\",{\"1\":{\"706\":1}}],[\"然后给每一段数据配一把锁\",{\"1\":{\"690\":1}}],[\"然后暂时赋值给\",{\"1\":{\"621\":1}}],[\"然后获取这个位置上的\",{\"1\":{\"571\":1}}],[\"然后与\",{\"1\":{\"571\":1}}],[\"然后调用\",{\"1\":{\"553\":1,\"561\":1,\"767\":1}}],[\"然后调用构造函数初始化\",{\"1\":{\"425\":1}}],[\"然后检查新容量是否大于最小需要容量\",{\"1\":{\"553\":1,\"558\":1}}],[\"然后将该编号赋予其要提出的提案\",{\"1\":{\"1373\":1}}],[\"然后将运算结果返回给客户端\",{\"1\":{\"1098\":1}}],[\"然后将源数组中的数据复制到新数组中\",{\"1\":{\"588\":1}}],[\"然后将字节码中的方法\",{\"1\":{\"523\":1}}],[\"然后将请求转发到实际的后端服务\",{\"1\":{\"69\":1}}],[\"然后通过互相交换自己的所有数据来消除两者之间的差异\",{\"1\":{\"1087\":1}}],[\"然后通过\",{\"1\":{\"533\":1,\"618\":1,\"682\":1,\"1281\":1,\"1322\":1}}],[\"然后通过一个存储在\",{\"1\":{\"499\":1}}],[\"然后通过thread\",{\"1\":{\"370\":1,\"823\":1}}],[\"然后根据结果进行插入或更新put\",{\"1\":{\"694\":1}}],[\"然后根据\",{\"1\":{\"425\":1}}],[\"然后根据这些信息自动生成路由规则\",{\"1\":{\"72\":1}}],[\"然后直接读取这条索引\",{\"1\":{\"1315\":1}}],[\"然后直接交给\",{\"1\":{\"934\":1}}],[\"然后直接清理掉端边界以外的内存\",{\"1\":{\"398\":1}}],[\"然后直接删除\",{\"1\":{\"145\":1,\"316\":1}}],[\"然后用户\",{\"1\":{\"261\":1}}],[\"然后在新数组中进行写操作\",{\"1\":{\"588\":1}}],[\"然后在刚刚介绍这些参数的时候都已经附带了一些说明\",{\"1\":{\"454\":1}}],[\"然后在需要的时候取出来使用\",{\"1\":{\"359\":1}}],[\"然后在操作大\",{\"1\":{\"163\":1,\"292\":1}}],[\"然后在发生错误时才可以回滚\",{\"1\":{\"137\":1}}],[\"然后使用\",{\"1\":{\"1322\":1}}],[\"然后使用threadlocal中的set方法进行数据处理\",{\"1\":{\"1031\":1}}],[\"然后使用后台线程去做缓冲池和磁盘之间的同步\",{\"1\":{\"136\":1}}],[\"然后使用了这个数据\",{\"1\":{\"127\":1}}],[\"然后呢\",{\"1\":{\"117\":1}}],[\"然后返回\",{\"1\":{\"1036\":1}}],[\"然后返回结果\",{\"1\":{\"286\":1}}],[\"然后返回行数据\",{\"1\":{\"106\":1}}],[\"然后返回成功\",{\"1\":{\"60\":2}}],[\"然后\",{\"1\":{\"96\":1,\"146\":1,\"279\":1,\"307\":1,\"441\":1,\"533\":1,\"535\":1,\"631\":1,\"654\":1,\"708\":1,\"752\":1,\"941\":2,\"1112\":1,\"1132\":1,\"1197\":1,\"1206\":2,\"1207\":1,\"1304\":2,\"1374\":1,\"1375\":2,\"1385\":1}}],[\"然后把对应的\",{\"1\":{\"1110\":1}}],[\"然后把这个作为一个链表赋值到新位置\",{\"1\":{\"572\":1}}],[\"然后把\",{\"1\":{\"96\":1,\"767\":1}}],[\"然后你会发现\",{\"1\":{\"89\":1}}],[\"然后告知执行器执行完成了\",{\"1\":{\"89\":1}}],[\"然后再更新\",{\"1\":{\"1390\":1}}],[\"然后再广播出去\",{\"1\":{\"1380\":1}}],[\"然后再将处理情况返回给协调者\",{\"1\":{\"1370\":1}}],[\"然后再加机器\",{\"1\":{\"1367\":1}}],[\"然后再加载其他目录下的类\",{\"1\":{\"359\":1}}],[\"然后再调用\",{\"1\":{\"1333\":1}}],[\"然后再选择强校验和弱校验的方式\",{\"1\":{\"1303\":1}}],[\"然后再发起共识请求\",{\"1\":{\"1110\":1}}],[\"然后再去派信使通知另外两个将军\",{\"1\":{\"1105\":1}}],[\"然后再执行上面的代码就不会报错了\",{\"1\":{\"1335\":1}}],[\"然后再执行\",{\"1\":{\"653\":1}}],[\"然后再进行修改和替换\",{\"1\":{\"585\":1}}],[\"然后再从队列中用\",{\"1\":{\"531\":1}}],[\"然后再把新元素放入指定位置\",{\"1\":{\"653\":1}}],[\"然后再把使用的空间一次清理掉\",{\"1\":{\"397\":1}}],[\"然后再把框架拆解成小的分支\",{\"1\":{\"80\":1}}],[\"然后再查询哈希槽和节点的映射关系\",{\"1\":{\"286\":1}}],[\"然后再写入到\",{\"1\":{\"229\":1}}],[\"然后再根据实现这些接口的集合的特点来选用\",{\"1\":{\"646\":1}}],[\"然后再根据\",{\"1\":{\"161\":1}}],[\"然后再讲事务的实现原理\",{\"1\":{\"133\":1}}],[\"然后再给另外一个朋友转账\",{\"1\":{\"124\":1}}],[\"然后再找到存储的数据\",{\"1\":{\"114\":1}}],[\"然后再通过聚簇索引定位行记录\",{\"1\":{\"112\":1}}],[\"然后再通过主键索引找到行数据\",{\"1\":{\"106\":1}}],[\"然后再提交\",{\"1\":{\"89\":1}}],[\"然后再返回\",{\"1\":{\"89\":1}}],[\"然后再转发给实际的微服务\",{\"1\":{\"75\":1}}],[\"然后再次尝试把数据插入到表中\",{\"1\":{\"33\":1}}],[\"然后请求经过过滤器处理后转发给具体的服务\",{\"1\":{\"69\":1}}],[\"然后请求到达\",{\"1\":{\"69\":1}}],[\"然后就可以开始读了\",{\"1\":{\"1388\":1}}],[\"然后就会导致一直等待\",{\"1\":{\"753\":1}}],[\"然后就会执行lockdata\",{\"1\":{\"56\":1}}],[\"然后就\",{\"1\":{\"272\":1}}],[\"然后就成功获取锁了\",{\"1\":{\"55\":1}}],[\"然后从文件系统中读取该名称的\",{\"1\":{\"351\":1}}],[\"然后从\",{\"1\":{\"56\":1}}],[\"然后存在在内存里面\",{\"1\":{\"34\":1}}],[\"然后由后台生成兑换码的列表\",{\"1\":{\"19\":1}}],[\"然后有总量限制\",{\"1\":{\"19\":1}}],[\"然后加载到\",{\"1\":{\"7\":1}}],[\"左\",{\"1\":{\"619\":1}}],[\"左边的生产者发送消息会指定\",{\"1\":{\"1315\":1}}],[\"左边补零\",{\"1\":{\"1315\":1}}],[\"左边淡蓝背景的为服务消费方使用的接口\",{\"1\":{\"1130\":1}}],[\"左边\",{\"1\":{\"181\":1}}],[\"左右一般小的应用\",{\"1\":{\"449\":1}}],[\"左右\",{\"1\":{\"246\":1,\"458\":1}}],[\"左右的寻址时间\",{\"1\":{\"98\":1}}],[\"左右子树也各自成为一个二叉查找树\",{\"1\":{\"97\":1}}],[\"左子树的节点均小于根节点的值\",{\"1\":{\"97\":1}}],[\"yahoo\",{\"1\":{\"1238\":1,\"1367\":1}}],[\"yu\",{\"1\":{\"720\":1}}],[\"yuan\",{\"1\":{\"720\":1}}],[\"y=f\",{\"1\":{\"640\":1}}],[\"yieldingwaitstrategy\",{\"1\":{\"1183\":1}}],[\"yield\",{\"1\":{\"576\":1,\"1183\":3}}],[\"yg\",{\"1\":{\"479\":1}}],[\"ygc\",{\"0\":{\"471\":1},\"1\":{\"412\":3}}],[\"ysiw\",{\"1\":{\"320\":1}}],[\"yes\",{\"1\":{\"220\":2,\"229\":1,\"267\":1,\"1371\":3}}],[\"yyyymmdd\",{\"1\":{\"882\":12}}],[\"yyds\",{\"1\":{\"744\":1}}],[\"yy没有成功插入\",{\"1\":{\"125\":1}}],[\"yy\",{\"1\":{\"125\":1,\"882\":10}}],[\"y\",{\"1\":{\"96\":1,\"640\":1}}],[\"young\",{\"0\":{\"479\":1},\"1\":{\"382\":1,\"387\":1,\"412\":3,\"479\":2,\"495\":1}}],[\"you\",{\"1\":{\"86\":2,\"293\":1,\"298\":1,\"302\":1,\"693\":2}}],[\"yourendpoint\",{\"1\":{\"1293\":1}}],[\"yourconsumergroup\",{\"1\":{\"1293\":1}}],[\"yourfiltertag\",{\"1\":{\"1293\":1}}],[\"yourtopic\",{\"1\":{\"1293\":1}}],[\"yourkit\",{\"1\":{\"377\":2}}],[\"your\",{\"1\":{\"7\":1,\"86\":3}}],[\"放弃了\",{\"1\":{\"692\":1}}],[\"放入后一段时间后index=5中的entry数据key变为了null\",{\"1\":{\"1037\":1}}],[\"放入树中\",{\"1\":{\"622\":1}}],[\"放入\",{\"1\":{\"577\":1}}],[\"放在数组的这个位置\",{\"1\":{\"96\":1}}],[\"放到\",{\"1\":{\"56\":2,\"441\":1}}],[\"索引固定⻓度\",{\"1\":{\"1315\":1}}],[\"索引序号\",{\"1\":{\"1315\":1}}],[\"索引文件中\",{\"1\":{\"1315\":1}}],[\"索引文件\",{\"1\":{\"1315\":2}}],[\"索引为\",{\"1\":{\"733\":2}}],[\"索引为什么会失效\",{\"0\":{\"118\":1}}],[\"索引集合\",{\"0\":{\"330\":1}}],[\"索引值为\",{\"1\":{\"328\":1}}],[\"索引已经排序\",{\"1\":{\"119\":1}}],[\"索引并不是越多越好\",{\"1\":{\"119\":1}}],[\"索引字段占用空间越小越好\",{\"1\":{\"119\":1}}],[\"索引的查询优化器可能会认为扫描整个表比使用索引更加高效\",{\"1\":{\"118\":1}}],[\"索引列上存在函数\",{\"1\":{\"118\":1}}],[\"索引列值为空\",{\"1\":{\"118\":1}}],[\"索引列的值必须唯一\",{\"1\":{\"104\":1}}],[\"索引内部就判断了\",{\"1\":{\"117\":1}}],[\"索引里面我特意去掉了\",{\"1\":{\"117\":1}}],[\"索引下推执行流程\",{\"1\":{\"117\":1}}],[\"索引下推\",{\"0\":{\"117\":1}}],[\"索引将失效\",{\"1\":{\"116\":1}}],[\"索引覆盖\",{\"0\":{\"115\":1}}],[\"索引\",{\"1\":{\"111\":1,\"120\":2},\"2\":{\"122\":1}}],[\"索引概念\",{\"0\":{\"111\":1}}],[\"索引结构和数据分开存放的索引\",{\"1\":{\"105\":1}}],[\"索引结构和数据一起存放的索引\",{\"1\":{\"105\":1}}],[\"索引才会被使用\",{\"1\":{\"104\":1}}],[\"索引类型\",{\"0\":{\"102\":1}}],[\"索引不止存在内存中\",{\"1\":{\"98\":1}}],[\"索引数据结构模型\",{\"0\":{\"95\":1}}],[\"索引维护需要代价\",{\"1\":{\"94\":1}}],[\"索引可以加快检索速度\",{\"1\":{\"94\":1}}],[\"索引是物理数据页存储\",{\"1\":{\"94\":1}}],[\"索引介绍\",{\"0\":{\"94\":1}}],[\"●\",{\"1\":{\"94\":2,\"113\":3}}],[\"三阶段提交\",{\"0\":{\"1371\":1},\"1\":{\"1369\":1,\"1371\":1}}],[\"三种角色\",{\"1\":{\"1355\":1}}],[\"三层组织结构\",{\"1\":{\"1315\":1}}],[\"三级缓存\",{\"1\":{\"1184\":1}}],[\"三段式策略\",{\"1\":{\"1183\":1}}],[\"三个消息会被发送到不同队列\",{\"1\":{\"1299\":1}}],[\"三个角色\",{\"1\":{\"1280\":1}}],[\"三个短语的缩写\",{\"1\":{\"1073\":1}}],[\"三个单词的明确定义\",{\"1\":{\"1067\":1}}],[\"三个服务器实例\",{\"1\":{\"23\":1}}],[\"三者的异同\",{\"0\":{\"665\":1}}],[\"三大特性\",{\"1\":{\"518\":1}}],[\"三\",{\"0\":{\"90\":1,\"434\":1},\"1\":{\"913\":1,\"1185\":1}}],[\"了解一下其初始化过程\",{\"1\":{\"534\":1}}],[\"了解一下即可\",{\"1\":{\"445\":1}}],[\"了解了阻塞存取和非阻塞存取\",{\"1\":{\"531\":1}}],[\"了解了\",{\"1\":{\"531\":1,\"533\":1,\"974\":1,\"1381\":1}}],[\"了解\",{\"0\":{\"448\":1,\"449\":1},\"1\":{\"245\":1,\"534\":1,\"1020\":1}}],[\"了解即可\",{\"0\":{\"550\":1,\"650\":1,\"651\":1},\"1\":{\"231\":1,\"671\":1,\"972\":2}}],[\"了\",{\"0\":{\"1155\":1},\"1\":{\"89\":1,\"244\":1,\"272\":1,\"359\":1,\"451\":2,\"459\":1,\"480\":1,\"495\":1,\"496\":1,\"557\":1,\"567\":1,\"634\":1,\"752\":1,\"756\":1,\"873\":1,\"911\":1,\"1070\":2,\"1074\":2,\"1155\":1,\"1170\":1,\"1273\":1,\"1375\":1,\"1380\":3,\"1381\":1}}],[\"两值相等才会进行更新\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"两种消息模型\",{\"0\":{\"1227\":1}}],[\"两种场景下都一样\",{\"1\":{\"1062\":1}}],[\"两种\",{\"1\":{\"503\":1}}],[\"两种错误\",{\"1\":{\"494\":1}}],[\"两种说法其实都没问题\",{\"1\":{\"396\":1}}],[\"两种方法\",{\"1\":{\"380\":1}}],[\"两端的\",{\"1\":{\"167\":1}}],[\"两者不能共存\",{\"1\":{\"1261\":1}}],[\"两者是有些区别\",{\"1\":{\"1157\":1}}],[\"两者底层都是使用小顶堆形式的二叉堆\",{\"1\":{\"897\":1}}],[\"两者都宕机也不影响已运行的提供者和消费者\",{\"1\":{\"1137\":1}}],[\"两者都可以暂停线程的执行\",{\"1\":{\"825\":1}}],[\"两者都具有队列的功能\",{\"1\":{\"668\":1}}],[\"两者都是可重入锁\",{\"0\":{\"860\":1}}],[\"两者都是线程安全的\",{\"1\":{\"651\":1}}],[\"两者都是先进后出的数据结构\",{\"1\":{\"493\":1}}],[\"两者都是由\",{\"1\":{\"147\":1}}],[\"两者联系和区别\",{\"0\":{\"563\":1}}],[\"两者各有千秋\",{\"1\":{\"272\":1}}],[\"两者的用途不同\",{\"1\":{\"1232\":1}}],[\"两者的核心差别在于\",{\"1\":{\"632\":1}}],[\"两者的性能都非常高\",{\"1\":{\"245\":1}}],[\"两者的实现方式不太一样\",{\"1\":{\"101\":1}}],[\"两阶段提交是一种保证分布式系统数据一致性的协议\",{\"1\":{\"1370\":1}}],[\"两阶段提交的方式就不一样了\",{\"1\":{\"89\":1}}],[\"两阶段提交\",{\"0\":{\"1370\":1},\"1\":{\"89\":1,\"1369\":1}}],[\"两个人据理力争的谁也不让谁\",{\"1\":{\"1375\":1}}],[\"两个人去宝屋收集宝物\",{\"1\":{\"881\":1}}],[\"两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"两个不同的服务\",{\"1\":{\"1165\":1}}],[\"两个不同的服务器上的服务提供的方法不在一个内存空间\",{\"1\":{\"1165\":1}}],[\"两个不同的事务不会同时运行\",{\"1\":{\"287\":1}}],[\"两个方向来分析一下\",{\"1\":{\"1012\":1}}],[\"两个操作之间存在\",{\"1\":{\"974\":1}}],[\"两个子类\",{\"1\":{\"857\":1}}],[\"两个及两个以上的作业在同一\",{\"1\":{\"814\":2}}],[\"两个任务是并行执行的\",{\"1\":{\"781\":1}}],[\"两个指针\",{\"1\":{\"708\":1}}],[\"两个指针交换\",{\"1\":{\"444\":1}}],[\"两个线程做了\",{\"1\":{\"968\":1}}],[\"两个线程\",{\"1\":{\"686\":1}}],[\"两个条件对象就构成一个环路\",{\"1\":{\"535\":1}}],[\"两个参数配置成相同的值\",{\"1\":{\"451\":1}}],[\"两个\",{\"1\":{\"382\":1,\"495\":1}}],[\"两个角色\",{\"1\":{\"251\":1}}],[\"两个又有很大的不同\",{\"1\":{\"147\":1}}],[\"两个系统对应的日志也是\",{\"1\":{\"23\":1}}],[\"两个服务器实例\",{\"1\":{\"23\":1}}],[\"改变主题\",{\"1\":{\"1304\":1}}],[\"改为\",{\"1\":{\"1206\":1}}],[\"改为处理其他事情\",{\"1\":{\"862\":1}}],[\"改用\",{\"1\":{\"1154\":1}}],[\"改进\",{\"1\":{\"835\":3}}],[\"改进了\",{\"1\":{\"256\":1}}],[\"改造后的模板方法模式真的是\",{\"1\":{\"744\":1}}],[\"改善锁机制性能\",{\"0\":{\"466\":1}}],[\"改成\",{\"1\":{\"89\":1}}],[\"改成提交\",{\"1\":{\"89\":1}}],[\"改单\",{\"1\":{\"18\":1}}],[\"状态然后进行\",{\"1\":{\"1380\":1}}],[\"状态时\",{\"1\":{\"1380\":1}}],[\"状态机会按顺序执行这些命令\",{\"1\":{\"1106\":1}}],[\"状态节点的时候\",{\"1\":{\"1014\":1}}],[\"状态节点生成\",{\"0\":{\"1013\":1}}],[\"状态的节点\",{\"1\":{\"1005\":1}}],[\"状态就需要从任务队列中移除任务\",{\"1\":{\"941\":1}}],[\"状态并且队列可以加入任务\",{\"1\":{\"941\":1}}],[\"状态中退出\",{\"1\":{\"821\":1}}],[\"状态相当于在等待状态的基础上增加了超时限制\",{\"1\":{\"820\":1}}],[\"状态信息究竟代表的是什么吧\",{\"1\":{\"1349\":1}}],[\"状态信息\",{\"1\":{\"742\":1,\"904\":1,\"1344\":1,\"1349\":2}}],[\"状态\",{\"1\":{\"89\":2,\"90\":2,\"820\":13,\"826\":1,\"1111\":1,\"1356\":3,\"1380\":2}}],[\"处于排队等候机制中的线程\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"处于\",{\"1\":{\"89\":1}}],[\"处理顺序没有特别要求\",{\"1\":{\"1284\":1}}],[\"处理消息丢失的情况\",{\"1\":{\"1224\":1}}],[\"处理消息\",{\"1\":{\"1222\":1}}],[\"处理这些无法正常消费的消息\",{\"1\":{\"1213\":1}}],[\"处理这种情况的一种方法是\",{\"1\":{\"96\":1}}],[\"处理失败\",{\"1\":{\"1213\":1}}],[\"处理完消息再提交\",{\"1\":{\"1207\":1}}],[\"处理完之后线程并不会立即被销毁\",{\"1\":{\"886\":1}}],[\"处理的情况\",{\"1\":{\"1144\":1}}],[\"处理方式会简单很多\",{\"1\":{\"1115\":1}}],[\"处理用户请求的时间变为\",{\"1\":{\"1076\":1}}],[\"处理用户请求需要\",{\"1\":{\"1076\":1}}],[\"处理器之间的平衡\",{\"1\":{\"974\":1}}],[\"处理器可以改变语句对应机器指令的执行顺序\",{\"1\":{\"969\":1}}],[\"处理速度和内存不匹配的问题\",{\"1\":{\"968\":1}}],[\"处理速度和内存处理速度不对等的问题\",{\"1\":{\"968\":1}}],[\"处理任务为了提高并发量\",{\"1\":{\"929\":1}}],[\"处理任务\",{\"1\":{\"927\":1}}],[\"处理文件的业务操作\",{\"1\":{\"909\":1}}],[\"处理文件的数量\",{\"1\":{\"909\":1}}],[\"处理异常\",{\"1\":{\"785\":1}}],[\"处理异步结算的结果\",{\"0\":{\"779\":1}}],[\"处理hash冲突\",{\"1\":{\"622\":1,\"686\":1}}],[\"处理记录命令的\",{\"1\":{\"302\":1}}],[\"处理步骤就是\",{\"1\":{\"96\":1}}],[\"处理\",{\"0\":{\"484\":1},\"1\":{\"69\":1,\"297\":1,\"1144\":2,\"1213\":1,\"1222\":1,\"1223\":1}}],[\"处理一个\",{\"1\":{\"21\":1}}],[\"处理核心的业务流量\",{\"1\":{\"8\":1}}],[\"里去再补一次\",{\"1\":{\"1264\":1}}],[\"里表现为主存和本地内存的内容可能不一致\",{\"1\":{\"969\":1}}],[\"里包含一个\",{\"1\":{\"690\":1}}],[\"里的消息都会存在于多个实例上\",{\"1\":{\"1263\":1}}],[\"里的那些信息\",{\"1\":{\"1159\":1}}],[\"里的那个\",{\"1\":{\"358\":1}}],[\"里的\",{\"1\":{\"571\":2}}],[\"里\",{\"1\":{\"280\":1,\"1264\":1}}],[\"里有\",{\"1\":{\"273\":1}}],[\"里头\",{\"1\":{\"136\":1}}],[\"里面去\",{\"1\":{\"1264\":1}}],[\"里面有一个内部类\",{\"1\":{\"857\":1}}],[\"里面大量使用到了\",{\"1\":{\"788\":1}}],[\"里面需要注意的是变量\",{\"1\":{\"576\":1}}],[\"里面添加这么多元素\",{\"1\":{\"564\":1}}],[\"里面会对局部变量\",{\"1\":{\"438\":1}}],[\"里面运行\",{\"1\":{\"422\":1}}],[\"里面来\",{\"1\":{\"419\":1}}],[\"里面看到的所有的类的类文件\",{\"1\":{\"353\":1}}],[\"里面增加新的\",{\"1\":{\"257\":1}}],[\"里面的一个组件\",{\"1\":{\"1172\":1}}],[\"里面的公平锁和非公平锁的父类\",{\"1\":{\"1014\":1}}],[\"里面的\",{\"1\":{\"235\":1}}],[\"里面已经记录了\",{\"1\":{\"89\":1}}],[\"里面就没有这条语句\",{\"1\":{\"89\":1}}],[\"里面就没有记录这个语句\",{\"1\":{\"89\":1}}],[\"里面\",{\"1\":{\"89\":1,\"1018\":1,\"1199\":1,\"1264\":1}}],[\"里并没有\",{\"1\":{\"89\":1}}],[\"得了\",{\"1\":{\"1155\":1}}],[\"得到方法执行结果并将组装成能够进行网络传输的消息体\",{\"1\":{\"1166\":1}}],[\"得到相同的输出\",{\"1\":{\"1106\":1}}],[\"得到的余数才能用来要存放的位置也就是对应的数组下标\",{\"1\":{\"684\":1}}],[\"得到key的值的同时得到key所对应的值\",{\"1\":{\"625\":2,\"663\":1}}],[\"得到了锁\",{\"1\":{\"604\":1}}],[\"得到执行然后获取到\",{\"1\":{\"370\":1,\"823\":1}}],[\"得到值之后判断位数组中的每个元素是否都为\",{\"1\":{\"307\":1}}],[\"得到哈希值\",{\"1\":{\"307\":1}}],[\"得到新的一行数据\",{\"1\":{\"89\":1}}],[\"得出的结果还是一样的\",{\"1\":{\"141\":1}}],[\"得保证查询至少达到range级别\",{\"1\":{\"120\":1}}],[\"得益于对应的\",{\"1\":{\"7\":1}}],[\"能干啥事\",{\"1\":{\"1386\":1}}],[\"能处理写请求嘛\",{\"1\":{\"1379\":1}}],[\"能删除子节点\",{\"1\":{\"1351\":1}}],[\"能设置节点\",{\"1\":{\"1351\":1}}],[\"能设置\",{\"1\":{\"1351\":1}}],[\"能获取节点数据和列出其子节点\",{\"1\":{\"1351\":1}}],[\"能创建子节点\",{\"1\":{\"1351\":1}}],[\"能满足日常工作的基本需要\",{\"1\":{\"1319\":1}}],[\"能否不引入\",{\"0\":{\"1200\":1}}],[\"能帮助我们做什么呢\",{\"1\":{\"1165\":1}}],[\"能支持处理器提供的\",{\"1\":{\"844\":1,\"993\":1}}],[\"能保证\",{\"1\":{\"835\":1}}],[\"能保证复合操作的原子性吗\",{\"0\":{\"694\":1}}],[\"能简单且高效地构造出应用广泛的大量的同步器\",{\"1\":{\"740\":1,\"903\":1}}],[\"能让使用者明确指定在一个长度为\",{\"1\":{\"407\":1}}],[\"能充分利用\",{\"1\":{\"407\":1}}],[\"能加载的类则与对方相互隔离\",{\"1\":{\"359\":1}}],[\"能加载的类都可以被\",{\"1\":{\"359\":1}}],[\"能存放1170\",{\"1\":{\"110\":1}}],[\"能力概览\",{\"1\":{\"1123\":1}}],[\"能力\",{\"1\":{\"89\":1}}],[\"能力的\",{\"1\":{\"89\":1}}],[\"能够很好地在保证\",{\"1\":{\"1387\":1}}],[\"能够接收客户端的请求\",{\"1\":{\"1378\":1}}],[\"能够发起投票\",{\"1\":{\"1378\":1}}],[\"能够容忍一定的机器故障\",{\"1\":{\"1354\":1,\"1362\":1}}],[\"能够容忍网络上节点的随意地增加或者减少\",{\"1\":{\"1090\":1}}],[\"能够同时保证\",{\"1\":{\"1068\":1}}],[\"能够明显提升系统性能\",{\"1\":{\"866\":1}}],[\"能够提高运算效率\",{\"1\":{\"684\":1}}],[\"能够极大地提高系统的并发性能\",{\"1\":{\"585\":1}}],[\"能够更高效及时地回收字符串内存\",{\"1\":{\"498\":1}}],[\"能够做到有理有据\",{\"1\":{\"245\":1}}],[\"能够在后台自动重写\",{\"1\":{\"233\":1,\"236\":1}}],[\"能够触发索引覆盖\",{\"1\":{\"115\":1}}],[\"能够自动切换到另外一个锁服务\",{\"1\":{\"61\":1}}],[\"能够唯一标示锁的随机字符串\",{\"1\":{\"48\":1}}],[\"归整个类所有\",{\"1\":{\"848\":1}}],[\"归档日志\",{\"1\":{\"89\":1}}],[\"归根结底就是利用\",{\"1\":{\"7\":1}}],[\"经历过技术面试的小伙伴想必对\",{\"1\":{\"1065\":1}}],[\"经比较后第一个\",{\"1\":{\"558\":1}}],[\"经验值在\",{\"1\":{\"449\":1,\"458\":1}}],[\"经常有长时间耗时的消息处理情况\",{\"1\":{\"1293\":1}}],[\"经常有预期之外的长时间耗时的消息\",{\"1\":{\"1292\":1}}],[\"经常会用到自旋操作来进行重试\",{\"1\":{\"844\":1,\"993\":1}}],[\"经常会伴随至少一次的\",{\"1\":{\"375\":1}}],[\"经常和\",{\"1\":{\"782\":1}}],[\"经常用于限制获取某种资源的线程数量\",{\"1\":{\"749\":1}}],[\"经常被拿来和\",{\"1\":{\"724\":1}}],[\"经常也会被拿来当做分布式\",{\"1\":{\"35\":1}}],[\"经过迭代后\",{\"1\":{\"1037\":1}}],[\"经过一轮探测式清理后\",{\"1\":{\"1037\":1}}],[\"经过rehash后发现该元素正确的index=4\",{\"1\":{\"1037\":1}}],[\"经过扰动函数处理过后得到\",{\"1\":{\"618\":1,\"682\":1}}],[\"经过多次的\",{\"1\":{\"444\":1}}],[\"经过多个版本的迭代\",{\"1\":{\"408\":1}}],[\"经过\",{\"1\":{\"351\":1,\"446\":1,\"1037\":1}}],[\"经过了优化器之后可以说这个语句具体该如何执行就已经定下来\",{\"1\":{\"87\":1}}],[\"完全由业务逻辑自由定制\",{\"1\":{\"1293\":1}}],[\"完全匹配的\",{\"1\":{\"1252\":1}}],[\"完全没必要\",{\"1\":{\"316\":1}}],[\"完全可以借着这个时间差再查一次\",{\"1\":{\"124\":1}}],[\"完成\",{\"1\":{\"1292\":1}}],[\"完成一定的同步功能\",{\"1\":{\"1020\":1}}],[\"完成加锁过程\",{\"1\":{\"1016\":1}}],[\"完成尾节点的设置\",{\"1\":{\"1011\":1}}],[\"完成对\",{\"1\":{\"1004\":1}}],[\"完成了\",{\"1\":{\"1375\":1}}],[\"完成了操作\",{\"1\":{\"840\":1,\"989\":1}}],[\"完成了修改工作\",{\"1\":{\"840\":1,\"989\":1}}],[\"完成运算\",{\"1\":{\"777\":1}}],[\"完成任务的封装之后\",{\"1\":{\"599\":1}}],[\"完成遍历后释放锁\",{\"1\":{\"534\":1}}],[\"完成的任务数\",{\"1\":{\"918\":1}}],[\"完成的\",{\"1\":{\"340\":1}}],[\"完成后则会给协调者返回响应\",{\"1\":{\"1371\":1}}],[\"完成后再到栈那里去运行方法\",{\"1\":{\"425\":1}}],[\"完成后\",{\"1\":{\"161\":1}}],[\"完成后线程返回\",{\"1\":{\"161\":1,\"231\":1}}],[\"完成这\",{\"1\":{\"86\":1}}],[\"完美地整合进了\",{\"1\":{\"6\":1}}],[\"列出\",{\"1\":{\"1328\":1}}],[\"列仍然可用\",{\"1\":{\"1246\":1}}],[\"列举了很多实际的例子\",{\"1\":{\"1071\":1}}],[\"列表的副本全部收到消息时\",{\"1\":{\"1206\":1}}],[\"列表的结尾会预留一定的容量空间\",{\"1\":{\"552\":1,\"656\":1}}],[\"列表清空后为\",{\"1\":{\"593\":2}}],[\"列表批量删除元素后为\",{\"1\":{\"593\":2}}],[\"列表大小为\",{\"1\":{\"593\":2}}],[\"列表插入元素后为\",{\"1\":{\"593\":2}}],[\"列表更新后为\",{\"1\":{\"593\":2}}],[\"列表删除元素后为\",{\"1\":{\"593\":1}}],[\"列表第二个元素为\",{\"1\":{\"593\":1}}],[\"列表元素数量\",{\"1\":{\"293\":1}}],[\"列表\",{\"0\":{\"179\":1},\"1\":{\"163\":1,\"174\":1,\"253\":1,\"1142\":1,\"1382\":1}}],[\"列名\",{\"1\":{\"120\":2,\"307\":1}}],[\"列类型不匹配\",{\"1\":{\"118\":1}}],[\"列上可以创建全文索引\",{\"1\":{\"103\":1,\"104\":1}}],[\"列\",{\"1\":{\"86\":1,\"366\":1}}],[\"表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号\",{\"1\":{\"1374\":1}}],[\"表达式的运用\",{\"1\":{\"749\":1}}],[\"表达式实现的方式\",{\"1\":{\"679\":1}}],[\"表达式操作\",{\"1\":{\"118\":1}}],[\"表中所有的元素\",{\"1\":{\"624\":1}}],[\"表中第一个唯一非空索引为密集索引\",{\"1\":{\"106\":1}}],[\"表里的扩容负载因子\",{\"1\":{\"571\":1}}],[\"表明此数据key值已经被垃圾回收掉了\",{\"1\":{\"1035\":1}}],[\"表明后继节点可能被阻塞了\",{\"1\":{\"1014\":1}}],[\"表明后继节点对应的线程仍在运行中\",{\"1\":{\"1014\":1}}],[\"表明创建新的线程失败\",{\"1\":{\"941\":1}}],[\"表明锁被释放\",{\"1\":{\"851\":1}}],[\"表明它可以进行序列化操作\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"表明它具有拷贝能力\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"表明它是一个列表\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"表明实现这个接口的\",{\"1\":{\"549\":1,\"586\":1}}],[\"表明这个类不能被继承\",{\"1\":{\"521\":1}}],[\"表示该节点\",{\"1\":{\"1349\":1}}],[\"表示该消息处理失败\",{\"1\":{\"1292\":1}}],[\"表示该消息处理成功\",{\"1\":{\"1292\":1}}],[\"表示该线程已经运行完毕\",{\"1\":{\"820\":1}}],[\"表示该线程需要等待其他线程做出一些特定动作\",{\"1\":{\"820\":1}}],[\"表示只有所有\",{\"1\":{\"1206\":1}}],[\"表示没有任何线程持有锁\",{\"1\":{\"1018\":1}}],[\"表示没有对象或没有引用\",{\"1\":{\"693\":1}}],[\"表示成功\",{\"1\":{\"1007\":1}}],[\"表示节点在等待队列中\",{\"1\":{\"1005\":1}}],[\"表示线程已经准备好了\",{\"1\":{\"1005\":1}}],[\"表示线程获取锁的请求已经取消了\",{\"1\":{\"1005\":1}}],[\"表示线程正在以独占的方式等待锁\",{\"1\":{\"1005\":1}}],[\"表示线程以共享的模式等待锁\",{\"1\":{\"1005\":1}}],[\"表示处于该节点的线程\",{\"1\":{\"1005\":1}}],[\"表示未锁定状态\",{\"1\":{\"904\":1}}],[\"表示进入同步代码前要获得\",{\"1\":{\"848\":1}}],[\"表示进入同步代码库前要获得\",{\"1\":{\"848\":1}}],[\"表示数据被修改的次数\",{\"1\":{\"840\":1,\"989\":1}}],[\"表示阻塞队列\",{\"1\":{\"791\":1}}],[\"表示这是这一代最后一个线程到达栅栏\",{\"1\":{\"756\":1,\"911\":1}}],[\"表示这个版本是已经提交了的事务生成的\",{\"1\":{\"141\":1}}],[\"表示这个版本是已提交的事务生成的\",{\"1\":{\"141\":1}}],[\"表示这个版本是由还没提交的事务生成的\",{\"1\":{\"141\":1}}],[\"表示这个版本是由将来启动的事务生成的\",{\"1\":{\"141\":1}}],[\"表示一个文件已经被完成\",{\"1\":{\"909\":1}}],[\"表示一个请求已经被完成\",{\"1\":{\"753\":1}}],[\"表示一个动态方法调用点\",{\"1\":{\"328\":1}}],[\"表示所有的线程都调用了\",{\"1\":{\"752\":1}}],[\"表示获取失败\",{\"1\":{\"748\":1}}],[\"表示锁处于未锁定状态\",{\"1\":{\"742\":1}}],[\"表示同步状态\",{\"1\":{\"742\":1,\"904\":1}}],[\"表示当前遍历期望的修改计数值\",{\"1\":{\"732\":1}}],[\"表示当前队列长度+1\",{\"1\":{\"535\":1}}],[\"表示下一个要遍历的节点的下标\",{\"1\":{\"732\":1}}],[\"表示下一个要遍历的节点\",{\"1\":{\"732\":1}}],[\"表示上一次调用\",{\"1\":{\"732\":1}}],[\"表示其具备访问有序性\",{\"1\":{\"705\":1}}],[\"表示在桶中找到key值\",{\"1\":{\"622\":1}}],[\"表示释放锁并进入无限期等待\",{\"1\":{\"604\":1}}],[\"表示需要复制的数组长度\",{\"1\":{\"588\":1}}],[\"表示队列初始容量\",{\"1\":{\"534\":1}}],[\"表示要写入文件的路径\",{\"1\":{\"484\":1}}],[\"表示要初始化内存的单位\",{\"1\":{\"478\":1}}],[\"表示要初始化内存的具体大小\",{\"1\":{\"478\":1}}],[\"表示\",{\"1\":{\"480\":1,\"534\":1,\"576\":2,\"1205\":1}}],[\"表示两个\",{\"1\":{\"453\":1}}],[\"表示新生代\",{\"1\":{\"452\":1}}],[\"表示年轻代与年老代所占比值为\",{\"1\":{\"449\":1}}],[\"表示方法表\",{\"1\":{\"332\":1}}],[\"表示方法的数量\",{\"1\":{\"332\":1}}],[\"表示方法句柄\",{\"1\":{\"328\":1}}],[\"表示字段和方法的描述符\",{\"1\":{\"331\":1}}],[\"表示的字段的名称\",{\"1\":{\"331\":1}}],[\"表示扫描过程中每次扫描后休息的时间间隔为\",{\"1\":{\"293\":1}}],[\"表示历史\",{\"1\":{\"231\":1}}],[\"表示增量\",{\"1\":{\"231\":1}}],[\"表示基础\",{\"1\":{\"231\":1}}],[\"表示索引的哪一列被使用显示使用哪个列或常数与key一起从表中选择行\",{\"1\":{\"120\":1}}],[\"表最多有一个匹配行\",{\"1\":{\"120\":1}}],[\"表仅有一行\",{\"1\":{\"120\":1}}],[\"表\",{\"0\":{\"96\":1},\"1\":{\"271\":1}}],[\"表名\",{\"1\":{\"86\":1,\"120\":1,\"307\":1}}],[\"表上的任意更新都会导致表上的所有查询缓存清空\",{\"1\":{\"85\":1}}],[\"做过分布式锁\",{\"1\":{\"1341\":1}}],[\"做高可用性的\",{\"1\":{\"1263\":1}}],[\"做元数据管理和集群的高可用\",{\"1\":{\"1235\":1}}],[\"做的一个简单总结\",{\"1\":{\"1177\":1}}],[\"做一次启发式清理工作\",{\"1\":{\"1036\":1}}],[\"做一个简陋的监控\",{\"1\":{\"918\":1}}],[\"做替换逻辑\",{\"1\":{\"1036\":1}}],[\"做法是初始化一个共享的\",{\"1\":{\"753\":1}}],[\"做比较\",{\"1\":{\"724\":1}}],[\"做与运算\",{\"1\":{\"571\":2}}],[\"做了下面这些事情\",{\"1\":{\"1199\":1}}],[\"做了一层封装\",{\"1\":{\"536\":1}}],[\"做了更多优化\",{\"1\":{\"184\":1}}],[\"做了优化迭代\",{\"1\":{\"17\":1}}],[\"做加减法\",{\"1\":{\"124\":1}}],[\"做完这些操作后\",{\"1\":{\"86\":1}}],[\"词法分析\",{\"1\":{\"86\":1}}],[\"认为服务假死\",{\"1\":{\"1207\":1}}],[\"认为共享资源每次被访问的时候不会出现问题\",{\"1\":{\"838\":1,\"987\":1}}],[\"认为共享资源每次被访问的时候就会出现问题\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"认识线程死锁\",{\"0\":{\"823\":1}}],[\"认证通过后\",{\"1\":{\"84\":1}}],[\"输出结构\",{\"1\":{\"940\":1}}],[\"输出结果可能是\",{\"1\":{\"782\":1}}],[\"输出结果如下\",{\"1\":{\"767\":2}}],[\"输出结果\",{\"1\":{\"353\":1,\"768\":1,\"882\":1}}],[\"输出内容可能不同\",{\"1\":{\"807\":1}}],[\"输出的部分内容如下\",{\"1\":{\"370\":1}}],[\"输出的行所引用的表\",{\"1\":{\"120\":1}}],[\"输出死锁信息\",{\"1\":{\"370\":1}}],[\"输出对应名称的参数的具体值\",{\"1\":{\"367\":1}}],[\"输出当前\",{\"1\":{\"367\":1}}],[\"输出传递给\",{\"1\":{\"365\":1}}],[\"输出虚拟机进程启动时\",{\"1\":{\"365\":1}}],[\"输出\",{\"1\":{\"365\":1,\"531\":1,\"551\":1,\"593\":1,\"652\":1,\"679\":1,\"704\":1,\"705\":1,\"706\":1,\"733\":1,\"778\":1,\"781\":1,\"782\":1,\"824\":1,\"944\":2}}],[\"输出主类的全名\",{\"1\":{\"365\":1}}],[\"输出示例\",{\"1\":{\"37\":1}}],[\"输完命令之后\",{\"1\":{\"84\":1}}],[\"建议遵循够用即可\",{\"1\":{\"1289\":1}}],[\"建议还要设置重试间隔\",{\"1\":{\"1204\":1}}],[\"建议选择较高版本的\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"建议不同类别的业务用不同的线程池\",{\"0\":{\"919\":1}}],[\"建议多花点精力搞懂\",{\"1\":{\"874\":1}}],[\"建议能默写出来并且要知道每一步虚拟机做了什么\",{\"1\":{\"489\":1}}],[\"建议阅读这篇\",{\"1\":{\"447\":1}}],[\"建议忘掉\",{\"1\":{\"446\":1}}],[\"建议\",{\"1\":{\"354\":1,\"412\":4,\"788\":1}}],[\"建议同时开启\",{\"1\":{\"236\":1}}],[\"建议单表不超过5个索引\",{\"1\":{\"119\":1}}],[\"建议使用自定义的线程池来执行\",{\"1\":{\"784\":1}}],[\"建议使用长链接\",{\"1\":{\"84\":1}}],[\"建议使用\",{\"1\":{\"57\":2,\"936\":1,\"1293\":1}}],[\"建立实时流数据管道\",{\"1\":{\"1190\":1}}],[\"建立多条连接放在池内\",{\"1\":{\"1158\":1}}],[\"建立连接\",{\"1\":{\"1301\":1}}],[\"建立连接收发消息\",{\"1\":{\"1155\":1}}],[\"建立连接过程复杂\",{\"1\":{\"84\":1}}],[\"建立对象就是为了使用对象\",{\"1\":{\"508\":1}}],[\"建立到组合索引\",{\"1\":{\"115\":1}}],[\"超文本传输协议\",{\"1\":{\"1154\":1}}],[\"超大规模微服务实践\",{\"1\":{\"1120\":1}}],[\"超时后会执行业务指定的处理逻辑\",{\"1\":{\"1183\":1}}],[\"超时后线程会自动苏醒\",{\"1\":{\"825\":1}}],[\"超时\",{\"1\":{\"857\":1}}],[\"超时等待\",{\"1\":{\"820\":1}}],[\"超时等待状态\",{\"1\":{\"820\":1}}],[\"超时时间为\",{\"1\":{\"251\":1}}],[\"超时越来越多\",{\"1\":{\"165\":1}}],[\"超时自动断开\",{\"1\":{\"84\":1}}],[\"超过半数\",{\"1\":{\"1380\":1}}],[\"超过最大值就不再扩充了\",{\"1\":{\"624\":1}}],[\"超过规定时间还是空的则返回\",{\"1\":{\"539\":1}}],[\"超过规定时间还未添加成功则返回\",{\"1\":{\"539\":1}}],[\"超过就触发分割\",{\"1\":{\"483\":1}}],[\"超过之后从头文件开始写\",{\"1\":{\"483\":1}}],[\"超过这个值将会抛出\",{\"1\":{\"480\":1,\"496\":1}}],[\"超过\",{\"1\":{\"163\":1,\"291\":1,\"712\":1}}],[\"超市卡这种\",{\"1\":{\"19\":1}}],[\"维持的会话机制\",{\"1\":{\"1383\":1}}],[\"维持和管理连接\",{\"1\":{\"84\":1}}],[\"维基百科是这样介绍中间件的\",{\"1\":{\"1218\":1}}],[\"维护一个创建的先后顺序\",{\"1\":{\"1382\":1}}],[\"维护了一个\",{\"1\":{\"1112\":1}}],[\"维护了一个双向链表来记录数据插入的顺序\",{\"1\":{\"713\":1}}],[\"维护排行榜\",{\"1\":{\"249\":1}}],[\"维度\",{\"1\":{\"76\":1}}],[\"维度和自定义\",{\"1\":{\"76\":1}}],[\"语法底层其实还是依赖\",{\"1\":{\"631\":1}}],[\"语法错误\",{\"1\":{\"524\":2}}],[\"语法分析\",{\"1\":{\"86\":1}}],[\"语句块来完成\",{\"1\":{\"861\":1}}],[\"语句正常返回\",{\"1\":{\"493\":1}}],[\"语句是这么写的\",{\"1\":{\"117\":1}}],[\"语句过程中在写完第一个日志后\",{\"1\":{\"89\":1}}],[\"语句来做例子\",{\"1\":{\"89\":1}}],[\"语句时的内部流程\",{\"1\":{\"89\":1}}],[\"语句如下\",{\"1\":{\"89\":1}}],[\"语句有多个字符串组成\",{\"1\":{\"86\":1}}],[\"语句做解析\",{\"1\":{\"86\":1}}],[\"语句\",{\"1\":{\"83\":1,\"412\":1}}],[\"语言实现\",{\"1\":{\"1237\":1}}],[\"语言使用\",{\"1\":{\"1172\":1}}],[\"语言是跨平台的\",{\"1\":{\"971\":1}}],[\"语言并没有直接实现\",{\"1\":{\"841\":1,\"990\":1}}],[\"语言并没有实现链表\",{\"1\":{\"180\":1}}],[\"语言里也有\",{\"1\":{\"833\":1}}],[\"语言特有的\",{\"1\":{\"833\":1}}],[\"语言独有\",{\"1\":{\"773\":1,\"899\":1}}],[\"语言中所有错误或异常的超类\",{\"1\":{\"524\":1}}],[\"语言中的字符串以空字符\",{\"1\":{\"256\":1}}],[\"语言中的字符串的长度通常是经过遍历计数来实现的\",{\"1\":{\"256\":1}}],[\"语言中的字符串被修改\",{\"1\":{\"256\":1}}],[\"语言中的字符串有如下提升\",{\"1\":{\"256\":1}}],[\"语言中的字符串\",{\"1\":{\"256\":1}}],[\"语言汇总能作为\",{\"1\":{\"445\":1}}],[\"语言层面的的常量概念\",{\"1\":{\"328\":1}}],[\"语言通过字节码的方式\",{\"1\":{\"324\":1}}],[\"语言编写的\",{\"1\":{\"256\":1}}],[\"语言写的\",{\"1\":{\"176\":1}}],[\"语言写的用来分析\",{\"1\":{\"164\":2,\"293\":2}}],[\"语言的\",{\"1\":{\"1147\":1}}],[\"语言的安全和\",{\"1\":{\"391\":1}}],[\"语言的负担\",{\"1\":{\"391\":1}}],[\"语言的单继承\",{\"1\":{\"330\":1}}],[\"语言的结构体\",{\"1\":{\"325\":1}}],[\"语言的一种方言\",{\"1\":{\"324\":1}}],[\"语言的字符串是这样的\",{\"1\":{\"256\":1}}],[\"语言的学习成本\",{\"1\":{\"8\":1}}],[\"语言的模块\",{\"1\":{\"6\":1}}],[\"语言\",{\"1\":{\"6\":1,\"49\":1}}],[\"语言来扩展网关的功能\",{\"1\":{\"6\":1}}],[\"语言开发而设计的\",{\"1\":{\"256\":1}}],[\"语言开发的分布式的消息系统\",{\"1\":{\"1276\":1}}],[\"语言开发的开源\",{\"1\":{\"242\":1}}],[\"语言开发的一个开源的\",{\"1\":{\"8\":1}}],[\"语言开发插件\",{\"1\":{\"8\":1}}],[\"语言开发\",{\"1\":{\"6\":1,\"1191\":1}}],[\"涵盖\",{\"1\":{\"82\":1,\"1168\":1}}],[\"执行提交就行了\",{\"1\":{\"1374\":1}}],[\"执行后请给我回复\",{\"1\":{\"1370\":1}}],[\"执行多少次都不变\",{\"1\":{\"1303\":1}}],[\"执行expungestaleentry\",{\"1\":{\"1040\":1}}],[\"执行完后\",{\"1\":{\"1040\":1}}],[\"执行完第二步后\",{\"1\":{\"1037\":1}}],[\"执行完哈希冲突判断后\",{\"1\":{\"686\":1}}],[\"执行探测式清理后\",{\"1\":{\"1037\":1}}],[\"执行++size操作\",{\"1\":{\"1036\":1}}],[\"执行replacestaleentry\",{\"1\":{\"1036\":1}}],[\"执行runnable\",{\"1\":{\"940\":1}}],[\"执行替换逻辑\",{\"1\":{\"1036\":1}}],[\"执行不同的\",{\"1\":{\"1007\":1}}],[\"执行相应的回调方法\",{\"1\":{\"1385\":1}}],[\"执行相应的拒绝策略的内容\",{\"1\":{\"941\":1}}],[\"执行相关内部类的\",{\"1\":{\"1007\":1}}],[\"执行之前\",{\"1\":{\"974\":1}}],[\"执行失败\",{\"1\":{\"941\":1}}],[\"执行任务过程介绍\",{\"0\":{\"950\":1,\"954\":1,\"958\":1}}],[\"执行任务需要实现的\",{\"1\":{\"934\":1}}],[\"执行任何查询sql时都会生成当前事务的一致性视图read\",{\"1\":{\"141\":1}}],[\"执行了\",{\"1\":{\"834\":1}}],[\"执行顺序有可能变成\",{\"1\":{\"834\":1}}],[\"执行效率太低\",{\"1\":{\"773\":1,\"899\":1}}],[\"执行效率大为提升\",{\"1\":{\"765\":1}}],[\"执行下一步操作\",{\"1\":{\"731\":1}}],[\"执行下面的代码\",{\"1\":{\"451\":1}}],[\"执行步骤\",{\"1\":{\"710\":1}}],[\"执行的命令\",{\"1\":{\"1112\":1}}],[\"执行的话\",{\"1\":{\"772\":1}}],[\"执行的机会\",{\"1\":{\"686\":1}}],[\"执行的任务会准时执行\",{\"1\":{\"599\":1}}],[\"执行add\",{\"1\":{\"552\":1,\"656\":1}}],[\"执行权到来时再次尝试将数据存到队列中\",{\"1\":{\"535\":1}}],[\"执行权到达生产者\",{\"1\":{\"535\":1}}],[\"执行权进行消费\",{\"1\":{\"535\":1}}],[\"执行行为\",{\"1\":{\"523\":1}}],[\"执行队列\",{\"1\":{\"368\":1}}],[\"执行所需的时间量\",{\"1\":{\"302\":1}}],[\"执行事务前后\",{\"1\":{\"281\":1}}],[\"执行事务\",{\"1\":{\"280\":1}}],[\"执行删除过期\",{\"1\":{\"272\":1}}],[\"执行命令仍然是单线程顺序执行\",{\"1\":{\"267\":1}}],[\"执行命令是单线程处理\",{\"1\":{\"163\":1,\"292\":1}}],[\"执行\",{\"0\":{\"506\":1},\"1\":{\"233\":1,\"280\":1,\"344\":4,\"375\":1,\"384\":1,\"425\":5,\"506\":1,\"557\":1,\"558\":1,\"559\":1,\"622\":1,\"686\":1,\"749\":1,\"814\":2,\"851\":2,\"860\":1,\"934\":5,\"1013\":1}}],[\"执行迁移时\",{\"1\":{\"167\":1}}],[\"执行写操作后立即返回\",{\"1\":{\"161\":2,\"231\":2}}],[\"执行写操作后\",{\"1\":{\"161\":1,\"231\":1}}],[\"执行耗时也会越长\",{\"1\":{\"157\":1,\"301\":1}}],[\"执行查询时所有未提交事务id数组\",{\"1\":{\"141\":1}}],[\"执行器调用引擎的提交事务接口\",{\"1\":{\"89\":1}}],[\"执行器生成这个操作的\",{\"1\":{\"89\":1}}],[\"执行器拿到引擎给的行数据\",{\"1\":{\"89\":1}}],[\"执行器先找引擎取\",{\"1\":{\"89\":1}}],[\"执行器等\",{\"1\":{\"82\":1}}],[\"执行器\",{\"0\":{\"88\":1},\"1\":{\"81\":1,\"90\":1}}],[\"执行业务\",{\"1\":{\"49\":1}}],[\"习惯养成\",{\"1\":{\"80\":1}}],[\"久而久之\",{\"1\":{\"80\":1}}],[\"跟准\",{\"1\":{\"1356\":1}}],[\"跟普通集群模式不一样的是\",{\"1\":{\"1263\":1}}],[\"跟\",{\"1\":{\"1007\":1,\"1311\":1}}],[\"跟常用的\",{\"1\":{\"1001\":1}}],[\"跟我们前面提到的\",{\"1\":{\"621\":1}}],[\"跟线程绑定\",{\"1\":{\"359\":1}}],[\"跟图\",{\"1\":{\"117\":1}}],[\"跟随企鹅君\",{\"1\":{\"80\":1,\"93\":1}}],[\"跟踪线程池的最大大小\",{\"1\":{\"941\":1}}],[\"跟踪\",{\"1\":{\"21\":1}}],[\"引出\",{\"0\":{\"1376\":1}}],[\"引用类型原子类\",{\"0\":{\"767\":1},\"1\":{\"762\":1,\"767\":2}}],[\"引用类型\",{\"1\":{\"762\":1}}],[\"引用类型数组原子类\",{\"1\":{\"762\":1,\"766\":1}}],[\"引用类型总结\",{\"0\":{\"392\":1},\"1\":{\"392\":1}}],[\"引用指向新节点\",{\"1\":{\"729\":1}}],[\"引用传递\",{\"1\":{\"729\":1}}],[\"引用作者的一段注释\",{\"1\":{\"708\":1}}],[\"引用失效时减一\",{\"1\":{\"445\":1}}],[\"引用计数器计算\",{\"1\":{\"445\":1}}],[\"引用计数法\",{\"0\":{\"390\":1}}],[\"引用强度逐渐减弱\",{\"1\":{\"392\":1}}],[\"引用\",{\"1\":{\"392\":1,\"729\":1}}],[\"引用的对象\",{\"1\":{\"391\":1,\"445\":1}}],[\"引发网络阻塞\",{\"1\":{\"163\":1}}],[\"引入\",{\"1\":{\"1224\":1}}],[\"引入的目的主要是提高消息消费的性能\",{\"1\":{\"1315\":1}}],[\"引入的性能更好的读写锁\",{\"1\":{\"871\":1}}],[\"引入的函数式编程\",{\"1\":{\"774\":1,\"901\":1}}],[\"引入的索引下推优化\",{\"1\":{\"117\":1}}],[\"引入多线程主要是为了提高网络\",{\"1\":{\"267\":1}}],[\"引入了基于\",{\"1\":{\"1200\":1,\"1235\":1,\"1344\":1}}],[\"引入了多副本\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"引入了多线程\",{\"1\":{\"267\":1}}],[\"引入了性能更好的读写锁\",{\"1\":{\"864\":1}}],[\"引入了大量的优化如自旋锁\",{\"1\":{\"847\":1}}],[\"引入了一种基于通道\",{\"1\":{\"499\":1}}],[\"引入了这个\",{\"1\":{\"485\":1}}],[\"引入了模块系统\",{\"1\":{\"353\":1}}],[\"引入了发布订阅\",{\"1\":{\"251\":1}}],[\"引入了\",{\"1\":{\"76\":1,\"174\":1,\"583\":1,\"788\":1,\"793\":1,\"974\":1,\"981\":1}}],[\"引擎错误\",{\"1\":{\"236\":1}}],[\"引擎就不支持事务\",{\"1\":{\"124\":1}}],[\"引擎使用的是聚簇索引\",{\"1\":{\"101\":1}}],[\"引擎是使用的非聚簇索引\",{\"1\":{\"101\":1}}],[\"引擎都是使用\",{\"1\":{\"101\":1}}],[\"引擎和\",{\"1\":{\"101\":1}}],[\"引擎层是插件式的\",{\"1\":{\"90\":1}}],[\"引擎把刚刚写入的\",{\"1\":{\"89\":1}}],[\"引擎将这行新数据更新到内存中\",{\"1\":{\"89\":1}}],[\"引擎直接用树搜索找到这一行\",{\"1\":{\"89\":1}}],[\"引擎在执行这个简单的\",{\"1\":{\"89\":1}}],[\"引擎特有的\",{\"1\":{\"89\":1}}],[\"引擎\",{\"1\":{\"89\":1,\"105\":1}}],[\"引擎下\",{\"1\":{\"37\":1}}],[\"接受顺序性也得到了保证\",{\"1\":{\"1379\":1}}],[\"接受该\",{\"1\":{\"1112\":1}}],[\"接受\",{\"1\":{\"1098\":1,\"1108\":1}}],[\"接受者\",{\"1\":{\"1098\":1,\"1222\":1}}],[\"接近或者等于\",{\"1\":{\"895\":1,\"922\":1}}],[\"接收和读取消息\",{\"1\":{\"1226\":1}}],[\"接收到了消息\",{\"1\":{\"1206\":1}}],[\"接收到消息并将消息反序列化为\",{\"1\":{\"1166\":1}}],[\"接收到调用后负责将方法\",{\"1\":{\"1166\":1}}],[\"接收端收到的就是\",{\"1\":{\"1152\":1}}],[\"接收数据\",{\"1\":{\"1151\":1}}],[\"接收方消费消息后\",{\"1\":{\"1048\":1}}],[\"接收一个集合类型作为参数\",{\"1\":{\"728\":1}}],[\"接收了一次用户请求\",{\"1\":{\"23\":1}}],[\"接着\",{\"1\":{\"1380\":1}}],[\"接着把这之后的日志发送给\",{\"1\":{\"1112\":1}}],[\"接着以staleslot位置往后迭代\",{\"1\":{\"1037\":1}}],[\"接着我们继续看看具体实现源代码\",{\"1\":{\"1037\":1}}],[\"接着执行清理操作\",{\"1\":{\"1037\":1}}],[\"接着向后查找过程中也未发现过期数据\",{\"1\":{\"1036\":1}}],[\"接着开始从staleslot向后查找\",{\"1\":{\"1036\":1}}],[\"接着开始以staleslot位置\",{\"1\":{\"1035\":1}}],[\"接着重点看下replacestaleentry\",{\"1\":{\"1036\":1}}],[\"接着看看get\",{\"1\":{\"1039\":1}}],[\"接着看看具体的resize\",{\"1\":{\"1038\":1}}],[\"接着看下rehash\",{\"1\":{\"1038\":1}}],[\"接着看下expungestaleentry\",{\"1\":{\"1037\":1}}],[\"接着看下这个有参构造函数的内部实现逻辑\",{\"1\":{\"570\":1}}],[\"接着看剩下for循环中的逻辑\",{\"1\":{\"1036\":1}}],[\"接着就是执行for循环遍历\",{\"1\":{\"1036\":1}}],[\"接着再来看下代码\",{\"1\":{\"1030\":1}}],[\"接着对于获取锁失败的流程\",{\"1\":{\"1003\":1}}],[\"接着上面的初始化参数继续查看\",{\"1\":{\"571\":1}}],[\"接口不会返回结果或抛出检查异常\",{\"1\":{\"943\":1}}],[\"接口不过是一个标识罢了\",{\"1\":{\"658\":1}}],[\"接口以及\",{\"1\":{\"934\":1}}],[\"接口或者\",{\"1\":{\"1131\":1}}],[\"接口或\",{\"1\":{\"934\":1}}],[\"接口有\",{\"1\":{\"774\":1}}],[\"接口描述了一个异步计算的阶段\",{\"1\":{\"774\":2,\"901\":1}}],[\"接口相关方法\",{\"1\":{\"729\":1}}],[\"接口让\",{\"1\":{\"679\":1}}],[\"接口实际上是出自java\",{\"1\":{\"661\":1}}],[\"接口实现\",{\"1\":{\"616\":1}}],[\"接口都是\",{\"1\":{\"661\":1}}],[\"接口和\",{\"1\":{\"661\":1}}],[\"接口和方法的创建中\",{\"1\":{\"522\":1}}],[\"接口才具有快速随机访问功能的\",{\"1\":{\"658\":1}}],[\"接口只是标识\",{\"1\":{\"658\":1}}],[\"接口只有一个实现类\",{\"1\":{\"76\":1}}],[\"接口下的集合\",{\"1\":{\"646\":1}}],[\"接口下面的集合\",{\"1\":{\"641\":1,\"644\":1}}],[\"接口定义了元素的剩余延迟时间\",{\"1\":{\"610\":1}}],[\"接口默认提供的\",{\"1\":{\"544\":1,\"862\":1}}],[\"接口的任务对象\",{\"1\":{\"934\":1}}],[\"接口的基本实现\",{\"1\":{\"900\":1}}],[\"接口的响应速度会得到大幅优化\",{\"1\":{\"772\":1}}],[\"接口的响应速度会非常慢\",{\"1\":{\"772\":1}}],[\"接口的很多方法\",{\"1\":{\"729\":1}}],[\"接口的实现类\",{\"1\":{\"665\":1,\"719\":1,\"934\":1,\"940\":1}}],[\"接口的比如\",{\"1\":{\"646\":1}}],[\"接口的集合比如\",{\"1\":{\"646\":1}}],[\"接口的集合\",{\"1\":{\"646\":1}}],[\"接口的\",{\"1\":{\"610\":1,\"630\":2,\"732\":1,\"934\":1}}],[\"接口的作用是什么\",{\"0\":{\"610\":1}}],[\"接口的有界队列实现类\",{\"1\":{\"541\":1,\"797\":1}}],[\"接口的来的\",{\"1\":{\"533\":1}}],[\"接口的应用场景\",{\"1\":{\"520\":1}}],[\"接口获得了队列的特性\",{\"1\":{\"533\":1}}],[\"接口可以\",{\"1\":{\"943\":1}}],[\"接口可以多继承\",{\"1\":{\"520\":1}}],[\"接口可以看作是方法区\",{\"1\":{\"496\":1}}],[\"接口没有构造方法\",{\"1\":{\"520\":1}}],[\"接口中的方法比较多\",{\"1\":{\"774\":1,\"901\":1}}],[\"接口中相关的插入方法为例进行源码讲解\",{\"1\":{\"729\":1}}],[\"接口中什么都没有定义\",{\"1\":{\"658\":1}}],[\"接口中只能是public\",{\"1\":{\"520\":2}}],[\"接口中定义的方法\",{\"1\":{\"520\":1}}],[\"接口中方法的符号引用\",{\"1\":{\"328\":1}}],[\"接口支持多继承\",{\"1\":{\"520\":1}}],[\"接口是一个抽象类型\",{\"1\":{\"520\":1}}],[\"接口等描述信息外\",{\"1\":{\"497\":1}}],[\"接口方法符号\",{\"1\":{\"497\":1}}],[\"接口方法\",{\"1\":{\"343\":1}}],[\"接口索引集合用来描述这个类实现了那些接口\",{\"1\":{\"330\":1}}],[\"接口\",{\"0\":{\"330\":1,\"655\":1,\"658\":1,\"726\":1},\"1\":{\"325\":1,\"520\":1,\"533\":1,\"552\":1,\"597\":1,\"600\":1,\"610\":1,\"639\":2,\"655\":1,\"656\":1,\"658\":2,\"667\":2,\"668\":1,\"678\":2,\"679\":1,\"726\":1,\"727\":1,\"774\":1,\"796\":1,\"857\":1,\"897\":1,\"900\":1,\"901\":1,\"934\":5,\"940\":2,\"943\":1,\"1140\":1,\"1212\":1}}],[\"接口数量\",{\"1\":{\"325\":1,\"330\":1}}],[\"接下来收到消息如何处理\",{\"1\":{\"1272\":1}}],[\"接下来看\",{\"1\":{\"1018\":1}}],[\"接下来再对解锁的基本流程进行分析\",{\"1\":{\"1014\":1}}],[\"接下来了解一下\",{\"1\":{\"1006\":1}}],[\"接下来介绍的美团的线程池参数动态配置这种方案就非常不错\",{\"1\":{\"922\":1}}],[\"接下来\",{\"1\":{\"625\":1,\"1013\":1}}],[\"接下来笔者就通过两张图让大家了解一下这两个条件是如何在阻塞队列中运用的\",{\"1\":{\"535\":1}}],[\"接下来虚拟机将为新生对象分配内存\",{\"1\":{\"503\":1}}],[\"接下来就介绍下索引类型\",{\"1\":{\"101\":1}}],[\"接下来我们解释一下各个参数的具体意义\",{\"1\":{\"561\":1}}],[\"接下来我们就可以进一步了解一下\",{\"1\":{\"532\":1}}],[\"接下来我们看看一条更新语句如何执行的呢\",{\"1\":{\"89\":1}}],[\"接下来我会结合开头提到的那条\",{\"1\":{\"83\":1}}],[\"解耦\",{\"0\":{\"1272\":1},\"1\":{\"1222\":1,\"1274\":1,\"1278\":1,\"1316\":1}}],[\"解释\",{\"1\":{\"1349\":1}}],[\"解释了又好像没解释\",{\"1\":{\"1150\":1}}],[\"解释一下几个方法和属性值的含义\",{\"1\":{\"1005\":1}}],[\"解除线程挂起状态\",{\"1\":{\"1014\":1}}],[\"解除变量的锁定状态\",{\"1\":{\"972\":1}}],[\"解读\",{\"1\":{\"799\":1}}],[\"解锁也是对这个字段\",{\"1\":{\"1018\":1}}],[\"解锁流程后续会介绍\",{\"1\":{\"1002\":1}}],[\"解锁规则\",{\"1\":{\"975\":1}}],[\"解锁\",{\"1\":{\"588\":1,\"591\":1,\"972\":1,\"975\":1,\"1007\":1}}],[\"解析和封装\",{\"1\":{\"1167\":1}}],[\"解析和初始化过\",{\"1\":{\"502\":1}}],[\"解析三个部分统称为连接\",{\"1\":{\"427\":1}}],[\"解析动作主要针对类或接口\",{\"1\":{\"343\":1}}],[\"解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程\",{\"1\":{\"343\":2}}],[\"解析阶段会介绍符号引用和直接引用\",{\"1\":{\"341\":1}}],[\"解析\",{\"0\":{\"343\":1},\"1\":{\"338\":1,\"427\":1,\"429\":1}}],[\"解析成实际的微服务的\",{\"1\":{\"75\":1}}],[\"解决这个问题\",{\"1\":{\"1314\":1}}],[\"解决前端或者\",{\"1\":{\"1303\":1}}],[\"解决消息堆积的问题\",{\"1\":{\"1275\":1}}],[\"解决分布式事务问题\",{\"1\":{\"1275\":1}}],[\"解决异步执行时上下文传递的问题\",{\"1\":{\"929\":1}}],[\"解决上述问题比较建议的办法是使用阿里巴巴开源的\",{\"1\":{\"929\":1}}],[\"解决上述问题很简单\",{\"1\":{\"140\":1}}],[\"解决方法也很简单\",{\"1\":{\"919\":1}}],[\"解决方案大致可以理解成\",{\"1\":{\"1105\":1}}],[\"解决方案\",{\"1\":{\"41\":1,\"1207\":1}}],[\"解决资源不足的问题\",{\"1\":{\"889\":1}}],[\"解决冲突的方式了\",{\"1\":{\"1033\":1}}],[\"解决冲突\",{\"1\":{\"616\":1,\"645\":1}}],[\"解决线程安全及线程间交互的效率\",{\"1\":{\"598\":1}}],[\"解决了什么问题\",{\"1\":{\"318\":1}}],[\"解决了\",{\"1\":{\"251\":1}}],[\"解决办法就是我们设置\",{\"1\":{\"1206\":1}}],[\"解决办法也比较粗暴\",{\"1\":{\"1205\":1}}],[\"解决办法\",{\"1\":{\"145\":2}}],[\"解决\",{\"1\":{\"130\":2,\"168\":1,\"1303\":1}}],[\"匹配成功\",{\"1\":{\"74\":1}}],[\"作比较\",{\"1\":{\"1169\":1}}],[\"作用于工作内存的变量\",{\"1\":{\"972\":2}}],[\"作用于主内存的变量\",{\"1\":{\"972\":2}}],[\"作用于主内存中的变量\",{\"1\":{\"972\":2}}],[\"作用的范围进行划分\",{\"1\":{\"73\":1}}],[\"作者们认为在良好的\",{\"1\":{\"708\":1}}],[\"作者本人\",{\"1\":{\"693\":1}}],[\"作者为日常\",{\"1\":{\"256\":1}}],[\"作者\",{\"1\":{\"156\":1,\"999\":1}}],[\"作者重写了该文档\",{\"1\":{\"128\":1}}],[\"作为数据节点\",{\"1\":{\"1382\":1}}],[\"作为注册中心\",{\"1\":{\"1341\":1}}],[\"作为每个队列的索引文件来\",{\"1\":{\"1315\":1}}],[\"作为消费消息的索引\",{\"1\":{\"1315\":1}}],[\"作为消息队列\",{\"1\":{\"1204\":1}}],[\"作为消息队列不可靠这个说法已经过时\",{\"1\":{\"1191\":1}}],[\"作为消息通信载体\",{\"1\":{\"1193\":1,\"1194\":1,\"1228\":1,\"1229\":1}}],[\"作为一个优秀高效且可靠的分布式协调框架\",{\"1\":{\"1377\":1}}],[\"作为一个程序员\",{\"1\":{\"1151\":1}}],[\"作为一名java老司机\",{\"1\":{\"93\":1}}],[\"作为生产环境的序列化方式\",{\"1\":{\"1147\":1}}],[\"作为并发编程的框架\",{\"1\":{\"1019\":1}}],[\"作为线程池的任务队列\",{\"1\":{\"961\":1}}],[\"作为线程池的工作队列\",{\"1\":{\"955\":1}}],[\"作为线程池的工作队列会对线程池带来如下影响\",{\"1\":{\"951\":1}}],[\"作为线程安全的\",{\"1\":{\"567\":1}}],[\"作为任务队列\",{\"1\":{\"897\":1}}],[\"作为高性能的非阻塞队列\",{\"1\":{\"796\":1}}],[\"作为执行器\",{\"1\":{\"784\":1}}],[\"作为参数\",{\"1\":{\"693\":1}}],[\"作为值\",{\"1\":{\"693\":1}}],[\"作为值可以有多个\",{\"1\":{\"616\":1,\"677\":1,\"693\":1}}],[\"作为键\",{\"1\":{\"693\":1}}],[\"作为键只能有一个\",{\"1\":{\"616\":1,\"677\":1,\"693\":1}}],[\"作为构造参数\",{\"1\":{\"669\":1}}],[\"作为链表就最适合元素增删的场景\",{\"1\":{\"656\":1,\"724\":1}}],[\"作为collection\",{\"1\":{\"633\":1}}],[\"作为初始化容量大小\",{\"1\":{\"570\":1}}],[\"作为虚拟机来说\",{\"1\":{\"503\":1}}],[\"作为起始的存活对象集\",{\"1\":{\"445\":1}}],[\"作为新的晋升年龄阈值\",{\"1\":{\"386\":1,\"495\":1}}],[\"作为方法区这些数据的访问入口\",{\"1\":{\"340\":1,\"349\":1}}],[\"作为字符串结束的标识\",{\"1\":{\"256\":1}}],[\"作为存储引擎\",{\"1\":{\"244\":1}}],[\"作为索引结构\",{\"1\":{\"101\":1}}],[\"作为微服务的入口\",{\"1\":{\"72\":1}}],[\"作为分布式系统中必不可少的一环\",{\"1\":{\"30\":1}}],[\"作为唯一标识符\",{\"1\":{\"18\":1}}],[\"作为\",{\"1\":{\"8\":1,\"37\":1,\"261\":1,\"359\":1,\"598\":1,\"1341\":1,\"1380\":1}}],[\"路径是我们可以自己定义的\",{\"1\":{\"1389\":1}}],[\"路径中找到一个名为\",{\"1\":{\"425\":1}}],[\"路径\",{\"1\":{\"365\":1}}],[\"路径等\",{\"1\":{\"72\":1}}],[\"路由信息管理\",{\"1\":{\"1281\":1}}],[\"路由模式\",{\"1\":{\"1259\":1}}],[\"路由规则也很简单\",{\"1\":{\"1252\":1}}],[\"路由规则非常简单\",{\"1\":{\"1252\":1}}],[\"路由键等都是遵循的\",{\"1\":{\"1253\":1}}],[\"路由键为\",{\"1\":{\"1252\":5}}],[\"路由键\",{\"1\":{\"1248\":1,\"1249\":1}}],[\"路由层\",{\"1\":{\"1130\":1}}],[\"路由和断言的对应关系\",{\"1\":{\"71\":1}}],[\"路由和\",{\"1\":{\"71\":1}}],[\"路由断言规则\",{\"1\":{\"70\":1}}],[\"路由判断\",{\"1\":{\"69\":1}}],[\"路由\",{\"1\":{\"7\":1}}],[\"运算完之后再写回\",{\"1\":{\"968\":1}}],[\"运行服务提供者\",{\"1\":{\"1128\":1}}],[\"运行期流量调度\",{\"1\":{\"1122\":1}}],[\"运行上面的代码理应输出\",{\"1\":{\"835\":1}}],[\"运行上面的代码后的输出结果如下\",{\"1\":{\"767\":1}}],[\"运行中的\",{\"1\":{\"951\":1}}],[\"运行中\",{\"1\":{\"820\":1}}],[\"运行状态\",{\"1\":{\"820\":1}}],[\"运行到消亡的过程\",{\"1\":{\"806\":1}}],[\"运行错误是引起程序非正常终端的错误\",{\"1\":{\"524\":1}}],[\"运行结果\",{\"1\":{\"384\":1,\"564\":2,\"757\":2}}],[\"运行\",{\"1\":{\"377\":1,\"820\":1,\"1321\":1}}],[\"运行时报错\",{\"1\":{\"634\":3}}],[\"运行时异常\",{\"1\":{\"524\":1}}],[\"运行时系统的内部错误和资源耗尽错误\",{\"1\":{\"524\":1}}],[\"运行时数据区域的一个核心\",{\"1\":{\"493\":1}}],[\"运行时数据区域的一块逻辑区域\",{\"1\":{\"341\":1,\"496\":1}}],[\"运行时数据区域\",{\"0\":{\"491\":1},\"1\":{\"491\":2,\"810\":1}}],[\"运行时数据区\",{\"0\":{\"434\":1},\"1\":{\"489\":1}}],[\"运行时常量池的功能类似于传统编程语言的符号表\",{\"1\":{\"497\":1}}],[\"运行时常量池\",{\"0\":{\"497\":1},\"1\":{\"498\":1}}],[\"运行时常量池还在方法区\",{\"1\":{\"393\":1}}],[\"运行时常量池剩下的东西还在方法区\",{\"1\":{\"393\":1}}],[\"运行时常量池主要回收的是废弃的常量\",{\"1\":{\"393\":1}}],[\"运行时间最长的方法\",{\"1\":{\"377\":1}}],[\"运行时动态配置网关\",{\"1\":{\"72\":1}}],[\"运行在内核空间\",{\"1\":{\"808\":1}}],[\"运行在用户空间\",{\"1\":{\"808\":1}}],[\"运行在\",{\"1\":{\"324\":1}}],[\"运营同学可以在后台设置兑换码的奖励物品\",{\"1\":{\"19\":1}}],[\"才依然可用\",{\"1\":{\"1357\":1}}],[\"才给客⼾端返回写⼊成功\",{\"1\":{\"1314\":1}}],[\"才是所谓的\",{\"1\":{\"1263\":1}}],[\"才是协议\",{\"1\":{\"1161\":1}}],[\"才开始流行的\",{\"1\":{\"1155\":1}}],[\"才开始真正执行类中定义的\",{\"1\":{\"344\":1}}],[\"才使得我们可以随心所欲替换\",{\"1\":{\"1132\":1}}],[\"才使得越来越多的公司开始使用以及接受分布式架构\",{\"1\":{\"1122\":1,\"1168\":1}}],[\"才需要去实现它\",{\"1\":{\"1007\":1}}],[\"才被引入completablefuture\",{\"1\":{\"774\":1,\"901\":1}}],[\"才被引入的\",{\"1\":{\"668\":1,\"772\":1}}],[\"才进行树化操作\",{\"1\":{\"708\":1}}],[\"才可以改变其他节点的\",{\"1\":{\"1110\":1}}],[\"才可以通过\",{\"1\":{\"1019\":1}}],[\"才可以使treemap中的数据按顺序排列\",{\"1\":{\"663\":1}}],[\"才可以在高维度视角理解问题\",{\"1\":{\"80\":1}}],[\"才真正分配容量\",{\"1\":{\"555\":1}}],[\"才移动到老年代\",{\"1\":{\"444\":1}}],[\"才认为两个类是相同的\",{\"1\":{\"357\":1}}],[\"才能得到处理\",{\"1\":{\"1379\":1}}],[\"才能顺序消费\",{\"1\":{\"1286\":1}}],[\"才能接受特定主题的消息\",{\"1\":{\"1279\":1}}],[\"才能进行其他逻辑处理\",{\"1\":{\"863\":1}}],[\"才能调用商品推荐接口\",{\"1\":{\"772\":1}}],[\"才能调用商品详情和物流信息接口\",{\"1\":{\"772\":1}}],[\"才能让\",{\"1\":{\"742\":1}}],[\"才能确定当前链表不为空\",{\"1\":{\"712\":1}}],[\"才能说明可能需要将最年长的键值对\",{\"1\":{\"712\":1}}],[\"才能够从队列中出队\",{\"1\":{\"671\":1}}],[\"才能从队列中取出\",{\"1\":{\"597\":1}}],[\"才能成功返回\",{\"1\":{\"161\":1}}],[\"才能继续执行\",{\"1\":{\"132\":1}}],[\"才能匹配路由\",{\"1\":{\"71\":1}}],[\"才会成为真正的\",{\"1\":{\"1356\":1}}],[\"才会接着执行后面的逻辑\",{\"1\":{\"909\":1}}],[\"才会执行system\",{\"1\":{\"753\":1}}],[\"才会执行转换红黑树操作\",{\"1\":{\"619\":1,\"622\":1}}],[\"才会返回\",{\"1\":{\"752\":1}}],[\"才会使用到\",{\"1\":{\"49\":1}}],[\"才会设置\",{\"1\":{\"47\":1}}],[\"说到崩溃恢复我们首先要提到\",{\"1\":{\"1380\":1}}],[\"说到底\",{\"1\":{\"1159\":1}}],[\"说到如何给线程池配置参数\",{\"1\":{\"921\":1}}],[\"说这个的目的是为了告诉大家\",{\"1\":{\"1152\":1}}],[\"说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能\",{\"1\":{\"1125\":1}}],[\"说简单点\",{\"1\":{\"955\":1}}],[\"说多不多\",{\"1\":{\"975\":1}}],[\"说完了\",{\"1\":{\"969\":1}}],[\"说起\",{\"1\":{\"967\":1}}],[\"说一说\",{\"0\":{\"659\":1,\"669\":1}}],[\"说一下\",{\"0\":{\"245\":1}}],[\"说说生产者\",{\"0\":{\"1254\":1}}],[\"说说线程的生命周期和状态\",{\"0\":{\"820\":1}}],[\"说说\",{\"0\":{\"640\":1,\"1255\":1}}],[\"说白了就是消费者\",{\"1\":{\"1281\":1}}],[\"说白了就是消息队列服务器嘛\",{\"1\":{\"1281\":1}}],[\"说白了就是生产者\",{\"1\":{\"1281\":1}}],[\"说白了就是tcp\",{\"1\":{\"1151\":1}}],[\"说白了就是执行多次\",{\"1\":{\"1097\":1}}],[\"说白了就是对\",{\"1\":{\"975\":1}}],[\"说白了就是定义了一些规范来解决这些问题\",{\"1\":{\"971\":1}}],[\"说白了就是\",{\"1\":{\"917\":1,\"1281\":1,\"1379\":1}}],[\"说白了在\",{\"1\":{\"441\":1}}],[\"说白了它就是对一个表达式进行\",{\"1\":{\"70\":1}}],[\"说明节点创建成功\",{\"1\":{\"1335\":1}}],[\"说明你已经成功连接\",{\"1\":{\"1322\":1}}],[\"说明及可加载插件式的应用软件\",{\"1\":{\"1132\":1}}],[\"说明对方已经成为\",{\"1\":{\"1111\":1}}],[\"说明是替换操作\",{\"1\":{\"1036\":1}}],[\"说明是链表\",{\"1\":{\"577\":1}}],[\"说明该锁没有被任何线程持有\",{\"1\":{\"1014\":1}}],[\"说明该元素不在布隆过滤器中\",{\"1\":{\"307\":1}}],[\"说明共享资源已被获取\",{\"1\":{\"1013\":1}}],[\"说明头结点处于唤醒状态\",{\"1\":{\"1012\":1}}],[\"说明p为头节点且当前没有获取到锁\",{\"1\":{\"1012\":1}}],[\"说明当前桶位置的entry是过期数据\",{\"1\":{\"1036\":1}}],[\"说明当前set操作是一个替换操作\",{\"1\":{\"1036\":1}}],[\"说明当前节点在真实数据队列的首部\",{\"1\":{\"1012\":1}}],[\"说明当前线程可以争取共享资源\",{\"1\":{\"1011\":1}}],[\"说明等待队列的第一个有效节点线程与当前线程不同\",{\"1\":{\"1011\":1}}],[\"说明等待队列的第一个有效节点中的线程与当前线程相同\",{\"1\":{\"1011\":1}}],[\"说明等待队列中没有元素\",{\"1\":{\"1011\":1}}],[\"说明此时队列中至少有一个有效节点\",{\"1\":{\"1011\":1}}],[\"说明队列中存在有效节点\",{\"1\":{\"1011\":1}}],[\"说明被别的线程已经修改\",{\"1\":{\"1011\":1}}],[\"说明子类中无法重写它们\",{\"1\":{\"1006\":1}}],[\"说明创建和启动工作线程成功\",{\"1\":{\"941\":1}}],[\"说明已经有其它线程更新了\",{\"1\":{\"841\":1,\"990\":1}}],[\"说明正在扩容或者是红黑树\",{\"1\":{\"578\":2}}],[\"说明正在初始化\",{\"1\":{\"576\":1}}],[\"说明有\",{\"1\":{\"576\":1}}],[\"说明另外的线程执行cas\",{\"1\":{\"576\":1}}],[\"说明\",{\"1\":{\"195\":1,\"212\":1,\"344\":1,\"449\":1,\"1062\":1,\"1355\":1}}],[\"说明查询就需要优化了\",{\"1\":{\"120\":1}}],[\"说代码\",{\"1\":{\"156\":1}}],[\"说的一篇结合具体场景聊分布式\",{\"1\":{\"15\":1}}],[\"返回消费失败\",{\"1\":{\"1292\":1}}],[\"返回消费成功\",{\"1\":{\"1292\":1}}],[\"返回consumeresult\",{\"1\":{\"1292\":2}}],[\"返回成功\",{\"1\":{\"1112\":1}}],[\"返回当前线程的中断状态\",{\"1\":{\"1012\":1}}],[\"返回前驱节点\",{\"1\":{\"1005\":1}}],[\"返回只有一个线程的线程池\",{\"1\":{\"953\":1}}],[\"返回可用处理器的java虚拟机的数量\",{\"1\":{\"928\":1}}],[\"返回线程池对象的弊端如下\",{\"1\":{\"889\":1,\"917\":1,\"937\":1}}],[\"返回负值\",{\"1\":{\"748\":1}}],[\"返回同步状态的当前值\",{\"1\":{\"742\":1,\"904\":1}}],[\"返回链表中对应下标的元素\",{\"1\":{\"730\":1}}],[\"返回键值对的值\",{\"1\":{\"710\":1}}],[\"返回由指定映射支持的同步\",{\"1\":{\"698\":1}}],[\"返回由指定数组支持的固定大小的列表\",{\"1\":{\"634\":1}}],[\"返回最大元素\",{\"1\":{\"697\":1}}],[\"返回最大的元素\",{\"1\":{\"697\":1}}],[\"返回索引\",{\"1\":{\"697\":1}}],[\"返回值\",{\"1\":{\"680\":2}}],[\"返回特殊值\",{\"1\":{\"667\":2}}],[\"返回旧值\",{\"1\":{\"622\":1}}],[\"返回根节点\",{\"1\":{\"619\":1}}],[\"返回散列值也就是hashcode\",{\"1\":{\"618\":1,\"682\":1}}],[\"返回出去\",{\"1\":{\"604\":1}}],[\"返回列表中的列表迭代器\",{\"1\":{\"553\":1}}],[\"返回列表中的元素\",{\"1\":{\"553\":1}}],[\"返回的是一个包含该线程的\",{\"1\":{\"1012\":1}}],[\"返回的结果为\",{\"1\":{\"693\":1}}],[\"返回的list是可序列化并实现randomaccess接口\",{\"1\":{\"634\":1}}],[\"返回的迭代器是fail\",{\"1\":{\"553\":1}}],[\"返回的列表迭代器是fail\",{\"1\":{\"553\":2}}],[\"返回的数组的运行时类型是指定数组的运行时类型\",{\"1\":{\"553\":1,\"562\":1}}],[\"返回的数组将是\",{\"1\":{\"553\":1}}],[\"返回indexoutofboundsexception细节信息\",{\"1\":{\"553\":1}}],[\"返回true\",{\"1\":{\"553\":1}}],[\"返回原来在这个位置的元素\",{\"1\":{\"553\":1}}],[\"返回一个包含此列表中所有元素的数组\",{\"1\":{\"553\":1}}],[\"返回一个结果\",{\"1\":{\"81\":1}}],[\"返回复制后的数组\",{\"1\":{\"553\":1}}],[\"返回此arraylist实例的浅拷贝\",{\"1\":{\"553\":1}}],[\"返回此列表中指定位置的元素\",{\"1\":{\"553\":1}}],[\"返回此列表中指定元素的最后一次出现的索引\",{\"1\":{\"553\":1}}],[\"返回此列表中指定元素的首次出现的索引\",{\"1\":{\"553\":2}}],[\"返回此列表中的元素数\",{\"1\":{\"553\":1}}],[\"返回默认容量和最小容量中的较大值作为所需容量\",{\"1\":{\"553\":1,\"557\":1}}],[\"返回默认值\",{\"1\":{\"2\":1}}],[\"返回队列中指定位置的元素\",{\"1\":{\"536\":1}}],[\"返回对象的真实类型\",{\"1\":{\"523\":1}}],[\"返回地址\",{\"1\":{\"519\":1}}],[\"返回慢查询命令的数量\",{\"1\":{\"302\":1}}],[\"返回结果\",{\"1\":{\"285\":1,\"301\":1,\"1076\":1}}],[\"返回两个给定元素之间的距离\",{\"1\":{\"210\":1}}],[\"返回指定下标的非空节点\",{\"1\":{\"730\":1}}],[\"返回指定列表支持的同步\",{\"1\":{\"698\":1}}],[\"返回指定\",{\"1\":{\"157\":1,\"301\":1,\"698\":2}}],[\"返回\",{\"1\":{\"157\":1,\"177\":1,\"301\":1,\"531\":2,\"539\":2,\"603\":1,\"664\":1,\"712\":2,\"718\":1,\"742\":1,\"748\":1,\"752\":1,\"766\":1,\"1015\":2,\"1210\":1,\"1310\":2,\"1311\":1}}],[\"返回接口执行的结果\",{\"1\":{\"88\":1}}],[\"返回响应给网关\",{\"1\":{\"73\":1}}],[\"返回给定元素的经纬度信息\",{\"1\":{\"210\":1}}],[\"返回给客户端\",{\"1\":{\"69\":1}}],[\"返回给\",{\"1\":{\"69\":1}}],[\"悟空聊架构这篇文章\",{\"1\":{\"67\":1}}],[\"深度剖析\",{\"1\":{\"896\":1}}],[\"深度历险\",{\"1\":{\"213\":1}}],[\"深入到\",{\"1\":{\"996\":1}}],[\"深入浅出\",{\"1\":{\"982\":1}}],[\"深入浅出阻塞队列\",{\"1\":{\"545\":1}}],[\"深入分析\",{\"1\":{\"360\":1}}],[\"深入拆解虚拟机\",{\"1\":{\"472\":1}}],[\"深入拆解\",{\"1\":{\"359\":1,\"360\":1}}],[\"深入理解高并发编程\",{\"1\":{\"612\":1}}],[\"深入理解\",{\"1\":{\"67\":1,\"342\":2,\"343\":1,\"345\":1,\"377\":1,\"380\":1,\"386\":1,\"387\":2,\"388\":1,\"409\":1,\"489\":1,\"496\":1,\"497\":1,\"498\":1,\"511\":1,\"545\":1,\"876\":1,\"913\":1}}],[\"深耕业务还会有区分通用券和单独券的情况\",{\"1\":{\"19\":1}}],[\"图1\",{\"1\":{\"1247\":1}}],[\"图源java\",{\"1\":{\"904\":1}}],[\"图源从\",{\"1\":{\"742\":1}}],[\"图源\",{\"1\":{\"731\":1,\"820\":2,\"1053\":1}}],[\"图解线程池实现原理\",{\"1\":{\"893\":1,\"941\":1}}],[\"图解进程和线程的关系\",{\"0\":{\"810\":1}}],[\"图解\",{\"0\":{\"1040\":1},\"1\":{\"612\":1}}],[\"图文较长\",{\"1\":{\"604\":1}}],[\"图文讲解\",{\"1\":{\"604\":1}}],[\"图像\",{\"1\":{\"351\":1}}],[\"图片来源\",{\"1\":{\"890\":1,\"936\":1}}],[\"图片来自\",{\"1\":{\"342\":1,\"575\":1}}],[\"图片来自于\",{\"1\":{\"42\":1}}],[\"图片来自于美团官方文章\",{\"1\":{\"41\":1}}],[\"图片地址\",{\"1\":{\"178\":1}}],[\"图片的路径\",{\"1\":{\"254\":1}}],[\"图片的\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"图片\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"图4\",{\"1\":{\"117\":1}}],[\"图3\",{\"1\":{\"117\":1}}],[\"图中的虚线代表的就是各个节点之间使用\",{\"1\":{\"1085\":1}}],[\"图中的requestid即为我们各个系统链路关联的traceid\",{\"1\":{\"1045\":1}}],[\"图中的一处小错误\",{\"1\":{\"1007\":1}}],[\"图中只列举了主要的继承派生关系\",{\"1\":{\"639\":1}}],[\"图中程序计数器\",{\"1\":{\"445\":1}}],[\"图中四个\",{\"1\":{\"96\":1}}],[\"图中\",{\"1\":{\"96\":1}}],[\"图中博主也直接删掉了\",{\"1\":{\"85\":1}}],[\"图\",{\"1\":{\"67\":1,\"96\":1,\"117\":4,\"1106\":1,\"1108\":1,\"1109\":1}}],[\"|ˈdʌbəʊ|\",{\"1\":{\"1122\":1}}],[\"|=\",{\"1\":{\"677\":5}}],[\"||\",{\"1\":{\"553\":2,\"570\":2,\"571\":1,\"573\":1,\"576\":2,\"577\":3,\"578\":2,\"604\":1,\"621\":1,\"622\":5,\"623\":2,\"658\":1,\"677\":1,\"683\":2,\"711\":2,\"712\":1,\"748\":1,\"843\":1,\"890\":5,\"936\":5,\"941\":2,\"992\":1,\"1011\":2,\"1013\":1,\"1014\":1,\"1142\":1}}],[\"|\",{\"1\":{\"67\":2,\"125\":24,\"168\":2,\"219\":2,\"353\":4,\"545\":1,\"653\":33,\"785\":2,\"820\":1,\"841\":1,\"990\":1,\"1131\":9,\"1185\":1}}],[\"字从源码上分析\",{\"1\":{\"941\":1}}],[\"字面量\",{\"1\":{\"511\":2}}],[\"字面量包括整数\",{\"1\":{\"497\":1}}],[\"字面量是源代码中的固定值的表示法\",{\"1\":{\"497\":1}}],[\"字面量比较接近于\",{\"1\":{\"328\":1}}],[\"字面量和符号引用\",{\"1\":{\"328\":1}}],[\"字节左右\",{\"1\":{\"1184\":1}}],[\"字节流可以理解为一个双向的通道里流淌的二进制数据\",{\"1\":{\"1152\":1}}],[\"字节码解释器通过改变程序计数器来依次读取指令\",{\"1\":{\"492\":1,\"811\":1}}],[\"字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令\",{\"1\":{\"492\":1}}],[\"字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令\",{\"1\":{\"435\":1}}],[\"字节码文件中初始化方法有两种\",{\"1\":{\"430\":1}}],[\"字节码文件通过类加载器被搬运到\",{\"1\":{\"424\":1}}],[\"字节码文件\",{\"1\":{\"424\":1}}],[\"字节码可以是\",{\"1\":{\"351\":1}}],[\"字节码\",{\"1\":{\"344\":1}}],[\"字节码验证\",{\"1\":{\"341\":1}}],[\"字节码语义检查\",{\"1\":{\"341\":1}}],[\"字节内存的浪费\",{\"1\":{\"218\":1}}],[\"字节内存空间如果后续没办法再被分配存储其他数据的话\",{\"1\":{\"217\":1}}],[\"字节内存空间\",{\"1\":{\"217\":1}}],[\"字节的消息长度\",{\"1\":{\"1315\":1}}],[\"字节的\",{\"1\":{\"1315\":1}}],[\"字节的倍数\",{\"1\":{\"507\":1}}],[\"字节的整数倍\",{\"1\":{\"507\":2}}],[\"字节的内存\",{\"1\":{\"218\":2}}],[\"字节的连续内存空间\",{\"1\":{\"217\":1}}],[\"字节\",{\"1\":{\"218\":3,\"256\":1,\"1315\":1}}],[\"字典\",{\"1\":{\"174\":1}}],[\"字符串或者是二级制序列\",{\"1\":{\"1348\":1}}],[\"字符串对象的引用指向堆中的字符串对象\",{\"1\":{\"498\":1}}],[\"字符串对象的引用\",{\"1\":{\"498\":1}}],[\"字符串常量池具有缓存功能\",{\"1\":{\"848\":1}}],[\"字符串常量池这些都是不随虚拟机实现而改变的逻辑概念\",{\"1\":{\"498\":1}}],[\"字符串常量池和静态变量从永久代移动了\",{\"1\":{\"498\":1}}],[\"字符串常量池存放在永久代\",{\"1\":{\"498\":1}}],[\"字符串常量池\",{\"0\":{\"498\":1},\"1\":{\"498\":1}}],[\"字符串常量池被从方法区拿到了堆中\",{\"1\":{\"393\":1}}],[\"字符串类型字面量\",{\"1\":{\"328\":1}}],[\"字符串值的长度\",{\"1\":{\"293\":1}}],[\"字符串无法正确保存\",{\"1\":{\"256\":1}}],[\"字符串时\",{\"1\":{\"256\":1}}],[\"字符串的长度也就是已经使用的字节数\",{\"1\":{\"256\":1}}],[\"字符串的内容为整数的时候可以使用\",{\"1\":{\"177\":1}}],[\"字符串为\",{\"1\":{\"176\":1}}],[\"字符串\",{\"0\":{\"175\":1},\"1\":{\"174\":1,\"253\":1,\"256\":1,\"385\":1}}],[\"字\",{\"1\":{\"67\":1,\"412\":1}}],[\"字段来实现多线程的独占模式或者共享模式\",{\"1\":{\"1007\":1}}],[\"字段符号引用\",{\"1\":{\"497\":1}}],[\"字段信息\",{\"1\":{\"341\":1,\"496\":1}}],[\"字段被定义为什么数据类型这些都是无法固定的\",{\"1\":{\"331\":1}}],[\"字段包括类级变量以及实例变量\",{\"1\":{\"331\":1}}],[\"字段表示的同步状态来实现多线程的独占模式和共享模式\",{\"1\":{\"1006\":1}}],[\"字段表的结构\",{\"1\":{\"331\":1}}],[\"字段表\",{\"1\":{\"331\":2,\"333\":1}}],[\"字段表集合\",{\"0\":{\"331\":1}}],[\"字段或方法的符号引用\",{\"1\":{\"328\":1}}],[\"字段的升序来排列了\",{\"1\":{\"679\":1}}],[\"字段的\",{\"1\":{\"331\":2,\"896\":1,\"923\":1}}],[\"字段的作用域\",{\"1\":{\"331\":1}}],[\"字段的符号引用\",{\"1\":{\"328\":1}}],[\"字段的名称和描述符\",{\"1\":{\"328\":1}}],[\"字段数量\",{\"1\":{\"325\":1,\"331\":1}}],[\"字段\",{\"1\":{\"89\":1,\"343\":1,\"497\":1,\"840\":2,\"989\":2}}],[\"字段加\",{\"1\":{\"89\":1}}],[\"字段主要用于解决并发问题\",{\"1\":{\"34\":1}}],[\"字段和step字段主要用于获取批量\",{\"1\":{\"34\":1}}],[\"字段创建了唯一索引\",{\"1\":{\"33\":1}}],[\"字段无意义\",{\"1\":{\"33\":1}}],[\"非要等待发送短信这个比较耗时的操作才返回结果\",{\"1\":{\"1271\":1}}],[\"非分布式\",{\"1\":{\"1263\":1}}],[\"非必须\",{\"1\":{\"1128\":2}}],[\"非故障的节点在合理的时间内返回合理的响应\",{\"1\":{\"1067\":1}}],[\"非公平锁源码中的加锁流程如下\",{\"1\":{\"1002\":1}}],[\"非公平锁\",{\"1\":{\"858\":1,\"1001\":1,\"1002\":1,\"1007\":1,\"1018\":1}}],[\"非公平的共享模式获取许可证\",{\"1\":{\"748\":1}}],[\"非公平模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"非满条件\",{\"1\":{\"535\":3,\"544\":1}}],[\"非满\",{\"1\":{\"534\":1,\"535\":2}}],[\"非空非满\",{\"1\":{\"535\":1}}],[\"非空条件\",{\"1\":{\"535\":3,\"544\":1}}],[\"非空\",{\"1\":{\"534\":1,\"535\":2}}],[\"非空父类的类加载器无法找到相应的类\",{\"1\":{\"357\":1}}],[\"非运行时数据区的一部分\",{\"1\":{\"491\":1}}],[\"非堆内存其实我们已经说过了\",{\"1\":{\"443\":1}}],[\"非堆内存的整体信息\",{\"1\":{\"375\":1}}],[\"非静态资源初始化的<init>和静态资源初始化的<clinit>\",{\"1\":{\"430\":1}}],[\"非死不可\",{\"1\":{\"391\":1}}],[\"非常重要的一个特性\",{\"1\":{\"1385\":1}}],[\"非常有用的一个特性\",{\"1\":{\"1352\":1}}],[\"非常精辟\",{\"1\":{\"1152\":1}}],[\"非常易于扩展功能\",{\"1\":{\"1132\":1}}],[\"非常轻量级\",{\"1\":{\"1055\":1}}],[\"非常清晰\",{\"1\":{\"974\":1}}],[\"非常类似\",{\"1\":{\"755\":1,\"910\":1}}],[\"非常方便\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"非常适合阅读和学习\",{\"1\":{\"1173\":1}}],[\"非常适合用于作为数据共享的通道\",{\"1\":{\"791\":1}}],[\"非常适合\",{\"1\":{\"448\":1}}],[\"非常适合一些数据经常变化又对数据一致性要求没那么高的场景\",{\"1\":{\"147\":1}}],[\"非常频繁\",{\"1\":{\"375\":1}}],[\"非主键索引保存了非主键\",{\"1\":{\"107\":1}}],[\"非聚集索引\",{\"1\":{\"105\":1}}],[\"非聚簇索引\",{\"0\":{\"107\":1},\"1\":{\"105\":1}}],[\"非叶子节点不存储data\",{\"1\":{\"101\":1}}],[\"非叶子节点仅用来索引\",{\"1\":{\"100\":1}}],[\"非叶子节点的子树指针p\",{\"1\":{\"100\":1}}],[\"非叶子节点的子树指针与关键字个数相同\",{\"1\":{\"100\":1}}],[\"非叶子节点包含key和value\",{\"1\":{\"99\":1}}],[\"非阻塞算法来实现线程安全就好了\",{\"1\":{\"794\":1}}],[\"非阻塞队列可以通过\",{\"1\":{\"794\":1}}],[\"非阻塞队列的典型例子是\",{\"1\":{\"794\":1}}],[\"非阻塞时\",{\"1\":{\"687\":1}}],[\"非阻塞获取和新增元素的基础上\",{\"1\":{\"537\":1}}],[\"非阻塞式获取和新增元素的方法为\",{\"1\":{\"536\":1}}],[\"非阻塞式获取和新增元素\",{\"0\":{\"536\":1}}],[\"非阻塞\",{\"1\":{\"61\":1,\"63\":1,\"245\":1}}],[\"非自增\",{\"1\":{\"37\":1}}],[\"份\",{\"1\":{\"60\":1}}],[\"关注的是远程调用而非本地调用\",{\"1\":{\"1165\":1}}],[\"关联起来\",{\"1\":{\"1249\":1}}],[\"关联起来呢\",{\"1\":{\"1002\":1}}],[\"关联上\",{\"1\":{\"1199\":1}}],[\"关联\",{\"1\":{\"1013\":1}}],[\"关联到相应的事件处理器\",{\"1\":{\"265\":1}}],[\"关系来执行的结果一致\",{\"1\":{\"974\":1}}],[\"关系指定的顺序来执行\",{\"1\":{\"974\":1}}],[\"关系\",{\"1\":{\"974\":2}}],[\"关系型数据库\",{\"1\":{\"232\":1}}],[\"关系型数据库比如\",{\"1\":{\"63\":1}}],[\"关系型数据库的方式一般是通过唯一索引或者排他锁实现\",{\"1\":{\"62\":1}}],[\"关键点在于\",{\"1\":{\"710\":1}}],[\"关键字进行了很多优化\",{\"1\":{\"861\":1}}],[\"关键字进行同步处理\",{\"1\":{\"651\":1}}],[\"关键字锁都是可重入的\",{\"1\":{\"860\":1}}],[\"关键字类似\",{\"1\":{\"857\":1}}],[\"关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"855\":1}}],[\"关键字可以禁止指令进行重排序优化\",{\"1\":{\"980\":1}}],[\"关键字可以修饰方法以及代码块\",{\"1\":{\"855\":1}}],[\"关键字可以保证变量的可见性\",{\"1\":{\"833\":1}}],[\"关键字只能用于变量而\",{\"1\":{\"855\":1}}],[\"关键字是线程同步的轻量级实现\",{\"1\":{\"855\":1}}],[\"关键字是两个互补的存在\",{\"1\":{\"855\":1}}],[\"关键字和\",{\"1\":{\"855\":1}}],[\"关键字底层原理属于\",{\"1\":{\"850\":1}}],[\"关键字加到实例方法上是给对象实例上锁\",{\"1\":{\"848\":1}}],[\"关键字加到\",{\"1\":{\"848\":1}}],[\"关键字的使用方式主要有下面\",{\"1\":{\"848\":1}}],[\"关键字能保证变量的可见性\",{\"1\":{\"835\":1}}],[\"关键字能保证数据的可见性\",{\"1\":{\"833\":1,\"855\":1}}],[\"关键字禁止指令重排序的效果\",{\"1\":{\"834\":1}}],[\"关键字除了可以保证变量的可见性\",{\"1\":{\"834\":1}}],[\"关键字两者都能保证\",{\"1\":{\"833\":1,\"855\":1}}],[\"关键字其实并非是\",{\"1\":{\"833\":1}}],[\"关键字创建\",{\"1\":{\"777\":1}}],[\"关键字\",{\"0\":{\"777\":1,\"832\":1,\"846\":1},\"1\":{\"776\":1}}],[\"关键字主要⽤在三个地⽅\",{\"1\":{\"521\":1}}],[\"关键字修饰给去掉了\",{\"1\":{\"896\":1,\"923\":1}}],[\"关键字修饰也是很有必要的\",{\"1\":{\"834\":1}}],[\"关键字修饰\",{\"1\":{\"435\":1,\"744\":1,\"849\":1,\"860\":1}}],[\"关键字修饰的接口方法\",{\"1\":{\"344\":1}}],[\"关键字修饰的变量\",{\"1\":{\"342\":1}}],[\"关键字public\",{\"1\":{\"342\":1}}],[\"关键字模拟优化器执行\",{\"1\":{\"120\":1}}],[\"关键字这类\",{\"1\":{\"60\":1}}],[\"关闭自动提交\",{\"1\":{\"1207\":1}}],[\"关闭线程池\",{\"1\":{\"924\":3,\"945\":2}}],[\"关闭\",{\"1\":{\"449\":1}}],[\"关闭认证\",{\"1\":{\"373\":1}}],[\"关\",{\"1\":{\"265\":1}}],[\"关于发送消息\",{\"0\":{\"1288\":1}}],[\"关于中间件比较详细的介绍可以参考阿里巴巴淘系技术的一篇回答\",{\"1\":{\"1218\":1}}],[\"关于它为什么这么快这个问题\",{\"1\":{\"1179\":1}}],[\"关于如何在\",{\"1\":{\"1178\":1}}],[\"关于这个问题的详细答案\",{\"1\":{\"1174\":1}}],[\"关于这几种优化的详细信息可以查看下面这篇文章\",{\"1\":{\"854\":1}}],[\"关于平台线程和系统内核线程的对应关系多提一点\",{\"1\":{\"1053\":1}}],[\"关于公平锁和非公平锁的原理分析\",{\"1\":{\"1002\":1}}],[\"关于主内存与工作内存直接的具体交互协议\",{\"1\":{\"972\":1}}],[\"关于定时任务的详细介绍\",{\"1\":{\"962\":1}}],[\"关于饱和策略下面单独介绍一下\",{\"1\":{\"890\":1,\"936\":1}}],[\"关于虚拟线程\",{\"1\":{\"808\":1}}],[\"关于priorityqueue可以参考笔者编写的这篇文章\",{\"1\":{\"597\":1}}],[\"关于java\",{\"1\":{\"583\":1}}],[\"关于生产者\",{\"1\":{\"535\":1}}],[\"关于常见垃圾回收算法的详细介绍\",{\"1\":{\"447\":1}}],[\"关于常见的缓存读写策略的详细介绍\",{\"1\":{\"247\":1}}],[\"关于具体是标记可回收对象还是不可回收对象\",{\"1\":{\"396\":1}}],[\"关于默认的晋升年龄是\",{\"1\":{\"386\":1}}],[\"关于堆空间结构更详细的介绍\",{\"1\":{\"382\":1}}],[\"关于方法区的详细介绍\",{\"1\":{\"341\":1}}],[\"关于\",{\"0\":{\"450\":1,\"1133\":1},\"1\":{\"6\":1,\"7\":1,\"35\":1,\"51\":1,\"161\":1,\"236\":1,\"244\":1,\"249\":1,\"250\":1,\"252\":1,\"254\":1,\"268\":1,\"281\":2,\"408\":1,\"444\":1,\"544\":1,\"724\":1,\"742\":1,\"792\":1,\"793\":1,\"841\":1,\"857\":1,\"862\":1,\"990\":1,\"1085\":1,\"1184\":1,\"1343\":1,\"1361\":1}}],[\"举一个简单的例子\",{\"1\":{\"840\":1,\"841\":1,\"989\":1,\"990\":1}}],[\"举个栗子\",{\"1\":{\"478\":1,\"479\":2}}],[\"举个例子\",{\"1\":{\"60\":2,\"217\":1,\"306\":1,\"309\":1,\"313\":1,\"343\":1,\"686\":1,\"772\":1,\"816\":1,\"869\":1,\"891\":1,\"936\":1,\"972\":1,\"974\":1,\"1068\":1,\"1154\":1,\"1165\":1}}],[\"举例如下\",{\"1\":{\"1105\":1}}],[\"举例说明\",{\"1\":{\"141\":1,\"1358\":1}}],[\"举例\",{\"1\":{\"24\":1,\"33\":1,\"34\":1,\"145\":2,\"178\":2,\"182\":1,\"186\":1,\"190\":3,\"194\":2,\"203\":1,\"207\":1,\"211\":1,\"1221\":1}}],[\"威胁到程序的正常运行\",{\"1\":{\"60\":1}}],[\"针对更复杂的路由功能\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"针对存在恶意节点的情况\",{\"1\":{\"1097\":1}}],[\"针对没有恶意节点的情况\",{\"1\":{\"1097\":1}}],[\"针对于这些场景\",{\"1\":{\"1045\":1}}],[\"针对不同的情况我们画图来说明\",{\"1\":{\"1035\":1}}],[\"针对链表长度比较大的时候\",{\"1\":{\"800\":1}}],[\"针对热点缓存失效的情况\",{\"1\":{\"314\":1}}],[\"针对热点数据提前预热\",{\"1\":{\"310\":1}}],[\"针对\",{\"1\":{\"314\":1,\"387\":1}}],[\"针对网络数据的读写引入了多线程\",{\"1\":{\"245\":1}}],[\"针对单个文件操作\",{\"1\":{\"230\":1}}],[\"针对insert与delete操作\",{\"1\":{\"130\":1}}],[\"针对update操作\",{\"1\":{\"130\":1}}],[\"针对面试和工作应该够用了\",{\"1\":{\"59\":1}}],[\"针对这个问题\",{\"1\":{\"51\":1}}],[\"尝试从一个空队列中取一个元素也会同样阻塞\",{\"1\":{\"797\":1}}],[\"尝试从队列中取出元素\",{\"1\":{\"531\":1}}],[\"尝试将元素放入队列将导致操作阻塞\",{\"1\":{\"797\":1}}],[\"尝试将前驱节点指向后继节点\",{\"1\":{\"710\":1}}],[\"尝试获得锁\",{\"1\":{\"752\":1}}],[\"尝试获取许可证\",{\"1\":{\"748\":2,\"906\":1}}],[\"尝试获取资源\",{\"1\":{\"744\":2,\"1007\":2}}],[\"尝试获取可重入锁\",{\"1\":{\"604\":3}}],[\"尝试获取lock\",{\"1\":{\"603\":1}}],[\"尝试获取\",{\"1\":{\"603\":1}}],[\"尝试获取锁的过程如下图所示\",{\"1\":{\"742\":1}}],[\"尝试获取锁\",{\"1\":{\"56\":1,\"752\":1}}],[\"尝试释放资源\",{\"1\":{\"744\":2,\"748\":1,\"1007\":2}}],[\"尝试让后继节点\",{\"1\":{\"711\":1}}],[\"尝试让前驱节点\",{\"1\":{\"711\":1}}],[\"尝试在空的\",{\"1\":{\"601\":1}}],[\"尝试写入\",{\"1\":{\"577\":1}}],[\"尝试向队列中添加元素\",{\"1\":{\"531\":1}}],[\"尝试取消执行任务\",{\"1\":{\"774\":1}}],[\"尝试取\",{\"1\":{\"531\":1}}],[\"尝试运行当前类的\",{\"1\":{\"433\":1}}],[\"尝试把数据插入到表中\",{\"1\":{\"33\":1}}],[\"监测线程池运行状态\",{\"0\":{\"918\":1}}],[\"监视应用程序的\",{\"1\":{\"377\":1}}],[\"监视与管理控制台\",{\"0\":{\"372\":1}}],[\"监视虚拟机各种运行状态信息\",{\"0\":{\"366\":1}}],[\"监视的\",{\"1\":{\"280\":3}}],[\"监听的是删除事件\",{\"1\":{\"55\":1}}],[\"监控中心负责统计各服务调用次数\",{\"1\":{\"1136\":1}}],[\"监控中心的作用呢\",{\"0\":{\"1136\":1}}],[\"监控层\",{\"1\":{\"1130\":1}}],[\"监控工具jconsole\",{\"1\":{\"516\":1}}],[\"监控的端口号\",{\"1\":{\"373\":1}}],[\"监控系统\",{\"1\":{\"8\":1}}],[\"监控告警\",{\"1\":{\"2\":1}}],[\"监控\",{\"1\":{\"1\":1,\"4\":1,\"5\":1,\"68\":1,\"896\":1,\"923\":1}}],[\"监控等功能是每个服务都需要的\",{\"1\":{\"1\":1}}],[\"但大多都是过时的\",{\"1\":{\"1208\":1}}],[\"但速度较慢\",{\"1\":{\"1184\":1}}],[\"但由于是这几年才出来的\",{\"1\":{\"1161\":1}}],[\"但结构体呢\",{\"1\":{\"1159\":1}}],[\"但现在其实已经没分那么清了\",{\"1\":{\"1155\":1,\"1161\":1}}],[\"但有个软件不同\",{\"1\":{\"1155\":1}}],[\"但实际上\",{\"1\":{\"1154\":1}}],[\"但实际还有一些后台线程用于执行一些比较耗时的操作\",{\"1\":{\"268\":1}}],[\"但原理都类似\",{\"1\":{\"1152\":1}}],[\"但原理非常复杂\",{\"1\":{\"205\":1}}],[\"但每个应用都可以根据自身业务特点\",{\"1\":{\"1074\":1}}],[\"但每个线程有自己的程序计数器\",{\"1\":{\"807\":1}}],[\"但响应式编程难以理解\",{\"1\":{\"1062\":1}}],[\"但inheritablethreadlocal仍然有缺陷\",{\"1\":{\"1043\":1}}],[\"但为什么获取了锁以后还要中断线程呢\",{\"1\":{\"1015\":1}}],[\"但为了维护双向链表访问的有序性\",{\"1\":{\"712\":1}}],[\"但都会执行下次循环\",{\"1\":{\"1015\":1}}],[\"但并没有修改\",{\"1\":{\"1012\":1}}],[\"但并非数据进入方法区后就\",{\"1\":{\"480\":1,\"496\":1}}],[\"但并非要挑选出一个最好的收集器\",{\"1\":{\"400\":1}}],[\"但请注意\",{\"1\":{\"1011\":1}}],[\"但第二步获取锁失败后\",{\"1\":{\"1002\":1}}],[\"但对\",{\"1\":{\"974\":1}}],[\"但又不是真正意义上的重排序\",{\"1\":{\"969\":1}}],[\"但其他\",{\"1\":{\"1380\":1}}],[\"但其他任务将继续运行\",{\"1\":{\"962\":1}}],[\"但其实并不满足原子性\",{\"1\":{\"287\":1}}],[\"但callable仅在\",{\"1\":{\"943\":1}}],[\"但若有空闲线程可以复用\",{\"1\":{\"937\":1}}],[\"但还是建议大家去简单了解一下\",{\"1\":{\"912\":1}}],[\"但要注意\",{\"1\":{\"904\":1}}],[\"但凡涉及到网络读取\",{\"1\":{\"895\":1,\"922\":1}}],[\"但使用起来相对比较麻烦\",{\"1\":{\"873\":1}}],[\"但可能会导致某些线程永远无法获取到锁\",{\"1\":{\"858\":1}}],[\"但可以接收一个\",{\"1\":{\"669\":1}}],[\"但可以创建多个辅助索引\",{\"1\":{\"114\":1}}],[\"但失败的线程并不会被挂起\",{\"1\":{\"841\":1,\"990\":1}}],[\"但你真正运行了上面的代码之后\",{\"1\":{\"835\":1}}],[\"但此时积分系统是成功收到消息的\",{\"1\":{\"1370\":1}}],[\"但此时比对数据库记录版本时发现\",{\"1\":{\"840\":1,\"989\":1}}],[\"但此时\",{\"1\":{\"834\":1,\"1380\":1}}],[\"但此时用户线程仍然处于等待状态\",{\"1\":{\"402\":1}}],[\"但线程是一个比进程更小的执行单位\",{\"1\":{\"807\":1}}],[\"但一个重要的区别是\",{\"1\":{\"800\":1}}],[\"但一般不会使用\",{\"1\":{\"535\":1}}],[\"但一般正常调用的情况下是不会出现问题的\",{\"1\":{\"493\":1}}],[\"但没有剩余可用资源\",{\"1\":{\"744\":1,\"1007\":1}}],[\"但没关系\",{\"1\":{\"96\":1}}],[\"但它是个无边界的数据流\",{\"1\":{\"1161\":1}}],[\"但它们之间的权重不同\",{\"1\":{\"1142\":1}}],[\"但它们到\",{\"1\":{\"391\":1}}],[\"但它提供了更多的功能并且迭代效率相较于\",{\"1\":{\"719\":1}}],[\"但问题是一个\",{\"1\":{\"684\":1}}],[\"但两者有什么区别呢\",{\"1\":{\"668\":1}}],[\"但这个就要分为两种情况了\",{\"1\":{\"1380\":1}}],[\"但这里的匹配规则有些不同\",{\"1\":{\"1252\":1}}],[\"但这样增加了成本\",{\"1\":{\"1123\":1}}],[\"但这是通过使用一个全局的锁来同步不同线程间的并发访问\",{\"1\":{\"792\":1}}],[\"但这相当于对整个\",{\"1\":{\"583\":1,\"793\":1}}],[\"但这并不意味着必须拷贝数据\",{\"1\":{\"141\":1}}],[\"但队列已空\",{\"1\":{\"531\":1}}],[\"但队列已满\",{\"1\":{\"531\":1}}],[\"但从\",{\"1\":{\"506\":1}}],[\"但随着扩展会不断地申请内存\",{\"1\":{\"439\":1}}],[\"但会在先前构建的线程可用时重用它\",{\"1\":{\"957\":1}}],[\"但会尽量效率地把知识点都抛出来\",{\"1\":{\"416\":1}}],[\"但会对机器的\",{\"1\":{\"236\":1}}],[\"但后续步骤不是直接对可回收对象回收\",{\"1\":{\"398\":1}}],[\"但依然存在下面这些问题\",{\"1\":{\"397\":1}}],[\"但很有必要\",{\"1\":{\"341\":1}}],[\"但缓存雪崩导致的原因是缓存中的大量或者所有数据失效\",{\"1\":{\"315\":1}}],[\"但同样让系统复杂性提升\",{\"1\":{\"286\":1}}],[\"但性能太差\",{\"1\":{\"282\":1}}],[\"但通过使用\",{\"1\":{\"265\":1}}],[\"但\",{\"1\":{\"256\":1,\"407\":1,\"616\":1,\"668\":1,\"677\":1,\"693\":1,\"743\":1,\"781\":1,\"882\":1,\"972\":1,\"974\":1,\"1159\":1}}],[\"但不提交\",{\"1\":{\"1370\":1}}],[\"但不同的地方在于\",{\"1\":{\"1158\":1}}],[\"但不太能分高低\",{\"1\":{\"1157\":1}}],[\"但不适用于计算密集型任务\",{\"1\":{\"1056\":1}}],[\"但不能保证对变量的操作是原子性的\",{\"1\":{\"835\":1}}],[\"但不能保证数据的原子性\",{\"1\":{\"833\":1,\"855\":1}}],[\"但不利于资源的管理和保护\",{\"1\":{\"810\":1}}],[\"但不可以利用多核\",{\"1\":{\"808\":1}}],[\"但不再乎其如何实现\",{\"1\":{\"520\":1}}],[\"但不一定是并行\",{\"1\":{\"402\":1}}],[\"但不包括在方法内部声明的局部变量\",{\"1\":{\"331\":1}}],[\"但不存在于缓存中\",{\"1\":{\"309\":1,\"311\":1}}],[\"但不建议使用加锁的同步机制\",{\"1\":{\"694\":1}}],[\"但不建议使用\",{\"1\":{\"251\":1}}],[\"但不属于\",{\"1\":{\"189\":1}}],[\"但体积更小\",{\"1\":{\"233\":1,\"236\":1}}],[\"但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件\",{\"1\":{\"1315\":1}}],[\"但也是\",{\"1\":{\"1183\":1}}],[\"但也可以指定队列大小\",{\"1\":{\"542\":1,\"672\":1}}],[\"但也支持非阻塞获取和新增元素\",{\"1\":{\"541\":1}}],[\"但也带来了数据丢失的风险\",{\"1\":{\"230\":1}}],[\"但也有少部分\",{\"1\":{\"157\":1,\"301\":1}}],[\"但和\",{\"1\":{\"192\":1}}],[\"但如果一旦\",{\"1\":{\"167\":1}}],[\"但幻读仍有可能发生\",{\"1\":{\"132\":1}}],[\"但只是进行到了\",{\"1\":{\"1011\":1}}],[\"但只适合下列形式的子查询中的非唯一索引\",{\"1\":{\"120\":1}}],[\"但只有一个可以获取成功\",{\"1\":{\"55\":1}}],[\"但在使用之前我们还需要掌握几个概念\",{\"1\":{\"1381\":1}}],[\"但在中间出现了网络波动\",{\"1\":{\"1370\":1}}],[\"但在这个阶段结束\",{\"1\":{\"406\":1}}],[\"但在两次读取之间\",{\"1\":{\"128\":1}}],[\"但在\",{\"1\":{\"114\":1}}],[\"但允许有空值\",{\"1\":{\"104\":1}}],[\"但缺点是\",{\"1\":{\"96\":1}}],[\"但是过了一会\",{\"1\":{\"1380\":1}}],[\"但是挂了两个也不能正常工作了\",{\"1\":{\"1380\":1}}],[\"但是最重要的一致性并没有得到根本的解决\",{\"1\":{\"1371\":1}}],[\"但是内存限制了能够存储的容量不太大\",{\"1\":{\"1362\":1}}],[\"但是当两个机房中间网络断开的时候\",{\"1\":{\"1358\":1}}],[\"但是当前运行的线程数是小于最大线程数的\",{\"1\":{\"893\":1,\"941\":1}}],[\"但是你别忘了\",{\"1\":{\"1367\":1}}],[\"但是你真的了解\",{\"1\":{\"1341\":1}}],[\"但是你需要注意的是\",{\"1\":{\"1271\":1}}],[\"但是用的最多的还是上面介绍的\",{\"1\":{\"1335\":1}}],[\"但是随之的性能也会下降\",{\"1\":{\"1314\":1}}],[\"但是随着技术的成熟\",{\"1\":{\"8\":1}}],[\"但是积分系统在收到\",{\"1\":{\"1303\":1}}],[\"但是请注意它是\",{\"1\":{\"1281\":1}}],[\"但是请求数据在后续的业务校验\",{\"1\":{\"1220\":1}}],[\"但是对应一个\",{\"1\":{\"1262\":1}}],[\"但是对并发内部的基本框架原理了解的人却不多\",{\"1\":{\"1021\":1}}],[\"但是提供超高的吞吐量\",{\"1\":{\"1240\":1}}],[\"但是也有各自的问题\",{\"1\":{\"1304\":1}}],[\"但是也因为\",{\"1\":{\"1240\":1}}],[\"但是也需要注意控制复制的数据量\",{\"1\":{\"588\":1}}],[\"但是较目前来说\",{\"1\":{\"1240\":1}}],[\"但是其对跨平台的支持较差\",{\"1\":{\"1231\":1}}],[\"但是带来了数据的安全性\",{\"1\":{\"1206\":1}}],[\"但是为了保证消息不丢失的话一般会设置比较大一点\",{\"1\":{\"1204\":1}}],[\"但是为什么所有的变化都是对\",{\"1\":{\"1013\":1}}],[\"但是一般不推荐这么做\",{\"1\":{\"1204\":1}}],[\"但是要注意的是\",{\"1\":{\"1204\":1}}],[\"但是破坏了\",{\"1\":{\"1202\":1}}],[\"但是作者说测试不充分\",{\"1\":{\"1183\":1}}],[\"但是基本把\",{\"1\":{\"1166\":1}}],[\"但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性\",{\"1\":{\"1078\":1}}],[\"但是因为某些故障\",{\"1\":{\"1067\":1}}],[\"但是仍然会存在冲突\",{\"1\":{\"1033\":1}}],[\"但是此时提案者\",{\"1\":{\"1375\":1}}],[\"但是此时生产者无法再给主节点生产消息了\",{\"1\":{\"1314\":1}}],[\"但是此时\",{\"1\":{\"1014\":1}}],[\"但是锁被线程\",{\"1\":{\"1011\":1}}],[\"但是锁被其它线程占有\",{\"1\":{\"820\":1}}],[\"但是都调用了\",{\"1\":{\"1002\":1}}],[\"但是具体是如何加锁的呢\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"但是没有义务保证多线程间的语义也一致\",{\"1\":{\"969\":1,\"980\":1,\"981\":1}}],[\"但是队列里的任务得执行完毕\",{\"1\":{\"924\":1,\"945\":1}}],[\"但是优先级会被提升\",{\"1\":{\"897\":1}}],[\"但是小于最大线程数\",{\"1\":{\"893\":1,\"941\":1}}],[\"但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题\",{\"1\":{\"881\":1}}],[\"但是给缓存加一个比较短的过期时间\",{\"1\":{\"145\":1}}],[\"但是读锁却不能升级为写锁\",{\"1\":{\"869\":1}}],[\"但是从\",{\"1\":{\"845\":1,\"994\":1}}],[\"但是很多人都会答不上来\",{\"1\":{\"827\":1}}],[\"但是并发编程并不总是能提高程序运行速度的\",{\"1\":{\"817\":1}}],[\"但是每个实例都同步\",{\"1\":{\"1263\":1}}],[\"但是每个线程有自己的程序计数器\",{\"1\":{\"810\":1}}],[\"但是每次插入数据时均需要申请新的堆空间\",{\"1\":{\"668\":1}}],[\"但是注释上写着\",{\"1\":{\"767\":2}}],[\"但是有了双向链表明确的前后节点关系\",{\"1\":{\"713\":1}}],[\"但是已经简化了属性\",{\"1\":{\"688\":1,\"792\":1}}],[\"但是还是不建议在多线程下使用\",{\"1\":{\"685\":1}}],[\"但是还是保留了分代的概念\",{\"1\":{\"407\":1}}],[\"但是需要借助于condition接口与newcondition\",{\"1\":{\"862\":1}}],[\"但是需要注意的一点是如果你要删除某一个节点\",{\"1\":{\"1331\":1}}],[\"但是需要注意的是treemap它还实现了navigablemap接口和sortedmap\",{\"1\":{\"679\":1}}],[\"但是需要注意\",{\"1\":{\"781\":1}}],[\"但是需要明确\",{\"1\":{\"157\":1,\"301\":1,\"319\":1}}],[\"但是原理不变\",{\"1\":{\"618\":1,\"682\":1}}],[\"但是它同时也会减少两次上下文切换\",{\"1\":{\"1311\":1}}],[\"但是它们只提供了最基本的\",{\"1\":{\"1172\":1}}],[\"但是它们的实现方式不同\",{\"1\":{\"611\":1}}],[\"但是它的功能比\",{\"1\":{\"755\":1,\"910\":1}}],[\"但是它有下面三个明显的缺点\",{\"1\":{\"406\":1}}],[\"但是在分布式架构中\",{\"1\":{\"1304\":1}}],[\"但是在不同系统中如何保证事务呢\",{\"1\":{\"1275\":1}}],[\"但是在多线程环境下会导致一个线程获得还没有初始化的实例\",{\"1\":{\"834\":1}}],[\"但是在\",{\"1\":{\"598\":1}}],[\"但是在性能上会有一些损失\",{\"1\":{\"8\":1}}],[\"但是容易被忽视掉的知识点\",{\"1\":{\"558\":1}}],[\"但是第二个\",{\"1\":{\"558\":1}}],[\"但是arraylist数组的内容\",{\"1\":{\"553\":1}}],[\"但是如果发现有相同\",{\"1\":{\"680\":1}}],[\"但是如果要在指定位置\",{\"1\":{\"552\":1,\"656\":1}}],[\"但是如何执行\",{\"1\":{\"86\":1}}],[\"但是这些系统往往都存在分布式单点问题\",{\"1\":{\"1343\":1}}],[\"但是这些优化都是在虚拟机层面实现的\",{\"1\":{\"861\":1}}],[\"但是这种复制方式同样也会带来一个问题\",{\"1\":{\"1314\":1}}],[\"但是这种严格的匹配方式在很多情况下不能满足实际业务的需求\",{\"1\":{\"1252\":1}}],[\"但是这样也让它变为了同步操作\",{\"1\":{\"1204\":1}}],[\"但是这样做\",{\"1\":{\"708\":1}}],[\"但是这部分内存也被频繁地使用\",{\"1\":{\"499\":1}}],[\"但是这个时候方法区中是没有\",{\"1\":{\"425\":1}}],[\"但是这个功能不实用\",{\"1\":{\"85\":1}}],[\"但是比原来出现的几率会更小\",{\"1\":{\"496\":1}}],[\"但是永久区溢出\",{\"1\":{\"456\":1}}],[\"但是操作系统对一个进程内的线程数还是有限制的\",{\"1\":{\"449\":1,\"458\":1}}],[\"但是我\",{\"1\":{\"1062\":1}}],[\"但是我们知道在发布订阅模型中\",{\"1\":{\"1275\":1}}],[\"但是我们知道对堆内存是线程共享的\",{\"1\":{\"444\":1}}],[\"但是我们只需要传达一个消息就可以干其他事情了\",{\"1\":{\"1271\":1}}],[\"但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理\",{\"1\":{\"782\":1,\"909\":1}}],[\"但是我觉得其实没太大必要\",{\"1\":{\"316\":1}}],[\"但是他们因为互相引用对方\",{\"1\":{\"390\":1}}],[\"但是目前主流的虚拟机中并没有选择这个算法来管理内存\",{\"1\":{\"390\":1}}],[\"但是业务类在\",{\"1\":{\"359\":1}}],[\"但是可以通过\",{\"1\":{\"1257\":1}}],[\"但是可以作为\",{\"1\":{\"356\":1}}],[\"但是可能会造成太多过期\",{\"1\":{\"272\":1}}],[\"但是由我们自定义的类加载器加载的类是可能被卸载的\",{\"1\":{\"345\":1}}],[\"但是由于它基于\",{\"1\":{\"1240\":1}}],[\"但是由于系统访问量突然剧增\",{\"1\":{\"1076\":1}}],[\"但是由于系统出现故障\",{\"1\":{\"1076\":1}}],[\"但是由于\",{\"1\":{\"89\":1,\"834\":1,\"1007\":1}}],[\"但是增加了synchronized\",{\"1\":{\"332\":1}}],[\"但是低版本的\",{\"1\":{\"327\":1}}],[\"但是之前已经发生的写操作不会撤销\",{\"1\":{\"288\":1}}],[\"但是官网描述开启多线程读并不能有太大提升\",{\"1\":{\"267\":1}}],[\"但是使用\",{\"1\":{\"246\":1}}],[\"但是会增加内存消耗\",{\"1\":{\"217\":1}}],[\"但是被我问到\",{\"1\":{\"144\":1}}],[\"但是不允许使用异步化和自定义处理流程\",{\"1\":{\"1292\":1}}],[\"但是不太推荐\",{\"1\":{\"1172\":1}}],[\"但是不同项目之间如何传递\",{\"1\":{\"1045\":1}}],[\"但是不在乎每个实现类如何具体实现\",{\"1\":{\"520\":1}}],[\"但是不能写入消息\",{\"1\":{\"1281\":1}}],[\"但是不能超过\",{\"1\":{\"456\":1}}],[\"但是不能做到写读\",{\"1\":{\"140\":1}}],[\"但是不代表它的应用场景少\",{\"1\":{\"147\":1}}],[\"但是不支持范围查询和前缀匹配\",{\"1\":{\"103\":1}}],[\"但是多个请求里有读请求\",{\"1\":{\"140\":1}}],[\"但是幻读或不可重复读仍有可能发生\",{\"1\":{\"132\":1}}],[\"但是添加了mysql可以专门搜索包含null值的行\",{\"1\":{\"120\":1}}],[\"但是同时也会降低增删改操作速度\",{\"1\":{\"94\":1}}],[\"但是\",{\"1\":{\"29\":1,\"37\":1,\"71\":1,\"89\":2,\"101\":1,\"144\":1,\"147\":1,\"176\":1,\"180\":1,\"245\":2,\"246\":1,\"266\":1,\"267\":1,\"272\":1,\"307\":1,\"354\":1,\"359\":1,\"401\":1,\"484\":1,\"495\":1,\"499\":1,\"569\":1,\"579\":1,\"647\":1,\"684\":1,\"686\":1,\"694\":1,\"742\":1,\"799\":1,\"827\":1,\"838\":1,\"855\":1,\"934\":1,\"943\":1,\"968\":1,\"985\":1,\"987\":1,\"1069\":1,\"1076\":1,\"1087\":1,\"1123\":1,\"1144\":1,\"1165\":1,\"1172\":1,\"1192\":1,\"1197\":1,\"1205\":2,\"1206\":2,\"1224\":2,\"1277\":1,\"1280\":1,\"1281\":1,\"1299\":1,\"1304\":1,\"1311\":1,\"1313\":1,\"1315\":1,\"1335\":1,\"1346\":1,\"1355\":1,\"1359\":1,\"1367\":2,\"1382\":1,\"1387\":1,\"1389\":1}}],[\"但是像安全认证\",{\"1\":{\"1\":1}}],[\"同年获得此大奖荣誉的还有大名鼎鼎的\",{\"1\":{\"1178\":1}}],[\"同意\",{\"1\":{\"1112\":1}}],[\"同学之间如果采用传纸条的方式去传播消息\",{\"1\":{\"1369\":1}}],[\"同学\",{\"1\":{\"982\":1}}],[\"同理\",{\"1\":{\"537\":1}}],[\"同理消费者也会通过\",{\"1\":{\"531\":1}}],[\"同理方法\",{\"1\":{\"441\":1}}],[\"同样适合读多写少的业务场景\",{\"1\":{\"873\":1}}],[\"同样适用于\",{\"1\":{\"449\":1}}],[\"同样满足\",{\"1\":{\"798\":1}}],[\"同样继承了\",{\"1\":{\"727\":1}}],[\"同样的\",{\"1\":{\"712\":1}}],[\"同样\",{\"1\":{\"693\":1,\"1315\":1}}],[\"同样根据失败后处理方式的不同分为两类\",{\"1\":{\"667\":1}}],[\"同样在\",{\"1\":{\"287\":1}}],[\"同样需要修改\",{\"1\":{\"267\":1}}],[\"同样支持定制化的插件开发\",{\"1\":{\"8\":1}}],[\"同步完成之后准\",{\"1\":{\"1356\":1}}],[\"同步集群中所有的副本\",{\"1\":{\"1356\":1}}],[\"同步阶段主要是利用\",{\"1\":{\"1356\":1}}],[\"同步阶段\",{\"1\":{\"1356\":1}}],[\"同步双写\",{\"1\":{\"1314\":1}}],[\"同步复制\",{\"1\":{\"1314\":1}}],[\"同步复制和异步复制\",{\"0\":{\"1314\":1}}],[\"同步刷盘对\",{\"1\":{\"1313\":1}}],[\"同步刷盘和异步刷盘\",{\"0\":{\"1313\":1}}],[\"同步刷盘\",{\"1\":{\"1312\":1}}],[\"同步刷盘或者异步刷盘\",{\"1\":{\"1281\":1}}],[\"同步数据\",{\"1\":{\"1281\":1}}],[\"同步等待大妈给我配好饭菜\",{\"1\":{\"1271\":1}}],[\"同步通信\",{\"1\":{\"1271\":1}}],[\"同步程度达不到要求的副本中选择出\",{\"1\":{\"1206\":1}}],[\"同步程度达不到要求的参加不了\",{\"1\":{\"1197\":1}}],[\"同步转异步\",{\"1\":{\"1130\":1}}],[\"同步日志\",{\"1\":{\"1108\":1}}],[\"同步工具与\",{\"1\":{\"1019\":1}}],[\"同步工具\",{\"1\":{\"1019\":1}}],[\"同步状态实现对独占线程变量的设置\",{\"1\":{\"1019\":1}}],[\"同步状态中的\",{\"1\":{\"1019\":1}}],[\"同步状态来表示计数\",{\"1\":{\"1019\":1}}],[\"同步状态来保存信号量的当前计数\",{\"1\":{\"1019\":1}}],[\"同步状态\",{\"0\":{\"1006\":1},\"1\":{\"1002\":2}}],[\"同步语句块的实现使用的是\",{\"1\":{\"851\":1,\"853\":1}}],[\"同步语句块的情况\",{\"0\":{\"851\":1}}],[\"同步和异步的区别\",{\"0\":{\"815\":1}}],[\"同步器\",{\"1\":{\"755\":1,\"910\":1}}],[\"同步器的设计是基于模板方法模式的\",{\"1\":{\"744\":1}}],[\"同步控制\",{\"0\":{\"698\":1},\"1\":{\"695\":1}}],[\"同步队列中\",{\"1\":{\"904\":1}}],[\"同步队列\",{\"1\":{\"671\":1,\"889\":1,\"892\":1,\"937\":1,\"938\":1}}],[\"同步\",{\"1\":{\"231\":1,\"815\":1,\"1299\":1,\"1356\":1}}],[\"同步到到磁盘\",{\"1\":{\"230\":1}}],[\"同步硬盘操作通常依赖于系统调度机制\",{\"1\":{\"230\":1}}],[\"同步一次\",{\"1\":{\"161\":1,\"230\":1,\"231\":1}}],[\"同步保存操作\",{\"1\":{\"158\":1,\"227\":1}}],[\"同步更新数据\",{\"1\":{\"1379\":1}}],[\"同步更新\",{\"1\":{\"146\":1}}],[\"同一分组内所有消费者的消费行为必然是一致的\",{\"1\":{\"1297\":1}}],[\"同一\",{\"1\":{\"1181\":1}}],[\"同一个消费队列收到的消息是有顺序的\",{\"1\":{\"1299\":1}}],[\"同一个消费组中的所有消费者\",{\"1\":{\"1281\":1}}],[\"同一个\",{\"1\":{\"1202\":1}}],[\"同一个topic\",{\"1\":{\"1199\":1}}],[\"同一个服务部署在不同的机器时该调用哪一台机器上的服务\",{\"1\":{\"1123\":1}}],[\"同一个节点可能会重复收到相同的消息\",{\"1\":{\"1090\":1}}],[\"同一个线程多次获得锁是\",{\"1\":{\"1018\":1}}],[\"同一个线程在调用method1\",{\"1\":{\"860\":1}}],[\"同一个事务内生成的read\",{\"1\":{\"141\":1}}],[\"同一把锁\",{\"1\":{\"688\":1}}],[\"同一时刻只能有一个线程在运行\",{\"1\":{\"819\":1}}],[\"同一时刻只有一个线程可以获取到分布式锁访问共享资源\",{\"1\":{\"60\":1}}],[\"同一时刻只有一个线程可以获取到本地锁访问共享资源\",{\"1\":{\"60\":1}}],[\"同一时间段内\",{\"1\":{\"55\":1}}],[\"同时实现\",{\"1\":{\"1388\":1}}],[\"同时实现了\",{\"1\":{\"774\":1,\"901\":1}}],[\"同时你还要去解决分布式带来的一系列问题\",{\"1\":{\"1367\":1}}],[\"同时你还需要增加每个主题的队列数量\",{\"1\":{\"1305\":1}}],[\"同时集群中已经有过半的机器与该\",{\"1\":{\"1361\":1}}],[\"同时如果有新的节点加入\",{\"1\":{\"1356\":1}}],[\"同时如果我们听到局部变量表\",{\"1\":{\"438\":1}}],[\"同时返回给\",{\"1\":{\"1112\":1}}],[\"同时需要记住自己的投票历史\",{\"1\":{\"1098\":1}}],[\"同时采取问答的模式来帮助大家理解\",{\"1\":{\"999\":1}}],[\"同时传入的任务实例firsttask为null\",{\"1\":{\"941\":1}}],[\"同时执行拒绝策略\",{\"1\":{\"941\":1}}],[\"同时会唤醒同步队列中的一个线程\",{\"1\":{\"906\":2}}],[\"同时会唤醒等待队列中的一个线程\",{\"1\":{\"748\":1}}],[\"同时允许一个写线程获取写锁\",{\"1\":{\"871\":1}}],[\"同时又可以保证有写入操作时的线程安全\",{\"1\":{\"865\":1,\"866\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"324\":1}}],[\"同时运行多个线程的效率是否会高\",{\"1\":{\"819\":1}}],[\"同时我们可以干点其他事情\",{\"1\":{\"773\":1,\"899\":1}}],[\"同时对队列的读写存在多个线程同时进行的场景\",{\"1\":{\"794\":1}}],[\"同时对\",{\"1\":{\"694\":1}}],[\"同时进行\",{\"1\":{\"686\":1}}],[\"同时通过对链表进行相应的操作\",{\"1\":{\"645\":1}}],[\"同时请求相同资源\",{\"1\":{\"585\":1}}],[\"同时提供一些能被外界访问属性的方法\",{\"1\":{\"518\":1}}],[\"同时这个\",{\"1\":{\"412\":1}}],[\"同时开启\",{\"1\":{\"406\":1}}],[\"同时工作\",{\"1\":{\"406\":1}}],[\"同时\",{\"1\":{\"382\":1,\"406\":1,\"533\":2,\"607\":1,\"799\":1,\"814\":1,\"1011\":1,\"1104\":1,\"1161\":1,\"1196\":1,\"1240\":1,\"1257\":1,\"1390\":1}}],[\"同时使用了惰性删除与定期删除\",{\"1\":{\"245\":1}}],[\"同时还可以挂载子节点\",{\"1\":{\"1382\":1}}],[\"同时还能够通过该连接接收来自服务器的\",{\"1\":{\"1353\":1}}],[\"同时还具有多样化的操作方式\",{\"1\":{\"647\":1}}],[\"同时还提供\",{\"1\":{\"245\":1}}],[\"同时还有一个日志模块\",{\"1\":{\"90\":1}}],[\"同时也提出了一个方案\",{\"1\":{\"1375\":1}}],[\"同时也不需要像\",{\"1\":{\"1159\":1}}],[\"同时也支持集群方式和广播方式的消费\",{\"1\":{\"1281\":1}}],[\"同时也支持基于\",{\"1\":{\"1130\":1}}],[\"同时也支持对历史\",{\"1\":{\"233\":1}}],[\"同时也会与其他加入的对象的\",{\"1\":{\"680\":1}}],[\"同时也是支持\",{\"1\":{\"324\":1}}],[\"同时也贡献给了社区并随此次\",{\"1\":{\"233\":1}}],[\"同时将一个或多个\",{\"1\":{\"185\":1,\"286\":1}}],[\"同时将这个更新操作记录到\",{\"1\":{\"89\":1}}],[\"同时满足微服务与大数据场景\",{\"1\":{\"1236\":1}}],[\"同时满足\",{\"1\":{\"71\":1}}],[\"该值为\",{\"1\":{\"1382\":1}}],[\"该协议能够很好地支持\",{\"1\":{\"1377\":1}}],[\"该提案\",{\"1\":{\"1374\":1,\"1380\":1}}],[\"该节点子节点列表最后一次被修改时的事务\",{\"1\":{\"1382\":1}}],[\"该节点的子节点个数\",{\"1\":{\"1382\":1}}],[\"该节点的子节点列表最后一次修改时的事务\",{\"1\":{\"1349\":1}}],[\"该节点最后一次被修改的时间\",{\"1\":{\"1382\":1}}],[\"该节点被创建的时间\",{\"1\":{\"1382\":1}}],[\"该节点不参与\",{\"1\":{\"1356\":1}}],[\"该版本号的值增加\",{\"1\":{\"1349\":1}}],[\"该版本仅仅支持延迟功能的实现\",{\"1\":{\"598\":1}}],[\"该模型开发逻辑简单\",{\"1\":{\"1292\":1}}],[\"该模式的延迟会很高\",{\"1\":{\"1206\":1}}],[\"该结果按照消费失败处理\",{\"1\":{\"1292\":1}}],[\"该消息通过主题传递给所有的订阅者\",{\"1\":{\"1194\":1,\"1229\":1}}],[\"该成员变量可以被设置为blockingwaitstrategy\",{\"1\":{\"1183\":1}}],[\"该\",{\"1\":{\"1111\":2,\"1374\":1}}],[\"该字段才会使用\",{\"1\":{\"1005\":1}}],[\"该图片来源\",{\"1\":{\"950\":1,\"954\":1,\"958\":1}}],[\"该任务才会被加入进去\",{\"1\":{\"941\":1}}],[\"该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池\",{\"1\":{\"937\":1}}],[\"该线程才会从阻塞中被唤醒\",{\"1\":{\"908\":1}}],[\"该线程池中的线程数量始终不变\",{\"1\":{\"888\":1,\"937\":1}}],[\"该线程可以继续获取读锁\",{\"1\":{\"868\":1}}],[\"该线程不能取得写锁\",{\"1\":{\"868\":1}}],[\"该线程是否正在独占资源\",{\"1\":{\"744\":1,\"1007\":1}}],[\"该标识指明了该方法是一个同步方法\",{\"1\":{\"852\":1,\"853\":1}}],[\"该资源任意一个时刻只由一个线程占用\",{\"1\":{\"823\":1}}],[\"该调用直接返回\",{\"1\":{\"815\":1}}],[\"该调用就不可以返回\",{\"1\":{\"815\":1}}],[\"该元素会被移动到链表的末尾\",{\"1\":{\"717\":1,\"718\":1}}],[\"该元素会被移动至链表末端\",{\"1\":{\"705\":2}}],[\"该元素后面的所有元素都要向左移动一位\",{\"1\":{\"653\":1}}],[\"该元素后面的所有元素都要向右移动一位\",{\"1\":{\"653\":1}}],[\"该方法含义是替换过期数据的逻辑\",{\"1\":{\"1035\":1}}],[\"该方法返回了当前线程的中断状态\",{\"1\":{\"1015\":1}}],[\"该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池\",{\"1\":{\"888\":1}}],[\"该方法返回一个可根据实际情况调整线程数量的线程池\",{\"1\":{\"888\":1,\"937\":1}}],[\"该方法返回一个只有一个线程的线程池\",{\"1\":{\"888\":1,\"937\":1}}],[\"该方法返回一个固定线程数量的线程池\",{\"1\":{\"888\":1,\"937\":1}}],[\"该方法其实是为了中断线程\",{\"1\":{\"1015\":1}}],[\"该方法继承于\",{\"1\":{\"1007\":1}}],[\"该方法就是通过\",{\"1\":{\"767\":1}}],[\"该方法如果获取不到许可就立即返回\",{\"1\":{\"749\":1}}],[\"该方法会尝试使用\",{\"1\":{\"742\":1}}],[\"该方法会返回\",{\"1\":{\"713\":1}}],[\"该方法会返回一个\",{\"1\":{\"706\":1}}],[\"该方法通过比较索引值与链表\",{\"1\":{\"730\":1}}],[\"该方法我们上文提到过\",{\"1\":{\"712\":1}}],[\"该方法被linkedhashmap重写\",{\"1\":{\"712\":1}}],[\"该方法可以将指定集合包装成线程同步的集合\",{\"1\":{\"698\":1}}],[\"该方法中又调用了另一个需要相同锁的方法\",{\"1\":{\"50\":1}}],[\"该接口继承了\",{\"1\":{\"610\":1}}],[\"该构造方法就意味着\",{\"1\":{\"534\":1}}],[\"该列表中会记录哪些内存块是可用的\",{\"1\":{\"503\":1}}],[\"该参数只有在串行gc时才有效\",{\"1\":{\"464\":1}}],[\"该参数不需要进行设置\",{\"1\":{\"449\":1,\"452\":1}}],[\"该参数能够返回所有\",{\"1\":{\"298\":1}}],[\"该对象就可以被程序使用\",{\"1\":{\"392\":1}}],[\"该选项不存在了\",{\"1\":{\"366\":1}}],[\"该选项仅表示老年代\",{\"1\":{\"366\":1}}],[\"该类实现了\",{\"1\":{\"1140\":1}}],[\"该类将整数值与引用关联起来\",{\"1\":{\"762\":1,\"767\":1}}],[\"该类将\",{\"1\":{\"762\":1,\"767\":1}}],[\"该类型可以用纯\",{\"1\":{\"485\":1}}],[\"该类型替换了下面形式的in子查询的ref\",{\"1\":{\"120\":1}}],[\"该类对应的\",{\"1\":{\"394\":1}}],[\"该类所有的实例都已经被回收\",{\"1\":{\"394\":1}}],[\"该类加载器才会尝试去加载\",{\"1\":{\"357\":1}}],[\"该类的类加载器的实例已被\",{\"1\":{\"345\":1}}],[\"该类的所有的实例对象都已被\",{\"1\":{\"345\":1}}],[\"该类没有在其他任何地方被引用\",{\"1\":{\"345\":1}}],[\"该数据节点被\",{\"1\":{\"1382\":1}}],[\"该数据节点关联的数据内容为空\",{\"1\":{\"1349\":1}}],[\"该数据戳用于稍后的锁释放参数\",{\"1\":{\"871\":1}}],[\"该数据\",{\"1\":{\"309\":1,\"311\":1}}],[\"该数据是可见的\",{\"1\":{\"141\":2}}],[\"该缓冲区会在子进程创建新\",{\"1\":{\"233\":1}}],[\"该缓冲区会在子线程创建新\",{\"1\":{\"162\":1}}],[\"该功能是通过读取数据库中的键值对来实现的\",{\"1\":{\"233\":1}}],[\"该文件可能存在多个\",{\"1\":{\"231\":1}}],[\"该文件最多只有一个\",{\"1\":{\"231\":1}}],[\"该时间可以忽略不计\",{\"1\":{\"167\":1}}],[\"该视图在事务结束之前永远都不会变化\",{\"1\":{\"141\":1}}],[\"该日志文件由两部分组成\",{\"1\":{\"135\":1}}],[\"该联接类型与all相同\",{\"1\":{\"120\":1}}],[\"该联接类型类似于unique\",{\"1\":{\"120\":1}}],[\"该联接类型表示使用了索引合并优化方法\",{\"1\":{\"120\":1}}],[\"该联接类型如同ref\",{\"1\":{\"120\":1}}],[\"该机制是\",{\"1\":{\"55\":1,\"1352\":1}}],[\"势必会造成所有尝试获取锁的客户端来争夺锁\",{\"1\":{\"54\":1}}],[\"绑定建\",{\"1\":{\"1249\":1}}],[\"绑定\",{\"1\":{\"1151\":1,\"1249\":3,\"1253\":2,\"1256\":1}}],[\"绑定的\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"绑定了商品的订单信息\",{\"1\":{\"17\":1}}],[\"临时解决办法\",{\"1\":{\"412\":1}}],[\"临时顺序\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"临时顺序节点\",{\"1\":{\"53\":1,\"1382\":2}}],[\"临时节点能很好的实现这些需求\",{\"1\":{\"1390\":1}}],[\"临时节点主要用来选举\",{\"1\":{\"1387\":1}}],[\"临时节点\",{\"1\":{\"1335\":1,\"1382\":3,\"1387\":1}}],[\"临时节点会话消失则对应的节点消失\",{\"1\":{\"54\":1}}],[\"临时节点相比持久节点\",{\"1\":{\"54\":1}}],[\"临时节点只能做叶子节点\",{\"1\":{\"54\":1,\"1349\":1}}],[\"临时节点的生命周期是与\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"临时\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"直译过来就是最小活跃数负载均衡\",{\"1\":{\"1142\":1}}],[\"直译过来就是闲话\",{\"1\":{\"1084\":1}}],[\"直译过来是交换的意思\",{\"1\":{\"168\":1}}],[\"直至队列非空时为止\",{\"1\":{\"796\":1}}],[\"直至所有线程的任务都执行完毕\",{\"1\":{\"751\":1,\"907\":1,\"909\":1}}],[\"直至\",{\"1\":{\"730\":1,\"752\":1,\"908\":1}}],[\"直到被下一次更改覆盖\",{\"1\":{\"1345\":1}}],[\"直到收到回复\",{\"1\":{\"1105\":1}}],[\"直到所有的节点都存储了该新数据\",{\"1\":{\"1088\":1}}],[\"直到所有文件读取完之后\",{\"1\":{\"909\":1}}],[\"直到entry为null则停止寻找\",{\"1\":{\"1035\":1}}],[\"直到遇到entry=null的槽位才停止迭代\",{\"1\":{\"1035\":1}}],[\"直到碰到entry为null结束\",{\"1\":{\"1035\":1}}],[\"直到抢到锁为止\",{\"1\":{\"1015\":1}}],[\"直到获取成功或者不再需要获取\",{\"1\":{\"1012\":1}}],[\"直到获取成功为止\",{\"1\":{\"56\":1}}],[\"直到count\",{\"1\":{\"908\":1}}],[\"直到线程池中线程的数量等于\",{\"1\":{\"890\":1}}],[\"直到等待的时间超过了\",{\"1\":{\"890\":1,\"936\":1}}],[\"直到锁被另外一个线程释放为止\",{\"1\":{\"851\":1}}],[\"直到操作完成\",{\"1\":{\"841\":1,\"990\":1}}],[\"直到更新成功\",{\"1\":{\"840\":1,\"989\":1}}],[\"直到满足每个线程对资源的最大需求\",{\"1\":{\"824\":1}}],[\"直到最后一个线程到达屏障时\",{\"1\":{\"755\":1,\"910\":1}}],[\"直到其他线程完成各自的任务\",{\"1\":{\"753\":1}}],[\"直到其他线程释放该锁\",{\"1\":{\"742\":1}}],[\"直到有一个许可证可以获得然后拿走一个许可证\",{\"1\":{\"749\":1}}],[\"直到有一个线程添加一个延迟任务后通过\",{\"1\":{\"601\":1}}],[\"直到有元素\",{\"1\":{\"670\":1}}],[\"直到\",{\"1\":{\"601\":1,\"752\":1,\"904\":1,\"1096\":1}}],[\"直到某个调用者试图修改资源的内容时\",{\"1\":{\"585\":1}}],[\"直到发现相同进行值替换\",{\"1\":{\"571\":1}}],[\"直到添加第\",{\"1\":{\"557\":1}}],[\"直到中断或被唤醒\",{\"1\":{\"539\":2}}],[\"直到队列未满\",{\"1\":{\"796\":1}}],[\"直到队列非空或者线程被中断\",{\"1\":{\"535\":1}}],[\"直到队列有空间可用或者线程被中断\",{\"1\":{\"535\":1}}],[\"直到成功为止\",{\"1\":{\"503\":1}}],[\"直到它收集结束\",{\"1\":{\"401\":1}}],[\"直到弹出消息\",{\"1\":{\"251\":1}}],[\"直到写入完成\",{\"1\":{\"161\":1}}],[\"直到写入完成释放锁\",{\"1\":{\"140\":1}}],[\"直到将其删除\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"直接进行生产消息\",{\"1\":{\"1281\":1}}],[\"直接进入年老代\",{\"1\":{\"464\":1}}],[\"直接崩溃\",{\"1\":{\"1273\":1}}],[\"直接set数据到对应的桶中\",{\"1\":{\"1036\":1}}],[\"直接主线程执行\",{\"1\":{\"891\":1}}],[\"直接丢弃掉\",{\"1\":{\"891\":1,\"936\":1}}],[\"直接执行\",{\"1\":{\"827\":2}}],[\"直接让链表尾指向当前节点的前一个节点\",{\"1\":{\"731\":1}}],[\"直接让链表头指向当前节点的下一个节点\",{\"1\":{\"731\":1}}],[\"直接让last\",{\"1\":{\"710\":1}}],[\"直接继承\",{\"1\":{\"708\":1}}],[\"直接看一下hashset中的源码\",{\"1\":{\"680\":1}}],[\"直接输出hashmap\",{\"1\":{\"625\":1}}],[\"直接计算元素新的位置即可\",{\"1\":{\"624\":1}}],[\"直接覆盖\",{\"1\":{\"618\":1,\"682\":1}}],[\"直接发起通知唤醒因为锁被当前消费者持有而导致阻塞的生产者\",{\"1\":{\"604\":1}}],[\"直接复制该元素前的所有元素到新的数组\",{\"1\":{\"591\":1}}],[\"直接从容器中取出消息供自己使用即可\",{\"1\":{\"1218\":1}}],[\"直接从线程池中获取线程来处理\",{\"1\":{\"886\":1}}],[\"直接从数组中获取下标为\",{\"1\":{\"589\":1}}],[\"直接从内存里面拿就舒服了\",{\"1\":{\"34\":1}}],[\"直接过一遍源码\",{\"1\":{\"578\":1}}],[\"直接过一遍\",{\"1\":{\"577\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"117\":1}}],[\"直接作为链表赋值到新位置\",{\"1\":{\"572\":1}}],[\"直接赋值\",{\"1\":{\"572\":1}}],[\"直接链表头插法插入\",{\"1\":{\"571\":1}}],[\"直接头插法插入\",{\"1\":{\"571\":1}}],[\"直接创建了长度是\",{\"1\":{\"555\":1}}],[\"直接抛出\",{\"1\":{\"539\":2}}],[\"直接抛出异常\",{\"1\":{\"536\":1}}],[\"直接指针\",{\"0\":{\"510\":1},\"1\":{\"508\":1,\"510\":1}}],[\"直接返回它的\",{\"1\":{\"578\":1}}],[\"直接返回元素\",{\"1\":{\"578\":1}}],[\"直接返回\",{\"1\":{\"539\":1,\"752\":1,\"1036\":1}}],[\"直接返回字符串常量池中字符串对象\",{\"1\":{\"498\":1}}],[\"直接返回请求参数错误信息给客户端\",{\"1\":{\"307\":1}}],[\"直接内存的分配不会受到\",{\"1\":{\"499\":1}}],[\"直接内存并不是虚拟机运行时数据区的一部分\",{\"1\":{\"499\":1}}],[\"直接内存是一种特殊的内存缓冲区\",{\"1\":{\"499\":1}}],[\"直接内存\",{\"0\":{\"499\":1},\"1\":{\"491\":1}}],[\"直接引用就是指针或者对象地址\",{\"1\":{\"429\":1}}],[\"直接调用父类即\",{\"1\":{\"709\":1}}],[\"直接调用poll返回出去\",{\"1\":{\"604\":1}}],[\"直接调用\",{\"1\":{\"412\":1,\"604\":1,\"777\":1}}],[\"直接生成的\",{\"1\":{\"351\":1}}],[\"直接使用\",{\"1\":{\"1036\":1}}],[\"直接使用并发相关的一些关键字和类\",{\"1\":{\"971\":1}}],[\"直接使用操作系统原生的内核级线程\",{\"1\":{\"808\":1}}],[\"直接使用slowlog\",{\"1\":{\"302\":1}}],[\"直接使用下面这几个命令就可以了\",{\"1\":{\"260\":1}}],[\"直接\",{\"1\":{\"257\":1,\"1281\":1}}],[\"直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的\",{\"1\":{\"246\":1}}],[\"直接解析还原数据即可\",{\"1\":{\"236\":1}}],[\"直接更新即可\",{\"1\":{\"1035\":1}}],[\"直接更新\",{\"1\":{\"146\":1}}],[\"直接判断并跳过\",{\"1\":{\"117\":1}}],[\"直接在客户端判断当前线程有没有获取锁\",{\"1\":{\"56\":1}}],[\"直接就会在\",{\"1\":{\"56\":1}}],[\"直接利用临时节点的特性即可\",{\"1\":{\"54\":1}}],[\"直接通过getmap\",{\"1\":{\"883\":1}}],[\"直接通过主键索引找到存储的数据\",{\"1\":{\"113\":1}}],[\"直接通过主键索引找到对应的关键字\",{\"1\":{\"106\":1}}],[\"直接通过\",{\"1\":{\"47\":1,\"220\":1}}],[\"直接用数字\",{\"1\":{\"24\":1}}],[\"大门的垫脚砖\",{\"1\":{\"1341\":1}}],[\"大型网站技术架构\",{\"1\":{\"1241\":1}}],[\"大数据\",{\"1\":{\"1236\":1}}],[\"大大简化了\",{\"1\":{\"1200\":1,\"1235\":1,\"1344\":1}}],[\"大大减少了hash冲突的概率\",{\"1\":{\"1033\":1}}],[\"大佬们造出了非常多款式的\",{\"1\":{\"1154\":1}}],[\"大约会在整个electiontimeout的时间内不可用\",{\"1\":{\"1116\":1}}],[\"大体介绍一下\",{\"1\":{\"1019\":1}}],[\"大体上来说\",{\"1\":{\"266\":1}}],[\"大多都会被问到\",{\"1\":{\"741\":1}}],[\"大多数情况下也可以将一个\",{\"1\":{\"1251\":1}}],[\"大多数情况下\",{\"1\":{\"384\":1}}],[\"大致意思还是单线程下可以容忍歧义\",{\"1\":{\"693\":1}}],[\"大于等于\",{\"1\":{\"1374\":1}}],[\"大于\",{\"1\":{\"570\":1,\"749\":1}}],[\"大于最大容量\",{\"1\":{\"559\":1}}],[\"大的优先\",{\"1\":{\"1380\":2}}],[\"大的优先作为\",{\"1\":{\"1380\":1}}],[\"大的优先为\",{\"1\":{\"1380\":1}}],[\"大的更新\",{\"1\":{\"1114\":1}}],[\"大的数\",{\"1\":{\"669\":1}}],[\"大的应用建议使用\",{\"1\":{\"449\":1}}],[\"大的回答\",{\"1\":{\"387\":2,\"808\":1,\"1053\":1}}],[\"大块\",{\"1\":{\"424\":1}}],[\"大白话带你认识\",{\"0\":{\"415\":1}}],[\"大对象就是需要大量连续内存空间的对象\",{\"1\":{\"385\":1}}],[\"大对象直接进入老年代是一种优化策略\",{\"1\":{\"385\":1}}],[\"大对象直接进入老年代的行为是由虚拟机动态决定的\",{\"1\":{\"385\":1}}],[\"大对象直接进入老年代\",{\"0\":{\"385\":1}}],[\"大对象不要创建索引\",{\"1\":{\"119\":1}}],[\"大家可能都会想到\",{\"1\":{\"1389\":1}}],[\"大家可以先自己仔细想一想\",{\"1\":{\"1357\":1}}],[\"大家可以先通过上面讲解的内容\",{\"1\":{\"941\":1}}],[\"大家可以对照着图进行理解\",{\"1\":{\"1304\":1}}],[\"大家可以在官网下载使用\",{\"1\":{\"1057\":1}}],[\"大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起\",{\"1\":{\"1343\":1}}],[\"大家尝试理解一下\",{\"1\":{\"1281\":1}}],[\"大家尝试着去理解一下\",{\"1\":{\"1280\":1}}],[\"大家注意一下就好\",{\"1\":{\"1166\":1}}],[\"大家的第一反应可能是很简单呀\",{\"1\":{\"1026\":1}}],[\"大家只需要简单了解一下即可\",{\"1\":{\"961\":1}}],[\"大家已经搞懂\",{\"1\":{\"882\":1}}],[\"大家知道\",{\"1\":{\"794\":1}}],[\"大家知道有这么个东西就可以了\",{\"1\":{\"340\":1}}],[\"大家一定要加入自己的思想\",{\"1\":{\"741\":1}}],[\"大家看名字就知道这个收集器是一个单线程收集器了\",{\"1\":{\"401\":1}}],[\"大家慢慢都转而使用更加强大的\",{\"1\":{\"244\":1}}],[\"大量使用\",{\"1\":{\"1151\":1}}],[\"大量请求落到同一节点\",{\"1\":{\"1143\":1}}],[\"大量请求将落到后面的数据库上\",{\"1\":{\"297\":1}}],[\"大量线程可能会同时在争取\",{\"1\":{\"895\":1,\"922\":1}}],[\"大量失败重试的问题也是可以解决的\",{\"1\":{\"838\":1,\"987\":1}}],[\"大量阻塞线程会导致系统的上下文切换\",{\"1\":{\"837\":1,\"986\":1,\"995\":1}}],[\"大量\",{\"0\":{\"289\":1}}],[\"大幅减少\",{\"1\":{\"285\":1}}],[\"大幅减小了网络开销\",{\"1\":{\"283\":1}}],[\"大部分是分布式系统的情况\",{\"1\":{\"1123\":1}}],[\"大部分人解释这一定律时\",{\"1\":{\"1068\":1}}],[\"大部分时间都花在了等待\",{\"1\":{\"895\":1,\"922\":1}}],[\"大部分情况\",{\"1\":{\"386\":1,\"495\":1}}],[\"大部分类在具体用到的时候才会去加载\",{\"1\":{\"352\":1}}],[\"大部分的轮询的请求都是无效请求\",{\"1\":{\"251\":1}}],[\"大部分原因是为了之后重用数据\",{\"1\":{\"224\":1}}],[\"大概可以总结出\",{\"1\":{\"1007\":1}}],[\"大概都在\",{\"1\":{\"246\":1}}],[\"大概率是因为我们经常使用的分布式缓存\",{\"1\":{\"146\":1}}],[\"大小在\",{\"1\":{\"1184\":1}}],[\"大小的方法\",{\"1\":{\"479\":1}}],[\"大小的空间\",{\"1\":{\"456\":1}}],[\"大小的内存\",{\"1\":{\"218\":1}}],[\"大小的内存之外\",{\"1\":{\"218\":1}}],[\"大小\",{\"1\":{\"233\":2,\"449\":1,\"570\":1}}],[\"大\",{\"0\":{\"163\":1,\"290\":1},\"1\":{\"163\":1,\"292\":3,\"558\":2,\"949\":1}}],[\"大文本\",{\"1\":{\"119\":1}}],[\"大类场景分析与总结\",{\"1\":{\"171\":1}}],[\"大类\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"大规模集群比如上百个节点的时候比较推荐\",{\"1\":{\"35\":1}}],[\"释放成功后\",{\"1\":{\"1007\":1}}],[\"释放线程资源\",{\"1\":{\"924\":1}}],[\"释放了对\",{\"1\":{\"824\":1}}],[\"释放资源则反序释放\",{\"1\":{\"824\":1}}],[\"释放5个许可\",{\"1\":{\"749\":1}}],[\"释放当前节点的后置等待节点\",{\"1\":{\"748\":1,\"752\":1}}],[\"释放共享锁\",{\"1\":{\"748\":2,\"752\":2,\"906\":2}}],[\"释放一个许可\",{\"1\":{\"749\":1}}],[\"释放一个许可证\",{\"1\":{\"748\":1,\"906\":1}}],[\"释放一个或者多个许可证\",{\"1\":{\"748\":1}}],[\"释放许可证成功之后\",{\"1\":{\"748\":1,\"906\":1}}],[\"释放1个许可\",{\"1\":{\"747\":1,\"905\":1}}],[\"释放可重入锁lock\",{\"1\":{\"604\":1}}],[\"释放可重入锁\",{\"1\":{\"604\":1}}],[\"释放leader引用\",{\"1\":{\"604\":1}}],[\"释放lock\",{\"1\":{\"603\":1}}],[\"释放\",{\"1\":{\"603\":1}}],[\"释放内存只是第一步\",{\"1\":{\"165\":1}}],[\"释放多个锁\",{\"1\":{\"53\":1}}],[\"释放锁之前\",{\"1\":{\"742\":1,\"904\":1}}],[\"释放锁的过程\",{\"1\":{\"1007\":1}}],[\"释放锁的逻辑放在\",{\"1\":{\"588\":1}}],[\"释放锁的话\",{\"1\":{\"47\":1}}],[\"释放锁也会释放所有锁资源\",{\"1\":{\"53\":1}}],[\"释放锁\",{\"1\":{\"49\":1,\"53\":1,\"535\":2,\"536\":2,\"538\":1,\"604\":1,\"605\":1,\"851\":1,\"941\":1}}],[\"释放锁时\",{\"1\":{\"47\":1}}],[\"已存在与\",{\"1\":{\"712\":1}}],[\"已初始化\",{\"1\":{\"621\":1}}],[\"已启动的且未终止的\",{\"1\":{\"445\":1}}],[\"已被淘汰\",{\"1\":{\"1226\":1}}],[\"已被垃圾回收\",{\"1\":{\"1033\":1}}],[\"已被\",{\"1\":{\"382\":1,\"495\":1}}],[\"已删除\",{\"1\":{\"268\":1}}],[\"已支持\",{\"1\":{\"233\":1,\"896\":1,\"923\":1}}],[\"已提交事务的持久化特性\",{\"1\":{\"136\":1}}],[\"已获取多锁\",{\"1\":{\"53\":1}}],[\"已经同意提交了提案\",{\"1\":{\"1380\":1}}],[\"已经不可能成为\",{\"1\":{\"1380\":1}}],[\"已经没有超过半数的节点数了\",{\"1\":{\"1380\":1}}],[\"已经没办法支撑了\",{\"1\":{\"29\":1}}],[\"已经批准了比\",{\"1\":{\"1375\":1}}],[\"已经批准过的最大提案编号\",{\"1\":{\"1374\":1}}],[\"已经消费成功的消息\",{\"1\":{\"1306\":1}}],[\"已经使用的生产者分组可以废弃无需再设置\",{\"1\":{\"1296\":1}}],[\"已经成为业内共识的金融级可靠业务消息首选方案\",{\"1\":{\"1236\":1}}],[\"已经成为\",{\"1\":{\"1235\":1,\"1236\":1,\"1238\":1}}],[\"已经了解了\",{\"1\":{\"1166\":1}}],[\"已经介绍的非常详细了\",{\"1\":{\"1128\":1}}],[\"已经发布\",{\"1\":{\"1120\":1}}],[\"已经正式支持虚拟线程\",{\"1\":{\"1057\":1}}],[\"已经有了\",{\"1\":{\"1033\":1}}],[\"已经有了现成的解决方案\",{\"1\":{\"49\":1}}],[\"已经执行过\",{\"1\":{\"1013\":1}}],[\"已经执行完成的任务数\",{\"1\":{\"918\":1}}],[\"已经改变了\",{\"1\":{\"882\":1}}],[\"已经是\",{\"1\":{\"752\":1}}],[\"已经摒弃了\",{\"1\":{\"688\":1,\"792\":1}}],[\"已经初始化\",{\"1\":{\"576\":1}}],[\"已经到达数组末尾了\",{\"1\":{\"535\":1}}],[\"已经变成了\",{\"1\":{\"451\":1}}],[\"已经可以正式使用了\",{\"1\":{\"408\":1}}],[\"已经将运行时常量池从方法区中移了出来\",{\"1\":{\"393\":1}}],[\"已经被完成了\",{\"1\":{\"777\":1}}],[\"已经被回收\",{\"1\":{\"394\":1}}],[\"已经被加载的类会直接返回\",{\"1\":{\"352\":1,\"357\":1}}],[\"已经被淘汰了\",{\"1\":{\"1240\":1}}],[\"已经被淘汰\",{\"1\":{\"351\":1,\"583\":1,\"651\":1,\"793\":1}}],[\"已经把原本放在永久代的字符串常量池\",{\"1\":{\"342\":1}}],[\"已经存在\",{\"1\":{\"47\":1,\"571\":1}}],[\"已经整理到了\",{\"1\":{\"13\":1,\"65\":1,\"150\":1,\"153\":1,\"736\":1}}],[\"已经生产可用\",{\"1\":{\"8\":1,\"10\":1}}],[\"各层均为单向依赖\",{\"1\":{\"1130\":1}}],[\"各路学者直呼看不懂\",{\"1\":{\"1096\":1}}],[\"各线程之间计数器互不影响\",{\"1\":{\"492\":1}}],[\"各线程共享\",{\"1\":{\"445\":1}}],[\"各自的特点\",{\"1\":{\"380\":1}}],[\"各个微服务之间的通讯\",{\"1\":{\"1155\":1}}],[\"各个节点的状态最终会保持一致\",{\"1\":{\"1084\":1}}],[\"各个\",{\"1\":{\"359\":1}}],[\"各个修饰符都是布尔值\",{\"1\":{\"331\":1}}],[\"各个字段的含义如下\",{\"1\":{\"120\":1}}],[\"各并发事务之间数据库是独立的\",{\"1\":{\"281\":1}}],[\"各有优势\",{\"1\":{\"235\":1}}],[\"各位可以自己根据select\",{\"1\":{\"141\":1}}],[\"各种集群中就经常使用这个负载均衡策略\",{\"1\":{\"1143\":1}}],[\"各种锁及其\",{\"1\":{\"996\":1}}],[\"各种原子类是利用\",{\"1\":{\"978\":1}}],[\"各种各样的垃圾回收器\",{\"0\":{\"448\":1}}],[\"各种排行榜比如直播间送礼物的排行榜\",{\"1\":{\"194\":1}}],[\"各种\",{\"1\":{\"53\":1,\"971\":1,\"978\":1,\"1332\":1}}],[\"各渠道对应支付产品的名称不一样\",{\"1\":{\"17\":1}}],[\"创建成功的就说明获取到了锁\",{\"1\":{\"1388\":1}}],[\"创建成功的就是\",{\"1\":{\"1387\":1}}],[\"创建成功之后\",{\"1\":{\"53\":1}}],[\"创建子节点的权限\",{\"1\":{\"1384\":1}}],[\"创建该节点的会话的\",{\"1\":{\"1382\":1}}],[\"创建该临时节点的会话的\",{\"1\":{\"1349\":1}}],[\"创建临时节点\",{\"1\":{\"1335\":1}}],[\"创建持久化节点\",{\"1\":{\"1335\":1}}],[\"创建多个队列并且复制多份消息是会很影响资源和性能的\",{\"1\":{\"1278\":1}}],[\"创建日志\",{\"1\":{\"1108\":1}}],[\"创建直接启动\",{\"1\":{\"1059\":1}}],[\"创建不启动\",{\"1\":{\"1059\":1}}],[\"创建workerthread对象\",{\"1\":{\"940\":1}}],[\"创建新的entry\",{\"1\":{\"1035\":1}}],[\"创建新的数组\",{\"1\":{\"572\":1}}],[\"创建新线程的时候会用到\",{\"1\":{\"890\":1,\"936\":1}}],[\"创建和切换成本高\",{\"1\":{\"808\":1}}],[\"创建线程池\",{\"1\":{\"757\":2}}],[\"创建节点并指定数据内容\",{\"1\":{\"1335\":1}}],[\"创建节点\",{\"0\":{\"1325\":1,\"1335\":1},\"1\":{\"729\":1}}],[\"创建时如果给定了容量初始值\",{\"1\":{\"677\":1}}],[\"创建时如果不指定容量初始值\",{\"1\":{\"677\":1}}],[\"创建时指定了初始化容量或者负载因子\",{\"1\":{\"624\":1}}],[\"创建时可以不指定容量大小\",{\"1\":{\"542\":1,\"672\":1}}],[\"创建对象时初始化容量大小放在threshold中\",{\"1\":{\"624\":1}}],[\"创建对象是很频繁的事情\",{\"1\":{\"503\":1}}],[\"创建延迟队列\",{\"1\":{\"599\":1}}],[\"创建空数组\",{\"1\":{\"553\":1,\"555\":1}}],[\"创建initialcapacity大小的数组\",{\"1\":{\"553\":1,\"555\":1}}],[\"创建阻塞队列流程控制的锁\",{\"1\":{\"534\":1}}],[\"创建消费者线程\",{\"1\":{\"531\":1}}],[\"创建生产者线程\",{\"1\":{\"531\":1}}],[\"创建一个线程池\",{\"1\":{\"957\":1}}],[\"创建一个可重用固定数量线程的线程池\",{\"1\":{\"949\":1}}],[\"创建一个带名字的线程池生产工厂\",{\"1\":{\"894\":1,\"920\":1}}],[\"创建一个更新器\",{\"1\":{\"768\":1}}],[\"创建一个具有固定线程数量的线程池对象\",{\"1\":{\"749\":1,\"753\":1,\"909\":1}}],[\"创建一个长度+1的新数组\",{\"1\":{\"588\":1}}],[\"创建一个包含指定数组的副本的列表\",{\"1\":{\"587\":1}}],[\"创建一个空的链表对象\",{\"1\":{\"728\":1}}],[\"创建一个空的\",{\"1\":{\"587\":1}}],[\"创建一个大小为\",{\"1\":{\"531\":3}}],[\"创建一个\",{\"1\":{\"425\":1,\"531\":1,\"571\":1,\"593\":1}}],[\"创建一个数据库表\",{\"1\":{\"33\":1,\"34\":1}}],[\"创建的\",{\"1\":{\"340\":1,\"351\":2,\"961\":1}}],[\"创建快照时会阻塞主线程吗\",{\"0\":{\"227\":1}}],[\"创建快照之后\",{\"1\":{\"226\":1}}],[\"创建\",{\"0\":{\"158\":1,\"776\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1},\"1\":{\"570\":1,\"733\":1,\"897\":1,\"1057\":3,\"1333\":1,\"1382\":1}}],[\"创建了\",{\"1\":{\"53\":1}}],[\"锁也释放了\",{\"1\":{\"1388\":1}}],[\"锁队列的一个结点\",{\"1\":{\"904\":1}}],[\"锁可以绑定多个条件\",{\"1\":{\"862\":1}}],[\"锁被释放之后\",{\"1\":{\"858\":2}}],[\"锁被修饰保证了锁的内存地址肯定不会被修改\",{\"1\":{\"588\":1}}],[\"锁主要存在四种状态\",{\"1\":{\"854\":1}}],[\"锁与线程的那些事\",{\"1\":{\"853\":1}}],[\"锁指定对象\",{\"1\":{\"848\":1}}],[\"锁当前类\",{\"1\":{\"848\":1}}],[\"锁当前对象实例\",{\"1\":{\"848\":1}}],[\"锁粗化等技术来减少锁操作的开销\",{\"1\":{\"854\":1}}],[\"锁粗化\",{\"1\":{\"847\":1}}],[\"锁消除\",{\"1\":{\"847\":1,\"854\":1}}],[\"锁住\",{\"1\":{\"756\":1,\"911\":1}}],[\"锁的效率提升了很多\",{\"1\":{\"847\":1}}],[\"锁的详细解读\",{\"1\":{\"742\":1}}],[\"锁的公平性\",{\"1\":{\"534\":1}}],[\"锁粒度更细\",{\"1\":{\"691\":1,\"692\":1}}],[\"锁做了很多优化\",{\"1\":{\"688\":1,\"792\":1}}],[\"锁\",{\"1\":{\"604\":1,\"742\":2,\"871\":1,\"874\":1,\"876\":1,\"1002\":1,\"1022\":1,\"1179\":1}}],[\"锁自从引入锁升级策略后\",{\"1\":{\"579\":1}}],[\"锁加\",{\"1\":{\"579\":1}}],[\"锁写入数据\",{\"1\":{\"577\":1}}],[\"锁对象对读写操作进行同步\",{\"1\":{\"544\":1}}],[\"锁对应的子节点\",{\"1\":{\"56\":1}}],[\"锁是对自旋锁的一种改良\",{\"1\":{\"874\":1}}],[\"锁是对自旋锁的一种改进\",{\"1\":{\"742\":1}}],[\"锁是否分离\",{\"1\":{\"542\":1,\"672\":1}}],[\"锁是一个比较通用的解决方案\",{\"1\":{\"60\":1}}],[\"锁会被释放\",{\"1\":{\"535\":1}}],[\"锁状态标志等等\",{\"1\":{\"507\":1}}],[\"锁技术以及mvcc\",{\"1\":{\"133\":1}}],[\"锁定\",{\"1\":{\"972\":1}}],[\"锁定整张表\",{\"1\":{\"130\":1}}],[\"锁定该行\",{\"1\":{\"130\":1}}],[\"锁最终一定还是会被释放\",{\"1\":{\"61\":1}}],[\"锁服务是高可用的\",{\"1\":{\"61\":1}}],[\"锁只能被一个线程持有\",{\"1\":{\"61\":1}}],[\"锁从面试连环炮聊到神仙打架这篇文章\",{\"1\":{\"51\":1}}],[\"锁过期时间能够自己续期就好了\",{\"1\":{\"48\":1}}],[\"感觉这个有点类似\",{\"1\":{\"1237\":1}}],[\"感觉有可能是\",{\"1\":{\"767\":2}}],[\"感觉挺不错的\",{\"1\":{\"15\":1}}],[\"感谢\",{\"1\":{\"387\":1,\"615\":1,\"1026\":1}}],[\"感兴趣同学可以查阅一下\",{\"1\":{\"1015\":1}}],[\"感兴趣同学可以阅读一下\",{\"1\":{\"999\":1}}],[\"感兴趣地可以看看\",{\"1\":{\"286\":1}}],[\"感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下\",{\"1\":{\"1279\":1}}],[\"感兴趣的同学可以看下\",{\"1\":{\"1015\":1}}],[\"感兴趣的小伙伴\",{\"1\":{\"1143\":1}}],[\"感兴趣的小伙伴可以自己去研究一下\",{\"1\":{\"1388\":1}}],[\"感兴趣的小伙伴可以自行深入研究一下\",{\"1\":{\"359\":1}}],[\"感兴趣的小伙伴可以看看\",{\"1\":{\"258\":1}}],[\"感兴趣的小伙伴可以看看这篇文章\",{\"1\":{\"219\":1}}],[\"感兴趣的可自行查阅资料\",{\"1\":{\"1043\":1}}],[\"感兴趣的可以看看这篇文章\",{\"1\":{\"1178\":1}}],[\"感兴趣的可以看看下面这两篇文章\",{\"1\":{\"874\":1}}],[\"感兴趣的可以自行查阅相关资料\",{\"1\":{\"1032\":1}}],[\"感兴趣的也可以看看\",{\"1\":{\"454\":1}}],[\"感兴趣的话可以看看\",{\"1\":{\"242\":1}}],[\"感兴趣的朋友可以看看redis\",{\"1\":{\"51\":1}}],[\"怼过\",{\"1\":{\"51\":1}}],[\"曾经专门发文\",{\"1\":{\"51\":1}}],[\"发货\",{\"1\":{\"1299\":1}}],[\"发展到今天\",{\"1\":{\"1237\":1}}],[\"发展史\",{\"0\":{\"598\":1}}],[\"发出的投票为\",{\"1\":{\"1380\":1}}],[\"发出的调用一般会立即被处理\",{\"1\":{\"1232\":1}}],[\"发出一个调用之后\",{\"1\":{\"815\":1}}],[\"发出一个非满的通知\",{\"1\":{\"535\":1}}],[\"发起建连\",{\"1\":{\"1151\":1}}],[\"发起投票参与竞选\",{\"1\":{\"1108\":1}}],[\"发起大量请求\",{\"1\":{\"306\":1}}],[\"发不了就不发了呗\",{\"1\":{\"1096\":1}}],[\"发表了布鲁尔猜想的证明\",{\"1\":{\"1066\":1}}],[\"发现阶段\",{\"1\":{\"1356\":1}}],[\"发现自己的\",{\"1\":{\"1109\":1}}],[\"发现自己已经加载过了\",{\"1\":{\"358\":1}}],[\"发现队列已满\",{\"1\":{\"535\":1}}],[\"发现\",{\"1\":{\"293\":1,\"298\":1,\"444\":1,\"1085\":1,\"1380\":1}}],[\"发现当前用户尚未抢购且商品库存还有\",{\"1\":{\"60\":2}}],[\"发送的\",{\"1\":{\"1380\":1}}],[\"发送的消息的类型必须和主题的类型一致\",{\"1\":{\"1285\":1,\"1286\":1}}],[\"发送的消息体中自定义属性requestid\",{\"1\":{\"1048\":1}}],[\"发送提案内容和提案编号并让它无条件执行和提交\",{\"1\":{\"1374\":1}}],[\"发送提案的提交请求\",{\"1\":{\"1374\":1}}],[\"发送真正的提案\",{\"1\":{\"1374\":1}}],[\"发送异常\",{\"0\":{\"1301\":1}}],[\"发送心跳\",{\"1\":{\"1281\":1}}],[\"发送邮件\",{\"1\":{\"1272\":1}}],[\"发送消息的时候\",{\"1\":{\"1281\":1}}],[\"发送消息的时候指定\",{\"1\":{\"1202\":1}}],[\"发送消息到消息队列中去\",{\"1\":{\"1222\":1}}],[\"发送消息给第三方系统\",{\"0\":{\"1048\":1}}],[\"发送至消费方\",{\"1\":{\"1166\":1}}],[\"发送数据\",{\"1\":{\"1151\":1}}],[\"发送\",{\"1\":{\"1114\":1,\"1152\":1,\"1226\":1,\"1281\":1,\"1380\":1}}],[\"发送进程退出信号也能拿到\",{\"1\":{\"368\":1}}],[\"发送一次命令的\",{\"1\":{\"285\":1}}],[\"发送命令\",{\"1\":{\"285\":1,\"301\":1}}],[\"发送支付信息到第三方\",{\"1\":{\"17\":1}}],[\"发布消息\",{\"1\":{\"1222\":1}}],[\"发布和订阅消息流\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"发布自己内部商业应用像有版本号\",{\"1\":{\"1132\":1}}],[\"发布的功能最强大的运行监视和故障处理程序\",{\"1\":{\"377\":1}}],[\"发布大版本\",{\"1\":{\"327\":1}}],[\"发布者将消息发送到指定主题中\",{\"1\":{\"1279\":1}}],[\"发布者\",{\"1\":{\"1279\":1}}],[\"发布者发布一条消息\",{\"1\":{\"1194\":1,\"1229\":1}}],[\"发布者发布消息的时候不会管消费者的具体消费能力如何\",{\"1\":{\"251\":1}}],[\"发布者和生产者的意思类似\",{\"1\":{\"1182\":1}}],[\"发布者通过\",{\"1\":{\"251\":1}}],[\"发布订阅模式\",{\"1\":{\"1259\":1,\"1280\":2}}],[\"发布订阅模型\",{\"1\":{\"1194\":2,\"1229\":1,\"1279\":1,\"1280\":1}}],[\"发布订阅机制的实现就是基于这个\",{\"1\":{\"251\":1}}],[\"发布订阅\",{\"1\":{\"251\":1}}],[\"发布\",{\"0\":{\"1194\":1,\"1229\":1},\"1\":{\"233\":1,\"251\":1,\"1194\":2,\"1218\":1,\"1229\":1}}],[\"发布看\",{\"1\":{\"233\":1}}],[\"发生了\",{\"1\":{\"1311\":1}}],[\"发生切换\",{\"1\":{\"1311\":1}}],[\"发生上下文切换\",{\"1\":{\"1310\":3}}],[\"发生冲突了\",{\"1\":{\"1068\":2}}],[\"发生gc之后\",{\"1\":{\"1026\":1,\"1030\":1}}],[\"发生故障恢复后不能保证消息至少被消费一次\",{\"1\":{\"251\":1}}],[\"发生\",{\"1\":{\"168\":1,\"1310\":1}}],[\"发生读请求的时候\",{\"1\":{\"146\":1}}],[\"发生时钟变迁的情况下还存在安全性隐患\",{\"1\":{\"51\":1}}],[\"主备模式\",{\"1\":{\"1354\":1}}],[\"主从模式下\",{\"1\":{\"1314\":1}}],[\"主从结构\",{\"1\":{\"226\":1}}],[\"主动获取消息处理并提交\",{\"1\":{\"1293\":1}}],[\"主动让出\",{\"1\":{\"821\":1}}],[\"主题中存在多个队列\",{\"1\":{\"1280\":1}}],[\"主题模型\",{\"0\":{\"1279\":1},\"1\":{\"1277\":1,\"1279\":1,\"1280\":3}}],[\"主题模式\",{\"1\":{\"1259\":1,\"1280\":1}}],[\"主题的多种订阅模式\",{\"1\":{\"1238\":1}}],[\"主题\",{\"1\":{\"1196\":4,\"1202\":1,\"1231\":1,\"1250\":1,\"1279\":1,\"1280\":2}}],[\"主内存\",{\"1\":{\"972\":1}}],[\"主存\",{\"1\":{\"972\":1}}],[\"主调用线程\",{\"1\":{\"904\":1}}],[\"主流的商用程序语言\",{\"1\":{\"445\":1}}],[\"主版本号都会加\",{\"1\":{\"327\":1}}],[\"主观下线与客观下线的区别\",{\"1\":{\"318\":1}}],[\"主进程\",{\"1\":{\"227\":1}}],[\"主线程把任务交给空闲线程执行\",{\"1\":{\"958\":1}}],[\"主线程也可以执行\",{\"1\":{\"934\":1}}],[\"主线程可以执行\",{\"1\":{\"934\":1}}],[\"主线程首先要创建实现\",{\"1\":{\"934\":1}}],[\"主线程必须在启动其他线程后立即调用\",{\"1\":{\"753\":1}}],[\"主线程需要等待多个组件加载完毕\",{\"1\":{\"753\":1}}],[\"主线程就可以从\",{\"1\":{\"742\":1}}],[\"主线程中执行的\",{\"1\":{\"289\":1}}],[\"主线程中进行的\",{\"1\":{\"160\":1,\"232\":1}}],[\"主线程而不是主进程的主要是因为\",{\"1\":{\"227\":1}}],[\"主线程的阻塞\",{\"1\":{\"165\":1}}],[\"主线程执行\",{\"1\":{\"161\":1}}],[\"主线程调用\",{\"1\":{\"161\":4,\"231\":3}}],[\"主线程\",{\"1\":{\"158\":2,\"227\":2}}],[\"主键值\",{\"1\":{\"307\":1}}],[\"主键名\",{\"1\":{\"307\":1}}],[\"主键就是密集索引\",{\"1\":{\"106\":1}}],[\"主键索引保存了主键\",{\"1\":{\"107\":1}}],[\"主键索引\",{\"0\":{\"113\":1},\"1\":{\"104\":1}}],[\"主节点返回消息给客户端的时候是否需要同步从节点\",{\"1\":{\"1314\":1}}],[\"主节点处理写请求\",{\"1\":{\"299\":1}}],[\"主节点依然可以获取锁\",{\"1\":{\"51\":1}}],[\"主节点宕机了\",{\"1\":{\"51\":1}}],[\"主节点获取到锁后\",{\"1\":{\"51\":1}}],[\"主要涉及到两个角色\",{\"1\":{\"1370\":1}}],[\"主要依赖\",{\"1\":{\"1360\":1}}],[\"主要提供两个功能\",{\"1\":{\"1281\":1}}],[\"主要传输二进制数据流\",{\"1\":{\"1253\":1}}],[\"主要定义了一些客户端调用的命令\",{\"1\":{\"1253\":1}}],[\"主要定义了对于一个共享变量\",{\"1\":{\"967\":1}}],[\"主要负责消息的存储\",{\"1\":{\"1281\":1}}],[\"主要负责客户端命令发送给服务器\",{\"1\":{\"1253\":1}}],[\"主要负责接收\",{\"1\":{\"1247\":1}}],[\"主要负责加载\",{\"1\":{\"353\":1}}],[\"主要为\",{\"1\":{\"1199\":2,\"1344\":1}}],[\"主要为了快捷的校验兑换码信息的是否正确\",{\"1\":{\"19\":1}}],[\"主要有两大应用场景\",{\"1\":{\"1190\":1}}],[\"主要有推\",{\"1\":{\"1087\":1}}],[\"主要应用场景有哪些\",{\"0\":{\"1190\":1}}],[\"主要应用场景和\",{\"1\":{\"755\":1,\"910\":1}}],[\"主要访问高速缓存和内存\",{\"1\":{\"1184\":1}}],[\"主要解决了\",{\"1\":{\"1179\":1}}],[\"主要解决的是多个线程之间访问资源的同步性\",{\"1\":{\"847\":1}}],[\"主要针对面试或者速览\",{\"1\":{\"1177\":1}}],[\"主要针对配备多颗处理器及大容量内存的机器\",{\"1\":{\"407\":1}}],[\"主要原因是序列化之后的字节数组体积较大\",{\"1\":{\"1147\":1}}],[\"主要原因是因为\",{\"1\":{\"1120\":1}}],[\"主要原因有两个\",{\"1\":{\"1147\":1}}],[\"主要原理图如下\",{\"1\":{\"1004\":1}}],[\"主要讲述两阶段共识协议部分\",{\"1\":{\"1096\":1}}],[\"主要可用\",{\"1\":{\"1074\":1}}],[\"主要的核心逻辑还是在threadlocalmap中的\",{\"1\":{\"1031\":1}}],[\"主要的流程如下\",{\"1\":{\"1011\":1}}],[\"主要分析过程如下\",{\"1\":{\"1003\":1}}],[\"主要分为\",{\"1\":{\"90\":1}}],[\"主要来说主要有三点\",{\"1\":{\"862\":1}}],[\"主要使用\",{\"1\":{\"794\":1}}],[\"主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力\",{\"1\":{\"679\":1}}],[\"主要包括下面这\",{\"1\":{\"773\":1,\"899\":1}}],[\"主要包括\",{\"1\":{\"516\":1}}],[\"主要目的是为了避免字符串的重复创建\",{\"1\":{\"498\":1}}],[\"主要目的是保证输入的字节流能正确地解析并存储于方法区之内\",{\"1\":{\"341\":1}}],[\"主要服务一个方法需要调用其他方法的场景\",{\"1\":{\"493\":1}}],[\"主要作为方法调用的中转站使用\",{\"1\":{\"493\":1}}],[\"主要存放了编译期可知的各种数据类型\",{\"1\":{\"493\":1}}],[\"主要就是解决这些问题的\",{\"1\":{\"1367\":1}}],[\"主要就是把linkedblockingqueue的\",{\"1\":{\"896\":1,\"923\":1}}],[\"主要就是堆内存那块\",{\"1\":{\"450\":1}}],[\"主要就是完成一个加载工作\",{\"1\":{\"423\":1}}],[\"主要就是判断你输入的\",{\"1\":{\"86\":1}}],[\"主要放了一些存储的数据\",{\"1\":{\"421\":1}}],[\"主要优点\",{\"1\":{\"406\":1}}],[\"主要进行\",{\"0\":{\"387\":1}}],[\"主要完成下面\",{\"1\":{\"340\":1,\"349\":1}}],[\"主要体现在下面三个方面\",{\"1\":{\"292\":1}}],[\"主要指的是这个操作\",{\"1\":{\"287\":1}}],[\"主要逻辑是单线程完成的\",{\"1\":{\"268\":1}}],[\"主要在内存和网络\",{\"1\":{\"266\":1}}],[\"主要是用来协调服务的\",{\"1\":{\"1348\":1}}],[\"主要是一些细节上的差别\",{\"1\":{\"1281\":1}}],[\"主要是基于\",{\"1\":{\"1184\":1}}],[\"主要是给\",{\"1\":{\"1172\":1}}],[\"主要是判断threadlocalmap是否存在\",{\"1\":{\"1031\":1}}],[\"主要是为了避免二义性\",{\"1\":{\"693\":1}}],[\"主要是由两大接口派生而来\",{\"1\":{\"639\":1}}],[\"主要是对代码进行了一些优化和精简\",{\"1\":{\"598\":1}}],[\"主要是因为永久代\",{\"1\":{\"498\":1}}],[\"主要是包含\",{\"1\":{\"265\":1}}],[\"主要是单线程事件循环和\",{\"1\":{\"243\":1}}],[\"主要需要用到下面这两个命令\",{\"1\":{\"262\":1}}],[\"主要用在多线程领域\",{\"1\":{\"773\":1,\"899\":1}}],[\"主要用在一些需要执行耗时任务的场景\",{\"1\":{\"773\":1,\"899\":1}}],[\"主要用来解决两个服务的远程通信问题\",{\"1\":{\"1232\":1}}],[\"主要用来构建锁和同步器\",{\"1\":{\"740\":1,\"903\":1}}],[\"主要用来存放键值对\",{\"1\":{\"616\":1}}],[\"主要用来加载\",{\"1\":{\"353\":1}}],[\"主要用来提高\",{\"1\":{\"226\":1}}],[\"主要用来说明查询的类型\",{\"1\":{\"120\":1}}],[\"主要用于\",{\"1\":{\"1155\":1,\"1161\":1}}],[\"主要用于挂起当前线程\",{\"1\":{\"1012\":1}}],[\"主要用于存放新创建的对象\",{\"1\":{\"813\":1}}],[\"主要用于存放键值对\",{\"1\":{\"639\":1}}],[\"主要用于存放单一元素\",{\"1\":{\"639\":1}}],[\"主要用于存储地理位置信息\",{\"1\":{\"209\":1,\"212\":1}}],[\"主要用于表示业务类型\",{\"1\":{\"34\":1}}],[\"主要由下面这\",{\"1\":{\"42\":1}}],[\"主要由\",{\"1\":{\"7\":1}}],[\"主要还是看中了其优秀的高并发能力\",{\"1\":{\"6\":1}}],[\"主要通过过滤器\",{\"1\":{\"4\":1}}],[\"所实现的\",{\"1\":{\"1280\":1}}],[\"所在队列中依次发送消息\",{\"1\":{\"1299\":1}}],[\"所在实例上拉取数据过来\",{\"1\":{\"1263\":1}}],[\"所在实例\",{\"1\":{\"1263\":1}}],[\"所在的服务器\",{\"1\":{\"1361\":1}}],[\"所在的\",{\"1\":{\"578\":1}}],[\"所定义的是\",{\"1\":{\"1231\":1}}],[\"所做的一个总结\",{\"1\":{\"1120\":1}}],[\"所示\",{\"1\":{\"1109\":1}}],[\"所管辖的内存区域的过程中\",{\"1\":{\"884\":1}}],[\"所需的最小容量\",{\"1\":{\"553\":1,\"564\":1}}],[\"所包含的元素个数\",{\"1\":{\"553\":1}}],[\"所指向的线程才具备定时等待任务到期执行的权限\",{\"1\":{\"601\":1}}],[\"所指向的\",{\"1\":{\"444\":1}}],[\"所指向的数据库键的过期时间\",{\"1\":{\"271\":1}}],[\"所谓的状态同步是指数据同步\",{\"1\":{\"1361\":1}}],[\"所谓的公平锁就是先等待的线程先获得锁\",{\"1\":{\"862\":1}}],[\"所谓严格顺序是指\",{\"1\":{\"1299\":1}}],[\"所谓普通顺序是指\",{\"1\":{\"1299\":1}}],[\"所谓公平性是指严格按照线程等待的绝对时间顺序\",{\"1\":{\"797\":1}}],[\"所谓原子类说简单点就是具有原子\",{\"1\":{\"762\":1}}],[\"所谓\",{\"1\":{\"618\":1,\"682\":1}}],[\"所谓扰动函数指的就是\",{\"1\":{\"618\":1,\"682\":1}}],[\"所谓乐观锁就是\",{\"1\":{\"503\":1}}],[\"所谓吞吐量就是\",{\"1\":{\"403\":1}}],[\"所谓对象之间的相互引用问题\",{\"1\":{\"390\":1}}],[\"所谓可重入锁指的是在一个线程中可以多次获取同一把锁\",{\"1\":{\"50\":1}}],[\"所不具备的\",{\"1\":{\"288\":2,\"704\":1}}],[\"所不能提供的\",{\"1\":{\"188\":1}}],[\"所储存的字符串值的长度\",{\"1\":{\"177\":1}}],[\"所占用的内存比较大\",{\"1\":{\"163\":1,\"291\":1}}],[\"所选索引的长度\",{\"1\":{\"120\":1}}],[\"所有用户都可无条件访问\",{\"1\":{\"1351\":1}}],[\"所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的\",{\"1\":{\"1345\":1}}],[\"所有消息\",{\"1\":{\"1299\":1}}],[\"所有消息都会被发送到指定的\",{\"1\":{\"1202\":1}}],[\"所有负载均衡实现类均继承自\",{\"1\":{\"1140\":1}}],[\"所有节点收到投票信息时\",{\"1\":{\"1114\":1}}],[\"所有节点访问同一份最新的数据副本\",{\"1\":{\"1067\":1}}],[\"所有处理由\",{\"1\":{\"1007\":1}}],[\"所有被屏障拦截的线程才会继续干活\",{\"1\":{\"755\":1,\"910\":1}}],[\"所有被同步锁持有的对象\",{\"1\":{\"391\":1}}],[\"所有此时会直接进行插入\",{\"1\":{\"686\":1}}],[\"所有线程创建的实例对象都存放在主内存中\",{\"1\":{\"972\":1}}],[\"所有线程在当前任务执行完毕后\",{\"1\":{\"937\":1}}],[\"所有线程都会停止\",{\"1\":{\"531\":1}}],[\"所有线程共享数据区大小=新生代大小\",{\"1\":{\"450\":1}}],[\"所有对象共享一份\",{\"1\":{\"521\":1}}],[\"所有\",{\"1\":{\"330\":1}}],[\"所有的参与者\",{\"1\":{\"1370\":1}}],[\"所有的线程都注册在它一个身上\",{\"1\":{\"544\":1,\"862\":1}}],[\"所有的消费者线程都会被阻塞\",{\"1\":{\"530\":1}}],[\"所有的字段都还为零\",{\"1\":{\"506\":1}}],[\"所有的对象都分配到堆上也渐渐变得不那么\",{\"1\":{\"495\":1}}],[\"所有的对象都在堆中分配\",{\"1\":{\"495\":1}}],[\"所有的请求最终都会传送到顶层的启动类加载器\",{\"1\":{\"357\":1}}],[\"所有的\",{\"1\":{\"330\":1,\"571\":1,\"1019\":1}}],[\"所有的服务器都可以访问\",{\"1\":{\"249\":1}}],[\"所有的写命令会追加到\",{\"1\":{\"230\":1}}],[\"所有数据模型\",{\"1\":{\"244\":1}}],[\"所有由此我们可以看到\",{\"1\":{\"141\":1}}],[\"所有有匹配索引值的行将从这张表中读取\",{\"1\":{\"120\":1}}],[\"所有叶子节点均有一个链指针指向下一个叶子节点\",{\"1\":{\"100\":1}}],[\"所有引擎都可以使用\",{\"1\":{\"89\":1}}],[\"所有跨存储引擎的功能都在这一层实现\",{\"1\":{\"82\":1}}],[\"所有尝试获取锁的客户端都会对持有锁的子节点加监听器\",{\"1\":{\"54\":1}}],[\"所以能实现分布式锁呗\",{\"1\":{\"1388\":1}}],[\"所以其他\",{\"1\":{\"1380\":1}}],[\"所以其实现类也可以作为\",{\"1\":{\"796\":1}}],[\"所以此时server1\",{\"1\":{\"1380\":1}}],[\"所以此时通过判断size\",{\"1\":{\"1038\":1}}],[\"所以所有的一致性算法的\",{\"1\":{\"1369\":1}}],[\"所以我留给大家去思考\",{\"1\":{\"1315\":1}}],[\"所以我们所需要解决的是在分布式系统中\",{\"1\":{\"1370\":1}}],[\"所以我们配备的硬件资源并不会太高\",{\"1\":{\"1273\":1}}],[\"所以我们该问的不是\",{\"1\":{\"1155\":1}}],[\"所以我们直接看解锁的源码\",{\"1\":{\"1014\":1}}],[\"所以我们可以通过查看它的源代码\",{\"1\":{\"861\":1}}],[\"所以我们可以使用锁或者利用atomicreference类把多个共享变量合并成一个共享变量来操作\",{\"1\":{\"845\":1,\"994\":1}}],[\"所以我们可以考虑把数据库中的部分数据转移到缓存中去\",{\"1\":{\"246\":1}}],[\"所以我们这里以\",{\"1\":{\"763\":1,\"766\":1,\"767\":1,\"768\":1}}],[\"所以我们有很多种方式插入元素\",{\"1\":{\"729\":1}}],[\"所以我们想获取\",{\"1\":{\"625\":1}}],[\"所以我们需要给我们的消费者实现\",{\"1\":{\"1303\":1}}],[\"所以我们需要使用多个\",{\"1\":{\"1281\":1}}],[\"所以我们需要实现compareto进行到期时间比较\",{\"1\":{\"599\":1}}],[\"所以我们需要在\",{\"1\":{\"72\":1}}],[\"所以我们首先需要继承\",{\"1\":{\"599\":1}}],[\"所以我们不妨从添加方法入手\",{\"1\":{\"533\":1}}],[\"所以我们是否可以得出这样一个结论\",{\"1\":{\"533\":1}}],[\"所以我们必须选择\",{\"1\":{\"399\":1}}],[\"所以我们一般都说\",{\"1\":{\"265\":1}}],[\"所以推荐使用普通顺序模式\",{\"1\":{\"1299\":1}}],[\"所以总结来说\",{\"1\":{\"1280\":1}}],[\"所以总共会执行\",{\"1\":{\"1210\":1}}],[\"所以一般来讲要控制\",{\"1\":{\"1280\":1}}],[\"所以一般来说\",{\"1\":{\"506\":1}}],[\"所以整个耗时只是\",{\"1\":{\"1271\":1}}],[\"所以消息队列也是一个很古老的中间件了\",{\"1\":{\"1269\":1}}],[\"所以消费消息时也是按照顺序来消费的\",{\"1\":{\"1218\":1}}],[\"所以问题并不是消息队列是什么\",{\"1\":{\"1268\":1}}],[\"所以国内很少有公司有实力做\",{\"1\":{\"1240\":1}}],[\"所以并发能力很强\",{\"1\":{\"1240\":2}}],[\"所以并不影响对比\",{\"1\":{\"1062\":1}}],[\"所以自定义重试次数以及时间间隔\",{\"1\":{\"1211\":1}}],[\"所以大部分公司内部都还在使用\",{\"1\":{\"1161\":1}}],[\"所以对外一般用\",{\"1\":{\"1161\":1}}],[\"所以对于存在的\",{\"1\":{\"712\":1}}],[\"所以对于树节点类\",{\"1\":{\"708\":1}}],[\"所以对于响应要求高的应用应该尽量去减少发生\",{\"1\":{\"444\":1}}],[\"所以也不太可能取代掉\",{\"1\":{\"1161\":1}}],[\"所以也不是关键\",{\"1\":{\"1158\":1}}],[\"所以也有基于\",{\"1\":{\"1157\":1}}],[\"所以也就多了这些关键字对应的标志\",{\"1\":{\"332\":1}}],[\"所以失败的话会无限的重试\",{\"1\":{\"1115\":1}}],[\"所以处理相同的状态\",{\"1\":{\"1106\":1}}],[\"所以往后迭代最终数据放入到index=7的桶中\",{\"1\":{\"1037\":1}}],[\"所以说我们需要配置多个\",{\"1\":{\"1281\":1}}],[\"所以说\",{\"1\":{\"1014\":1,\"1194\":1}}],[\"所以会有这种数据存在\",{\"1\":{\"1033\":1}}],[\"所以会出现短暂的\",{\"1\":{\"1011\":1}}],[\"所以会进入\",{\"1\":{\"557\":1}}],[\"所以实现了\",{\"1\":{\"1007\":1}}],[\"所以就需要下面这种流程\",{\"1\":{\"1002\":1}}],[\"所以就有了\",{\"1\":{\"792\":1}}],[\"所以创建\",{\"1\":{\"961\":1}}],[\"所以子任务因为无法获取到线程资源无法正常执行\",{\"1\":{\"919\":1}}],[\"所以系统在产生一个线程\",{\"1\":{\"807\":1}}],[\"所以当我们选择使用\",{\"1\":{\"1152\":1}}],[\"所以当面试官套路我们threadlocalmap扩容机制的时候\",{\"1\":{\"1038\":1}}],[\"所以当\",{\"1\":{\"753\":1,\"1380\":1}}],[\"所以可能这个时候有一个\",{\"1\":{\"1379\":1}}],[\"所以可运行线程数量为20\",{\"1\":{\"749\":2}}],[\"所以可以将交换器理解成一个由绑定构成的路由表\",{\"1\":{\"1249\":1}}],[\"所以可以通过\",{\"1\":{\"693\":1}}],[\"所以可以选择\",{\"1\":{\"399\":1}}],[\"所以无法进行投票等操作了\",{\"1\":{\"1380\":1}}],[\"所以无法判断任务是否被线程池执行成功与否\",{\"1\":{\"944\":1}}],[\"所以无法被其他类重写\",{\"1\":{\"744\":1}}],[\"所以无法通过\",{\"1\":{\"693\":1}}],[\"所以直接让tail指针指向前驱节点a即可\",{\"1\":{\"711\":1}}],[\"所以直接让\",{\"1\":{\"710\":1,\"711\":1}}],[\"所以树节点\",{\"1\":{\"708\":1}}],[\"所以判断条件设置为\",{\"1\":{\"708\":1}}],[\"所以遍历时的效率和元素个数成正比\",{\"1\":{\"702\":1}}],[\"所以equals\",{\"1\":{\"678\":1}}],[\"所以必须实现\",{\"1\":{\"663\":1}}],[\"所以称为快速随机访问\",{\"1\":{\"658\":1}}],[\"所以非常消耗性能\",{\"1\":{\"619\":1}}],[\"所以了解延迟队列的添加逻辑我们只需阅读\",{\"1\":{\"603\":1}}],[\"所以默认构造方法什么也没做\",{\"1\":{\"602\":1}}],[\"所以元素添加时势必需要进行优先级排序\",{\"1\":{\"601\":1}}],[\"所以为了保证存取元素时线程安全\",{\"1\":{\"601\":1}}],[\"所以写操作的开销相对较大\",{\"1\":{\"585\":1}}],[\"所以要区别对待\",{\"1\":{\"571\":1}}],[\"所以每个状态机处理相同的命令序列\",{\"1\":{\"1106\":1}}],[\"所以每个线程都要有自己独立的副本\",{\"1\":{\"882\":1}}],[\"所以每次只可能存在\",{\"1\":{\"941\":1}}],[\"所以每次使用都必须使用静态方法\",{\"1\":{\"768\":1}}],[\"所以每次在获取资源操作的时候都会上锁\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"所以每一个\",{\"1\":{\"569\":1}}],[\"所以很显然是提供给用户调用的\",{\"1\":{\"564\":1}}],[\"所以插入和删除元素的时间复杂度受元素位置的影响\",{\"1\":{\"552\":1,\"656\":1}}],[\"所以签名定义了interruptedexception\",{\"1\":{\"533\":1}}],[\"所以该方法可能会被打断\",{\"1\":{\"533\":1}}],[\"所以存放结果返回\",{\"1\":{\"531\":1}}],[\"所以存在老版本的\",{\"1\":{\"236\":1}}],[\"所以不用担心后面的数据没接收到导致数据不一致性\",{\"1\":{\"1380\":1}}],[\"所以不管协调者有没有发消息给参与者\",{\"1\":{\"1371\":1}}],[\"所以不要放比较大的数据在\",{\"1\":{\"1348\":1}}],[\"所以不少编程语言的网络库里都会给\",{\"1\":{\"1158\":1}}],[\"所以不需要另外实现了\",{\"1\":{\"663\":1}}],[\"所以不支持快速随机访问\",{\"1\":{\"658\":1}}],[\"所以不能作为\",{\"1\":{\"1380\":1}}],[\"所以不能实现\",{\"1\":{\"655\":1,\"726\":1}}],[\"所以不能使用final修饰\",{\"1\":{\"520\":1}}],[\"所以不会导致所有写线程阻塞\",{\"1\":{\"872\":1}}],[\"所以不会进入\",{\"1\":{\"557\":1}}],[\"所以不会出现\",{\"1\":{\"384\":1}}],[\"所以程序员不能得到隐蔽起来的内存和伪造指针去指向存储器\",{\"1\":{\"515\":1}}],[\"所以老年代过小的话反而是会增多\",{\"1\":{\"450\":1}}],[\"所以需要程序员根据特定业务场景去选择适应的主从复制方案\",{\"1\":{\"1314\":1}}],[\"所以需要继续往后迭代查找\",{\"1\":{\"1040\":1}}],[\"所以需要从后往前找\",{\"1\":{\"1014\":1}}],[\"所以需要会熟练使用才行\",{\"1\":{\"669\":1}}],[\"所以需要停止所有进程\",{\"1\":{\"445\":1}}],[\"所以需要服务器实例最好可以自行计算\",{\"1\":{\"22\":1}}],[\"所以最多只能创建核心线程数的线程\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"所以最多只能记录到\",{\"1\":{\"444\":1}}],[\"所以最终查询的结果为500\",{\"1\":{\"141\":1}}],[\"所以有可能会出现两个对象共用一个内存的情况\",{\"1\":{\"444\":1}}],[\"所以只好通过\",{\"1\":{\"384\":1}}],[\"所以只会匹配\",{\"1\":{\"71\":1}}],[\"所以拿到的结果是\",{\"1\":{\"353\":1}}],[\"所以使用我们自定义加载器加载的类是可以被卸载掉的\",{\"1\":{\"345\":1}}],[\"所以它传的内容以字符串为主\",{\"1\":{\"1159\":1}}],[\"所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成\",{\"1\":{\"645\":1}}],[\"所以它需要一个\",{\"1\":{\"418\":1}}],[\"所以它们\",{\"1\":{\"345\":1}}],[\"所以它也被称为高度平衡树\",{\"1\":{\"98\":1}}],[\"所以方法表的访问标志中没有这两个对应的标志\",{\"1\":{\"332\":1}}],[\"所以父类索引只有一个\",{\"1\":{\"330\":1}}],[\"所以即使使用了\",{\"1\":{\"288\":1}}],[\"所以速度相当快\",{\"1\":{\"246\":1}}],[\"所以selec\",{\"1\":{\"141\":1}}],[\"所以生成的一致性视图read\",{\"1\":{\"141\":1}}],[\"所以引入了redo\",{\"1\":{\"136\":1}}],[\"所以这块代码是为了解决极端情况下的并发问题\",{\"1\":{\"1011\":1}}],[\"所以这并不是多线程工作\",{\"1\":{\"827\":1}}],[\"所以这两个线程就会互相等待而进入死锁状态\",{\"1\":{\"823\":1}}],[\"所以这一步将通过调用\",{\"1\":{\"712\":1}}],[\"所以这一行\",{\"1\":{\"89\":1}}],[\"所以这里我们假设购票系统能承受这一万的用户请求\",{\"1\":{\"1273\":1}}],[\"所以这里我们着重了解一下\",{\"1\":{\"712\":1}}],[\"所以这里可以自定义线程池执行器\",{\"1\":{\"1047\":1}}],[\"所以这里会存在问题\",{\"1\":{\"1043\":1}}],[\"所以这里在gc之后\",{\"1\":{\"1030\":1}}],[\"所以这里不能使用\",{\"1\":{\"1033\":1}}],[\"所以这里不能一一讲解\",{\"1\":{\"774\":1}}],[\"所以这里不多做阐述\",{\"1\":{\"949\":1}}],[\"所以这里方法签名抛出了interruptedexception\",{\"1\":{\"533\":1}}],[\"所以这个时候需要向未批准的\",{\"1\":{\"1374\":1}}],[\"所以这个时候会将\",{\"1\":{\"1011\":1}}],[\"所以这个散列值是不能直接拿来用的\",{\"1\":{\"684\":1}}],[\"所以这个算法里会跟踪记录这些发生引用更新的地方\",{\"1\":{\"406\":1}}],[\"所以这个语句在搜索索引树的时候\",{\"1\":{\"117\":1}}],[\"所以哈希索引做区间查询的速度是很慢的\",{\"1\":{\"96\":1}}],[\"所以恢复后这一行\",{\"1\":{\"89\":1}}],[\"所以\",{\"1\":{\"89\":2,\"96\":1,\"106\":1,\"141\":1,\"165\":1,\"180\":1,\"201\":1,\"212\":1,\"261\":1,\"272\":1,\"324\":1,\"327\":1,\"345\":1,\"359\":3,\"382\":1,\"406\":1,\"425\":1,\"450\":1,\"495\":1,\"529\":2,\"557\":1,\"558\":1,\"571\":1,\"601\":1,\"658\":1,\"690\":1,\"708\":3,\"712\":2,\"727\":1,\"762\":1,\"800\":1,\"811\":1,\"812\":1,\"820\":1,\"855\":1,\"884\":1,\"895\":1,\"922\":1,\"936\":1,\"943\":1,\"951\":1,\"974\":1,\"1014\":1,\"1030\":1,\"1123\":1,\"1126\":1,\"1159\":2,\"1165\":1,\"1191\":1,\"1192\":1,\"1202\":1,\"1204\":1,\"1252\":1,\"1260\":1,\"1271\":1,\"1280\":1,\"1281\":1,\"1315\":1,\"1341\":1,\"1343\":1,\"1371\":1,\"1375\":1,\"1380\":2}}],[\"所以你要关注的是紧接\",{\"1\":{\"86\":1}}],[\"所以多个应用服务就可以同时获取到锁\",{\"1\":{\"51\":1}}],[\"所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况\",{\"1\":{\"1314\":1}}],[\"所以在理解和实现上比较困难\",{\"1\":{\"1099\":1}}],[\"所以在多线程下\",{\"1\":{\"969\":1,\"980\":1,\"981\":1}}],[\"所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞\",{\"1\":{\"344\":1}}],[\"所以在并发数据结构中\",{\"1\":{\"800\":1}}],[\"所以在并发环境下可能出现如下情况\",{\"1\":{\"589\":1}}],[\"所以在头尾插入或者删除元素不受元素位置的影响\",{\"1\":{\"552\":1,\"656\":1}}],[\"所以在后续的垃圾收集器设计中停顿时间在不断缩短\",{\"1\":{\"401\":1}}],[\"所以在innodb中b+树高度一般为1\",{\"1\":{\"110\":1}}],[\"所以在\",{\"1\":{\"22\":1,\"688\":1,\"1379\":1}}],[\"所以利用率低\",{\"1\":{\"19\":1}}],[\"手写\",{\"1\":{\"1173\":1}}],[\"手头的任务后\",{\"1\":{\"950\":1}}],[\"手工优化存在困难的时候\",{\"1\":{\"403\":1}}],[\"手动发到\",{\"1\":{\"1264\":1}}],[\"手动实现\",{\"1\":{\"1212\":1}}],[\"手动实现工具类\",{\"1\":{\"634\":1}}],[\"手动释放锁\",{\"1\":{\"1001\":1}}],[\"手动清理\",{\"1\":{\"294\":1}}],[\"手动开启事务\",{\"1\":{\"125\":1}}],[\"手动给锁设置过期时间\",{\"1\":{\"49\":1}}],[\"手机网站支付\",{\"1\":{\"17\":1}}],[\"异常来拒绝新来的任务\",{\"1\":{\"891\":1}}],[\"异常出现之后自动生成\",{\"1\":{\"368\":1}}],[\"异常\",{\"1\":{\"357\":1,\"480\":1,\"496\":1,\"536\":2,\"539\":2,\"630\":1,\"634\":1,\"732\":1,\"748\":1,\"752\":1,\"773\":1,\"785\":1,\"799\":1,\"899\":1,\"924\":1}}],[\"异常处理机制\",{\"1\":{\"515\":1}}],[\"异常处理\",{\"0\":{\"780\":1},\"1\":{\"2\":1,\"492\":2,\"811\":1,\"924\":1}}],[\"异步复制会不会也像异步刷盘那样影响消息的可靠性呢\",{\"1\":{\"1314\":1}}],[\"异步复制\",{\"1\":{\"1314\":1}}],[\"异步刷盘只有在\",{\"1\":{\"1313\":1}}],[\"异步刷盘\",{\"1\":{\"1312\":1}}],[\"异步修复\",{\"1\":{\"1078\":1}}],[\"异步过程中\",{\"1\":{\"1047\":1}}],[\"异步计算的结果\",{\"1\":{\"934\":1}}],[\"异步线程池框架\",{\"1\":{\"896\":1,\"923\":1}}],[\"异步\",{\"0\":{\"1271\":1},\"1\":{\"815\":1,\"1271\":1,\"1274\":1,\"1316\":1}}],[\"异步任务编排组合\",{\"1\":{\"774\":1,\"901\":1}}],[\"异步处理所有文件\",{\"1\":{\"909\":1}}],[\"异步处理\",{\"1\":{\"266\":1}}],[\"异步缓存写入\",{\"0\":{\"147\":1}}],[\"异步续期\",{\"1\":{\"49\":1}}],[\"默认方式\",{\"1\":{\"1351\":1}}],[\"默认重试两次\",{\"1\":{\"1301\":1}}],[\"默认队列选择算法\",{\"1\":{\"1299\":1}}],[\"默认支持保留所有消息\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"默认支持最多\",{\"1\":{\"569\":1}}],[\"默认错误处理器的重试次数以及时间间隔是由\",{\"1\":{\"1211\":1}}],[\"默认配置下\",{\"1\":{\"1210\":1}}],[\"默认配置会使用\",{\"1\":{\"158\":1}}],[\"默认会重试多少次\",{\"0\":{\"1210\":1}}],[\"默认采用的一种负载均衡策略\",{\"1\":{\"1141\":1}}],[\"默认采用的持久化方式\",{\"1\":{\"226\":1}}],[\"默认从当前的staleslot开始\",{\"1\":{\"1036\":1}}],[\"默认格式化值与初始化值相同\",{\"1\":{\"882\":1}}],[\"默认非公平模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"默认情况\",{\"1\":{\"609\":1}}],[\"默认情况下创建的线程名字类似\",{\"1\":{\"894\":1,\"920\":1}}],[\"默认情况下这两个变量都是\",{\"1\":{\"883\":1}}],[\"默认情况下元素采用自然顺序进行排序\",{\"1\":{\"799\":1}}],[\"默认情况下不能保证线程访问队列的公平性\",{\"1\":{\"797\":1}}],[\"默认情况下\",{\"1\":{\"49\":1,\"158\":1,\"229\":1,\"359\":1,\"385\":1,\"479\":1,\"534\":1,\"597\":1,\"709\":1}}],[\"默认2扩容后是4\",{\"1\":{\"572\":1}}],[\"默认大小为\",{\"1\":{\"570\":1}}],[\"默认并发级别\",{\"1\":{\"570\":1}}],[\"默认负载因子\",{\"1\":{\"570\":1}}],[\"默认初始化容量\",{\"1\":{\"570\":1}}],[\"默认初始容量大小\",{\"1\":{\"553\":1,\"555\":1}}],[\"默认构造函数\",{\"1\":{\"555\":1,\"621\":1}}],[\"默认无参构造函数\",{\"1\":{\"553\":1}}],[\"默认的构造函数是\",{\"1\":{\"1210\":1}}],[\"默认的构造方法是\",{\"1\":{\"756\":1,\"911\":1}}],[\"默认的等待策略\",{\"1\":{\"1183\":1}}],[\"默认的负载因子\",{\"1\":{\"619\":1}}],[\"默认的初始大小为\",{\"1\":{\"677\":1}}],[\"默认的初始容量是16\",{\"1\":{\"619\":1}}],[\"默认的初始化大小为\",{\"1\":{\"616\":1,\"677\":1}}],[\"默认的垃圾收集器是\",{\"1\":{\"448\":1}}],[\"默认的垃圾回收器依然是\",{\"1\":{\"408\":1}}],[\"默认的文件名是\",{\"1\":{\"229\":1}}],[\"默认收集器\",{\"1\":{\"403\":1}}],[\"默认垃圾收集器\",{\"1\":{\"400\":1}}],[\"默认晋升年龄并不都是\",{\"1\":{\"386\":1}}],[\"默认值\",{\"1\":{\"449\":1}}],[\"默认值是false\",{\"1\":{\"471\":1}}],[\"默认值是1\",{\"1\":{\"470\":1}}],[\"默认值是1s\",{\"1\":{\"468\":1}}],[\"默认值是0\",{\"1\":{\"469\":1}}],[\"默认值是物理内存的\",{\"1\":{\"451\":2}}],[\"默认值是\",{\"1\":{\"386\":1}}],[\"默认值为\",{\"1\":{\"233\":2,\"496\":1}}],[\"默认实现是空方法\",{\"1\":{\"354\":1}}],[\"默认只会使用多线程进行\",{\"1\":{\"267\":1}}],[\"默认使用的序列化方式是\",{\"1\":{\"1146\":1}}],[\"默认使用的是\",{\"1\":{\"403\":1,\"891\":1}}],[\"默认使用非公平锁\",{\"1\":{\"857\":1,\"865\":1}}],[\"默认使用forkjoinpool\",{\"1\":{\"784\":1}}],[\"默认使用\",{\"1\":{\"218\":1}}],[\"默认是按\",{\"1\":{\"679\":1}}],[\"默认是小顶堆\",{\"1\":{\"669\":1}}],[\"默认是integer\",{\"1\":{\"542\":1,\"672\":1}}],[\"默认是非公平锁\",{\"1\":{\"541\":1}}],[\"默认是public\",{\"1\":{\"520\":1}}],[\"默认是\",{\"1\":{\"202\":1,\"570\":3,\"692\":1}}],[\"默认选项\",{\"1\":{\"158\":1,\"227\":1}}],[\"默认\",{\"1\":{\"49\":3,\"449\":2,\"451\":2,\"569\":1,\"570\":1,\"1157\":1,\"1249\":1}}],[\"默认为物理内存的\",{\"1\":{\"456\":2}}],[\"默认为永不过期\",{\"1\":{\"177\":1}}],[\"默认为\",{\"1\":{\"49\":1,\"386\":1,\"495\":1,\"616\":1,\"619\":1,\"622\":1,\"624\":1,\"645\":1,\"677\":1,\"683\":1,\"705\":1,\"888\":1,\"1140\":1}}],[\"默认关闭\",{\"1\":{\"35\":1,\"235\":1}}],[\"看起来很简单\",{\"1\":{\"1379\":1}}],[\"看英文图片和英文文档的时候就不要怂\",{\"1\":{\"1315\":1}}],[\"看源码\",{\"1\":{\"1210\":1}}],[\"看\",{\"1\":{\"1169\":1}}],[\"看作一台\",{\"1\":{\"1251\":1}}],[\"看作当前\",{\"1\":{\"1109\":1}}],[\"看作是\",{\"1\":{\"971\":1,\"981\":1}}],[\"看作是异步运算结果的载体\",{\"1\":{\"777\":1}}],[\"看作是比\",{\"1\":{\"283\":1}}],[\"看作是一个存储二进制数字\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"看完了threadlocalhash\",{\"1\":{\"1035\":1}}],[\"看一下这个\",{\"1\":{\"1008\":1}}],[\"看看\",{\"1\":{\"748\":1,\"873\":1}}],[\"看不太懂也没关系\",{\"1\":{\"710\":1,\"711\":1}}],[\"看两者源代码可以发现\",{\"1\":{\"563\":1}}],[\"看这篇就够了\",{\"1\":{\"316\":1}}],[\"看到这里的同学实在是太有耐心了\",{\"1\":{\"1391\":1}}],[\"看到这里是不是觉得\",{\"1\":{\"1390\":1}}],[\"看到这里\",{\"1\":{\"1011\":1}}],[\"看到这块代码\",{\"1\":{\"1002\":1}}],[\"看到的只是\",{\"1\":{\"522\":1}}],[\"看到很多小伙伴简历上写了\",{\"1\":{\"144\":1}}],[\"看到百度\",{\"1\":{\"15\":1}}],[\"看下符合哪个路由规则\",{\"1\":{\"69\":1}}],[\"看门狗续期前也会先判断是否需要执行续期操作\",{\"1\":{\"49\":1}}],[\"看门狗就会执行续期操作\",{\"1\":{\"49\":1}}],[\"看门狗名字的由来于\",{\"1\":{\"49\":1}}],[\"看门狗自动续期\",{\"1\":{\"49\":1}}],[\"看门狗\",{\"1\":{\"49\":1}}],[\"客户端收到通知后找到自己定义的\",{\"1\":{\"1385\":1}}],[\"客户端和服务端是通过\",{\"1\":{\"1383\":1}}],[\"客户端能够通过心跳检测与服务器保持有效的会话\",{\"1\":{\"1353\":1}}],[\"客户端无需关注\",{\"1\":{\"1297\":1}}],[\"客户端可以用这些命令实现自己的业务逻辑\",{\"1\":{\"1253\":1}}],[\"客户端名称\",{\"1\":{\"302\":1}}],[\"客户端请求必须等待定期清理过期\",{\"1\":{\"289\":1}}],[\"客户端需要自己维护\",{\"1\":{\"287\":1}}],[\"客户端实现\",{\"1\":{\"286\":1}}],[\"客户端连接\",{\"1\":{\"265\":1}}],[\"客户端断开连接或者\",{\"1\":{\"251\":1}}],[\"客户端来简单演示一下\",{\"1\":{\"251\":1}}],[\"客户端超时阻塞\",{\"1\":{\"163\":1,\"292\":1}}],[\"客户端发出一条sql查询语句的执行过程\",{\"1\":{\"81\":1}}],[\"客户端发送的请求满足\",{\"1\":{\"71\":1}}],[\"客户端发送的请求必须同时满足这两个断言\",{\"1\":{\"71\":1}}],[\"客户端的请求先通过匹配规则找到合适的路由\",{\"1\":{\"69\":1}}],[\"客户端的请求到达网关后\",{\"1\":{\"69\":1}}],[\"客户端通常运行在独立的\",{\"1\":{\"60\":1,\"63\":1}}],[\"客户端会话\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"客户端框架\",{\"1\":{\"53\":1,\"1332\":1}}],[\"客户端获取锁就是在locks下创建临时顺序节点\",{\"1\":{\"53\":1}}],[\"客户端成功地获得分布式锁\",{\"1\":{\"51\":1}}],[\"客户端\",{\"0\":{\"1332\":1,\"1333\":1},\"1\":{\"49\":1,\"53\":1,\"280\":3,\"302\":1,\"1166\":5,\"1222\":1,\"1319\":1,\"1331\":2}}],[\"客户的长网址\",{\"1\":{\"24\":1}}],[\"秒这一量级\",{\"1\":{\"820\":1}}],[\"秒杀进行过程中\",{\"1\":{\"309\":1}}],[\"秒的数据\",{\"1\":{\"236\":1}}],[\"秒的自动过期时间\",{\"1\":{\"48\":1}}],[\"秒一次\",{\"1\":{\"161\":1,\"231\":1}}],[\"秒\",{\"1\":{\"49\":3,\"161\":1,\"231\":1,\"293\":1,\"448\":2,\"785\":1,\"888\":1,\"1213\":1,\"1281\":1}}],[\"秒为单位\",{\"1\":{\"48\":1}}],[\"标准的\",{\"1\":{\"1132\":1}}],[\"标准误差为\",{\"1\":{\"205\":1,\"212\":1}}],[\"标量替换优化技术将会导致一些微妙的变化\",{\"1\":{\"495\":1}}],[\"标记为\",{\"1\":{\"1085\":1}}],[\"标记等待过程中是否中断过\",{\"1\":{\"1012\":1}}],[\"标记是否成功拿到资源\",{\"1\":{\"1012\":1}}],[\"标记线程启动成功\",{\"1\":{\"941\":1}}],[\"标记工作线程是否创建成功\",{\"1\":{\"941\":1}}],[\"标记工作线程是否启动成功\",{\"1\":{\"941\":1}}],[\"标记与引用关联起来\",{\"1\":{\"762\":1,\"767\":1}}],[\"标记过程仍然与\",{\"1\":{\"398\":1}}],[\"标记清除后会产生大量不连续的内存碎片\",{\"1\":{\"396\":1}}],[\"标记和清除两个过程效率都不高\",{\"1\":{\"396\":1}}],[\"标记\",{\"0\":{\"396\":1,\"398\":1},\"1\":{\"396\":3,\"398\":3,\"399\":3,\"405\":1,\"406\":2,\"407\":3,\"484\":1,\"503\":3}}],[\"标志设置最大元空间大小\",{\"1\":{\"496\":1}}],[\"标志方法类型\",{\"1\":{\"328\":1}}],[\"标志\",{\"1\":{\"328\":1}}],[\"标红色表示比较常用的过滤器\",{\"1\":{\"73\":1}}],[\"标示这个锁有一个\",{\"1\":{\"48\":1}}],[\"标识\",{\"1\":{\"852\":1,\"853\":1}}],[\"标识实现这个接口的类具有随机访问功能\",{\"1\":{\"658\":1}}],[\"标识什么\",{\"1\":{\"658\":1}}],[\"标识正负\",{\"1\":{\"38\":1}}],[\"标识符和名称生成\",{\"1\":{\"37\":1}}],[\"设想一下假如两者相等的话\",{\"1\":{\"1206\":1}}],[\"设备的响应\",{\"1\":{\"819\":1}}],[\"设备只有一个在运行\",{\"1\":{\"816\":1}}],[\"设为一致\",{\"1\":{\"479\":1}}],[\"设置可以更加便于理解\",{\"1\":{\"1389\":1}}],[\"设置节点\",{\"1\":{\"1384\":1}}],[\"设置从服务端接受消息的最大等待时间\",{\"1\":{\"1293\":1}}],[\"设置预绑定的订阅关系\",{\"1\":{\"1293\":1}}],[\"设置接入点\",{\"1\":{\"1293\":1}}],[\"设置消费者分组\",{\"1\":{\"1293\":1}}],[\"设置新的自定义的错误处理器就可以实现\",{\"1\":{\"1211\":1}}],[\"设置完成之后\",{\"1\":{\"1204\":1}}],[\"设置该节点不关联任何线程\",{\"1\":{\"1013\":1}}],[\"设置前任节点等待状态为signal\",{\"1\":{\"1012\":1}}],[\"设置当前线程为独占线程\",{\"1\":{\"1007\":1}}],[\"设置变量\",{\"1\":{\"1002\":2}}],[\"设置变量的初始值\",{\"1\":{\"429\":1}}],[\"设置线程池名称前缀\",{\"1\":{\"894\":1,\"920\":1}}],[\"设置线程栈的大小\",{\"0\":{\"459\":1},\"1\":{\"459\":1}}],[\"设置超时时间为\",{\"1\":{\"785\":1}}],[\"设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值\",{\"1\":{\"763\":1,\"766\":1}}],[\"设置同步状态的值\",{\"1\":{\"742\":1,\"904\":1}}],[\"设置好多久到期然后将任务提交到延迟队列中即可\",{\"1\":{\"599\":1}}],[\"设置容量\",{\"1\":{\"570\":1}}],[\"设置队列是否有界是可选的\",{\"1\":{\"529\":1}}],[\"设置每个\",{\"1\":{\"485\":1}}],[\"设置每兆堆空闲空间中softreference的存活时间\",{\"1\":{\"468\":1}}],[\"设置用于\",{\"1\":{\"485\":1}}],[\"设置基于\",{\"1\":{\"485\":1}}],[\"设置fullgc时是否先ygc\",{\"1\":{\"471\":1}}],[\"设置是否优先\",{\"0\":{\"471\":1}}],[\"设置tlab占eden区的百分比\",{\"1\":{\"470\":1}}],[\"设置\",{\"0\":{\"470\":1},\"1\":{\"480\":3,\"485\":1,\"496\":2,\"570\":1,\"1006\":1,\"1206\":5}}],[\"设置对象头\",{\"0\":{\"505\":1}}],[\"设置对象超过多大时直接在老年代分配\",{\"1\":{\"469\":1}}],[\"设置对象直接分配在老年代\",{\"0\":{\"469\":1}}],[\"设置堆空间存活时间\",{\"0\":{\"468\":1}}],[\"设置垃圾最大年龄\",{\"0\":{\"464\":1},\"1\":{\"464\":1}}],[\"设置关闭system\",{\"1\":{\"463\":1}}],[\"设置关闭手动\",{\"0\":{\"463\":1}}],[\"设置原始类型的快速优化\",{\"0\":{\"462\":1},\"1\":{\"462\":1}}],[\"设置内存页的大小\",{\"0\":{\"461\":1},\"1\":{\"461\":1}}],[\"设置年轻代最大值\",{\"1\":{\"454\":1}}],[\"设置年轻代和老年代的大小\",{\"0\":{\"454\":1}}],[\"设置年轻代大小\",{\"1\":{\"449\":1,\"454\":1}}],[\"设置两个\",{\"1\":{\"453\":1}}],[\"设置为单线程处理任务\",{\"1\":{\"929\":1}}],[\"设置为首节点\",{\"1\":{\"710\":1}}],[\"设置为空\",{\"1\":{\"603\":1}}],[\"设置为\",{\"1\":{\"449\":1,\"705\":1,\"709\":1,\"718\":1,\"1012\":1,\"1013\":1}}],[\"设置持久代最大值\",{\"1\":{\"449\":1}}],[\"设置持久代\",{\"1\":{\"449\":1}}],[\"设置不允许冒险\",{\"1\":{\"388\":1}}],[\"设置不同的失效时间比如随机设置缓存的失效时间\",{\"1\":{\"314\":1}}],[\"设置的\",{\"1\":{\"359\":1}}],[\"设置二级缓存\",{\"1\":{\"314\":1}}],[\"设置热点数据永不过期或者过期时间比较长\",{\"1\":{\"310\":1}}],[\"设置随机过期时间\",{\"1\":{\"289\":2}}],[\"设置1的话只会开启主线程\",{\"1\":{\"267\":1}}],[\"设置多个字段的值\",{\"1\":{\"186\":1}}],[\"设置单个字段的值\",{\"1\":{\"186\":1}}],[\"设置值并设置过期时间\",{\"1\":{\"177\":1}}],[\"设置过期时间还是有问题的\",{\"1\":{\"272\":1}}],[\"设置过期时间\",{\"1\":{\"177\":2}}],[\"设置一个比较合理的值\",{\"1\":{\"1204\":1}}],[\"设置一个\",{\"1\":{\"451\":1}}],[\"设置一个或多个指定\",{\"1\":{\"177\":1,\"286\":1}}],[\"设置一个过期时间\",{\"1\":{\"48\":1}}],[\"设置指定哈希表中指定字段的值\",{\"1\":{\"185\":1}}],[\"设置指定\",{\"1\":{\"177\":1,\"202\":1}}],[\"设计一个分布式系统必定会遇到一个问题\",{\"1\":{\"1368\":1}}],[\"设计的崩溃可恢复的原子消息广播算法\",{\"1\":{\"1359\":1}}],[\"设计的文章\",{\"1\":{\"15\":1}}],[\"设计中大量使用了批量处理和异步的思想\",{\"1\":{\"1191\":1}}],[\"设计\",{\"1\":{\"1159\":1}}],[\"设计思想的示意图\",{\"1\":{\"974\":1}}],[\"设计思路上\",{\"1\":{\"19\":1}}],[\"设计者就让\",{\"1\":{\"708\":1}}],[\"设计者就用\",{\"1\":{\"601\":1}}],[\"设计者提供了带有等待时间的\",{\"1\":{\"537\":1}}],[\"设计与实现\",{\"1\":{\"237\":1,\"265\":1,\"274\":1,\"320\":1,\"1092\":1}}],[\"设计了两种可能的消息传播模式\",{\"1\":{\"1086\":1}}],[\"设计了\",{\"1\":{\"51\":1}}],[\"设计指南\",{\"1\":{\"43\":1}}],[\"值存入对应的\",{\"1\":{\"1315\":1}}],[\"值对\",{\"1\":{\"1226\":1}}],[\"值判断是否要进行重试\",{\"1\":{\"1210\":1}}],[\"值就会在原来的基础上+1\",{\"1\":{\"1018\":1}}],[\"值就减\",{\"1\":{\"753\":1}}],[\"值被减为\",{\"1\":{\"908\":1}}],[\"值会加一\",{\"1\":{\"840\":1,\"989\":1}}],[\"值本身就是\",{\"1\":{\"693\":1}}],[\"值没有在集合中\",{\"1\":{\"693\":1}}],[\"值的\",{\"1\":{\"1035\":2}}],[\"值的修改\",{\"1\":{\"1004\":1}}],[\"值的范围值\",{\"1\":{\"684\":1}}],[\"值的对象\",{\"1\":{\"680\":1}}],[\"值作比较\",{\"1\":{\"680\":1}}],[\"值可以重复\",{\"1\":{\"625\":1}}],[\"值以及\",{\"1\":{\"618\":1,\"682\":1}}],[\"值小于\",{\"1\":{\"578\":1}}],[\"值计算位置\",{\"1\":{\"578\":1}}],[\"值相等的数据\",{\"1\":{\"1035\":1}}],[\"值相等的情况\",{\"1\":{\"1033\":1}}],[\"值相等时才更新\",{\"1\":{\"840\":1,\"989\":1}}],[\"值相等\",{\"1\":{\"578\":1}}],[\"值一致\",{\"1\":{\"571\":1}}],[\"值是否和要\",{\"1\":{\"571\":1}}],[\"值是否相等\",{\"1\":{\"47\":1}}],[\"值无符号右移\",{\"1\":{\"571\":1}}],[\"值无意义\",{\"1\":{\"551\":1,\"652\":1}}],[\"值吗\",{\"0\":{\"551\":1,\"652\":1}}],[\"值得注意的是上述四个构造方法中\",{\"1\":{\"621\":1}}],[\"值得注意的是\",{\"1\":{\"503\":1,\"588\":1,\"1154\":1}}],[\"值得学习借鉴\",{\"1\":{\"412\":1}}],[\"值减少为单个全局\",{\"1\":{\"485\":1}}],[\"值进行\",{\"1\":{\"193\":1}}],[\"值为当前数据库中的\",{\"1\":{\"840\":1,\"989\":1}}],[\"值为\",{\"1\":{\"120\":1,\"693\":1,\"748\":1,\"752\":1,\"756\":1,\"906\":1,\"908\":1,\"911\":1,\"1033\":1}}],[\"值当作指针会让辅助索引占用更多的空间\",{\"1\":{\"108\":1}}],[\"值经过哈希函数的换算\",{\"1\":{\"96\":1}}],[\"值\",{\"1\":{\"96\":1,\"185\":1,\"193\":1,\"257\":1,\"551\":2,\"571\":1,\"573\":1,\"577\":1,\"618\":1,\"619\":1,\"652\":2,\"677\":1,\"678\":1,\"682\":1,\"706\":1,\"767\":8,\"799\":1,\"840\":1,\"843\":2,\"857\":1,\"865\":1,\"929\":1,\"989\":1,\"992\":2,\"1030\":4,\"1109\":1,\"1315\":1}}],[\"值不存在的时候才能\",{\"1\":{\"48\":1}}],[\"值分别对应的含义\",{\"1\":{\"37\":1}}],[\">test\",{\"1\":{\"1030\":1}}],[\">2\",{\"1\":{\"834\":1}}],[\">3\",{\"1\":{\"834\":1}}],[\">0\",{\"1\":{\"576\":1}}],[\">survivor\",{\"1\":{\"386\":1,\"495\":1}}],[\">>>=\",{\"1\":{\"1042\":1}}],[\">>>\",{\"1\":{\"571\":1,\"573\":1,\"576\":1,\"618\":6,\"677\":5,\"682\":6}}],[\">>1\",{\"1\":{\"558\":1}}],[\">>\",{\"1\":{\"352\":1,\"553\":1,\"558\":3,\"713\":2,\"730\":1,\"884\":1,\"1212\":1}}],[\">解析\",{\"1\":{\"339\":1,\"349\":1}}],[\">准备\",{\"1\":{\"339\":1,\"349\":1}}],[\">初始化\",{\"1\":{\"339\":1,\"349\":1}}],[\">连接\",{\"1\":{\"339\":1,\"349\":1}}],[\">请求\",{\"1\":{\"145\":1}}],[\">=\",{\"1\":{\"99\":1,\"553\":4,\"577\":2,\"592\":1,\"622\":1,\"624\":2,\"632\":1,\"677\":1,\"683\":1,\"906\":1,\"941\":3,\"1036\":3,\"1038\":5,\"1206\":2}}],[\">redo\",{\"1\":{\"90\":1}}],[\">binlog\",{\"1\":{\"90\":1}}],[\">引擎\",{\"1\":{\"90\":2}}],[\">执行器\",{\"1\":{\"90\":2}}],[\">权限校验\",{\"1\":{\"90\":2}}],[\">优化器\",{\"1\":{\"90\":1}}],[\">分析器\",{\"1\":{\"90\":1}}],[\">查询缓存\",{\"1\":{\"90\":1}}],[\">\",{\"1\":{\"47\":3,\"49\":1,\"81\":4,\"120\":11,\"145\":3,\"168\":1,\"177\":16,\"181\":11,\"185\":8,\"189\":10,\"193\":13,\"202\":6,\"206\":8,\"210\":11,\"219\":3,\"251\":4,\"261\":7,\"267\":1,\"280\":28,\"328\":1,\"352\":1,\"354\":1,\"357\":1,\"359\":3,\"370\":2,\"386\":1,\"484\":2,\"495\":1,\"531\":2,\"538\":1,\"553\":15,\"555\":1,\"557\":3,\"558\":1,\"559\":1,\"564\":1,\"570\":3,\"571\":2,\"576\":2,\"578\":1,\"587\":1,\"591\":1,\"592\":2,\"599\":5,\"604\":1,\"619\":2,\"621\":4,\"622\":1,\"623\":1,\"624\":2,\"629\":1,\"630\":1,\"631\":1,\"663\":1,\"677\":1,\"679\":2,\"686\":3,\"694\":2,\"704\":3,\"706\":3,\"710\":5,\"712\":3,\"713\":7,\"730\":1,\"732\":1,\"748\":3,\"749\":1,\"753\":1,\"756\":1,\"757\":3,\"767\":2,\"778\":2,\"779\":13,\"780\":4,\"781\":11,\"782\":4,\"784\":1,\"785\":1,\"823\":2,\"824\":1,\"835\":1,\"882\":1,\"883\":1,\"884\":1,\"900\":1,\"909\":4,\"911\":1,\"918\":1,\"927\":1,\"941\":1,\"944\":2,\"969\":2,\"1012\":2,\"1013\":2,\"1014\":1,\"1029\":1,\"1030\":3,\"1032\":1,\"1036\":4,\"1037\":2,\"1038\":1,\"1041\":3,\"1047\":1,\"1062\":3,\"1140\":1,\"1141\":3,\"1142\":3,\"1185\":1,\"1204\":3,\"1206\":2,\"1210\":5,\"1212\":1,\"1293\":1}}],[\"啥也不做\",{\"1\":{\"47\":1}}],[\"像哪一个节点是\",{\"1\":{\"1097\":1}}],[\"像屏障一样\",{\"1\":{\"969\":1}}],[\"像常用的\",{\"1\":{\"929\":1}}],[\"像我们前面提到的\",{\"1\":{\"838\":1,\"987\":1}}],[\"像这种情况我们就可以使用并行运行多个\",{\"1\":{\"782\":1}}],[\"像integer类等都已经实现了comparable接口\",{\"1\":{\"663\":1}}],[\"像一些二进制文件\",{\"1\":{\"256\":1}}],[\"像消息确认机制等功能还需要我们自己实现\",{\"1\":{\"251\":1}}],[\"像见鬼了一样\",{\"1\":{\"129\":1}}],[\"像\",{\"1\":{\"43\":1,\"50\":1,\"319\":1,\"837\":1,\"847\":1,\"971\":1,\"986\":1,\"987\":1,\"1087\":1,\"1099\":1,\"1147\":1,\"1159\":1}}],[\"像滴滴开源的tinyid\",{\"1\":{\"34\":1}}],[\"总不能数据只在\",{\"1\":{\"1379\":1}}],[\"总不能你这边下了订单却没加积分吧\",{\"1\":{\"1369\":1}}],[\"总不能这个系统我扣钱成功了你那积分系统积分没加吧\",{\"1\":{\"1275\":1}}],[\"总算把这篇博客写完了\",{\"1\":{\"1316\":1}}],[\"总体来说却别不大\",{\"1\":{\"713\":1}}],[\"总占用超过\",{\"1\":{\"444\":1}}],[\"总是先被\",{\"1\":{\"1110\":1}}],[\"总是会假设最好的情况\",{\"1\":{\"985\":1}}],[\"总是会假设最坏的情况\",{\"1\":{\"985\":1}}],[\"总是2的幂次倍\",{\"1\":{\"619\":1}}],[\"总是使用\",{\"1\":{\"616\":1,\"677\":2}}],[\"总是应当小于\",{\"1\":{\"412\":1}}],[\"总是跟这个事务在启动时看到的数据是一致的\",{\"1\":{\"132\":1}}],[\"总消耗时间的比值\",{\"1\":{\"403\":1}}],[\"总活跃用户数\",{\"1\":{\"261\":1}}],[\"总共可用的字符空间大小\",{\"1\":{\"256\":1}}],[\"总之\",{\"1\":{\"133\":1,\"1371\":1}}],[\"总比全表扫描要好\",{\"1\":{\"117\":1}}],[\"总结项目经验的时候\",{\"1\":{\"1341\":1}}],[\"总结来说\",{\"1\":{\"1315\":1}}],[\"总结来说就是\",{\"1\":{\"307\":1}}],[\"总结一下在\",{\"1\":{\"570\":1}}],[\"总结一下\",{\"1\":{\"530\":1,\"578\":1,\"1011\":1,\"1202\":1}}],[\"总结了关于集合使用常见的注意事项以及其具体原理\",{\"1\":{\"628\":1}}],[\"总结了\",{\"1\":{\"412\":1}}],[\"总结\",{\"0\":{\"43\":1,\"57\":1,\"63\":1,\"90\":1,\"195\":1,\"212\":1,\"579\":1,\"853\":1,\"981\":1,\"995\":1,\"1021\":1,\"1070\":1,\"1079\":1,\"1089\":1,\"1091\":1,\"1161\":1,\"1172\":1,\"1316\":1,\"1362\":1,\"1391\":1},\"1\":{\"69\":1,\"136\":1,\"138\":1,\"140\":1,\"387\":1,\"516\":1,\"578\":1,\"810\":1,\"827\":1,\"848\":1,\"968\":1,\"1070\":1,\"1231\":1,\"1240\":1}}],[\"总的来说\",{\"1\":{\"30\":1,\"578\":1,\"598\":1,\"647\":1,\"1003\":1,\"1012\":1,\"1387\":1}}],[\"纯裸\",{\"1\":{\"1152\":2,\"1161\":1}}],[\"纯文本文件\",{\"1\":{\"1131\":1}}],[\"纯本地操作\",{\"1\":{\"42\":1}}],[\"纯纯的浪费网络带宽资源\",{\"1\":{\"22\":1}}],[\"除非主动进行\",{\"1\":{\"1362\":1}}],[\"除非是马总这种神级程序员\",{\"1\":{\"1151\":1}}],[\"除非搞清楚注释的意思了\",{\"1\":{\"767\":2}}],[\"除非这个对象与引用链上的任何一个对象建立关联\",{\"1\":{\"391\":1}}],[\"除去持久代\",{\"1\":{\"449\":1}}],[\"除此之外\",{\"1\":{\"42\":1,\"176\":1,\"918\":1,\"1141\":1,\"1184\":1,\"1379\":1}}],[\"除了原生支持\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"除了发布\",{\"1\":{\"1222\":1}}],[\"除了消息队列之外\",{\"1\":{\"1218\":1}}],[\"除了能够应用在分布式系统中\",{\"1\":{\"1123\":1}}],[\"除了能减少\",{\"1\":{\"285\":1}}],[\"除了上边\",{\"1\":{\"1019\":1}}],[\"除了上面提到的钩子方法之外\",{\"1\":{\"744\":1}}],[\"除了上面提到的之外\",{\"1\":{\"253\":1}}],[\"除了上面介绍的直接使用\",{\"1\":{\"631\":1}}],[\"除了上面介绍的方式之外\",{\"1\":{\"43\":1}}],[\"除了上面这三个基本条件之外\",{\"1\":{\"61\":1}}],[\"除了抽象了线程和主内存之间的关系之外\",{\"1\":{\"971\":1,\"981\":1}}],[\"除了更易管理\",{\"1\":{\"934\":1}}],[\"除了避免\",{\"1\":{\"917\":1}}],[\"除了提供了更为好用和强大的\",{\"1\":{\"774\":2,\"901\":1}}],[\"除了实现了\",{\"1\":{\"729\":1}}],[\"除了告知用户\",{\"1\":{\"524\":1}}],[\"除了final关键字之外\",{\"1\":{\"521\":1}}],[\"除了一些\",{\"1\":{\"493\":1}}],[\"除了追求低停顿外\",{\"1\":{\"407\":1}}],[\"除了使用多线程进行垃圾收集外\",{\"1\":{\"402\":1}}],[\"除了对象\",{\"1\":{\"390\":1}}],[\"除了这\",{\"1\":{\"972\":1}}],[\"除了这三种类加载器之外\",{\"1\":{\"353\":1}}],[\"除了这一阶段之外\",{\"1\":{\"341\":1}}],[\"除了这些方法之外\",{\"1\":{\"299\":1}}],[\"除了这些\",{\"1\":{\"157\":1,\"301\":1}}],[\"除了这些之外\",{\"1\":{\"30\":1}}],[\"除了修改配置文件之外\",{\"1\":{\"302\":1}}],[\"除了会消耗更多的内存空间和带宽\",{\"1\":{\"292\":1}}],[\"除了下面介绍的内容之外\",{\"1\":{\"284\":1}}],[\"除了执行过程中出现错误的命令外\",{\"1\":{\"281\":1}}],[\"除了不满足原子性和持久性之外\",{\"1\":{\"279\":1}}],[\"除了做缓存\",{\"0\":{\"249\":1}}],[\"除了要分配\",{\"1\":{\"218\":1}}],[\"除了要求唯一之外\",{\"1\":{\"22\":1}}],[\"除了只有索引树被扫描\",{\"1\":{\"120\":1}}],[\"除了const类型\",{\"1\":{\"120\":1}}],[\"除了聚簇索引外\",{\"1\":{\"111\":1}}],[\"除了根节点和叶子节点\",{\"1\":{\"99\":1}}],[\"除了具备临时\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"除了具有持久\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"除了高可用和并发之外\",{\"1\":{\"35\":1}}],[\"除了\",{\"1\":{\"7\":1,\"18\":1,\"35\":2,\"199\":1,\"205\":1,\"330\":1,\"353\":1,\"354\":1,\"402\":1,\"493\":1,\"749\":1,\"781\":1,\"1097\":1,\"1355\":1}}],[\"会发生一种机房间网络线路故障\",{\"1\":{\"1358\":1}}],[\"会发生数据竞争\",{\"1\":{\"60\":1}}],[\"会发现\",{\"1\":{\"1335\":1}}],[\"会开启一个定时任务\",{\"1\":{\"1304\":1}}],[\"会从消息队列中拉取消息并消费\",{\"1\":{\"1272\":1}}],[\"会获取到该消息的\",{\"1\":{\"1252\":1}}],[\"会根据消息头把消息发送给感兴趣的\",{\"1\":{\"1248\":1}}],[\"会根据初始化的长度决定使用哪种类型\",{\"1\":{\"256\":1}}],[\"会不会卡住后续队列消息的消费\",{\"1\":{\"1209\":1}}],[\"会不断创建新的线程\",{\"1\":{\"957\":1}}],[\"会不断地延长锁的过期时间\",{\"1\":{\"49\":1}}],[\"会尽力将这些\",{\"1\":{\"1199\":1}}],[\"会尽可能将\",{\"1\":{\"451\":1}}],[\"会向初始化投票一样首先给自己投票\",{\"1\":{\"1380\":1}}],[\"会向所有\",{\"1\":{\"1281\":1}}],[\"会向所有的\",{\"1\":{\"1111\":1}}],[\"会向注册中心订阅自己所需的服务\",{\"1\":{\"1128\":1}}],[\"会向注册中心注册自己提供的服务\",{\"1\":{\"1128\":1}}],[\"会失败\",{\"1\":{\"1115\":1}}],[\"会达到一个\",{\"1\":{\"1112\":1}}],[\"会生成一个\",{\"1\":{\"1112\":1}}],[\"会生成一致性视图read\",{\"1\":{\"141\":1}}],[\"会传播节点的所有数据\",{\"1\":{\"1089\":1}}],[\"会减少计数\",{\"1\":{\"1019\":1}}],[\"会减少堆直到\",{\"1\":{\"449\":1,\"451\":1}}],[\"会增加计数\",{\"1\":{\"1019\":1}}],[\"会作为参数\",{\"1\":{\"1012\":1}}],[\"会作用于类的所有对象实例\",{\"1\":{\"848\":1}}],[\"会通过\",{\"1\":{\"1010\":1}}],[\"会通过插入特定的\",{\"1\":{\"834\":1}}],[\"会执行下面的代码\",{\"1\":{\"1013\":1}}],[\"会执行\",{\"1\":{\"1011\":1,\"1015\":1}}],[\"会执行框架\",{\"1\":{\"1007\":1}}],[\"会执行线程的相应准备工作\",{\"1\":{\"827\":1}}],[\"会创建新线程执行任务\",{\"1\":{\"958\":1}}],[\"会创建一个与传入集合相同元素的链表对象\",{\"1\":{\"728\":1}}],[\"会严重影响其处理任务的速度\",{\"1\":{\"929\":1}}],[\"会每隔一秒打印出线程池的线程数\",{\"1\":{\"918\":1}}],[\"会\",{\"1\":{\"904\":2}}],[\"会提升做事效率嘛\",{\"1\":{\"895\":1,\"922\":1}}],[\"会提示你转换为\",{\"1\":{\"882\":1}}],[\"会清理掉\",{\"1\":{\"884\":1}}],[\"会给所有的\",{\"1\":{\"1374\":1}}],[\"会给\",{\"1\":{\"844\":1,\"993\":1}}],[\"会给它分配相应大小的空间\",{\"1\":{\"218\":1}}],[\"会频繁失败和重试\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"会启动一个线程并使线程进入了就绪状态\",{\"1\":{\"827\":1}}],[\"会指定其大小\",{\"1\":{\"798\":1}}],[\"会自增自己的\",{\"1\":{\"1111\":1}}],[\"会自旋\",{\"1\":{\"752\":1}}],[\"会自动释放当前线程占有的对象锁\",{\"1\":{\"826\":1}}],[\"会自动按照剩余延迟时间进行升序排序\",{\"1\":{\"609\":1}}],[\"会自动调整年轻代大小\",{\"1\":{\"449\":1}}],[\"会尝试成为\",{\"1\":{\"1109\":1}}],[\"会尝试获取当前\",{\"1\":{\"852\":1}}],[\"会尝试获取实例对象的锁\",{\"1\":{\"852\":1}}],[\"会尝试获取对象的锁\",{\"1\":{\"851\":1}}],[\"会尝试使用\",{\"1\":{\"748\":1}}],[\"会尝试通过\",{\"1\":{\"742\":1}}],[\"会累加\",{\"1\":{\"742\":1,\"904\":1}}],[\"会有消息丢失的风险\",{\"1\":{\"1207\":1}}],[\"会有问题\",{\"1\":{\"1155\":1}}],[\"会有什么问题\",{\"0\":{\"1152\":1}}],[\"会有\",{\"1\":{\"917\":1}}],[\"会有大部分方法和\",{\"1\":{\"727\":1}}],[\"会有一个\",{\"1\":{\"441\":2}}],[\"会更耗时\",{\"1\":{\"713\":1}}],[\"会假设对象没有重复出现\",{\"1\":{\"680\":1}}],[\"会伴随着一次重新\",{\"1\":{\"624\":1}}],[\"会进行事务的执行操作\",{\"1\":{\"1371\":1}}],[\"会进行重试\",{\"1\":{\"1301\":1}}],[\"会进行扩容\",{\"1\":{\"619\":1}}],[\"会进行哪些操作\",{\"1\":{\"307\":2}}],[\"会首先调用\",{\"1\":{\"619\":1}}],[\"会影响性能\",{\"1\":{\"869\":1}}],[\"会影响其他任务的执行\",{\"1\":{\"611\":1}}],[\"会影响perm的大小\",{\"1\":{\"461\":1}}],[\"会按照到期时间升序编排任务\",{\"1\":{\"597\":1}}],[\"会占用额外的内存空间\",{\"1\":{\"585\":1}}],[\"会占用大量的\",{\"1\":{\"297\":1}}],[\"会默认在将指定的元素追加到此列表的末尾\",{\"1\":{\"552\":1,\"656\":1}}],[\"会让代码难以维护比如忘记做判空处理就会导致空指针异常\",{\"1\":{\"551\":1,\"652\":1}}],[\"会等待用户所传的时间段\",{\"1\":{\"537\":1}}],[\"会调用内部类\",{\"1\":{\"1007\":1}}],[\"会调用到内部类\",{\"1\":{\"1007\":1}}],[\"会调用\",{\"1\":{\"742\":1,\"904\":1,\"1016\":1}}],[\"会调用没有规定时间的\",{\"1\":{\"536\":1}}],[\"会调用interprocessmutex\",{\"1\":{\"56\":1}}],[\"会选择动态代理方式\",{\"1\":{\"523\":1}}],[\"会比\",{\"1\":{\"446\":1}}],[\"会移动到老年代\",{\"1\":{\"444\":1}}],[\"会在目标字段前后增加了\",{\"1\":{\"1184\":1}}],[\"会在后文介绍到\",{\"1\":{\"1179\":1}}],[\"会在循环中反复从linkedblockingqueue\",{\"1\":{\"954\":1}}],[\"会在循环中反复从\",{\"1\":{\"950\":1}}],[\"会在异步任务\",{\"1\":{\"781\":1}}],[\"会在两个任务都执行完成后\",{\"1\":{\"781\":1}}],[\"会在扩容之后使用链表头插法插入到指定位置\",{\"1\":{\"572\":1}}],[\"会在对象头中的标记字段里记录年龄\",{\"1\":{\"444\":1}}],[\"会在无法满足内存分配时报错\",{\"1\":{\"436\":1}}],[\"会触发一个叫做\",{\"1\":{\"444\":1}}],[\"会先试错\",{\"1\":{\"1390\":1}}],[\"会先将数据从内存中加载到高速缓存中\",{\"1\":{\"1184\":1}}],[\"会先计算对象的hashcode值来判断对象加入的位置\",{\"1\":{\"680\":1}}],[\"会先放到\",{\"1\":{\"444\":1}}],[\"会先根据\",{\"1\":{\"256\":1}}],[\"会看到它的\",{\"1\":{\"435\":1}}],[\"会覆盖类变量的显式初始化\",{\"1\":{\"430\":1}}],[\"会直接使用你给定的大小\",{\"1\":{\"677\":1}}],[\"会直接返回\",{\"1\":{\"358\":1}}],[\"会直接给它分配\",{\"1\":{\"218\":1}}],[\"会委托给\",{\"1\":{\"358\":1}}],[\"会抛出异常\",{\"1\":{\"341\":1,\"634\":1}}],[\"会把我们的消息分配到对应的\",{\"1\":{\"1249\":1}}],[\"会把我们的请求送往其中的一台\",{\"1\":{\"42\":1}}],[\"会把消息持久化到磁盘\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"会把放入队列中的线程不断去获取锁\",{\"1\":{\"1012\":1}}],[\"会把\",{\"1\":{\"827\":1}}],[\"会把所有的\",{\"1\":{\"419\":1}}],[\"会把最早的执行命令依次舍弃\",{\"1\":{\"302\":1}}],[\"会对消息进行重试处理\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"会对该\",{\"1\":{\"1114\":1}}],[\"会对指令进行重排序\",{\"1\":{\"969\":1,\"981\":1}}],[\"会对核心线程和非核心线程一视同仁\",{\"1\":{\"890\":1}}],[\"会对\",{\"1\":{\"293\":1}}],[\"会为\",{\"1\":{\"256\":1}}],[\"会被初始化一个虚拟节点\",{\"1\":{\"1014\":1}}],[\"会被清理掉\",{\"1\":{\"884\":1}}],[\"会被压入栈中\",{\"1\":{\"441\":1}}],[\"会被记录下来\",{\"1\":{\"256\":1}}],[\"会被\",{\"1\":{\"231\":1}}],[\"会被回滚\",{\"1\":{\"125\":1}}],[\"会结合多个源\",{\"1\":{\"206\":1}}],[\"会造成系统压力过大\",{\"1\":{\"1285\":1}}],[\"会造成性能瓶颈\",{\"1\":{\"1260\":1}}],[\"会造成\",{\"1\":{\"165\":1}}],[\"会导致所有的服务器间同步状态\",{\"1\":{\"1344\":1,\"1362\":1}}],[\"会导致发生交换后的\",{\"1\":{\"168\":1}}],[\"会导致\",{\"1\":{\"161\":1,\"307\":1,\"1261\":1}}],[\"会阻塞主节点\",{\"1\":{\"164\":1}}],[\"会阻塞工作线程\",{\"1\":{\"163\":1,\"292\":1}}],[\"会阻塞\",{\"1\":{\"158\":1,\"227\":1}}],[\"会返回成功\",{\"1\":{\"1112\":1}}],[\"会返回本次转移到\",{\"1\":{\"531\":1}}],[\"会返回之前位的值\",{\"1\":{\"202\":1}}],[\"会返回\",{\"1\":{\"157\":1,\"301\":1}}],[\"会返回一个\",{\"1\":{\"157\":1,\"301\":1,\"934\":1}}],[\"会返回所有符合规则的\",{\"1\":{\"157\":1,\"301\":1}}],[\"会随着数据库里数据的修改而发生变化\",{\"1\":{\"108\":1}}],[\"会一起被加载到内存\",{\"1\":{\"108\":1}}],[\"会经历3次磁盘i\",{\"1\":{\"99\":1}}],[\"会出现死锁问题\",{\"1\":{\"860\":1}}],[\"会出现同一个值的情况\",{\"1\":{\"96\":1}}],[\"会出现什么情况呢\",{\"1\":{\"89\":1}}],[\"会将自己的状态\",{\"1\":{\"1380\":1}}],[\"会将自己的信息注册到\",{\"1\":{\"1281\":1}}],[\"会将该提案编号\",{\"1\":{\"1373\":1}}],[\"会将消息压缩后在发送到\",{\"1\":{\"1302\":1}}],[\"会将成功发送到消息队列的消息存储在消息生产者服务器上\",{\"1\":{\"1222\":1}}],[\"会将\",{\"1\":{\"1112\":1}}],[\"会将这个\",{\"1\":{\"1112\":1}}],[\"会将任务加入\",{\"1\":{\"950\":1}}],[\"会将链表首节点移除\",{\"1\":{\"712\":1}}],[\"会将其扩充为\",{\"1\":{\"677\":1}}],[\"会将请求转发到\",{\"1\":{\"75\":1}}],[\"会将当前线程和对应的\",{\"1\":{\"56\":1}}],[\"会将对应的子节点删除\",{\"1\":{\"53\":1}}],[\"会话断了是不是意味着这个节点没了\",{\"1\":{\"1387\":1}}],[\"会话超时失效事件\",{\"1\":{\"1383\":1}}],[\"会话转移事件\",{\"1\":{\"1383\":1}}],[\"会话还有对应的事件\",{\"1\":{\"1383\":1}}],[\"会话机制\",{\"1\":{\"1381\":1}}],[\"会话的一个重要标识\",{\"1\":{\"1353\":1}}],[\"会话\",{\"0\":{\"1353\":1,\"1383\":1},\"1\":{\"1391\":1}}],[\"会话失效节点自动被删除\",{\"1\":{\"54\":1}}],[\"会话消失则节点消失\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"会判断\",{\"1\":{\"53\":1}}],[\"会多一步网络转发\",{\"1\":{\"1\":1}}],[\"滴滴等等\",{\"1\":{\"1172\":1}}],[\"滴滴\",{\"0\":{\"42\":1}}],[\"qmq\",{\"1\":{\"1223\":1}}],[\"qcon\",{\"1\":{\"1178\":1}}],[\"quorum\",{\"1\":{\"1069\":3}}],[\"quantum\",{\"1\":{\"820\":1}}],[\"qunar\",{\"1\":{\"742\":1}}],[\"quick\",{\"1\":{\"633\":1}}],[\"quicklist\",{\"1\":{\"174\":4}}],[\"queuing\",{\"1\":{\"1230\":1,\"1237\":1,\"1245\":1}}],[\"queueid\",{\"1\":{\"1315\":3}}],[\"queue2\",{\"1\":{\"1252\":5}}],[\"queue1\",{\"1\":{\"1252\":3}}],[\"queue<e>\",{\"1\":{\"533\":2,\"670\":1}}],[\"queue\",{\"0\":{\"640\":1,\"644\":1,\"666\":1,\"667\":1,\"1250\":1,\"1255\":1,\"1397\":1},\"1\":{\"446\":2,\"531\":19,\"533\":7,\"536\":1,\"639\":1,\"640\":1,\"667\":4,\"669\":1,\"670\":1,\"727\":1,\"794\":1,\"796\":3,\"798\":1,\"801\":1,\"918\":1,\"940\":2,\"941\":1,\"999\":2,\"1005\":1,\"1011\":1,\"1193\":1,\"1200\":1,\"1213\":1,\"1218\":1,\"1228\":1,\"1249\":4,\"1250\":1,\"1252\":2,\"1253\":1,\"1255\":1,\"1262\":4,\"1263\":16,\"1264\":1,\"1315\":2,\"1379\":1}}],[\"queued\",{\"1\":{\"280\":9}}],[\"questions\",{\"1\":{\"511\":1}}],[\"question\",{\"1\":{\"511\":2,\"1218\":1}}],[\"query\",{\"1\":{\"246\":1,\"299\":2}}],[\"q\",{\"1\":{\"156\":1,\"365\":1,\"601\":3,\"602\":1,\"603\":3,\"604\":5,\"605\":2,\"1016\":5}}],[\"qps\",{\"1\":{\"41\":1,\"246\":2}}],[\"qq\",{\"1\":{\"17\":3,\"19\":2,\"156\":1,\"171\":2,\"320\":3,\"567\":1,\"876\":1,\"1151\":1,\"1241\":1}}],[\"基金会管理\",{\"1\":{\"1171\":1}}],[\"基础概念\",{\"0\":{\"514\":1}}],[\"基础类库\",{\"1\":{\"353\":1,\"516\":1}}],[\"基础\",{\"0\":{\"241\":1,\"1107\":1,\"1121\":1,\"1189\":1},\"1\":{\"412\":1}}],[\"基础上实现的\",{\"1\":{\"1245\":1}}],[\"基础上对节点增加双向指针实现双向链表的特性\",{\"1\":{\"708\":1}}],[\"基础上在各个节点之间维护一条双向链表\",{\"1\":{\"702\":1}}],[\"基础上维护一条双向链表\",{\"1\":{\"702\":1}}],[\"基础上\",{\"1\":{\"41\":1}}],[\"基数计数概率算法为了节省内存并不会直接存储元数据\",{\"1\":{\"205\":1}}],[\"基数统计\",{\"0\":{\"204\":1},\"1\":{\"253\":1}}],[\"基本离不开\",{\"1\":{\"1352\":1}}],[\"基本是完全一样的\",{\"1\":{\"1194\":1}}],[\"基本支持所有主流编程语言且与平台无关\",{\"1\":{\"1170\":1}}],[\"基本可用是指分布式系统在出现不可预知故障的时候\",{\"1\":{\"1076\":1}}],[\"基本可用\",{\"0\":{\"1076\":1},\"1\":{\"1073\":1}}],[\"基本原理以后\",{\"1\":{\"1020\":1}}],[\"基本数据类型\",{\"1\":{\"764\":2}}],[\"基本数据类型原子类的优势\",{\"0\":{\"764\":1}}],[\"基本数据类型的零值\",{\"1\":{\"342\":2}}],[\"基本类型原子类只能更新一个变量\",{\"1\":{\"767\":1}}],[\"基本类型原子类\",{\"0\":{\"763\":1}}],[\"基本类型\",{\"1\":{\"762\":1}}],[\"基本类型也可以实现转换\",{\"1\":{\"634\":1}}],[\"基本被淘汰\",{\"1\":{\"677\":1}}],[\"基本上不会看到它的存在\",{\"1\":{\"1252\":1}}],[\"基本上\",{\"1\":{\"406\":1}}],[\"基本操作演示\",{\"1\":{\"202\":1,\"206\":1}}],[\"基本操作\",{\"1\":{\"177\":1,\"189\":1,\"193\":1,\"210\":1}}],[\"基本架构\",{\"0\":{\"81\":1}}],[\"基于该协议\",{\"1\":{\"1360\":1}}],[\"基于此上述架构图可变为\",{\"1\":{\"1310\":1}}],[\"基于此协议的客户端与消息中间件可传递消息\",{\"1\":{\"1230\":1}}],[\"基于消息通知方式不存在定时阶梯间隔\",{\"1\":{\"1285\":1}}],[\"基于定时消息的超时任务处理具备如下优势\",{\"1\":{\"1285\":1}}],[\"基于timeoutblockingwaitstrategy的策略\",{\"1\":{\"1183\":1}}],[\"基于历史原因\",{\"1\":{\"1160\":1}}],[\"基于这个思路\",{\"1\":{\"1154\":1}}],[\"基于字节流\",{\"1\":{\"1152\":2}}],[\"基于微内核架构\",{\"1\":{\"1132\":1}}],[\"基于微内核架构的系统\",{\"1\":{\"1132\":1}}],[\"基于产品的应用程序是已经打包好并且拥有不同版本\",{\"1\":{\"1132\":1}}],[\"基于访问压力实时管理集群容量\",{\"1\":{\"1123\":1}}],[\"基于主流配置中心\",{\"1\":{\"896\":1,\"923\":1}}],[\"基于链表实现\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"基于数据库的唯一键来保证重复数据不会被插入多条\",{\"1\":{\"1303\":1}}],[\"基于数据库的号段模式来生成分布式\",{\"1\":{\"34\":1}}],[\"基于数组还支持批量操作\",{\"1\":{\"1184\":1}}],[\"基于数组实现\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"基于知名的开源项目\",{\"1\":{\"244\":1}}],[\"基于分布式架构\",{\"1\":{\"1240\":1}}],[\"基于分布式键值存储系统比如\",{\"1\":{\"62\":1}}],[\"基于分布式协调服务\",{\"1\":{\"62\":1}}],[\"基于关系型数据库比如\",{\"1\":{\"62\":1}}],[\"基于内存\",{\"1\":{\"35\":1,\"243\":1}}],[\"基于同步\",{\"1\":{\"4\":1}}],[\"基于\",{\"0\":{\"46\":1,\"52\":1},\"1\":{\"1\":1,\"4\":2,\"5\":1,\"6\":1,\"7\":1,\"10\":2,\"37\":1,\"49\":1,\"62\":1,\"68\":1,\"76\":1,\"205\":1,\"209\":1,\"212\":1,\"243\":1,\"249\":1,\"265\":2,\"377\":1,\"643\":1,\"665\":1,\"708\":1,\"776\":1,\"1120\":1,\"1159\":1,\"1168\":1,\"1170\":1,\"1178\":1,\"1183\":2,\"1191\":1,\"1238\":1,\"1240\":2,\"1310\":1}}],[\"起始偏移量为\",{\"1\":{\"1315\":2}}],[\"起源于德国哲学家\",{\"1\":{\"41\":1}}],[\"起步要比\",{\"1\":{\"5\":1,\"68\":1}}],[\"美团的骚操作\",{\"0\":{\"923\":1}}],[\"美团的骚操作至今让我难忘\",{\"1\":{\"921\":1}}],[\"美团的方式是自定义了一个叫做\",{\"1\":{\"896\":1,\"923\":1}}],[\"美团给出了一个让面试官虎躯一震的回答\",{\"1\":{\"896\":1}}],[\"美团技术团\",{\"1\":{\"412\":1}}],[\"美团技术团队的思路是主要对线程池的核心参数实现自定义可配置\",{\"1\":{\"896\":1,\"923\":1}}],[\"美团技术团队在\",{\"1\":{\"896\":1,\"923\":1}}],[\"美团技术团队\",{\"1\":{\"2\":1,\"486\":3,\"742\":1,\"788\":1,\"876\":1,\"999\":1}}],[\"美团点评分布式\",{\"1\":{\"41\":1}}],[\"美团\",{\"0\":{\"41\":1}}],[\"依旧有消息重复消费的风险\",{\"1\":{\"1207\":1}}],[\"依赖于语言或库的支持\",{\"1\":{\"1056\":1}}],[\"依赖于\",{\"0\":{\"861\":2}}],[\"依赖\",{\"1\":{\"781\":1}}],[\"依赖boxed的装箱操作\",{\"1\":{\"634\":1}}],[\"依赖时间\",{\"1\":{\"38\":1}}],[\"依然不会执行\",{\"1\":{\"557\":1}}],[\"依然可能会出现锁无法被释放的问题\",{\"1\":{\"48\":1}}],[\"依次在队列中往后排队即可\",{\"1\":{\"1011\":1}}],[\"依次是\",{\"1\":{\"854\":1}}],[\"依次和插入的\",{\"1\":{\"622\":1}}],[\"依次包括了访问标志\",{\"1\":{\"332\":1}}],[\"依次看下每个组件的作用\",{\"1\":{\"83\":1}}],[\"依次调用\",{\"1\":{\"23\":1}}],[\"比例\",{\"1\":{\"895\":1,\"922\":1}}],[\"比说我们要读取处理\",{\"1\":{\"782\":1}}],[\"比方省略了abstractlist\",{\"1\":{\"639\":1}}],[\"比\",{\"0\":{\"862\":1},\"1\":{\"236\":2,\"557\":1,\"558\":1,\"649\":1,\"895\":1,\"922\":1}}],[\"比较重要的几个概念\",{\"1\":{\"1196\":1}}],[\"比较重要的有下面\",{\"1\":{\"243\":1}}],[\"比较它们的权重值是否相等\",{\"1\":{\"1142\":1}}],[\"比较适合节点数量比较多或者节点动态变化的场景\",{\"1\":{\"1089\":1,\"1091\":1}}],[\"比较适合中心化系统\",{\"1\":{\"1083\":1}}],[\"比较适合读请求比较多的场景\",{\"1\":{\"145\":1}}],[\"比较推荐\",{\"1\":{\"1078\":1}}],[\"比较麻烦\",{\"1\":{\"897\":1}}],[\"比较与交换\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"比较并替换\",{\"1\":{\"765\":1}}],[\"比较\",{\"0\":{\"665\":1},\"1\":{\"622\":2,\"732\":1}}],[\"比较mincapacity和\",{\"1\":{\"553\":1}}],[\"比较简单的原因\",{\"1\":{\"936\":1}}],[\"比较简单\",{\"1\":{\"394\":1}}],[\"比较常用的方法有下面几个\",{\"1\":{\"779\":1}}],[\"比较常用的办法是自己维护\",{\"1\":{\"286\":1}}],[\"比较常用的\",{\"1\":{\"244\":1}}],[\"比较常用的一种是实现errorwebexceptionhandler并重写其中的handle方法\",{\"1\":{\"77\":1}}],[\"比较老牌同时也是使用的比较多的还是\",{\"1\":{\"244\":1}}],[\"比较灵活\",{\"1\":{\"38\":1,\"1001\":1}}],[\"比如选主\",{\"1\":{\"1391\":1}}],[\"比如当一个锁得到释放它会通知所有等待的客户端从而造成\",{\"1\":{\"1388\":1}}],[\"比如当第二阶段\",{\"1\":{\"1370\":1}}],[\"比如协调者在指定时间内未收到全部的确认消息则进行事务中断的处理\",{\"1\":{\"1371\":1}}],[\"比如单点\",{\"1\":{\"1371\":1}}],[\"比如各个分布式组件如何协调起来\",{\"1\":{\"1367\":1}}],[\"比如创建订单服务\",{\"1\":{\"1367\":1}}],[\"比如现在有一个由\",{\"1\":{\"1358\":1}}],[\"比如假如我们有\",{\"1\":{\"1357\":1}}],[\"比如假如有两个提供相同服务的服务器\",{\"1\":{\"1144\":1}}],[\"比如稀疏索引等等问题\",{\"1\":{\"1315\":1}}],[\"比如此时我下订单然后增加积分\",{\"1\":{\"1304\":1}}],[\"比如此时我需要将信息发送给短信系统和邮件系统\",{\"1\":{\"1278\":1}}],[\"比如将\",{\"1\":{\"1303\":1}}],[\"比如这里我们是三个\",{\"1\":{\"1380\":1}}],[\"比如这里是同一个订单\",{\"1\":{\"1299\":1}}],[\"比如这个时候我们启动了\",{\"1\":{\"1380\":1}}],[\"比如这个时候我们消费的顺序为修改删除增加\",{\"1\":{\"1275\":1}}],[\"比如这个时候\",{\"1\":{\"1370\":1}}],[\"比如这个时候采用异步复制的方式\",{\"1\":{\"1314\":1}}],[\"比如订单消息\",{\"1\":{\"1280\":1}}],[\"比如订单号\",{\"1\":{\"1272\":1}}],[\"比如生产者生产了一系列的有序消息\",{\"1\":{\"1275\":1}}],[\"比如增加积分\",{\"1\":{\"1275\":1}}],[\"比如大家一起喝咖啡熬夜到晚上\",{\"1\":{\"1264\":1}}],[\"比如凌晨\",{\"1\":{\"1207\":1}}],[\"比如某度云盘\",{\"1\":{\"1155\":1}}],[\"比如比较有名的grpc\",{\"1\":{\"1154\":1}}],[\"比如消息体是否被压缩过和消息体格式之类的\",{\"1\":{\"1152\":1}}],[\"比如消息队列中消息的异步写入磁盘\",{\"1\":{\"147\":1}}],[\"比如加入\",{\"1\":{\"1152\":1}}],[\"比如用bind\",{\"1\":{\"1151\":1}}],[\"比如用户在提交订单之后\",{\"1\":{\"1220\":1}}],[\"比如用户\",{\"1\":{\"28\":1}}],[\"比如你刚刚消费完消息之后\",{\"1\":{\"1205\":1}}],[\"比如你觉得\",{\"1\":{\"1132\":1}}],[\"比如你可以将一个用户所有的关注人存在一个集合中\",{\"1\":{\"188\":1}}],[\"比如负载均衡策略\",{\"1\":{\"1131\":1}}],[\"比如电商系统可以简单地拆分成订单系统\",{\"1\":{\"1125\":1}}],[\"比如电商平台购物领取的优惠券\",{\"1\":{\"19\":1}}],[\"比如怎么选举领导者\",{\"1\":{\"1099\":1}}],[\"比如对于需要确保强一致性的场景如银行一般会选择保证\",{\"1\":{\"1068\":1}}],[\"比如对象实例\",{\"1\":{\"421\":1}}],[\"比如部分节点网络出了问题\",{\"1\":{\"1067\":1}}],[\"比如遇到了\",{\"1\":{\"1033\":1}}],[\"比如机器的寄存器\",{\"1\":{\"972\":1}}],[\"比如非常容易削弱编译器的优化能力\",{\"1\":{\"971\":1}}],[\"比如等待时间过长的任务会被移除并重新添加到队列中\",{\"1\":{\"897\":1}}],[\"比如fixedthreadpool\",{\"1\":{\"897\":1}}],[\"比如longadder\",{\"1\":{\"838\":1,\"987\":1}}],[\"比如atomicinteger\",{\"1\":{\"838\":1,\"987\":1}}],[\"比如银行家算法\",{\"1\":{\"824\":1}}],[\"比如请求\",{\"1\":{\"821\":1}}],[\"比如调用了\",{\"1\":{\"821\":1}}],[\"比如上文所说到过的程序计数器\",{\"1\":{\"821\":1}}],[\"比如绿色线程不能直接使用操作系统提供的功能如异步\",{\"1\":{\"808\":1}}],[\"比如京东的\",{\"1\":{\"787\":1}}],[\"比如取消任务\",{\"1\":{\"785\":1}}],[\"比如一个线程获得了某个对象的锁\",{\"1\":{\"860\":1}}],[\"比如一个线程在执行一个带锁的方法\",{\"1\":{\"50\":1}}],[\"比如一个\",{\"1\":{\"661\":1}}],[\"比如可以实现多路通知功能也就是在一个lock对象中可以创建多个condition实例\",{\"1\":{\"544\":1,\"862\":1}}],[\"比如put\",{\"1\":{\"535\":1}}],[\"比如通过\",{\"1\":{\"523\":1,\"820\":1}}],[\"比如方法的覆盖\",{\"1\":{\"519\":1}}],[\"比如方法的重载\",{\"1\":{\"519\":1}}],[\"比如下面几篇文章就挺不错\",{\"1\":{\"788\":1}}],[\"比如下面的参数就是设置老年代与新生代内存的比值为\",{\"1\":{\"479\":1}}],[\"比如下面这个语句\",{\"1\":{\"86\":1}}],[\"比如我创建了一个名字为\",{\"1\":{\"1199\":1}}],[\"比如我下面介绍的\",{\"1\":{\"1167\":1}}],[\"比如我执行一个\",{\"1\":{\"968\":1}}],[\"比如我现在有一个写请求\",{\"1\":{\"1379\":1}}],[\"比如我现在自己定义一个\",{\"1\":{\"433\":1}}],[\"比如我现在要\",{\"1\":{\"433\":1}}],[\"比如我们有多个短信系统作为消费者\",{\"1\":{\"1280\":1}}],[\"比如我们有多个秒杀系统作为生产者\",{\"1\":{\"1280\":1}}],[\"比如我们有一个购票系统\",{\"1\":{\"1271\":1}}],[\"比如我们这里的主题就可以叫做\",{\"1\":{\"1272\":1}}],[\"比如我们同时发了\",{\"1\":{\"1202\":1}}],[\"比如我们在同一个线程中声明了两个\",{\"1\":{\"883\":1}}],[\"比如我们在执行下面这个查询语句时\",{\"1\":{\"81\":1}}],[\"比如我们上面代码中的\",{\"1\":{\"753\":1}}],[\"比如我们提到的\",{\"1\":{\"740\":1,\"903\":1}}],[\"比如我们执行一个方法\",{\"1\":{\"441\":1}}],[\"比如我们现在写了一个\",{\"1\":{\"418\":1}}],[\"比如我们编写一个称为\",{\"1\":{\"358\":1}}],[\"比如我们定义了public\",{\"1\":{\"342\":1}}],[\"比如我们的短信验证码可能只在\",{\"1\":{\"270\":1}}],[\"比如类信息\",{\"1\":{\"420\":1}}],[\"比如输出\",{\"1\":{\"367\":1}}],[\"比如实现了\",{\"1\":{\"359\":1}}],[\"比如实现自定义的路由规则\",{\"1\":{\"6\":1}}],[\"比如java\",{\"1\":{\"353\":1}}],[\"比如给\",{\"1\":{\"342\":1}}],[\"比如查询的数据库\",{\"1\":{\"307\":1}}],[\"比如查询余额\",{\"1\":{\"124\":1}}],[\"比如突发的热点新闻事件等\",{\"1\":{\"298\":1}}],[\"比如参与秒杀活动的商品数据等\",{\"1\":{\"298\":1}}],[\"比如二次哈希\",{\"1\":{\"294\":1}}],[\"比如哈希中冗余了大量的无用键值对\",{\"1\":{\"292\":1}}],[\"比如直接使用\",{\"1\":{\"292\":1}}],[\"比如直播间送礼物的排行榜\",{\"1\":{\"258\":1}}],[\"比如其他事务\",{\"1\":{\"287\":1}}],[\"比如事务\",{\"1\":{\"287\":1}}],[\"比如图片\",{\"1\":{\"256\":1}}],[\"比如拼接\",{\"1\":{\"256\":1}}],[\"比如说集群管理\",{\"1\":{\"1381\":1}}],[\"比如说此时选\",{\"1\":{\"1380\":1}}],[\"比如说把一个班级作为整个系统\",{\"1\":{\"1368\":1}}],[\"比如说我们监听这个临时节点的父节点\",{\"1\":{\"1387\":1}}],[\"比如说我们想要实现自己的负载均衡策略\",{\"1\":{\"1131\":1}}],[\"比如说我们现在点开\",{\"1\":{\"435\":1}}],[\"比如说你声明了一个数组\",{\"1\":{\"558\":1}}],[\"比如说\",{\"1\":{\"229\":1,\"353\":1,\"781\":1,\"1303\":1,\"1375\":1}}],[\"比如说面试官很可能会追问\",{\"1\":{\"145\":1}}],[\"比如重启机器\",{\"1\":{\"224\":1}}],[\"比如是否点赞过某个视频\",{\"1\":{\"203\":1}}],[\"比如优先级任务队列\",{\"1\":{\"194\":1}}],[\"比如浏览量\",{\"1\":{\"147\":1}}],[\"比如b\",{\"1\":{\"98\":1}}],[\"比如原来是\",{\"1\":{\"89\":1}}],[\"比如多个索引的时候该如何选择索引\",{\"1\":{\"87\":1}}],[\"比如存储过程\",{\"1\":{\"82\":1}}],[\"比如添加请求头\",{\"1\":{\"69\":1}}],[\"比如共享数据被修改\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"比如它这里增加了双号段避免获取\",{\"1\":{\"41\":1}}],[\"比如使用集合类型的时候没有考虑到数据量的快速增长\",{\"1\":{\"292\":1}}],[\"比如使用\",{\"1\":{\"37\":1}}],[\"比如根据订单\",{\"1\":{\"33\":1,\"34\":1}}],[\"比如身份证\",{\"1\":{\"28\":1}}],[\"比如在\",{\"1\":{\"1371\":1}}],[\"比如在新生代中\",{\"1\":{\"399\":1}}],[\"比如在第一个实例算是第一层\",{\"1\":{\"23\":1}}],[\"比如在服务上启用\",{\"1\":{\"7\":1}}],[\"比如疫情优惠券\",{\"1\":{\"19\":1}}],[\"比如日销\",{\"1\":{\"18\":1}}],[\"比如\",{\"1\":{\"8\":1,\"22\":1,\"54\":1,\"86\":1,\"89\":1,\"124\":1,\"125\":1,\"147\":1,\"224\":1,\"236\":1,\"242\":1,\"249\":1,\"254\":1,\"270\":1,\"286\":1,\"319\":2,\"327\":1,\"340\":1,\"341\":1,\"344\":1,\"359\":1,\"366\":1,\"385\":1,\"495\":1,\"523\":1,\"552\":1,\"558\":1,\"560\":1,\"629\":1,\"646\":1,\"649\":1,\"656\":1,\"817\":1,\"897\":1,\"968\":2,\"971\":1,\"981\":1,\"1056\":1,\"1062\":1,\"1068\":1,\"1078\":2,\"1132\":1,\"1152\":1,\"1155\":1,\"1157\":2,\"1158\":1,\"1159\":2,\"1167\":1,\"1193\":1,\"1207\":1,\"1228\":1,\"1237\":1,\"1246\":1,\"1249\":1,\"1275\":1,\"1303\":1,\"1315\":1,\"1335\":1,\"1344\":1,\"1349\":1,\"1367\":1,\"1369\":1,\"1381\":1,\"1383\":1,\"1388\":1,\"1391\":1}}],[\"比如金山\",{\"1\":{\"8\":1}}],[\"机制是互斥的\",{\"1\":{\"1261\":1}}],[\"机制有什么好处呢\",{\"1\":{\"1197\":1}}],[\"机制进行了增强\",{\"1\":{\"1131\":1}}],[\"机制的实现\",{\"1\":{\"1131\":1}}],[\"机制被大量用在开源项目中\",{\"1\":{\"1131\":1}}],[\"机制了解么\",{\"0\":{\"1131\":1}}],[\"机制和版本号机制来帮助客户端检测数据的变化和版本号的变更\",{\"1\":{\"1069\":1}}],[\"机制来解决\",{\"1\":{\"233\":1}}],[\"机制来保证的\",{\"1\":{\"141\":1}}],[\"机制\",{\"0\":{\"1385\":1},\"1\":{\"231\":1,\"249\":1,\"631\":2,\"1085\":1,\"1140\":1,\"1197\":1,\"1206\":1,\"1237\":1,\"1261\":2,\"1346\":2,\"1352\":2,\"1381\":1}}],[\"机制都用到了这种策略\",{\"1\":{\"147\":1}}],[\"机房的节点\",{\"1\":{\"38\":1}}],[\"机器可以在不影响写性能的情况下提升集群的读性能\",{\"1\":{\"1355\":1}}],[\"机器不参与\",{\"1\":{\"1355\":1}}],[\"机器故障之后恢复数据\",{\"1\":{\"224\":1}}],[\"机器进程\",{\"1\":{\"35\":1}}],[\"机器指标\",{\"1\":{\"2\":1}}],[\"约等于\",{\"1\":{\"816\":1}}],[\"约束多个实现类具有统一的行为\",{\"1\":{\"520\":1}}],[\"约\",{\"1\":{\"38\":1,\"480\":1}}],[\"毫秒的时间片段内\",{\"1\":{\"407\":1}}],[\"毫秒精度的\",{\"1\":{\"271\":1}}],[\"毫秒为单位\",{\"1\":{\"48\":1}}],[\"毫秒\",{\"1\":{\"38\":1,\"407\":1,\"1213\":1}}],[\"始终为\",{\"1\":{\"38\":1}}],[\"雪花算法\",{\"0\":{\"38\":1},\"1\":{\"40\":3,\"41\":1}}],[\"时任研究院的首席科学家\",{\"1\":{\"1343\":1}}],[\"时效性\",{\"1\":{\"1240\":1}}],[\"时返回失败\",{\"1\":{\"1112\":1}}],[\"时传入一个\",{\"1\":{\"897\":1}}],[\"时获取锁失败\",{\"1\":{\"860\":1}}],[\"时可以直接获得当前对象的锁\",{\"1\":{\"860\":1}}],[\"时为非公平锁\",{\"1\":{\"857\":1,\"865\":1}}],[\"时为公平锁\",{\"1\":{\"857\":1,\"865\":1}}],[\"时代意味着多个线程可以同时运行\",{\"1\":{\"816\":1}}],[\"时刻\",{\"1\":{\"814\":1}}],[\"时抛出了\",{\"1\":{\"785\":1}}],[\"时被阻塞\",{\"1\":{\"755\":1,\"910\":1}}],[\"时的事务\",{\"1\":{\"1382\":1}}],[\"时的空闲时间\",{\"1\":{\"819\":1}}],[\"时的\",{\"1\":{\"708\":1}}],[\"时存储键值对的节点类\",{\"1\":{\"708\":1}}],[\"时树节点具备双向链表的特性\",{\"1\":{\"708\":1}}],[\"时将链表\",{\"1\":{\"691\":1}}],[\"时就会失败\",{\"1\":{\"904\":1}}],[\"时就已经存在\",{\"1\":{\"668\":1}}],[\"时就是不会再次使用的\",{\"1\":{\"445\":1}}],[\"时会抛\",{\"1\":{\"630\":1}}],[\"时会比较耗时\",{\"1\":{\"163\":1,\"292\":1}}],[\"时才会将链表转换为红黑树\",{\"1\":{\"577\":1}}],[\"时计算位置时会用到\",{\"1\":{\"570\":1}}],[\"时无效另一种直接在旧生代分配的情况是大的数组对象\",{\"1\":{\"449\":1}}],[\"时许开始无法访问和使用\",{\"1\":{\"412\":1}}],[\"时都会存在数据丢失的情况\",{\"1\":{\"282\":1}}],[\"时建议采用分批次删除和异步删除的方式进行\",{\"1\":{\"165\":1}}],[\"时速度会很快\",{\"1\":{\"96\":1}}],[\"时\",{\"1\":{\"50\":1,\"163\":1,\"164\":1,\"169\":1,\"251\":1,\"256\":1,\"292\":1,\"344\":1,\"357\":1,\"386\":1,\"425\":1,\"433\":1,\"449\":2,\"451\":2,\"455\":1,\"531\":1,\"555\":1,\"557\":1,\"616\":1,\"619\":1,\"645\":1,\"677\":1,\"683\":1,\"693\":2,\"712\":2,\"717\":1,\"718\":1,\"752\":3,\"753\":2,\"756\":1,\"841\":1,\"904\":1,\"911\":1,\"990\":1,\"1010\":1,\"1011\":1,\"1019\":1,\"1105\":1,\"1114\":1,\"1302\":1}}],[\"时钟问题的解决需要弱依赖于\",{\"1\":{\"41\":1}}],[\"时序等元素\",{\"1\":{\"37\":1}}],[\"时间维度精确到毫秒\",{\"1\":{\"1306\":1}}],[\"时间与可用性\",{\"0\":{\"1116\":1}}],[\"时间内没有收到\",{\"1\":{\"1115\":1}}],[\"时间内任务还没有执行完\",{\"1\":{\"944\":1}}],[\"时间单位\",{\"1\":{\"890\":1,\"936\":1}}],[\"时间成本相对较高\",{\"1\":{\"847\":1}}],[\"时间分片\",{\"1\":{\"820\":1}}],[\"时间段\",{\"1\":{\"814\":1}}],[\"时间到了队列还是满的\",{\"1\":{\"537\":1}}],[\"时间片切换到另一个任务之前会先保存自己的状态\",{\"1\":{\"895\":1,\"922\":1}}],[\"时间片用完\",{\"1\":{\"821\":1}}],[\"时间片用后就要被切换下来放入调度队列的末尾等待再次调度\",{\"1\":{\"820\":1}}],[\"时间片\",{\"1\":{\"820\":1}}],[\"时间片尝试获取元素\",{\"1\":{\"535\":1}}],[\"时间片进行入队操作\",{\"1\":{\"535\":1}}],[\"时间为timeout的时长\",{\"1\":{\"533\":1}}],[\"时间非常大\",{\"1\":{\"412\":1}}],[\"时间的比例\",{\"1\":{\"484\":1}}],[\"时间的比例不高于\",{\"1\":{\"220\":1}}],[\"时间的比例不低于\",{\"1\":{\"220\":1}}],[\"时间的影响\",{\"1\":{\"272\":1}}],[\"时间复杂度接近是\",{\"1\":{\"632\":1}}],[\"时间复杂度接近于\",{\"1\":{\"632\":1}}],[\"时间复杂度是\",{\"1\":{\"588\":1}}],[\"时间复杂度就为\",{\"1\":{\"552\":1,\"656\":1}}],[\"时间复杂度为\",{\"1\":{\"157\":2,\"256\":2,\"301\":2,\"552\":2,\"653\":2,\"654\":1,\"656\":2,\"658\":2,\"725\":1,\"729\":2}}],[\"时间复杂度的命令可能会导致慢查询之外\",{\"1\":{\"301\":1}}],[\"时间复杂度的命令可能会导致阻塞之外\",{\"1\":{\"157\":1}}],[\"时间复杂度的命令\",{\"1\":{\"157\":1,\"301\":1}}],[\"时间复杂度\",{\"1\":{\"157\":1,\"301\":1}}],[\"时间复杂度退化为o\",{\"1\":{\"97\":1}}],[\"时间顺序\",{\"1\":{\"127\":1,\"128\":1,\"129\":1}}],[\"时间\",{\"1\":{\"82\":1,\"895\":1,\"922\":1}}],[\"时间和节点\",{\"1\":{\"37\":1}}],[\"时间戳\",{\"1\":{\"35\":1,\"37\":1,\"271\":1,\"302\":1}}],[\"随之也带来了很多的问题\",{\"1\":{\"1370\":1}}],[\"随时查阅即可\",{\"1\":{\"975\":1}}],[\"随时可以提交事务\",{\"1\":{\"89\":1}}],[\"随处运行\",{\"1\":{\"515\":1}}],[\"随机生成一个\",{\"1\":{\"1141\":1}}],[\"随机数落到对应的区间\",{\"1\":{\"1141\":1}}],[\"随机调用\",{\"1\":{\"1140\":1}}],[\"随机传播特性\",{\"1\":{\"1084\":1}}],[\"随机排序\",{\"1\":{\"696\":1}}],[\"随机点名等等\",{\"1\":{\"259\":1}}],[\"随机点名等场景\",{\"1\":{\"190\":1}}],[\"随机获取集合中的元素\",{\"1\":{\"190\":1}}],[\"随机获取集合中的元素并移除\",{\"1\":{\"190\":1}}],[\"随机获取指定集合中指定数量的元素\",{\"1\":{\"189\":1,\"260\":1}}],[\"随机移除并获取指定集合中一个或多个元素\",{\"1\":{\"189\":1,\"260\":1}}],[\"随机或伪随机数\",{\"1\":{\"37\":1}}],[\"随后将情况返回给\",{\"1\":{\"1374\":1}}],[\"随后用户调用\",{\"1\":{\"1310\":1}}],[\"随后我们再将\",{\"1\":{\"710\":1}}],[\"随后\",{\"1\":{\"604\":1,\"686\":2,\"1220\":1}}],[\"随后的执行中\",{\"1\":{\"535\":1}}],[\"随后写数据\",{\"1\":{\"145\":1}}],[\"随后读数据\",{\"1\":{\"145\":1}}],[\"随着分布式和微服务系统的发展\",{\"1\":{\"1218\":1}}],[\"随着后续的发展\",{\"1\":{\"1191\":1}}],[\"随着系统的发展\",{\"1\":{\"1123\":1}}],[\"随着互联网的发展\",{\"1\":{\"1123\":1}}],[\"随着类的加载而加载\",{\"1\":{\"521\":2}}],[\"随着方法结束而销毁\",{\"1\":{\"493\":1}}],[\"随着线程的死亡而死亡\",{\"1\":{\"493\":1}}],[\"随着线程的创建而创建\",{\"1\":{\"493\":1}}],[\"随着线程的结束而死亡\",{\"1\":{\"492\":1}}],[\"随着线程的结束内存自然就被回收了\",{\"1\":{\"445\":1}}],[\"随着更多类的创建\",{\"1\":{\"480\":1,\"496\":1}}],[\"随着\",{\"1\":{\"157\":1,\"230\":1,\"244\":1,\"301\":1,\"495\":1,\"529\":1,\"651\":1}}],[\"随着数据的插入自增\",{\"1\":{\"106\":1}}],[\"随着使用人数越来越多\",{\"1\":{\"29\":1}}],[\"因其架构简单\",{\"1\":{\"1236\":1}}],[\"因其每次需要保存信息恢复信息\",{\"1\":{\"821\":1}}],[\"因为当客户端挂了\",{\"1\":{\"1388\":1}}],[\"因为当前线程的锁存在\",{\"1\":{\"56\":1}}],[\"因为创建节点的唯一性\",{\"1\":{\"1388\":1}}],[\"因为初始化所以\",{\"1\":{\"1380\":1}}],[\"因为网络原因\",{\"1\":{\"1379\":1}}],[\"因为网络原因没有收到\",{\"1\":{\"1379\":1}}],[\"因为只需要半数同意就行\",{\"1\":{\"1379\":1}}],[\"因为上述仅仅是超过半数的\",{\"1\":{\"1374\":1}}],[\"因为上面图中的四个角色都是需要做集群的\",{\"1\":{\"1281\":1}}],[\"因为事实上它只解决了各个事务的原子性问题\",{\"1\":{\"1370\":1}}],[\"因为整个班级有消息在进行传播\",{\"1\":{\"1368\":1}}],[\"因为整个过程是异步的\",{\"1\":{\"1304\":1}}],[\"因为小花已经知道这个消息了\",{\"1\":{\"1368\":1}}],[\"因为分区容忍性\",{\"1\":{\"1368\":1}}],[\"因为分布式应用必定涉及到各个系统之间的通信问题\",{\"1\":{\"1269\":1}}],[\"因为我认为加机器更加适用于构建集群\",{\"1\":{\"1367\":1}}],[\"因为我们一开始讲了在\",{\"1\":{\"1380\":1}}],[\"因为我们只有一个\",{\"1\":{\"1380\":1}}],[\"因为我们刚刚画的仅仅是一个消费者组\",{\"1\":{\"1280\":1}}],[\"因为我们是可以克隆的\",{\"1\":{\"553\":1}}],[\"因为少于等于一半是不可能产生\",{\"1\":{\"1358\":1}}],[\"因为有一个知识点因为写嗨了忘讲了\",{\"1\":{\"1315\":1}}],[\"因为两者就是不同的概念\",{\"1\":{\"1314\":1}}],[\"因为产生消息堆积的根源其实就只有两个\",{\"1\":{\"1305\":1}}],[\"因为其它消费者组也需要呀\",{\"1\":{\"1280\":1}}],[\"因为其生成规则包括\",{\"1\":{\"37\":1}}],[\"因为他不仅是消息队列的精华\",{\"1\":{\"1274\":1}}],[\"因为他们需要通知\",{\"1\":{\"753\":1}}],[\"因为是基于主从\",{\"1\":{\"1263\":1}}],[\"因为前面也说了\",{\"1\":{\"1232\":1}}],[\"因为用户请求数据写入消息队列之后就立即返回给用户了\",{\"1\":{\"1220\":1}}],[\"因为用户线程可能会不断的更新引用域\",{\"1\":{\"406\":1}}],[\"因为间隔太小的话重试的效果就不明显了\",{\"1\":{\"1204\":1}}],[\"因为字符串可以转成编码再变成\",{\"1\":{\"1159\":1}}],[\"因为每个日志包含相同的命令\",{\"1\":{\"1106\":1}}],[\"因为越随机的信源的熵越大\",{\"1\":{\"1087\":1}}],[\"因为密集型计算始终需要\",{\"1\":{\"1056\":1}}],[\"因为mdc是基于threadlocal去实现的\",{\"1\":{\"1047\":1}}],[\"因为key值是弱引用类型\",{\"1\":{\"1033\":1}}],[\"因为题目说的是在做\",{\"1\":{\"1030\":1}}],[\"因为线程\",{\"1\":{\"972\":1}}],[\"因为线程安全的问题\",{\"1\":{\"677\":1}}],[\"因为executor\",{\"1\":{\"940\":1}}],[\"因为不可能存在任务队列满的情况\",{\"1\":{\"951\":1}}],[\"因为不同的业务的并发以及对资源的使用情况都不同\",{\"1\":{\"919\":1}}],[\"因为不是有序的\",{\"1\":{\"96\":1}}],[\"因为获取写锁的时候\",{\"1\":{\"868\":1}}],[\"因为公平锁为了保证时间上的绝对顺序\",{\"1\":{\"858\":1}}],[\"因为访问静态\",{\"1\":{\"848\":1}}],[\"因为操作系统要防止一个线程或者进程长时间占用\",{\"1\":{\"821\":1}}],[\"因为同一进程中的线程极有可能会相互影响\",{\"1\":{\"810\":1}}],[\"因为对象的属性修改类型原子类都是抽象类\",{\"1\":{\"768\":1}}],[\"因为最开头if已经确保了p不是尾结点了\",{\"1\":{\"710\":1}}],[\"因为最开始\",{\"1\":{\"89\":1}}],[\"因为源码的判断是从链表初始元素开始遍历\",{\"1\":{\"708\":1}}],[\"因为内部使用双向链表维护各个节点\",{\"1\":{\"702\":1}}],[\"因为内存是有限的\",{\"1\":{\"270\":1}}],[\"因为红黑树在旋转的时候\",{\"1\":{\"688\":1}}],[\"因为多线程下使用\",{\"1\":{\"685\":1}}],[\"因为二叉查找树在某些情况下会退化成一个线性结构\",{\"1\":{\"683\":1}}],[\"因为除了\",{\"1\":{\"678\":1}}],[\"因为容量问题而导致操作失败后处理方式的不同\",{\"1\":{\"667\":1}}],[\"因为如果先获取keyset然后再执行map\",{\"1\":{\"625\":1}}],[\"因为毕竟扰动了\",{\"1\":{\"618\":1,\"682\":1}}],[\"因为所有成员变量在类加载时都已经初始完成了\",{\"1\":{\"602\":1}}],[\"因为程序仅仅移动一下而已\",{\"1\":{\"558\":1}}],[\"因为执行了\",{\"1\":{\"557\":1}}],[\"因为还是一个空的\",{\"1\":{\"557\":1}}],[\"因为还是可能存在定期删除和惰性删除漏掉了很多过期\",{\"1\":{\"272\":1}}],[\"因为该列表不保留对它的引用\",{\"1\":{\"553\":1}}],[\"因为要存放直接后继和直接前驱以及数据\",{\"1\":{\"552\":1,\"656\":1}}],[\"因为需要先移动到指定位置再插入和删除\",{\"1\":{\"552\":1,\"656\":1}}],[\"因为在不同的队列此时就无法使用\",{\"1\":{\"1299\":1}}],[\"因为在程序中\",{\"1\":{\"1184\":1}}],[\"因为在这段时间它的值可能被改为其他值\",{\"1\":{\"843\":1,\"992\":1}}],[\"因为在实际开发中\",{\"1\":{\"647\":1}}],[\"因为在实际开发过程中\",{\"1\":{\"503\":1}}],[\"因为在进行上述操作的时候集合中第\",{\"1\":{\"552\":1,\"656\":1}}],[\"因为会阻塞线程的缘故\",{\"1\":{\"533\":1}}],[\"因为阻塞期间可能会被打断\",{\"1\":{\"533\":1}}],[\"因为避免了在\",{\"1\":{\"499\":1}}],[\"因为大家其实也不会说一定要去深究到底\",{\"1\":{\"460\":1}}],[\"因为老年代的清理是使用\",{\"1\":{\"450\":1}}],[\"因为直到现在为止还没有最好的垃圾收集器出现\",{\"1\":{\"400\":1}}],[\"因为永久代被移除了\",{\"1\":{\"366\":2}}],[\"因为它真是只有加机器\",{\"1\":{\"1367\":1}}],[\"因为它没有匹配任何路由键\",{\"1\":{\"1252\":1}}],[\"因为它定制化程度更高\",{\"1\":{\"1159\":1}}],[\"因为它是一直需要用的数据\",{\"1\":{\"1012\":1}}],[\"因为它是无界队列\",{\"1\":{\"799\":1}}],[\"因为它只管连自己公司的服务器就\",{\"1\":{\"1155\":1}}],[\"因为它只需要在数组末尾添加一个元素即可\",{\"1\":{\"653\":1}}],[\"因为它只是为了说明返回的类型\",{\"1\":{\"633\":1}}],[\"因为它执行的时间不确定\",{\"1\":{\"446\":1}}],[\"因为它无法委托给子类加载器去尝试加载\",{\"1\":{\"359\":1}}],[\"因为它们只读取一次\",{\"1\":{\"120\":1}}],[\"因为volatile修饰符和transient修饰符不可以修饰方法\",{\"1\":{\"332\":1}}],[\"因为这里创建的threadlocal并没有指向任何值\",{\"1\":{\"1030\":1}}],[\"因为这里获取的\",{\"1\":{\"571\":1}}],[\"因为这时可能有其他线程进行了操作\",{\"1\":{\"571\":1}}],[\"因为这个功能还在持续完善优化中\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"因为这个方法的实现原理是先创建一个新的数组\",{\"1\":{\"588\":1}}],[\"因为这个这个定期任务线程是在\",{\"1\":{\"289\":1}}],[\"因为这个算是\",{\"1\":{\"267\":1}}],[\"因为这样可能会造成\",{\"1\":{\"145\":1}}],[\"因为可以把缓存中的数据持久化到磁盘上\",{\"1\":{\"245\":1}}],[\"因为时不时地创建一个\",{\"1\":{\"236\":1}}],[\"因为主节点上执行时\",{\"1\":{\"164\":1}}],[\"因为缓存的写入速度是比数据库的写入速度快很多\",{\"1\":{\"145\":1}}],[\"因为此时事务100和事务200还未提交\",{\"1\":{\"141\":1}}],[\"因为索引文件通常比数据文件小\",{\"1\":{\"120\":1}}],[\"因为仅有一行\",{\"1\":{\"120\":1}}],[\"因为b+树的这些好处\",{\"1\":{\"101\":1}}],[\"因为\",{\"1\":{\"47\":1,\"280\":1,\"344\":1,\"443\":1,\"444\":1,\"507\":1,\"677\":1,\"712\":1,\"713\":1,\"826\":1,\"848\":1,\"882\":1,\"1090\":1,\"1165\":2,\"1166\":1,\"1303\":1,\"1344\":1,\"1349\":1,\"1362\":1,\"1371\":1,\"1375\":1,\"1380\":2,\"1387\":1}}],[\"因此基于事件\",{\"1\":{\"1222\":1}}],[\"因此性能也会更好一些\",{\"1\":{\"1159\":1}}],[\"因此性能会有一点影响\",{\"1\":{\"1\":1}}],[\"因此它们需要有个统一的标准\",{\"1\":{\"1155\":1}}],[\"因此采用了一种最简单的\",{\"1\":{\"1132\":1}}],[\"因此共识算法的工作就是保持复制日志的一致性\",{\"1\":{\"1106\":1}}],[\"因此我们通过\",{\"1\":{\"1015\":1}}],[\"因此这些元素的内存地址一般来说是连续的\",{\"1\":{\"1184\":1}}],[\"因此这个时候变更\",{\"1\":{\"1013\":1}}],[\"因此这块变化\",{\"1\":{\"1013\":1}}],[\"因此这种策略会降低对于新任务提交速度\",{\"1\":{\"891\":1,\"936\":1}}],[\"因此执行了\",{\"1\":{\"1007\":1}}],[\"因此可以自由调整获取消息的频率\",{\"1\":{\"1293\":1}}],[\"因此可以看出\",{\"1\":{\"1007\":1}}],[\"因此可以保障原子性\",{\"1\":{\"978\":1}}],[\"因此可以作为任务直接被线程执行\",{\"1\":{\"900\":1}}],[\"因此长时间运行的任务可以延迟其他任务\",{\"1\":{\"962\":1}}],[\"因此线程池中的线程数不会超过\",{\"1\":{\"951\":1}}],[\"因此fixedthreadpool最多只能创建核心线程数的线程\",{\"1\":{\"897\":1}}],[\"因此返回\",{\"1\":{\"834\":1}}],[\"因此避免了死锁\",{\"1\":{\"824\":1}}],[\"因此程序不可能正常终止\",{\"1\":{\"823\":1}}],[\"因此进程是动态的\",{\"1\":{\"806\":1}}],[\"因此会根据锁类型不同\",{\"1\":{\"1007\":1}}],[\"因此会降低性能\",{\"1\":{\"897\":1}}],[\"因此会带来不可忽视的性能问题\",{\"1\":{\"792\":1}}],[\"因此会由\",{\"1\":{\"359\":1}}],[\"因此下次访问该元素时\",{\"1\":{\"717\":1}}],[\"因此时间复杂度为\",{\"1\":{\"653\":1,\"654\":2,\"725\":2}}],[\"因此时间复杂度是\",{\"1\":{\"653\":2}}],[\"因此size\",{\"1\":{\"590\":1}}],[\"因此在某些情况下还是可能会存在读取到旧数据的情况\",{\"1\":{\"1069\":1}}],[\"因此在使用\",{\"1\":{\"924\":1}}],[\"因此在\",{\"1\":{\"895\":1,\"922\":1}}],[\"因此在对跳表进行遍历时\",{\"1\":{\"800\":1}}],[\"因此在迭代遍历生成的迭代器的时候\",{\"1\":{\"713\":1}}],[\"因此在读取操作时不需要进行同步控制和锁操作\",{\"1\":{\"589\":1}}],[\"因此在实际应用中这个方法的性能表现比较优秀\",{\"1\":{\"588\":1}}],[\"因此在实际的业务场景中\",{\"1\":{\"18\":1}}],[\"因此其时间复杂度与数组长度成正比\",{\"1\":{\"588\":1}}],[\"因此多个调用者只是读取操作时可以共享同一份资源\",{\"1\":{\"585\":1}}],[\"因此尽可能将对象分配在新生代是明智的做法\",{\"1\":{\"479\":1}}],[\"因此垃圾收集器所关注的都是堆和方法这部分内存\",{\"1\":{\"445\":1}}],[\"因此不会进行消费重试\",{\"1\":{\"1292\":1}}],[\"因此不需要在每次发送消息时动态创建生产者\",{\"1\":{\"1290\":1}}],[\"因此不需要考虑垃圾回收的问题\",{\"1\":{\"445\":1}}],[\"因此不建议使用\",{\"1\":{\"1183\":1}}],[\"因此不断有人尝试简化这一算法\",{\"1\":{\"1097\":1}}],[\"因此不一定会很快发现那些只具有弱引用的对象\",{\"1\":{\"392\":1,\"884\":1}}],[\"因此效率也不高\",{\"1\":{\"398\":1}}],[\"因此为需要被回收的对象\",{\"1\":{\"391\":1}}],[\"因此也不会进行消费重试\",{\"1\":{\"1292\":1}}],[\"因此也是必须要从后往前遍历才能够遍历完全部的\",{\"1\":{\"1014\":1}}],[\"因此也是可见的\",{\"1\":{\"141\":1}}],[\"因此也被称作\",{\"1\":{\"382\":1,\"495\":1}}],[\"因此他一开始就具备了插件扩展功能的特性\",{\"1\":{\"377\":1}}],[\"因此他对应用程序的实际性能的影响很小\",{\"1\":{\"377\":1}}],[\"因此输出结果为\",{\"1\":{\"353\":1}}],[\"因此被称为类变量\",{\"1\":{\"342\":1}}],[\"因此是非常灵活的\",{\"1\":{\"340\":1}}],[\"因此是不可见的\",{\"1\":{\"141\":1}}],[\"因此除了\",{\"1\":{\"330\":1}}],[\"因此禁止长时间开启\",{\"1\":{\"298\":1}}],[\"因此需要决定electiontimeout的时间\",{\"1\":{\"1116\":1}}],[\"因此需要移动平均\",{\"1\":{\"653\":1,\"654\":1,\"725\":1,\"729\":1}}],[\"因此需要谨慎使用\",{\"1\":{\"298\":1}}],[\"因此需要对\",{\"1\":{\"86\":1}}],[\"因此一般情况下并不建议开启\",{\"1\":{\"267\":1}}],[\"因此读写速度非常快\",{\"1\":{\"242\":1}}],[\"因此添加失败\",{\"1\":{\"189\":1}}],[\"因此此条数据是可见的\",{\"1\":{\"141\":1}}],[\"因此假如由于系统错误或者rollback操作而回滚的话可以根据undo\",{\"1\":{\"138\":1}}],[\"因此称为是不可重复读\",{\"1\":{\"128\":1}}],[\"因此\",{\"1\":{\"89\":1,\"117\":1,\"168\":1,\"205\":1,\"234\":1,\"244\":1,\"251\":2,\"267\":1,\"279\":1,\"281\":1,\"282\":1,\"283\":1,\"297\":1,\"324\":1,\"359\":1,\"507\":1,\"553\":1,\"584\":1,\"588\":1,\"590\":1,\"671\":1,\"706\":1,\"716\":1,\"719\":1,\"740\":1,\"765\":1,\"784\":1,\"793\":1,\"819\":1,\"840\":1,\"841\":1,\"847\":1,\"866\":1,\"895\":1,\"903\":1,\"922\":1,\"925\":1,\"989\":1,\"990\":1,\"1062\":1,\"1066\":1,\"1067\":1,\"1068\":1,\"1069\":1,\"1074\":2,\"1078\":1,\"1090\":1,\"1096\":1,\"1104\":1,\"1106\":2,\"1132\":1,\"1142\":1,\"1179\":1,\"1209\":1,\"1220\":1,\"1285\":1,\"1297\":2,\"1353\":1,\"1355\":1}}],[\"因此认为可以继续执行抢购流程\",{\"1\":{\"60\":2}}],[\"因此要求订单号的位数适中\",{\"1\":{\"18\":1}}],[\"去做一些典型的应用场景呢\",{\"1\":{\"1381\":1}}],[\"去做服务发现的组件\",{\"1\":{\"1157\":1}}],[\"去中心化\",{\"1\":{\"1281\":1}}],[\"去中心化的\",{\"1\":{\"1090\":1}}],[\"去查询相关的\",{\"1\":{\"1281\":1}}],[\"去看一下有哪些文件夹和\",{\"1\":{\"1199\":1}}],[\"去看看维基百科对于\",{\"1\":{\"37\":1}}],[\"去执行对应的方法然后返回结果给客户端的类\",{\"1\":{\"1166\":1}}],[\"去解析得到它背后的\",{\"1\":{\"1157\":1}}],[\"去创建\",{\"1\":{\"889\":1,\"937\":1}}],[\"去继承\",{\"1\":{\"708\":1}}],[\"去重代码示例\",{\"1\":{\"632\":2}}],[\"去加载\",{\"1\":{\"358\":1}}],[\"去编译成\",{\"1\":{\"8\":1}}],[\"快捷地查看多个\",{\"1\":{\"377\":1}}],[\"快速判断第一个节点table\",{\"1\":{\"622\":1}}],[\"快速随机访问就是通过元素的序号快速获取元素对象\",{\"1\":{\"552\":1,\"656\":1}}],[\"快速随机访问\",{\"1\":{\"549\":1,\"586\":1}}],[\"快速加载同时避免丢失过多的数据\",{\"1\":{\"235\":1}}],[\"快速列表\",{\"1\":{\"174\":1}}],[\"快速接入\",{\"1\":{\"30\":1}}],[\"快照可以进行数据库备份\",{\"1\":{\"236\":1}}],[\"快照持久化是\",{\"1\":{\"226\":1}}],[\"快照文件用的工具\",{\"1\":{\"164\":2,\"293\":2}}],[\"快照文件的话\",{\"1\":{\"158\":1}}],[\"快照文件\",{\"1\":{\"158\":1,\"227\":1}}],[\"快照\",{\"0\":{\"158\":1},\"1\":{\"35\":1,\"224\":1,\"282\":1}}],[\"你总得保证两边的数据需要一致吧\",{\"1\":{\"1369\":1}}],[\"你总能获取到最靠谱的信息\",{\"1\":{\"174\":1}}],[\"你想想为什么我们要创建临时节点\",{\"1\":{\"1387\":1}}],[\"你想想\",{\"1\":{\"1369\":1}}],[\"你想一下\",{\"1\":{\"1280\":1}}],[\"你想一想嘛\",{\"1\":{\"1126\":1}}],[\"你抓到一个同学问他们的情况\",{\"1\":{\"1368\":1}}],[\"你首先需要将业务进行拆分\",{\"1\":{\"1367\":1}}],[\"你一个分布式系统必定涉及到多个机器\",{\"1\":{\"1367\":1}}],[\"你一定也注意到每个\",{\"1\":{\"1196\":1}}],[\"你能回答到什么地步呢\",{\"1\":{\"1341\":1}}],[\"你运行上面的代码会报错\",{\"1\":{\"1335\":1}}],[\"你在使用的\",{\"1\":{\"1335\":1}}],[\"你有没有好奇\",{\"1\":{\"1312\":1}}],[\"你还需要注意的是\",{\"1\":{\"1304\":1}}],[\"你还用啥\",{\"1\":{\"1299\":1}}],[\"你还可以进行\",{\"1\":{\"779\":1}}],[\"你还可以\",{\"1\":{\"631\":1}}],[\"你还可以通过\",{\"1\":{\"479\":1,\"780\":1}}],[\"你还可以通过下面这个命令\",{\"1\":{\"219\":1}}],[\"你上面也没有讲到呀\",{\"1\":{\"1280\":1}}],[\"你现在又讲\",{\"1\":{\"1276\":1}}],[\"你现在维护着一个身份证信息和姓名的表\",{\"1\":{\"96\":1}}],[\"你个混蛋\",{\"1\":{\"1276\":1}}],[\"你那积分系统给我加了积分\",{\"1\":{\"1275\":1}}],[\"你敢说每次发送验证码的时候是一发你就收到了的么\",{\"1\":{\"1273\":1}}],[\"你又提出了一个概念\",{\"1\":{\"1271\":1}}],[\"你只要知道\",{\"1\":{\"1276\":1}}],[\"你只能手动写程序把那\",{\"1\":{\"1264\":1}}],[\"你只需要部分锁即可\",{\"1\":{\"800\":1}}],[\"你任何一个机器宕机了\",{\"1\":{\"1263\":1}}],[\"你消费的时候\",{\"1\":{\"1263\":1}}],[\"你创建的\",{\"1\":{\"1263\":2}}],[\"你可能听得一头雾水\",{\"1\":{\"1386\":1}}],[\"你可能对\",{\"1\":{\"1315\":1}}],[\"你可能会发现一个问题\",{\"1\":{\"1281\":1}}],[\"你可能会好奇这个\",{\"1\":{\"1280\":1}}],[\"你可能会反驳我\",{\"1\":{\"1271\":1}}],[\"你可能觉得很弱智\",{\"1\":{\"1277\":1}}],[\"你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念\",{\"1\":{\"1217\":1}}],[\"你可以让\",{\"1\":{\"1388\":1}}],[\"你可以理解为第一阶段为试探\",{\"1\":{\"1374\":1}}],[\"你可以理解为其他副本只是\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"你可以看到\",{\"1\":{\"1371\":1}}],[\"你可以看到图中生产者组中的生产者会向主题发送消息\",{\"1\":{\"1280\":1}}],[\"你可以先创建父节点\",{\"1\":{\"1335\":1}}],[\"你可以先对每个组件的名字有个印象\",{\"1\":{\"83\":1}}],[\"你可以大概理解为\",{\"1\":{\"1315\":1}}],[\"你可以设置\",{\"1\":{\"1313\":1}}],[\"你可以设想下\",{\"1\":{\"96\":1}}],[\"你可以试想一下\",{\"1\":{\"1304\":1}}],[\"你可以很明显地看出\",{\"1\":{\"1281\":1}}],[\"你可以完全控制创建的线程\",{\"1\":{\"962\":1}}],[\"你可以选择这个策略\",{\"1\":{\"891\":1,\"936\":1}}],[\"你可以把反熵中的熵了解为节点之间数据的混乱程度\",{\"1\":{\"1087\":1}}],[\"你可以把多个变量放在一个对象里来进行\",{\"1\":{\"845\":1,\"994\":1}}],[\"你可以把\",{\"1\":{\"777\":1,\"971\":1,\"981\":1,\"1182\":1}}],[\"你可以通过下面两种方式创建持久化的节点\",{\"1\":{\"1335\":1}}],[\"你可以通过下面的参数启动\",{\"1\":{\"408\":1}}],[\"你可以通过一些手段来检测线程池的运行状态比如\",{\"1\":{\"918\":1}}],[\"你可以通过\",{\"1\":{\"777\":1,\"780\":1,\"782\":1}}],[\"你可以通过watch\",{\"1\":{\"280\":1}}],[\"你可以使用lists类及其newarraylist\",{\"1\":{\"634\":1}}],[\"你可以使用immutablelist类及其of\",{\"1\":{\"634\":1}}],[\"你可以使用\",{\"1\":{\"327\":1,\"496\":1,\"781\":1,\"1303\":1}}],[\"你可以更直观看到\",{\"1\":{\"325\":1}}],[\"你可以自己本机安装\",{\"1\":{\"242\":1}}],[\"你可以轻松地导出\",{\"1\":{\"236\":1}}],[\"你可以对照着参考一下\",{\"1\":{\"1373\":1}}],[\"你可以对\",{\"1\":{\"210\":1}}],[\"你可以将其理解为生产消费者模型中的消费者\",{\"1\":{\"1182\":1}}],[\"你可以将其看作是一种设计模式\",{\"1\":{\"773\":1,\"899\":1}}],[\"你可以将代码替换成\",{\"1\":{\"679\":1}}],[\"你可以将碎片率过高的主节点转换为从节点\",{\"1\":{\"220\":1}}],[\"你可以将内存碎片简单地理解为那些不可用的空闲内存\",{\"1\":{\"217\":1}}],[\"你可以将\",{\"1\":{\"201\":1,\"212\":1,\"261\":1,\"279\":1,\"283\":1,\"748\":1,\"906\":1,\"929\":1}}],[\"你可以直接修改这个对象中的某些字段的值\",{\"1\":{\"184\":1,\"195\":1}}],[\"你可以基于\",{\"1\":{\"181\":1,\"188\":1}}],[\"你可以在官方文档中找到\",{\"1\":{\"1131\":1}}],[\"你可以在控制台输入jconsole命令启动或者在\",{\"1\":{\"372\":1}}],[\"你可以在\",{\"1\":{\"174\":1}}],[\"你可以想象一下一棵\",{\"1\":{\"98\":1}}],[\"你可以参考这篇文章\",{\"1\":{\"43\":1}}],[\"你可以从使用主从模式来提高可用性\",{\"1\":{\"34\":1}}],[\"你知道服务的域名\",{\"1\":{\"1157\":1}}],[\"你得知道\",{\"1\":{\"1157\":1}}],[\"你得先建立连接\",{\"1\":{\"1157\":1}}],[\"你需要注意的是\",{\"1\":{\"1272\":1}}],[\"你需要保证消息没有被重复消费\",{\"1\":{\"1224\":1}}],[\"你需要确保\",{\"1\":{\"1206\":1}}],[\"你需要在这个基础上加入一些\",{\"1\":{\"1152\":1}}],[\"你需要将前一个命令的结果给后续的命令使用\",{\"1\":{\"287\":1}}],[\"你根本不知道到哪个地方才算一条完整消息\",{\"1\":{\"1152\":1}}],[\"你压根不知道这玩意是干嘛的\",{\"1\":{\"1142\":1}}],[\"你自己实现一个序列化模块就好了啊\",{\"1\":{\"1132\":1}}],[\"你如果阅读过\",{\"1\":{\"1129\":1}}],[\"你们这些审稿人就是缺乏幽默细胞\",{\"1\":{\"1096\":1}}],[\"你们要的线上\",{\"1\":{\"412\":1,\"486\":1}}],[\"你传我我传他\",{\"1\":{\"1084\":1}}],[\"你要存放的数据就放在上面\",{\"1\":{\"1349\":1}}],[\"你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的\",{\"1\":{\"1303\":1}}],[\"你要的\",{\"1\":{\"982\":1}}],[\"你要给朋友小王转\",{\"1\":{\"124\":1}}],[\"你不用考虑消息丢失或者说\",{\"1\":{\"1224\":1}}],[\"你不需要了解底层原理\",{\"1\":{\"971\":1}}],[\"你不停地往堆内存里面丢数据\",{\"1\":{\"451\":1}}],[\"你硬是拉来了\",{\"1\":{\"895\":1,\"922\":1}}],[\"你本来一件事情只需要\",{\"1\":{\"895\":1,\"922\":1}}],[\"你通过这个三个方法也可以实现和volatile禁止重排序一样的效果\",{\"1\":{\"834\":1}}],[\"你将掌握最常用的\",{\"1\":{\"476\":1}}],[\"你会怎么做呢\",{\"1\":{\"1379\":1}}],[\"你会无数次看到这玩意\",{\"1\":{\"1129\":1}}],[\"你会得到一个有序的结果\",{\"1\":{\"800\":1}}],[\"你会需要一个全局锁来保证整个平衡树的线程安全\",{\"1\":{\"800\":1}}],[\"你会发现每次输出结果都小于\",{\"1\":{\"835\":1}}],[\"你会发现\",{\"1\":{\"386\":1,\"1272\":1}}],[\"你会先登陆数据库系统\",{\"1\":{\"84\":1}}],[\"你的\",{\"1\":{\"284\":1}}],[\"你也看到了上面并没有动态指定队列长度的方法\",{\"1\":{\"896\":1,\"923\":1}}],[\"你也自己可以指定返回的慢查询命令的数量\",{\"1\":{\"302\":1}}],[\"你也不需要担心线程安全问题\",{\"1\":{\"267\":1}}],[\"你也可以认为\",{\"1\":{\"569\":1}}],[\"你也可以直接通过\",{\"1\":{\"302\":1}}],[\"你也可以直接操作\",{\"1\":{\"236\":1}}],[\"你也可以通过\",{\"1\":{\"280\":1}}],[\"你也可以使用开源的\",{\"1\":{\"35\":1}}],[\"你完全可以选择市面上比较成熟的一些消息队列比如\",{\"1\":{\"251\":1}}],[\"你仅仅了解了上面这些内容的话是远远不够的\",{\"1\":{\"145\":1}}],[\"你这\",{\"1\":{\"124\":1}}],[\"你肯定不陌生\",{\"1\":{\"124\":1}}],[\"你已经知道了前缀索引规则\",{\"1\":{\"117\":1}}],[\"你就要一台服务器来处理该服务的请求\",{\"1\":{\"1139\":1}}],[\"你就可以将线程数设置为\",{\"1\":{\"895\":1,\"922\":1}}],[\"你就可以拥有更好的性能\",{\"1\":{\"800\":1}}],[\"你就可以对数据库进行操作了\",{\"1\":{\"84\":1}}],[\"你就需要保持这棵树是平衡二叉树\",{\"1\":{\"97\":1}}],[\"你就需要在交互对话里面输入密码\",{\"1\":{\"84\":1}}],[\"你应该先完成一个整体框架的构建\",{\"1\":{\"80\":1}}],[\"你或许在想\",{\"1\":{\"48\":1}}],[\"多于\",{\"1\":{\"1344\":2,\"1362\":2}}],[\"多打点饭哦\",{\"1\":{\"1271\":1}}],[\"多种协议\",{\"1\":{\"1246\":1}}],[\"多种消费模式和持久性模式等功能\",{\"1\":{\"1240\":1}}],[\"多种开箱即用的集群方案\",{\"1\":{\"242\":1}}],[\"多机房跨区域数据复制\",{\"1\":{\"1238\":1}}],[\"多语言客户端\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"多台服务器都可以处理这个请求\",{\"1\":{\"1139\":1}}],[\"多播\",{\"1\":{\"1090\":1}}],[\"多节点部署的情况下\",{\"1\":{\"1069\":1}}],[\"多级缓存和指令重排这类设计可能会导致程序运行出现一些问题\",{\"1\":{\"971\":1}}],[\"多次执行\",{\"1\":{\"972\":1}}],[\"多次调用\",{\"1\":{\"941\":1}}],[\"多次读同一数据\",{\"1\":{\"128\":1}}],[\"多余的空闲线程不会立即销毁\",{\"1\":{\"890\":1}}],[\"多余的空闲线程存活的最长时间\",{\"1\":{\"890\":1,\"936\":1}}],[\"多读场景\",{\"1\":{\"838\":1,\"987\":1}}],[\"多写场景\",{\"1\":{\"838\":1,\"987\":1}}],[\"多任务\",{\"1\":{\"820\":1}}],[\"多核时代多线程主要是为了提高进程利用多核\",{\"1\":{\"816\":1}}],[\"多核时代\",{\"1\":{\"816\":1}}],[\"多核\",{\"1\":{\"816\":1}}],[\"多核环境下的硬件优势\",{\"1\":{\"407\":1}}],[\"多对多\",{\"1\":{\"808\":1}}],[\"多对一\",{\"1\":{\"808\":1}}],[\"多了一个超时时间\",{\"1\":{\"774\":1}}],[\"多了两个没有必要的引用吗\",{\"1\":{\"708\":1}}],[\"多了两个没有必要的引用\",{\"1\":{\"708\":1}}],[\"多行\",{\"1\":{\"691\":2}}],[\"多实现\",{\"1\":{\"518\":1}}],[\"多态的实现过程\",{\"1\":{\"519\":1}}],[\"多态的实现\",{\"1\":{\"519\":1}}],[\"多态的底层实现是动态绑定\",{\"1\":{\"519\":1}}],[\"多态实现原理\",{\"0\":{\"519\":1}}],[\"多态\",{\"1\":{\"515\":1,\"518\":2}}],[\"多张表\",{\"1\":{\"412\":1}}],[\"多\",{\"1\":{\"384\":1}}],[\"多合一故障处理工具\",{\"0\":{\"377\":1}}],[\"多用组合少用继承\",{\"1\":{\"356\":1}}],[\"多线程下\",{\"1\":{\"972\":1}}],[\"多线程下无法正确判定键值对是否存在\",{\"1\":{\"693\":1}}],[\"多线程\",{\"1\":{\"913\":1,\"982\":1}}],[\"多线程编程中一般线程的个数都大于\",{\"1\":{\"895\":1,\"922\":1}}],[\"多线程面试问题\",{\"1\":{\"827\":1}}],[\"多线程环境使用原子类保证线程安全\",{\"1\":{\"764\":1}}],[\"多线程环境不使用原子类保证线程安全\",{\"1\":{\"764\":1}}],[\"多线程环境下使用\",{\"1\":{\"1286\":1}}],[\"多线程环境下\",{\"1\":{\"693\":1}}],[\"多线程访问容器里不同数据段的数据\",{\"1\":{\"688\":1,\"792\":1}}],[\"多线程操作导致死循环问题\",{\"0\":{\"685\":1},\"1\":{\"694\":1}}],[\"多线程网络模型全面揭秘\",{\"1\":{\"267\":1}}],[\"多线程连环\",{\"1\":{\"267\":1}}],[\"多线程就会存在死锁\",{\"1\":{\"266\":1}}],[\"多提一嘴\",{\"1\":{\"256\":1}}],[\"多路复用技术的使用让\",{\"1\":{\"265\":1}}],[\"多路复用程序\",{\"1\":{\"265\":2}}],[\"多路复用程序来监听多个套接字\",{\"1\":{\"265\":1}}],[\"多路复用\",{\"1\":{\"243\":1,\"265\":1}}],[\"多大的内存碎片率才是需要清理呢\",{\"1\":{\"219\":1}}],[\"多个消费者可以订阅同一队列\",{\"1\":{\"1255\":1}}],[\"多个消费者可以订阅同一个队列\",{\"1\":{\"1250\":1}}],[\"多个事件发生的顺序等等都可以是一个提案\",{\"1\":{\"1097\":1}}],[\"多个事务对同一个数据读取的结果是相同的\",{\"1\":{\"281\":1}}],[\"多个节点之间的网络本来是连通的\",{\"1\":{\"1067\":1}}],[\"多个虚拟线程挂载在一个平台线程上\",{\"1\":{\"1053\":1}}],[\"多个用户线程映射到多个内核线程\",{\"1\":{\"808\":1}}],[\"多个用户线程映射到一个内核线程\",{\"1\":{\"808\":1}}],[\"多个键值对可能会被分配到同一个桶\",{\"1\":{\"686\":1}}],[\"多个线程互不干扰\",{\"1\":{\"1028\":1}}],[\"多个线程共享进程的堆和方法区\",{\"1\":{\"810\":1}}],[\"多个线程同时被阻塞\",{\"1\":{\"823\":1}}],[\"多个线程同时被唤醒\",{\"1\":{\"753\":1}}],[\"多个线程同时访问时可能会导致数据混乱\",{\"1\":{\"818\":1}}],[\"多个线程同时对链表进行操作\",{\"1\":{\"685\":1}}],[\"多个线程在开始执行任务前首先\",{\"1\":{\"753\":1}}],[\"多个线程可以同时持有读锁\",{\"1\":{\"871\":1}}],[\"多个线程可以同时读取列表中的元素\",{\"1\":{\"589\":1}}],[\"多个线程可同时执行\",{\"1\":{\"743\":1}}],[\"多个线程对\",{\"1\":{\"631\":1,\"686\":1}}],[\"多个⼦类对同⼀⽅法的重写\",{\"1\":{\"518\":1}}],[\"多个\",{\"1\":{\"96\":1,\"265\":1,\"1196\":1,\"1206\":1,\"1231\":1,\"1237\":1,\"1246\":1}}],[\"多个玩家都可以输入兑换\",{\"1\":{\"19\":1}}],[\"多表查询的时候如何选择关联顺序等\",{\"1\":{\"87\":1}}],[\"多重锁\",{\"1\":{\"50\":1}}],[\"多一些\",{\"1\":{\"35\":1}}],[\"结论是基于零拷贝技术\",{\"1\":{\"1311\":1}}],[\"结点数量达到阈值\",{\"1\":{\"622\":1}}],[\"结尾的字符数组\",{\"1\":{\"256\":1}}],[\"结构清晰\",{\"1\":{\"1173\":1}}],[\"结构里也特别明显\",{\"1\":{\"1159\":1}}],[\"结构体数据\",{\"1\":{\"1159\":1}}],[\"结构性修改\",{\"1\":{\"622\":1}}],[\"结构也由\",{\"1\":{\"579\":1}}],[\"结构\",{\"1\":{\"332\":1}}],[\"结构实现\",{\"1\":{\"243\":1}}],[\"结构非常详细的介绍\",{\"1\":{\"174\":1}}],[\"结合公平锁和非公平锁的加锁流程\",{\"1\":{\"1002\":1}}],[\"结合使用\",{\"1\":{\"634\":1}}],[\"结合在一起使用也就是\",{\"1\":{\"618\":1,\"682\":1}}],[\"结合上面的源码\",{\"1\":{\"357\":1}}],[\"结合\",{\"1\":{\"233\":1,\"1316\":1}}],[\"结合数据库号段模式的优缺点和\",{\"1\":{\"42\":1}}],[\"结合二维码绑定的商品信息\",{\"1\":{\"17\":1}}],[\"结果自己挂掉了\",{\"1\":{\"1205\":1}}],[\"结果如下\",{\"1\":{\"1030\":1}}],[\"结果数据库上也没有查到对应的数据\",{\"1\":{\"306\":1}}],[\"结果为真或假\",{\"1\":{\"70\":1}}],[\"结果\",{\"1\":{\"34\":2,\"293\":1,\"561\":1,\"562\":1}}],[\"=0\",{\"1\":{\"1290\":1}}],[\"=线程运行总时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"=>\",{\"1\":{\"621\":1}}],[\"=99\",{\"1\":{\"561\":1}}],[\"=系统表\",{\"1\":{\"120\":1}}],[\"=2\",{\"1\":{\"99\":1}}],[\"=========================\",{\"1\":{\"918\":2}}],[\"===================================================\",{\"1\":{\"370\":1}}],[\"=============================\",{\"1\":{\"370\":1}}],[\"==null\",{\"1\":{\"632\":1,\"680\":1}}],[\"==0\",{\"1\":{\"629\":1}}],[\"==\",{\"1\":{\"47\":1,\"49\":1,\"307\":2,\"353\":1,\"357\":2,\"531\":1,\"534\":1,\"535\":4,\"536\":2,\"537\":2,\"538\":2,\"553\":10,\"555\":1,\"557\":1,\"571\":10,\"572\":1,\"573\":2,\"576\":4,\"577\":12,\"578\":4,\"587\":1,\"591\":1,\"603\":1,\"604\":4,\"618\":1,\"619\":2,\"621\":1,\"622\":13,\"623\":5,\"624\":6,\"630\":3,\"631\":1,\"632\":1,\"682\":1,\"683\":5,\"686\":1,\"710\":3,\"711\":4,\"712\":1,\"713\":4,\"729\":3,\"730\":3,\"731\":6,\"732\":3,\"752\":5,\"756\":2,\"777\":1,\"834\":2,\"843\":4,\"871\":3,\"890\":3,\"900\":1,\"911\":2,\"936\":3,\"941\":8,\"992\":4,\"1007\":2,\"1011\":6,\"1012\":2,\"1013\":4,\"1014\":6,\"1015\":1,\"1018\":4,\"1020\":1,\"1036\":17,\"1037\":2,\"1038\":2,\"1041\":3,\"1042\":1,\"1043\":1,\"1142\":3,\"1210\":1,\"1213\":1}}],[\"=\",{\"1\":{\"34\":5,\"37\":2,\"38\":1,\"49\":6,\"53\":4,\"56\":11,\"106\":3,\"110\":1,\"135\":2,\"141\":1,\"218\":2,\"219\":1,\"307\":2,\"352\":1,\"353\":5,\"357\":7,\"359\":1,\"370\":2,\"384\":7,\"386\":4,\"390\":7,\"425\":1,\"429\":1,\"438\":2,\"451\":2,\"480\":1,\"495\":4,\"498\":2,\"531\":10,\"534\":9,\"535\":10,\"536\":5,\"537\":6,\"538\":6,\"551\":1,\"553\":56,\"555\":11,\"557\":1,\"558\":9,\"559\":1,\"561\":7,\"562\":6,\"564\":12,\"570\":20,\"571\":44,\"572\":33,\"573\":10,\"576\":9,\"577\":27,\"578\":15,\"587\":4,\"588\":5,\"591\":6,\"592\":3,\"593\":3,\"599\":5,\"601\":4,\"603\":2,\"604\":11,\"605\":1,\"618\":1,\"619\":20,\"621\":11,\"622\":30,\"623\":14,\"624\":40,\"625\":5,\"629\":7,\"630\":4,\"631\":2,\"632\":3,\"633\":1,\"634\":25,\"649\":6,\"652\":1,\"662\":1,\"663\":6,\"677\":4,\"679\":5,\"682\":1,\"683\":21,\"686\":3,\"688\":3,\"693\":1,\"704\":1,\"705\":1,\"706\":3,\"709\":4,\"710\":16,\"711\":14,\"712\":8,\"713\":27,\"727\":3,\"729\":11,\"730\":8,\"731\":19,\"732\":10,\"733\":3,\"742\":1,\"747\":3,\"748\":4,\"749\":5,\"752\":3,\"753\":6,\"756\":12,\"757\":10,\"763\":5,\"764\":2,\"765\":2,\"766\":7,\"767\":29,\"768\":6,\"777\":4,\"778\":2,\"779\":3,\"780\":4,\"781\":4,\"782\":7,\"784\":1,\"785\":2,\"797\":1,\"798\":3,\"807\":2,\"823\":2,\"834\":2,\"835\":7,\"837\":1,\"838\":1,\"841\":1,\"843\":1,\"857\":1,\"865\":3,\"871\":5,\"882\":26,\"883\":5,\"884\":1,\"890\":6,\"894\":6,\"895\":2,\"900\":4,\"904\":1,\"905\":3,\"909\":10,\"911\":12,\"918\":1,\"920\":6,\"922\":2,\"927\":1,\"928\":4,\"936\":6,\"940\":30,\"941\":23,\"944\":6,\"974\":3,\"986\":1,\"987\":1,\"990\":1,\"992\":1,\"1001\":2,\"1007\":3,\"1011\":31,\"1012\":13,\"1013\":17,\"1014\":30,\"1015\":6,\"1018\":2,\"1020\":7,\"1028\":3,\"1030\":13,\"1031\":4,\"1032\":9,\"1035\":2,\"1036\":53,\"1037\":26,\"1038\":21,\"1041\":9,\"1042\":10,\"1043\":6,\"1046\":3,\"1047\":2,\"1058\":1,\"1059\":2,\"1060\":3,\"1061\":2,\"1062\":9,\"1141\":12,\"1142\":30,\"1151\":1,\"1154\":2,\"1204\":3,\"1206\":6,\"1209\":4,\"1210\":9,\"1211\":2,\"1213\":7,\"1256\":1,\"1271\":2,\"1290\":1,\"1293\":5,\"1299\":1,\"1310\":2,\"1311\":1,\"1327\":11,\"1329\":11,\"1330\":11,\"1333\":4,\"1338\":1,\"1349\":11}}],[\"先说一下结论\",{\"1\":{\"1357\":1}}],[\"先说结论\",{\"1\":{\"251\":1,\"687\":1,\"849\":1}}],[\"先进入\",{\"1\":{\"1322\":1}}],[\"先进先出\",{\"1\":{\"280\":1,\"667\":1}}],[\"先使用\",{\"1\":{\"1322\":1}}],[\"先将短时间高并发产生的事务消息存储在消息队列中\",{\"1\":{\"1221\":1}}],[\"先在所有的将军中选出一个大将军\",{\"1\":{\"1105\":1}}],[\"先介绍一个简化版拜占庭将军的例子来帮助理解共识算法\",{\"1\":{\"1105\":1}}],[\"先断开的是\",{\"1\":{\"1014\":1}}],[\"先复制一份数据到\",{\"1\":{\"968\":1}}],[\"先申请的线程先得到锁\",{\"1\":{\"858\":1}}],[\"先判断对象是否已经实例过\",{\"1\":{\"834\":1}}],[\"先判断用户发来的请求的值是否存在于布隆过滤器中\",{\"1\":{\"307\":1}}],[\"先带着大家简单理解一下跳表\",{\"1\":{\"800\":1}}],[\"先来回答第一个问题\",{\"1\":{\"708\":1}}],[\"先来看下\",{\"1\":{\"1005\":1}}],[\"先来看一下稍微官方点的解释\",{\"1\":{\"1139\":1}}],[\"先来看一下\",{\"1\":{\"641\":1}}],[\"先来看看逻辑比较复杂的阻塞式获取元素方法\",{\"1\":{\"604\":1}}],[\"先来看看\",{\"1\":{\"536\":1,\"713\":1}}],[\"先完成了插入操作\",{\"1\":{\"686\":1}}],[\"先遍历\",{\"1\":{\"622\":1}}],[\"先调用ensurecapacityinternal方法\",{\"1\":{\"557\":1}}],[\"先调用\",{\"1\":{\"553\":1,\"561\":1}}],[\"先看看第一个例子\",{\"1\":{\"531\":1}}],[\"先于对象的创建\",{\"1\":{\"521\":1}}],[\"先自己尝试加载这个类\",{\"1\":{\"359\":1}}],[\"先获取互斥锁\",{\"1\":{\"310\":1}}],[\"先从总体上来说\",{\"1\":{\"816\":1}}],[\"先从\",{\"0\":{\"555\":1},\"1\":{\"146\":1}}],[\"先从表中删除含有重复关键字值的冲突行\",{\"1\":{\"33\":1}}],[\"先查\",{\"1\":{\"146\":1}}],[\"先读数据\",{\"1\":{\"145\":1}}],[\"先把\",{\"1\":{\"145\":1}}],[\"先更新\",{\"1\":{\"145\":2}}],[\"先拿第5条数据做对比\",{\"1\":{\"141\":1}}],[\"先通过辅助索引找到主键索引\",{\"1\":{\"114\":1}}],[\"先通过辅助索引定位主键值\",{\"1\":{\"112\":1}}],[\"先写数据\",{\"1\":{\"145\":1}}],[\"先写\",{\"1\":{\"89\":2}}],[\"先经过第一层的\",{\"1\":{\"1003\":1}}],[\"先经过\",{\"1\":{\"69\":1}}],[\"先比较锁对应的\",{\"1\":{\"47\":1}}],[\"先插入一行数据\",{\"1\":{\"34\":1}}],[\"~pugh\",{\"1\":{\"982\":1}}],[\"~capacity\",{\"1\":{\"941\":1}}],[\"~\",{\"1\":{\"34\":1,\"391\":1,\"400\":1}}],[\"需求是用户在购买完之后能接收到购买完成的短信\",{\"1\":{\"1271\":1}}],[\"需求比较大的时候\",{\"1\":{\"34\":1}}],[\"需的最小容量大于初始化容量\",{\"1\":{\"621\":1}}],[\"需要让\",{\"1\":{\"1379\":1}}],[\"需要所有人都知道才可提供服务\",{\"1\":{\"1368\":1}}],[\"需要讲和理解的东西太多了\",{\"1\":{\"1361\":1}}],[\"需要异步化\",{\"1\":{\"1293\":1}}],[\"需要重新发起获取消息请求\",{\"1\":{\"1293\":1}}],[\"需要重新执行\",{\"1\":{\"972\":1}}],[\"需要主动调用\",{\"1\":{\"1293\":1}}],[\"需要主动获取消息\",{\"1\":{\"1293\":1}}],[\"需要频繁调用接口扫描\",{\"1\":{\"1285\":1}}],[\"需要在其上进行二次开发\",{\"1\":{\"1250\":1}}],[\"需要在消息队列的订单消费者进程真正处理完该订单之后\",{\"1\":{\"1220\":1}}],[\"需要一个\",{\"1\":{\"1249\":1}}],[\"需要一直等待么\",{\"1\":{\"1016\":1}}],[\"需要与交换器类型和绑定键\",{\"1\":{\"1249\":1}}],[\"需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合\",{\"1\":{\"1222\":1}}],[\"需要适当修改业务流程进行配合\",{\"1\":{\"1220\":1}}],[\"需要手动实现\",{\"1\":{\"1212\":1}}],[\"需要手动移动后面的元素\",{\"1\":{\"649\":1}}],[\"需要这些消息的消费者可以订阅这些\",{\"1\":{\"1196\":1}}],[\"需要通过网络编程才能传递方法调用所需要的参数\",{\"1\":{\"1165\":1}}],[\"需要通过异常处理的方式处理运行错误\",{\"1\":{\"524\":1}}],[\"需要跟服务端\",{\"1\":{\"1155\":1}}],[\"需要找到\",{\"1\":{\"1112\":1}}],[\"需要找客服进行协助\",{\"1\":{\"18\":1}}],[\"需要补充说明的一点是\",{\"1\":{\"1068\":1}}],[\"需要创建大量的平台线程异步处理才能达到虚拟线程的处理速度\",{\"1\":{\"1062\":1}}],[\"需要唤醒\",{\"1\":{\"1014\":1}}],[\"需要返回\",{\"1\":{\"1011\":1}}],[\"需要自定义消费速率\",{\"1\":{\"1293\":1}}],[\"需要自定义同步器实现\",{\"1\":{\"1007\":2}}],[\"需要自定义获取同步状态和释放状态的方式\",{\"1\":{\"1006\":1}}],[\"需要实现精准\",{\"1\":{\"1285\":1}}],[\"需要实现的方法如下\",{\"1\":{\"1007\":1}}],[\"需要实现接口\",{\"1\":{\"523\":1}}],[\"需要从工作线程中移除对应的worker\",{\"1\":{\"941\":1}}],[\"需要大约5秒钟来执行其任务\",{\"1\":{\"940\":1}}],[\"需要捕获并处理该异常\",{\"1\":{\"924\":1}}],[\"需要越少线程\",{\"1\":{\"895\":1,\"922\":1}}],[\"需要越多线程\",{\"1\":{\"895\":1,\"922\":1}}],[\"需要调用awaittermination方法进行同步等待\",{\"1\":{\"924\":1}}],[\"需要调用这个实例对象所属类的静态\",{\"1\":{\"848\":1}}],[\"需要调用第\",{\"1\":{\"709\":1}}],[\"需要别的线程调用同一个对象上的\",{\"1\":{\"825\":1}}],[\"需要占用大量的\",{\"1\":{\"819\":1}}],[\"需要添加超时时间\",{\"1\":{\"785\":1}}],[\"需要使用\",{\"1\":{\"767\":1,\"1257\":1}}],[\"需要使用其对应的包装类\",{\"1\":{\"649\":1}}],[\"需要加强线程池的基础知识\",{\"1\":{\"927\":1}}],[\"需要加锁\",{\"1\":{\"764\":1}}],[\"需要加载业务类的时候\",{\"1\":{\"359\":1}}],[\"需要同步的操作\",{\"1\":{\"837\":2,\"986\":2}}],[\"需要同步的线程数量\",{\"1\":{\"757\":2}}],[\"需要同时重写\",{\"1\":{\"664\":1}}],[\"需要维护双向链表的缘故\",{\"1\":{\"713\":1}}],[\"需要线程安全的集合类型时请考虑使用\",{\"1\":{\"695\":1,\"698\":1}}],[\"需要排序时选择\",{\"1\":{\"646\":1}}],[\"需要对\",{\"1\":{\"631\":1}}],[\"需要用到对象的属性修改类型原子类\",{\"1\":{\"768\":1}}],[\"需要用到\",{\"1\":{\"604\":1,\"656\":1,\"724\":1}}],[\"需要用到的时候就可以直接从\",{\"1\":{\"968\":1}}],[\"需要用到的时候\",{\"1\":{\"34\":1,\"37\":1}}],[\"需要目标数组\",{\"1\":{\"563\":1}}],[\"需要提前分配数组内存\",{\"1\":{\"542\":1,\"672\":1}}],[\"需要我们格外留意\",{\"1\":{\"534\":1}}],[\"需要我们根据具体的业务情况来进一步判断\",{\"1\":{\"293\":1}}],[\"需要拦截特定的方法\",{\"1\":{\"523\":1}}],[\"需要根据消费重试逻辑判断是否进行重试消费\",{\"1\":{\"1292\":2}}],[\"需要根据配置文件运行时动态加载不同的对象或类\",{\"1\":{\"523\":1}}],[\"需要根据身份证号查找对应的名字\",{\"1\":{\"96\":1}}],[\"需要由程序员自己管理内存\",{\"1\":{\"517\":1}}],[\"需要掌握\",{\"1\":{\"503\":2}}],[\"需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置\",{\"1\":{\"653\":1}}],[\"需要将目标位置之后的所有元素都向后移动一个位置\",{\"1\":{\"653\":1}}],[\"需要将需要执行的任务封装成延迟任务对象\",{\"1\":{\"609\":1}}],[\"需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用\",{\"1\":{\"493\":1}}],[\"需要将之前的操作都记录下来\",{\"1\":{\"137\":1}}],[\"需要要找到一个合适的\",{\"1\":{\"483\":1}}],[\"需要严格的测试\",{\"1\":{\"449\":1}}],[\"需要\",{\"1\":{\"412\":1,\"861\":1}}],[\"需要被回收\",{\"1\":{\"391\":1}}],[\"需要远程主机提供\",{\"1\":{\"366\":1}}],[\"需要继承\",{\"1\":{\"359\":1,\"708\":1}}],[\"需要查找类或资源时\",{\"1\":{\"356\":1}}],[\"需要触发其初始化\",{\"1\":{\"344\":1}}],[\"需要设置\",{\"1\":{\"1252\":1}}],[\"需要设置一个过期时间\",{\"1\":{\"307\":1}}],[\"需要设计一种有效的兑换码生成策略\",{\"1\":{\"19\":1}}],[\"需要单独对其进行优化\",{\"1\":{\"297\":1}}],[\"需要指定\",{\"1\":{\"293\":1}}],[\"需要服务端和客户端的共同实现\",{\"1\":{\"287\":1}}],[\"需要注意\",{\"1\":{\"454\":1,\"727\":1}}],[\"需要注意控制一次批量操作的\",{\"1\":{\"287\":1}}],[\"需要注意的是刚刚\",{\"1\":{\"1380\":1}}],[\"需要注意的是stampedlock不可重入\",{\"1\":{\"873\":1}}],[\"需要注意的是布隆过滤器可能会存在误判的情况\",{\"1\":{\"307\":1}}],[\"需要注意的是\",{\"1\":{\"96\":1,\"298\":1,\"387\":1,\"811\":1,\"1011\":1,\"1374\":1}}],[\"需要修改\",{\"1\":{\"267\":1}}],[\"需要减少字符串时\",{\"1\":{\"256\":1}}],[\"需要增加字符串时\",{\"1\":{\"256\":1}}],[\"需要依靠客户端来实现往集群中分片写入数据\",{\"1\":{\"245\":1}}],[\"需要定期对\",{\"1\":{\"230\":1}}],[\"需要定时断开\",{\"1\":{\"84\":1}}],[\"需要管理使用地理空间数据的场景\",{\"1\":{\"211\":1}}],[\"需要保存状态信息\",{\"1\":{\"203\":1}}],[\"需要保证自己存储全部已经提交的日志条目\",{\"1\":{\"1114\":1}}],[\"需要保证元素唯一时选择实现\",{\"1\":{\"646\":1}}],[\"需要保证线程安全就选用\",{\"1\":{\"646\":1}}],[\"需要保证\",{\"1\":{\"42\":1}}],[\"需要随机获取数据源中的元素根据某个权重进行排序的场景\",{\"1\":{\"194\":1}}],[\"需要随机获取数据源中的元素的场景\",{\"1\":{\"190\":1,\"259\":1}}],[\"需要获取多个数据源交集\",{\"1\":{\"190\":1,\"259\":1}}],[\"需要存储的数据有优先级或者重要程度的场景\",{\"1\":{\"194\":1}}],[\"需要存储常规数据的场景\",{\"1\":{\"178\":1}}],[\"需要存放的数据不能重复的场景\",{\"1\":{\"190\":1}}],[\"需要计数的场景\",{\"1\":{\"178\":1}}],[\"需要进行调用的时候会\",{\"1\":{\"1390\":1}}],[\"需要进行初始化一个头结点出来\",{\"1\":{\"1011\":1}}],[\"需要进行数据迁移\",{\"1\":{\"167\":1}}],[\"需要进行分库分表\",{\"1\":{\"29\":1}}],[\"需要人工介入\",{\"1\":{\"167\":1}}],[\"需要等待锁释放\",{\"1\":{\"820\":1}}],[\"需要等待\",{\"1\":{\"161\":1,\"819\":1}}],[\"需要回表\",{\"1\":{\"117\":1}}],[\"需要扫码两遍索引树\",{\"1\":{\"112\":1}}],[\"需要额外开辟空间和数据维护工作\",{\"1\":{\"94\":1}}],[\"需要额外的基础设施保障做高可用\",{\"1\":{\"10\":1}}],[\"需要先从\",{\"1\":{\"1281\":1}}],[\"需要先从磁盘读入内存\",{\"1\":{\"89\":1}}],[\"需要先遍历链表找到该节点\",{\"1\":{\"654\":1}}],[\"需要先移动到指定位置\",{\"1\":{\"654\":1,\"725\":1}}],[\"需要先根据\",{\"1\":{\"286\":1}}],[\"需要先知道你要做什么\",{\"1\":{\"86\":1}}],[\"需要尽量避免重启\",{\"1\":{\"72\":1}}],[\"需要判断占有该锁的线程和请求获取锁的线程是否为同一个\",{\"1\":{\"50\":1}}],[\"需要才会执行续期\",{\"1\":{\"49\":1}}],[\"需要解决重复\",{\"1\":{\"35\":1,\"37\":1,\"38\":1}}],[\"需要满足下面这些要求\",{\"1\":{\"30\":1}}],[\"需要满足哪些要求\",{\"0\":{\"30\":1}}],[\"需要具备接入层的服务器实例自主生成的能力\",{\"1\":{\"22\":1}}],[\"优势\",{\"1\":{\"1090\":1}}],[\"优势在于范围查找\",{\"1\":{\"103\":1}}],[\"优先执行\",{\"1\":{\"757\":4}}],[\"优先选择回收价值最大的\",{\"1\":{\"407\":1}}],[\"优先级显得没有意义\",{\"1\":{\"1258\":1}}],[\"优先级高的队列会先被消费\",{\"1\":{\"1258\":1}}],[\"优先级阻塞队列\",{\"1\":{\"897\":1}}],[\"优先级任务队列\",{\"1\":{\"194\":1}}],[\"优先级\",{\"1\":{\"168\":1}}],[\"优秀的地方\",{\"1\":{\"236\":2}}],[\"优化数据桶的位置等操作\",{\"1\":{\"1039\":1}}],[\"优化\",{\"1\":{\"486\":1,\"633\":1}}],[\"优化热点\",{\"1\":{\"299\":1}}],[\"优化改进得来\",{\"1\":{\"205\":1}}],[\"优化器的作用就是它认为的最优的执行方案去执行\",{\"1\":{\"87\":1}}],[\"优化器\",{\"0\":{\"87\":1},\"1\":{\"81\":1,\"82\":1,\"90\":1}}],[\"优点\",{\"0\":{\"1055\":1},\"1\":{\"33\":1,\"34\":1,\"35\":2,\"37\":1,\"38\":1}}],[\"优惠方案的空间范围决定了可以组织的优惠活动次数\",{\"1\":{\"19\":1}}],[\"优惠方案\",{\"1\":{\"19\":2}}],[\"优惠编码兑换奖品\",{\"1\":{\"19\":1}}],[\"优惠券体量大\",{\"1\":{\"19\":1}}],[\"优惠券\",{\"1\":{\"19\":2}}],[\"优惠券和兑换券\",{\"0\":{\"19\":1}}],[\"第四章第一节\",{\"1\":{\"1343\":1}}],[\"第四\",{\"1\":{\"1281\":1}}],[\"第四阶段调用成员变量的waitfor方法\",{\"1\":{\"1183\":1}}],[\"第四种情况\",{\"1\":{\"1035\":1}}],[\"第三\",{\"1\":{\"1281\":1}}],[\"第三阶段执行\",{\"1\":{\"1183\":1}}],[\"第三阶段睡眠执行时间\",{\"1\":{\"1183\":1}}],[\"第三种情况\",{\"1\":{\"1035\":1}}],[\"第三章\",{\"1\":{\"982\":1}}],[\"第三章对于空间分配担保的描述如下\",{\"1\":{\"388\":1}}],[\"第三版中被改正过来了\",{\"1\":{\"387\":1}}],[\"第三方包中的\",{\"1\":{\"341\":1}}],[\"第三方微服务路由规则\",{\"1\":{\"75\":1}}],[\"第三方生成支付订单推给用户设备\",{\"1\":{\"17\":1}}],[\"第三方模块以及大多数的依赖项\",{\"1\":{\"6\":1}}],[\"第5条数据事务id为300\",{\"1\":{\"141\":1}}],[\"第二则是当\",{\"1\":{\"1380\":1}}],[\"第二\",{\"1\":{\"1281\":1}}],[\"第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作\",{\"1\":{\"1370\":1}}],[\"第二阶段\",{\"1\":{\"1370\":1}}],[\"第二阶段自旋指定时间\",{\"1\":{\"1183\":1}}],[\"第二阶段执行\",{\"1\":{\"1183\":2}}],[\"第二种情况\",{\"1\":{\"1035\":1,\"1040\":1}}],[\"第二种代表我们只能使用两个参数版的\",{\"1\":{\"661\":1}}],[\"第二个文件为\",{\"1\":{\"1315\":1}}],[\"第二个性质需要一致性检查来进行保证\",{\"1\":{\"1112\":1}}],[\"第二个构造方法可以指定是公平模式还是非公平模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"第二个\",{\"1\":{\"572\":1}}],[\"第二个日志还没有写完期间发生了\",{\"1\":{\"89\":1}}],[\"第二大影响因素是为\",{\"1\":{\"479\":1}}],[\"第二次不会再调用\",{\"1\":{\"446\":1}}],[\"第二次没有插入过查出来却多了100条记录\",{\"1\":{\"129\":1}}],[\"第二版\",{\"1\":{\"409\":1,\"511\":1,\"680\":1}}],[\"第二版中\",{\"1\":{\"387\":1}}],[\"第二部分是\",{\"1\":{\"367\":1}}],[\"第二步\",{\"1\":{\"33\":1,\"86\":1,\"768\":1}}],[\"第一阶段\",{\"1\":{\"1370\":1}}],[\"第一阶段自旋指定次数\",{\"1\":{\"1183\":1}}],[\"第一阶段自旋\",{\"1\":{\"1183\":2}}],[\"第一\",{\"1\":{\"1263\":1,\"1281\":1}}],[\"第一次接触\",{\"1\":{\"1150\":1}}],[\"第一次获取锁的话\",{\"1\":{\"56\":1}}],[\"第一次获取锁的时候\",{\"1\":{\"56\":1}}],[\"第一种情况\",{\"1\":{\"1035\":1,\"1040\":1}}],[\"第一部分用于存储对象自身的运行时数据\",{\"1\":{\"507\":1}}],[\"第一部分是系统的属性\",{\"1\":{\"367\":1}}],[\"第一个是我们提到的\",{\"1\":{\"1380\":1}}],[\"第一个节点入队\",{\"1\":{\"1014\":1}}],[\"第一个节点为虚节点\",{\"1\":{\"1011\":1}}],[\"第一个节点储存的数据是什么\",{\"1\":{\"1011\":1}}],[\"第一个\",{\"1\":{\"558\":1}}],[\"第一个字是\",{\"1\":{\"117\":1}}],[\"第一个匹配成功\",{\"1\":{\"71\":1}}],[\"第一步肯定需要\",{\"1\":{\"1379\":1}}],[\"第一步是清空当前staleslot位置的数据\",{\"1\":{\"1037\":1}}],[\"第一步很好理解\",{\"1\":{\"1002\":1}}],[\"第一步\",{\"1\":{\"33\":1,\"84\":1,\"86\":1,\"768\":1}}],[\"第\",{\"1\":{\"38\":4,\"285\":1,\"327\":2,\"342\":2,\"496\":1,\"498\":1,\"531\":1,\"557\":1,\"558\":2,\"706\":2,\"1214\":1}}],[\"具有全局唯一性的\",{\"1\":{\"1373\":1}}],[\"具有不可分割性\",{\"1\":{\"1344\":1}}],[\"具有高性能\",{\"1\":{\"1276\":1}}],[\"具有强一致性\",{\"1\":{\"1238\":1}}],[\"具有最小的活跃数\",{\"1\":{\"1142\":1}}],[\"具有相同的最小活跃数\",{\"1\":{\"1142\":2}}],[\"具有可重入特性\",{\"1\":{\"1001\":1}}],[\"具有取消任务\",{\"1\":{\"900\":1}}],[\"具有指令重排的特性\",{\"1\":{\"834\":1}}],[\"具有双端队列的特性\",{\"1\":{\"727\":1}}],[\"具有内建算法等\",{\"1\":{\"647\":1}}],[\"具有四种类型的\",{\"1\":{\"482\":1}}],[\"具有较高的效率\",{\"1\":{\"97\":1}}],[\"具有以下特点\",{\"1\":{\"97\":1}}],[\"具有动态路由和插件热加载\",{\"1\":{\"8\":1}}],[\"具体怎么做呢\",{\"1\":{\"1388\":1}}],[\"具体怎么用呢\",{\"1\":{\"74\":1}}],[\"具体存储路径为\",{\"1\":{\"1315\":1}}],[\"具体原理图如下\",{\"1\":{\"1166\":1}}],[\"具体流程\",{\"1\":{\"1037\":1}}],[\"具体代码如下\",{\"1\":{\"1036\":1,\"1038\":1,\"1042\":1}}],[\"具体细节后面会讲到\",{\"1\":{\"1035\":1}}],[\"具体操作方式后面会讲到\",{\"1\":{\"1033\":1}}],[\"具体可见\",{\"1\":{\"1016\":1}}],[\"具体可以看下面这几篇文章\",{\"1\":{\"1361\":1}}],[\"具体可以阅读这篇文章\",{\"1\":{\"912\":1}}],[\"具体可以参考\",{\"1\":{\"693\":1,\"808\":1,\"1053\":1}}],[\"具体挂起流程用流程图表示如下\",{\"1\":{\"1012\":1}}],[\"具体两个方法下面细细分析\",{\"1\":{\"1012\":1}}],[\"具体实现可以参见这篇文章rocketmq\",{\"1\":{\"1292\":1}}],[\"具体实现如下\",{\"1\":{\"1045\":1}}],[\"具体实现\",{\"1\":{\"1038\":1}}],[\"具体实现方法如下\",{\"1\":{\"1011\":1}}],[\"具体实现思路如下\",{\"1\":{\"706\":1}}],[\"具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的\",{\"1\":{\"1008\":1}}],[\"具体每一处核心方法的作用会在文章后面详细进行阐述\",{\"1\":{\"1007\":1}}],[\"具体场景是下面这样的\",{\"1\":{\"909\":1}}],[\"具体还是要根据项目实际线上运行情况来动态调整\",{\"1\":{\"895\":1,\"922\":1}}],[\"具体方法可以使用版本号机制或\",{\"1\":{\"838\":1,\"987\":1}}],[\"具体方法是采用\",{\"1\":{\"233\":1}}],[\"具体的实现原理非常简单\",{\"1\":{\"1141\":1}}],[\"具体的计算方法是\",{\"1\":{\"895\":1,\"922\":1}}],[\"具体的源码可以参考\",{\"1\":{\"654\":1}}],[\"具体的规则由我们自己实现\",{\"1\":{\"359\":1}}],[\"具体的流程分析\",{\"1\":{\"69\":1}}],[\"具体点说是\",{\"1\":{\"341\":1}}],[\"具体是哪个服务提供者处理请求是由你的请求的参数决定的\",{\"1\":{\"1143\":1}}],[\"具体是哪个类加载器加载呢\",{\"1\":{\"356\":1}}],[\"具体是哪个类加载器加载由\",{\"1\":{\"340\":1}}],[\"具体是如何反熵的呢\",{\"1\":{\"1087\":1}}],[\"具体是否具体要进行移除\",{\"1\":{\"712\":1}}],[\"具体是这样做的\",{\"1\":{\"307\":1}}],[\"具体命令如下\",{\"1\":{\"307\":1}}],[\"具体来说是这样的\",{\"1\":{\"773\":1,\"899\":1}}],[\"具体来说会有数据覆盖的风险\",{\"1\":{\"686\":1}}],[\"具体来说\",{\"1\":{\"292\":1,\"788\":1,\"1078\":2}}],[\"具体值取决于写出的数据量和\",{\"1\":{\"230\":1}}],[\"具体什么时候清理需要通过下面两个参数控制\",{\"1\":{\"220\":1}}],[\"具体多大才算大呢\",{\"1\":{\"163\":1,\"291\":1}}],[\"具体步骤是这样的\",{\"1\":{\"33\":1}}],[\"具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用\",{\"1\":{\"1236\":1}}],[\"具备\",{\"1\":{\"49\":1}}],[\"插入顺序则为\",{\"1\":{\"705\":1}}],[\"插入顺序遍历\",{\"0\":{\"704\":1}}],[\"插入的数据被线程\",{\"1\":{\"686\":1}}],[\"插入的是链表尾部\",{\"1\":{\"622\":1}}],[\"插入时可能存在扩容过程\",{\"1\":{\"668\":1}}],[\"插入队列的对象必须是可比较大小的\",{\"1\":{\"799\":1}}],[\"插入队首\",{\"1\":{\"667\":1}}],[\"插入队尾\",{\"1\":{\"667\":2}}],[\"插入后回调\",{\"1\":{\"622\":1,\"686\":1}}],[\"插入元素相较于\",{\"1\":{\"713\":1}}],[\"插入元素到\",{\"1\":{\"588\":1}}],[\"插入元素\",{\"0\":{\"588\":1,\"729\":1}}],[\"插入\",{\"1\":{\"571\":1,\"694\":2}}],[\"插入第二个值时才会进行扩容\",{\"1\":{\"570\":1}}],[\"插入和删除元素的时间复杂度\",{\"0\":{\"653\":1,\"654\":1,\"725\":1}}],[\"插入和删除元素的话\",{\"1\":{\"552\":2,\"656\":2}}],[\"插入和删除是否受元素位置的影响\",{\"1\":{\"552\":1,\"656\":1}}],[\"插入和删除在平均和最坏情况下的时间复杂度都是\",{\"1\":{\"98\":1}}],[\"插入数据这里\",{\"1\":{\"33\":1}}],[\"插件依赖\",{\"1\":{\"1257\":1}}],[\"插件机制\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"插件模块可以扩展系统的功能\",{\"1\":{\"1132\":1}}],[\"插件模块\",{\"1\":{\"1132\":1}}],[\"插件开发教程\",{\"1\":{\"11\":1}}],[\"插件开发工具包\",{\"1\":{\"7\":1}}],[\"插件是\",{\"1\":{\"9\":1}}],[\"插件的详细介绍\",{\"1\":{\"7\":1}}],[\"插件编写规范\",{\"1\":{\"7\":1}}],[\"插件\",{\"1\":{\"7\":2,\"325\":1,\"1132\":1,\"1199\":1}}],[\"插件在\",{\"1\":{\"7\":1}}],[\"给自己投票为\",{\"1\":{\"1380\":1}}],[\"给出的上限是每个结点的数据大小最大是\",{\"1\":{\"1348\":1}}],[\"给我加个鸡腿\",{\"1\":{\"1271\":1}}],[\"给我解释一下双重检验锁方式实现单例模式的原理呗\",{\"1\":{\"834\":1}}],[\"给清理掉\",{\"1\":{\"1264\":1}}],[\"给多个消费者进行处理\",{\"1\":{\"1250\":1,\"1255\":1}}],[\"给每一个follower\",{\"1\":{\"1112\":1}}],[\"给线程池里的线程命名通常有下面两种方式\",{\"1\":{\"894\":1,\"920\":1}}],[\"给当前类加锁\",{\"1\":{\"848\":1}}],[\"给当前对象实例加锁\",{\"1\":{\"848\":1}}],[\"给节点\",{\"1\":{\"729\":1}}],[\"给定\",{\"1\":{\"848\":1}}],[\"给定对象的锁\",{\"1\":{\"848\":1}}],[\"给定的默认容量为\",{\"1\":{\"619\":1}}],[\"给定类的二进制名称\",{\"1\":{\"351\":1}}],[\"给该调用者\",{\"1\":{\"585\":1}}],[\"给对象添加一个引用计数器\",{\"1\":{\"445\":1}}],[\"给对象中添加一个引用计数器\",{\"1\":{\"390\":1}}],[\"给一个标记位\",{\"1\":{\"396\":1}}],[\"给缓存数据设置过期时间有啥用\",{\"0\":{\"270\":1}}],[\"给指定\",{\"1\":{\"177\":1}}],[\"给这个\",{\"1\":{\"48\":1}}],[\"给\",{\"1\":{\"33\":1,\"89\":1,\"289\":1,\"384\":1}}],[\"只在\",{\"1\":{\"1007\":1}}],[\"只用知道\",{\"1\":{\"807\":1}}],[\"只锁定当前链表或红黑二叉树的首节点\",{\"1\":{\"691\":1,\"692\":1}}],[\"只提供了\",{\"1\":{\"622\":1}}],[\"只提供了纯文本控制台环境的服务器上\",{\"1\":{\"366\":1}}],[\"只会放在一个\",{\"1\":{\"1263\":1}}],[\"只会传播节点新增的数据\",{\"1\":{\"1089\":1}}],[\"只会成功一次\",{\"1\":{\"571\":1}}],[\"只会唤醒注册在该condition实例中的所有等待线程\",{\"1\":{\"544\":1,\"862\":1}}],[\"只会在取出\",{\"1\":{\"272\":1}}],[\"只加载一次\",{\"1\":{\"521\":1}}],[\"只支持出栈和入栈两种操作\",{\"1\":{\"493\":1}}],[\"只支持最简单的\",{\"1\":{\"245\":1}}],[\"只负责\",{\"1\":{\"426\":1}}],[\"只不过不太建议\",{\"1\":{\"1280\":1}}],[\"只不过在解耦这个特定业务环境下是使用发布\",{\"1\":{\"1222\":1}}],[\"只不过这个节点上的数据可能并不是最新的\",{\"1\":{\"1069\":1}}],[\"只不过这种做法会使得使用\",{\"1\":{\"708\":1}}],[\"只不过\",{\"1\":{\"777\":1,\"1383\":1}}],[\"只不过队列满时只会阻塞单位为unit\",{\"1\":{\"533\":1}}],[\"只不过方法区的实现从永久代变成了元空间\",{\"1\":{\"393\":1}}],[\"只不过幻读是重点在插入和删除\",{\"1\":{\"130\":1}}],[\"只具有弱引用的对象拥有更短暂的生命周期\",{\"1\":{\"392\":1,\"884\":1}}],[\"只对应一个\",{\"1\":{\"1202\":2}}],[\"只对单个共享变量有效\",{\"1\":{\"845\":1,\"994\":1}}],[\"只对触发起作用\",{\"1\":{\"480\":1}}],[\"只对老年代进行垃圾收集\",{\"1\":{\"387\":1}}],[\"只对新生代进行垃圾收集\",{\"1\":{\"387\":1}}],[\"只输出进程的本地虚拟机唯一\",{\"1\":{\"365\":1}}],[\"只与类相关\",{\"1\":{\"342\":1}}],[\"只面向虚拟机\",{\"1\":{\"324\":1}}],[\"只保留最近\",{\"1\":{\"302\":1}}],[\"只保存一个商品\",{\"1\":{\"257\":1}}],[\"只使用主线程\",{\"1\":{\"267\":1}}],[\"只要半数以上节点存活\",{\"1\":{\"1362\":1}}],[\"只要在sessiontimeout规定的时间内能够重新连接上集群中任意一台服务器\",{\"1\":{\"1353\":1}}],[\"只要我们的系统没有崩溃就行了\",{\"1\":{\"1273\":1}}],[\"只要对该类消息感兴趣\",{\"1\":{\"1222\":1}}],[\"只要是有一个副本挂掉\",{\"1\":{\"1206\":1}}],[\"只要上下游都约定好了\",{\"1\":{\"1152\":1}}],[\"只要稍微对可靠性有些要求\",{\"1\":{\"1151\":1}}],[\"只要大多数服务器都是可操作的\",{\"1\":{\"1106\":1}}],[\"只要问到分布式相关的内容\",{\"1\":{\"1065\":1}}],[\"只要发生垃圾回收\",{\"1\":{\"1030\":1}}],[\"只要强引用存在\",{\"1\":{\"1030\":1}}],[\"只要不改变程序的执行结果\",{\"1\":{\"974\":1}}],[\"只要有一个节点得到超半数节点的票数\",{\"1\":{\"1356\":1}}],[\"只要有一个节点是可用的就行了\",{\"1\":{\"1069\":1}}],[\"只要有一个执行完成即可\",{\"1\":{\"782\":1}}],[\"只要有一个没有包含就直接返回false\",{\"1\":{\"592\":1}}],[\"只要哈希函数映射得比较均匀松散\",{\"1\":{\"684\":1}}],[\"只要程序运行结束\",{\"1\":{\"440\":1}}],[\"只要垃圾回收器没有回收它\",{\"1\":{\"392\":1}}],[\"只要加载它们的类加载器不同\",{\"1\":{\"357\":1}}],[\"只要想通一点就好了\",{\"1\":{\"345\":1}}],[\"只要知道这个方法在方法表中的偏移量就可以直接调用该方法了\",{\"1\":{\"343\":1}}],[\"只要\",{\"1\":{\"236\":1}}],[\"只要保证\",{\"1\":{\"51\":1}}],[\"只需重写第一层所需要的部分方法即可\",{\"1\":{\"1003\":1}}],[\"只需用两种锁的组合来对读写请求进行控制即可\",{\"1\":{\"140\":1}}],[\"只需要修改尾结点的指针即可完成插入\",{\"1\":{\"654\":1,\"725\":1}}],[\"只需要修改头结点的指针即可完成插入\",{\"1\":{\"654\":1,\"725\":1}}],[\"只需要安装jre\",{\"1\":{\"516\":1}}],[\"只需要向着没用过的内存方向将该指针移动对象内存大小位置即可\",{\"1\":{\"503\":1}}],[\"只需要知道对象实例初始化时会去方法区中找类信息\",{\"1\":{\"425\":1}}],[\"只需要付出少量对象的复制成本就可以完成每次垃圾收集\",{\"1\":{\"399\":1}}],[\"只需要发送一次\",{\"1\":{\"287\":1}}],[\"只需要一次网络传输\",{\"1\":{\"287\":1}}],[\"只需要一个\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"只需要\",{\"1\":{\"205\":1,\"212\":1}}],[\"只需要对\",{\"1\":{\"117\":1}}],[\"只需要在\",{\"1\":{\"1211\":1}}],[\"只需要在一棵索引树上就能获取sql所需的所有列数据\",{\"1\":{\"115\":1}}],[\"只需要在用户领取时分配优惠券信息即可\",{\"1\":{\"19\":1}}],[\"只需要遍历叶子节点\",{\"1\":{\"101\":1}}],[\"只需要往后追加\",{\"1\":{\"96\":1}}],[\"只需要监听前一个节点就好了\",{\"1\":{\"54\":1}}],[\"只检索给定范围的行\",{\"1\":{\"120\":1}}],[\"只能等待前面的写请求完成\",{\"1\":{\"1388\":1}}],[\"只能做叶子节点\",{\"1\":{\"1335\":1,\"1382\":1}}],[\"只能为我们保证\",{\"1\":{\"1202\":1}}],[\"只能满足可用性\",{\"1\":{\"1068\":1}}],[\"只能同时满足以下三点中的两个\",{\"1\":{\"1067\":1}}],[\"只能保证一个共享变量的原子操作\",{\"0\":{\"845\":1,\"994\":1},\"1\":{\"995\":1}}],[\"只能看到\",{\"1\":{\"820\":1}}],[\"只能在一个内核线程上运行无法利用多核\",{\"1\":{\"808\":1}}],[\"只能在创建时指定任务\",{\"1\":{\"611\":1}}],[\"只能指定初始的队列大小\",{\"1\":{\"799\":1}}],[\"只能按照下标访问其中的元素\",{\"1\":{\"649\":1}}],[\"只能按照任务的执行顺序依次执行\",{\"1\":{\"611\":1}}],[\"只能调用\",{\"1\":{\"604\":1}}],[\"只能调用静态的成员\",{\"1\":{\"521\":1}}],[\"只能选择\",{\"1\":{\"583\":1,\"793\":1,\"1068\":1}}],[\"只能引用常量池中常量来描述\",{\"1\":{\"331\":1}}],[\"只能存活\",{\"1\":{\"272\":1}}],[\"只能通过指针来定位\",{\"1\":{\"655\":1,\"726\":1}}],[\"只能通过getarray和setarray方法访问\",{\"1\":{\"589\":1}}],[\"只能通过\",{\"1\":{\"251\":1}}],[\"只能从一端插入元素\",{\"1\":{\"667\":1}}],[\"只能从\",{\"1\":{\"117\":1,\"1110\":1}}],[\"只能用于链表的情况\",{\"1\":{\"688\":1}}],[\"只能用\",{\"1\":{\"117\":1}}],[\"只是它那时没有其他的服务器了\",{\"1\":{\"1380\":1}}],[\"只是它注册中心使用了\",{\"1\":{\"1298\":1}}],[\"只是逻辑标记已消费\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"只是默认的一个错误处理器\",{\"1\":{\"1212\":1}}],[\"只是泛指调用\",{\"1\":{\"1182\":1}}],[\"只是响应来自\",{\"1\":{\"1108\":1}}],[\"只是一种思想\",{\"1\":{\"1099\":1}}],[\"只是一个固定长度的数组\",{\"1\":{\"649\":1}}],[\"只是一个元素\",{\"1\":{\"572\":1}}],[\"只是hashmap是由数组+链表实现的\",{\"1\":{\"1029\":1}}],[\"只是记录中断记录\",{\"1\":{\"1015\":1}}],[\"只是占位\",{\"1\":{\"1011\":1}}],[\"只是简单介绍了\",{\"1\":{\"999\":1}}],[\"只是传入的参数不相同\",{\"1\":{\"961\":1}}],[\"只是在提交修改的时候去验证对应的资源\",{\"1\":{\"838\":1,\"987\":1}}],[\"只是会尽量保证某个时刻达到数据一致的状态\",{\"1\":{\"1078\":1}}],[\"只是会麻烦一些\",{\"1\":{\"834\":1}}],[\"只是会在add\",{\"1\":{\"680\":1}}],[\"只是测试使用\",{\"1\":{\"753\":1}}],[\"只是维持了一个可获得许可证的数量\",{\"1\":{\"749\":1}}],[\"只是为了兼容旧版本\",{\"1\":{\"688\":1,\"792\":1}}],[\"只是为了占位\",{\"1\":{\"33\":1}}],[\"只是队列满时添加元素会抛出异常\",{\"1\":{\"541\":1}}],[\"只是规定了有方法区这么个概念和它的作用\",{\"1\":{\"496\":1}}],[\"只是这个文本文件它写的都是英文\",{\"1\":{\"418\":1}}],[\"只是根据对象存活周期的不同将内存分为几块\",{\"1\":{\"399\":1}}],[\"只是\",{\"1\":{\"356\":1}}],[\"只是参照的中心点是\",{\"1\":{\"210\":1}}],[\"只是实现了这个算法并提供了一些开箱即用的\",{\"1\":{\"205\":1}}],[\"只是功能依然非常简陋\",{\"1\":{\"182\":1}}],[\"只是功能过于简单且存在很多缺陷\",{\"1\":{\"182\":1}}],[\"只是按顺序把\",{\"1\":{\"117\":1}}],[\"只是性能会差一些\",{\"1\":{\"51\":1}}],[\"只有子节点列表变更才会更新\",{\"1\":{\"1349\":1}}],[\"只有消息同步双写到主从节点上时才返回写入成功\",{\"1\":{\"1314\":1}}],[\"只有用到\",{\"1\":{\"1007\":1}}],[\"只有用到condition才需要去实现它\",{\"1\":{\"744\":1}}],[\"只有执行相同次数的\",{\"1\":{\"972\":1}}],[\"只有执行的是\",{\"1\":{\"811\":1}}],[\"只有写锁没有被当前线程占用的情况才会获取失败\",{\"1\":{\"868\":1}}],[\"只有写写才会互斥\",{\"1\":{\"584\":1,\"793\":1}}],[\"只有自己使用完毕后才释放资源\",{\"1\":{\"823\":1}}],[\"只有内核程序可以访问\",{\"1\":{\"808\":1}}],[\"只有拿到许可证的线程才能执行\",{\"1\":{\"748\":1,\"906\":1}}],[\"只有获取到共享资源的线程才能执行\",{\"1\":{\"747\":1,\"905\":1}}],[\"只有一个服务器是\",{\"1\":{\"1108\":1}}],[\"只有一个执行线程\",{\"1\":{\"962\":1}}],[\"只有一个会胜出\",{\"1\":{\"841\":1,\"990\":1}}],[\"只有一个线程能执行\",{\"1\":{\"743\":1}}],[\"只有一个节点\",{\"1\":{\"624\":1}}],[\"只有这样\",{\"1\":{\"742\":1}}],[\"只有这两个方法返回\",{\"1\":{\"712\":1}}],[\"只有为\",{\"1\":{\"712\":1}}],[\"只有读读不互斥\",{\"1\":{\"584\":1,\"793\":1,\"865\":1}}],[\"只有它能与\",{\"1\":{\"402\":1}}],[\"只有两者都相同的情况\",{\"1\":{\"357\":1}}],[\"只有主动去使用类才会初始化类\",{\"1\":{\"344\":1}}],[\"只有同步到磁盘中才算持久化保存了\",{\"1\":{\"229\":1}}],[\"只有指定字段不存在时设置指定字段的值\",{\"1\":{\"185\":1}}],[\"只有在持有全局锁mainlock的前提下才能访问此集合\",{\"1\":{\"941\":2}}],[\"只有在整堆收集\",{\"1\":{\"498\":1}}],[\"只有在\",{\"1\":{\"177\":1}}],[\"只有在查询条件中使用了创建索引时的第一个字段\",{\"1\":{\"104\":1}}],[\"只有保证了事务的持久性\",{\"1\":{\"125\":1}}],[\"只有使用了\",{\"1\":{\"124\":1}}],[\"只有\",{\"1\":{\"90\":1,\"601\":1,\"752\":1,\"1110\":2,\"1311\":1}}],[\"只有未指定锁超时时间\",{\"1\":{\"49\":1}}],[\"只有当前线程调用\",{\"1\":{\"883\":1}}],[\"只有当数组长度大于或者等于\",{\"1\":{\"619\":1,\"622\":1}}],[\"只有当元素过期时\",{\"1\":{\"597\":1}}],[\"只有当父类加载器都反馈自己无法完成这个请求\",{\"1\":{\"433\":1}}],[\"只有当父加载器反馈自己无法完成这个加载请求\",{\"1\":{\"357\":1}}],[\"只有当\",{\"1\":{\"48\":1,\"749\":1}}],[\"只追加文件\",{\"1\":{\"35\":1,\"224\":1,\"282\":1}}],[\"`integer\",{\"1\":{\"558\":1}}],[\"`id`\",{\"1\":{\"33\":2,\"34\":3}}],[\"`\",{\"1\":{\"558\":1}}],[\"`hugecapacity\",{\"1\":{\"558\":1}}],[\"`biz\",{\"1\":{\"34\":5}}],[\"`version`\",{\"1\":{\"34\":4}}],[\"`current\",{\"1\":{\"34\":4}}],[\"`step`\",{\"1\":{\"34\":4}}],[\"`stub`\",{\"1\":{\"33\":3}}],[\"`sequence\",{\"1\":{\"33\":1,\"34\":4}}],[\"专门的一致性算法\",{\"1\":{\"1391\":1}}],[\"专门设计的一种支持崩溃恢复的原子广播协议\",{\"1\":{\"1360\":1}}],[\"专门给应用程序使用\",{\"1\":{\"808\":1}}],[\"专门开辟的一块区域\",{\"1\":{\"498\":1}}],[\"专门来加载\",{\"1\":{\"359\":1}}],[\"专门维护了一个使用\",{\"1\":{\"242\":1}}],[\"专门针对内存碎片问题做了优化\",{\"1\":{\"218\":1}}],[\"专门用来生成分布式\",{\"1\":{\"30\":1}}],[\"专属内容\",{\"1\":{\"13\":1,\"65\":1,\"150\":1,\"153\":1,\"736\":1}}],[\"拿出小本本\",{\"1\":{\"1347\":1}}],[\"拿我自己来说吧\",{\"1\":{\"1341\":1}}],[\"拿到这个任务的\",{\"1\":{\"609\":1}}],[\"拿到最终结果\",{\"1\":{\"21\":1}}],[\"拿\",{\"1\":{\"359\":1,\"693\":1}}],[\"拿对应的\",{\"1\":{\"56\":1}}],[\"拿锁且不设置锁超时时间\",{\"1\":{\"49\":1}}],[\"拿来即用\",{\"1\":{\"30\":1}}],[\"方面的参数\",{\"1\":{\"449\":1}}],[\"方便以后调用\",{\"1\":{\"1390\":1}}],[\"方便提问\",{\"1\":{\"1065\":1}}],[\"方便理解\",{\"1\":{\"941\":1}}],[\"方便处理更复杂的业务场景\",{\"1\":{\"757\":1}}],[\"方便\",{\"1\":{\"731\":3,\"732\":1}}],[\"方便实现栈和队列等数据结构\",{\"1\":{\"727\":1}}],[\"方便故障恢复\",{\"1\":{\"160\":1,\"232\":1}}],[\"方便快速地访问单条记录\",{\"1\":{\"111\":1}}],[\"方便易用\",{\"1\":{\"30\":1}}],[\"方法发送消息实际上是异步的操作\",{\"1\":{\"1204\":1}}],[\"方法参数等信息调用本地的方法\",{\"1\":{\"1166\":1}}],[\"方法参数等信息传递到服务端\",{\"1\":{\"1166\":1}}],[\"方法给赋值的\",{\"1\":{\"1043\":1}}],[\"方法提供替换过期数据的功能\",{\"1\":{\"1036\":1}}],[\"方法检查中断标记\",{\"1\":{\"1015\":1}}],[\"方法以后\",{\"1\":{\"1014\":1}}],[\"方法以及优先级比较\",{\"1\":{\"599\":1}}],[\"方法名\",{\"1\":{\"1006\":1,\"1007\":1}}],[\"方法所在的类\",{\"1\":{\"1002\":1}}],[\"方法threadpoolexecutor\",{\"1\":{\"962\":1}}],[\"方法运行示意图\",{\"1\":{\"950\":2}}],[\"方法用于提交需要返回值的任务\",{\"1\":{\"944\":1}}],[\"方法用于提交不需要返回值的任务\",{\"1\":{\"944\":1}}],[\"方法用来判断对象的相等性\",{\"1\":{\"678\":1}}],[\"方法用来排序\",{\"1\":{\"661\":2}}],[\"方法启动真实的线程实例\",{\"1\":{\"941\":1}}],[\"方法相结合可以实现等待\",{\"1\":{\"862\":1}}],[\"方法相同\",{\"1\":{\"767\":1}}],[\"方法配合\",{\"1\":{\"861\":1}}],[\"方法2\",{\"1\":{\"860\":1}}],[\"方法1\",{\"1\":{\"860\":1}}],[\"方法占用的锁是当前实例对象锁\",{\"1\":{\"848\":1}}],[\"方法占用的锁是当前类的锁\",{\"1\":{\"848\":1}}],[\"方法方可启动线程并使线程进入就绪状态\",{\"1\":{\"827\":1}}],[\"方法当成一个\",{\"1\":{\"827\":1}}],[\"方法当链表大小超过容量时返回\",{\"1\":{\"718\":1}}],[\"方法吗\",{\"0\":{\"827\":1}}],[\"方法定义在\",{\"1\":{\"826\":1}}],[\"方法被调用后\",{\"1\":{\"825\":1}}],[\"方法释放了锁\",{\"1\":{\"825\":1}}],[\"方法没有释放锁\",{\"1\":{\"825\":1}}],[\"方法对比\",{\"0\":{\"825\":1}}],[\"方法对数组扩容\",{\"1\":{\"619\":1}}],[\"方法或\",{\"1\":{\"820\":1}}],[\"方法或compare\",{\"1\":{\"661\":1}}],[\"方法后面都会细讲\",{\"1\":{\"1036\":1}}],[\"方法后返回为\",{\"1\":{\"946\":1}}],[\"方法后\",{\"1\":{\"924\":1,\"940\":1,\"946\":1}}],[\"方法后开始运行\",{\"1\":{\"820\":1}}],[\"方法后置操作\",{\"0\":{\"711\":1,\"712\":1}}],[\"方法可以对排队中的线程进行\",{\"1\":{\"1012\":1}}],[\"方法可以将线程置于\",{\"1\":{\"820\":1}}],[\"方法可以组合多个\",{\"1\":{\"786\":1}}],[\"方法可以处理正常的返回结果和异常\",{\"1\":{\"786\":1}}],[\"方法可以处理异常并重新抛出\",{\"1\":{\"786\":1}}],[\"方法可以在任务完成时触发回调函数\",{\"1\":{\"786\":1}}],[\"方法可以提升性能\",{\"1\":{\"564\":1}}],[\"方法不定义在\",{\"0\":{\"826\":1}}],[\"方法不会\",{\"1\":{\"799\":1}}],[\"方法不会等待所有的\",{\"1\":{\"782\":1}}],[\"方法不知道大家注意到没有\",{\"1\":{\"564\":1}}],[\"方法拿来对比的是\",{\"1\":{\"782\":1}}],[\"方法类似的还有\",{\"1\":{\"781\":1}}],[\"方法类型\",{\"1\":{\"343\":1}}],[\"方法接受一个\",{\"1\":{\"779\":1}}],[\"方法接受的参数是\",{\"1\":{\"778\":2}}],[\"方法为其赋值\",{\"1\":{\"780\":1}}],[\"方法为其传入结果\",{\"1\":{\"777\":1}}],[\"方法为阻塞调用\",{\"1\":{\"774\":1,\"901\":1}}],[\"方法为例\",{\"1\":{\"748\":2}}],[\"方法里面做了转发\",{\"1\":{\"767\":2}}],[\"方法告诉\",{\"1\":{\"756\":1,\"911\":1}}],[\"方法使用示例如下\",{\"1\":{\"779\":1}}],[\"方法使用不当很容易产生死锁\",{\"1\":{\"753\":1}}],[\"方法使得\",{\"1\":{\"749\":1}}],[\"方法之间的调用互斥么\",{\"1\":{\"848\":1}}],[\"方法之外\",{\"1\":{\"749\":1}}],[\"方法之后将会进入到\",{\"1\":{\"820\":1}}],[\"方法之后的语句不会被执行\",{\"1\":{\"908\":1}}],[\"方法之后的语句得到执行\",{\"1\":{\"752\":1,\"908\":1}}],[\"方法之后的方法才被执行\",{\"1\":{\"757\":1}}],[\"方法之后的条件\",{\"1\":{\"756\":1,\"911\":1}}],[\"方法之后\",{\"1\":{\"359\":1,\"820\":1}}],[\"方法增加一个许可证\",{\"1\":{\"749\":1}}],[\"方法阻塞\",{\"1\":{\"749\":1}}],[\"方法而非\",{\"1\":{\"742\":1}}],[\"方法而不是lock\",{\"1\":{\"535\":1}}],[\"方法而不是loadclass\",{\"1\":{\"354\":1}}],[\"方法独占该锁\",{\"1\":{\"742\":1}}],[\"方法底层调用的是带参数的\",{\"1\":{\"777\":1}}],[\"方法底层依然是基于迭代器\",{\"1\":{\"732\":1}}],[\"方法底部依赖的\",{\"1\":{\"632\":1}}],[\"方法内部调用的\",{\"1\":{\"711\":1}}],[\"方法完成了下面这些操作\",{\"1\":{\"710\":1,\"712\":1}}],[\"方法完成多线程之间的等待唤醒\",{\"1\":{\"607\":1}}],[\"方法取值来说\",{\"1\":{\"693\":1}}],[\"方法向\",{\"1\":{\"678\":1}}],[\"方法保证\",{\"1\":{\"677\":1}}],[\"方法保证capacity足够大\",{\"1\":{\"553\":1,\"561\":1}}],[\"方法逻辑\",{\"1\":{\"654\":1,\"731\":1}}],[\"方法删除满足特定条件的元素\",{\"1\":{\"631\":1}}],[\"方法删除指定集合中所有出现的元素\",{\"1\":{\"593\":1}}],[\"方法删除指定元素\",{\"1\":{\"593\":1}}],[\"方法判断线程池状态\",{\"1\":{\"941\":1}}],[\"方法判断\",{\"1\":{\"630\":1}}],[\"方法如下\",{\"1\":{\"630\":1,\"698\":1}}],[\"方法转为\",{\"1\":{\"630\":1}}],[\"方法实际上是将\",{\"1\":{\"624\":1}}],[\"方法实现\",{\"1\":{\"1036\":1}}],[\"方法实现原理\",{\"1\":{\"1026\":2}}],[\"方法实现按年龄来排序\",{\"0\":{\"663\":1}}],[\"方法实现数组自己复制自己\",{\"1\":{\"553\":1,\"561\":1}}],[\"方法实现数组之间的复制\",{\"1\":{\"553\":1}}],[\"方法实现锁的异步续期\",{\"1\":{\"49\":1}}],[\"方法添加元素的分析如下\",{\"1\":{\"622\":1}}],[\"方法更好\",{\"1\":{\"934\":1}}],[\"方法更加简化\",{\"1\":{\"618\":1,\"682\":1}}],[\"方法更新指定位置的元素\",{\"1\":{\"593\":1}}],[\"方法也就是扰动函数是为了防止一些实现比较差的\",{\"1\":{\"618\":1,\"682\":1}}],[\"方法也是相反的\",{\"1\":{\"535\":1}}],[\"方法和属性值\",{\"1\":{\"1005\":1}}],[\"方法和非静态\",{\"1\":{\"848\":1}}],[\"方法和使用自制的comparator方法或者以两个\",{\"1\":{\"661\":1}}],[\"方法和\",{\"0\":{\"825\":1},\"1\":{\"610\":1,\"629\":1,\"664\":1,\"934\":1}}],[\"方法查看索引\",{\"1\":{\"605\":1}}],[\"方法看看当前队首元素是否就是本次入队的元素\",{\"1\":{\"603\":1}}],[\"方法将其插入指定元素之前\",{\"1\":{\"729\":1}}],[\"方法将其唤醒\",{\"1\":{\"601\":1}}],[\"方法将元素节点插入链表尾部即可\",{\"1\":{\"729\":1}}],[\"方法将元素存放到优先队列中\",{\"1\":{\"603\":1}}],[\"方法将节点从\",{\"1\":{\"711\":1}}],[\"方法将\",{\"1\":{\"621\":1}}],[\"方法将集合元素存到优先队列\",{\"1\":{\"602\":1}}],[\"方法清空列表中所有元素\",{\"1\":{\"593\":1}}],[\"方法扩容的操作\",{\"1\":{\"588\":1}}],[\"方法有两个版本\",{\"1\":{\"729\":1}}],[\"方法有两种返回方式\",{\"1\":{\"493\":1}}],[\"方法有三个版本\",{\"1\":{\"588\":1}}],[\"方法继续获取\",{\"1\":{\"571\":1}}],[\"方法还没有查看\",{\"1\":{\"571\":1}}],[\"方法还没有执行\",{\"1\":{\"506\":1}}],[\"方法主要是为了给原有数组扩容\",{\"1\":{\"562\":1}}],[\"方法源码详解\",{\"0\":{\"1031\":1}}],[\"方法源码分析如下\",{\"1\":{\"756\":1,\"911\":1}}],[\"方法源码\",{\"1\":{\"571\":1,\"618\":2,\"682\":2}}],[\"方法源码我们知道\",{\"1\":{\"559\":1}}],[\"方法源码如下\",{\"1\":{\"218\":1}}],[\"方法时会返回一个\",{\"1\":{\"934\":1}}],[\"方法时还需要进行异常处理\",{\"1\":{\"924\":1}}],[\"方法时经过的节点\",{\"1\":{\"732\":1}}],[\"方法时\",{\"1\":{\"558\":1,\"742\":1,\"756\":1,\"908\":1,\"911\":1,\"924\":1}}],[\"方法进行加锁\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"方法进行后续处理\",{\"1\":{\"1002\":1}}],[\"方法进行重写\",{\"1\":{\"711\":1}}],[\"方法进行扩容\",{\"1\":{\"557\":1}}],[\"方法进行通知时\",{\"1\":{\"544\":1,\"862\":1}}],[\"方法非常简单\",{\"1\":{\"557\":1}}],[\"方法比较\",{\"1\":{\"553\":1}}],[\"方法唤醒正在等待插入元素的生产者线程\",{\"1\":{\"544\":1}}],[\"方法唤醒正在等待消费的消费者线程\",{\"1\":{\"544\":1}}],[\"方法让消费者进行等待\",{\"1\":{\"544\":1}}],[\"方法让生产者进行等待\",{\"1\":{\"544\":1}}],[\"方法返回\",{\"1\":{\"1308\":2}}],[\"方法返回当前锁是不是没有被线程持有\",{\"1\":{\"1014\":1}}],[\"方法返回的其实就是\",{\"1\":{\"900\":1}}],[\"方法返回的并不是\",{\"1\":{\"634\":1}}],[\"方法返回值小于等于\",{\"1\":{\"597\":1}}],[\"方法返回值\",{\"1\":{\"539\":2}}],[\"方法返回地址\",{\"1\":{\"493\":1}}],[\"方法其实就是对于\",{\"1\":{\"536\":1}}],[\"方法其实是调用\",{\"1\":{\"49\":1}}],[\"方法同理\",{\"1\":{\"536\":2}}],[\"方法等待队列非空时获取并移除元素\",{\"1\":{\"535\":1}}],[\"方法在执行之前会创建一个栈帧用于存储局部变量表\",{\"1\":{\"812\":1}}],[\"方法在指定位置插入元素\",{\"1\":{\"593\":1}}],[\"方法在队列为空的时候会阻塞\",{\"1\":{\"799\":1}}],[\"方法在队列已满的情况下\",{\"1\":{\"537\":1}}],[\"方法在队列满的时候等待队列非满时插入元素\",{\"1\":{\"535\":1}}],[\"方法在内存中的指针或者偏移量\",{\"1\":{\"343\":1}}],[\"方法正好是相反的\",{\"1\":{\"535\":1}}],[\"方法就会一直阻塞\",{\"1\":{\"908\":1}}],[\"方法就会阻塞消费者线程\",{\"1\":{\"531\":1}}],[\"方法就会阻塞\",{\"1\":{\"531\":1}}],[\"方法就是首先检查当前引用是否等于预期引用\",{\"1\":{\"843\":1,\"992\":1}}],[\"方法就像树立起一个栅栏的行为一样\",{\"1\":{\"756\":1,\"911\":1}}],[\"方法就知道为什么会抛出\",{\"1\":{\"634\":1}}],[\"方法就能获取键值对了\",{\"1\":{\"625\":1}}],[\"方法就很简单了\",{\"1\":{\"535\":1}}],[\"方法再看take\",{\"1\":{\"535\":1}}],[\"方法来创建子线程\",{\"1\":{\"1043\":1}}],[\"方法来获取返回值\",{\"1\":{\"944\":1}}],[\"方法来获取默认值或将其值更改为当前线程所存的副本的值\",{\"1\":{\"881\":1}}],[\"方法来等待任务执行完成\",{\"1\":{\"934\":1}}],[\"方法来指定任务之间的优先级比较规则\",{\"1\":{\"897\":1}}],[\"方法来指定元素排序规则\",{\"1\":{\"799\":1}}],[\"方法来包装我们的\",{\"1\":{\"792\":1}}],[\"方法来处理异常情况\",{\"1\":{\"780\":1}}],[\"方法来处理任务执行过程中可能出现的抛出异常的情况\",{\"1\":{\"780\":1}}],[\"方法来保证原子操作\",{\"1\":{\"765\":1}}],[\"方法来完成的\",{\"1\":{\"753\":1}}],[\"方法来检查是否已经完成\",{\"1\":{\"777\":1}}],[\"方法来检查\",{\"1\":{\"680\":1}}],[\"方法来比较\",{\"1\":{\"558\":1,\"559\":1}}],[\"方法来实现元素出队\",{\"1\":{\"535\":1}}],[\"方法来实现元素入队\",{\"1\":{\"535\":1}}],[\"方法来加载类\",{\"1\":{\"357\":2,\"359\":1}}],[\"方法只能调用一次\",{\"1\":{\"777\":1}}],[\"方法只是简单的调用了hashmap的put\",{\"1\":{\"680\":1}}],[\"方法只是给\",{\"1\":{\"622\":1}}],[\"方法只要返回数组长度就可以了\",{\"1\":{\"590\":1}}],[\"方法只需要两步即可\",{\"1\":{\"573\":1}}],[\"方法只得到了\",{\"1\":{\"531\":1}}],[\"方法只会被系统自动调用一次\",{\"1\":{\"446\":1}}],[\"方法存放\",{\"1\":{\"531\":1}}],[\"方法消费元素\",{\"1\":{\"531\":1}}],[\"方法生产\",{\"1\":{\"531\":1}}],[\"方法生成的\",{\"1\":{\"37\":1}}],[\"方法符号引用\",{\"1\":{\"497\":1}}],[\"方法服务\",{\"1\":{\"494\":1,\"812\":1}}],[\"方法调用的结果也需要通过网络编程来接收\",{\"1\":{\"1165\":1}}],[\"方法调用的一个方法\",{\"1\":{\"622\":1}}],[\"方法调用的数据需要通过栈进行传递\",{\"1\":{\"493\":1}}],[\"方法调用都是通过栈来实现的\",{\"1\":{\"493\":1}}],[\"方法调用是通过本地方法栈实现的\",{\"1\":{\"493\":1}}],[\"方法中的\",{\"1\":{\"1013\":1}}],[\"方法中的参数就会按一定顺序排列在这个局部变量表中\",{\"1\":{\"442\":1}}],[\"方法中判断是否真的转换为红黑树\",{\"1\":{\"683\":1}}],[\"方法中执行链表转红黑树的判断逻辑\",{\"1\":{\"683\":1}}],[\"方法中也能看到如下说明\",{\"1\":{\"680\":1}}],[\"方法中没有传递任何参数的话返回的是\",{\"1\":{\"633\":1}}],[\"方法中\",{\"1\":{\"558\":2,\"658\":1,\"941\":1,\"1012\":1,\"1013\":1}}],[\"方法中重新与引用链上的任何一个对象建立了关联\",{\"1\":{\"446\":1}}],[\"方法逃脱死亡的对象\",{\"1\":{\"446\":1}}],[\"方法出口\",{\"1\":{\"438\":1}}],[\"方法执行完成\",{\"1\":{\"958\":2}}],[\"方法执行完成后\",{\"1\":{\"825\":1}}],[\"方法执行完毕后相应的栈帧也会出栈并释放内存空间\",{\"1\":{\"494\":1}}],[\"方法执行完毕\",{\"1\":{\"430\":1}}],[\"方法执行的内存模型\",{\"1\":{\"438\":1}}],[\"方法带有一个\",{\"1\":{\"435\":1}}],[\"方法了\",{\"1\":{\"391\":1,\"1013\":1}}],[\"方法会执行\",{\"1\":{\"1007\":1}}],[\"方法会阻塞当前线程直到任务完成\",{\"1\":{\"944\":1}}],[\"方法会等到所有的\",{\"1\":{\"782\":1}}],[\"方法会使用示例如下\",{\"1\":{\"781\":1}}],[\"方法会抛出\",{\"1\":{\"634\":1,\"924\":1}}],[\"方法会先调用\",{\"1\":{\"630\":1}}],[\"方法会先获取当前请求锁的线程\",{\"1\":{\"56\":1}}],[\"方法会被逐渐弃用移除\",{\"1\":{\"391\":1}}],[\"方法一直被认为是一个糟糕的设计\",{\"1\":{\"391\":1}}],[\"方法已经被虚拟机调用过时\",{\"1\":{\"391\":1}}],[\"方法级的程序运行性能分析\",{\"1\":{\"377\":1}}],[\"方法打破双亲委派模型呢\",{\"1\":{\"359\":1}}],[\"方法即可\",{\"1\":{\"354\":1,\"359\":1,\"603\":1,\"619\":1,\"777\":1,\"807\":1,\"1333\":1}}],[\"方法解析该类\",{\"1\":{\"354\":1}}],[\"方法是把当前节点置为虚节点\",{\"1\":{\"1012\":1}}],[\"方法是阻塞的\",{\"1\":{\"785\":1}}],[\"方法是一个本地方法\",{\"1\":{\"765\":1}}],[\"方法是countdownlatch\",{\"1\":{\"752\":2}}],[\"方法是semaphore\",{\"1\":{\"748\":1}}],[\"方法是否返回\",{\"1\":{\"712\":1}}],[\"方法是\",{\"1\":{\"710\":1,\"1002\":1}}],[\"方法是通过遍历所有元素的方法来做的\",{\"1\":{\"632\":1}}],[\"方法是分两步进行的\",{\"1\":{\"589\":1}}],[\"方法是针对泛型集合说的\",{\"1\":{\"558\":1}}],[\"方法是针对字符串说的\",{\"1\":{\"558\":1}}],[\"方法是为了能够响应中断操作\",{\"1\":{\"535\":1}}],[\"方法是哪里是实现的了\",{\"1\":{\"533\":1}}],[\"方法是带锁线程安全\",{\"1\":{\"344\":1}}],[\"方法是编译之后自动生成的\",{\"1\":{\"344\":1}}],[\"方法的最后\",{\"1\":{\"1038\":1}}],[\"方法的执行示意图\",{\"1\":{\"958\":2}}],[\"方法的区别\",{\"1\":{\"934\":1}}],[\"方法的任务执行结果\",{\"1\":{\"900\":1}}],[\"方法的话\",{\"1\":{\"944\":1}}],[\"方法的话不会以多线程的方式执行\",{\"1\":{\"827\":1}}],[\"方法的话就会通知所有处于等待状态的线程\",{\"1\":{\"544\":1,\"862\":1}}],[\"方法的内容\",{\"1\":{\"827\":1}}],[\"方法的线程\",{\"1\":{\"807\":1}}],[\"方法的线程会阻塞直到\",{\"1\":{\"777\":1}}],[\"方法的顺序就是获取许可证的顺序\",{\"1\":{\"747\":1,\"905\":1}}],[\"方法的逻辑如下\",{\"1\":{\"731\":1}}],[\"方法的逻辑也很简单\",{\"1\":{\"536\":1}}],[\"方法的整体操作就是让当前节点\",{\"1\":{\"711\":1}}],[\"方法的整体逻辑为\",{\"1\":{\"603\":1}}],[\"方法的返回值处告诉我们插入前是否存在相同元素\",{\"1\":{\"680\":1}}],[\"方法的参数是\",{\"1\":{\"779\":1}}],[\"方法的参数是一个泛型数组\",{\"1\":{\"633\":1}}],[\"方法的参数现在使用更好\",{\"1\":{\"633\":1}}],[\"方法的实现\",{\"1\":{\"632\":1,\"710\":1,\"748\":1}}],[\"方法的实现细节\",{\"1\":{\"535\":1}}],[\"方法的可读性更好\",{\"1\":{\"629\":1}}],[\"方法的分析如下\",{\"1\":{\"622\":1}}],[\"方法的代码\",{\"1\":{\"622\":1}}],[\"方法的性能会稍差一点点\",{\"1\":{\"618\":1,\"682\":1}}],[\"方法的时间复杂度也是\",{\"1\":{\"629\":1}}],[\"方法的时间复杂度是\",{\"1\":{\"588\":1}}],[\"方法的时候\",{\"1\":{\"552\":1,\"625\":1,\"656\":1,\"884\":1,\"908\":1}}],[\"方法的流程\",{\"1\":{\"535\":1}}],[\"方法的源码如下\",{\"1\":{\"557\":1}}],[\"方法的源码\",{\"1\":{\"535\":1,\"629\":1,\"1039\":1}}],[\"方法的\",{\"1\":{\"533\":1}}],[\"方法的步骤如下\",{\"1\":{\"425\":1}}],[\"方法的那个类\",{\"1\":{\"344\":1}}],[\"方法的调用\",{\"1\":{\"344\":1}}],[\"方法的过程\",{\"1\":{\"344\":1}}],[\"方法的名称和描述符\",{\"1\":{\"328\":1}}],[\"方法句柄和调用限定符\",{\"1\":{\"343\":1}}],[\"方法信息\",{\"1\":{\"341\":1,\"496\":1}}],[\"方法区实现\",{\"1\":{\"498\":1}}],[\"方法区常用参数有哪些\",{\"1\":{\"496\":1}}],[\"方法区和永久代以及元空间的关系很像\",{\"1\":{\"496\":1}}],[\"方法区和永久代以及元空间是什么关系呢\",{\"1\":{\"496\":1}}],[\"方法区的实现是不同的\",{\"1\":{\"496\":1}}],[\"方法区到底要如何实现那就是虚拟机自己要考虑的事情了\",{\"1\":{\"496\":1}}],[\"方法区主要用于存放已被加载的类信息\",{\"1\":{\"813\":1}}],[\"方法区主要的作用是存放类的元数据信息\",{\"1\":{\"436\":1}}],[\"方法区主要回收的是无用的类\",{\"1\":{\"394\":1}}],[\"方法区中静态变量所引用的对象\",{\"1\":{\"445\":1}}],[\"方法区中\",{\"1\":{\"429\":1}}],[\"方法区中常量引用的对象\",{\"1\":{\"391\":1,\"445\":1}}],[\"方法区中类静态属性引用的对象\",{\"1\":{\"391\":1}}],[\"方法区以及线程的信息\",{\"1\":{\"377\":1}}],[\"方法区\",{\"0\":{\"420\":1,\"436\":1,\"496\":1},\"1\":{\"342\":1,\"420\":1,\"424\":1,\"480\":3,\"491\":1,\"496\":3,\"498\":1}}],[\"方法区会存储已被虚拟机加载的\",{\"1\":{\"341\":1,\"496\":1}}],[\"方法区属于是\",{\"1\":{\"341\":1,\"496\":1}}],[\"方法获取调用结果\",{\"1\":{\"1204\":1}}],[\"方法获取返回值\",{\"1\":{\"944\":2}}],[\"方法获取列表大小\",{\"1\":{\"593\":1}}],[\"方法获取指定位置的元素\",{\"1\":{\"593\":1}}],[\"方法获取到了\",{\"1\":{\"589\":1}}],[\"方法获取值\",{\"1\":{\"589\":1}}],[\"方法获取\",{\"1\":{\"340\":1,\"351\":1}}],[\"方法表中都可以携带自己的属性表集合\",{\"1\":{\"333\":1}}],[\"方法表的结构\",{\"1\":{\"332\":1}}],[\"方法表的结构如同字段表一样\",{\"1\":{\"332\":1}}],[\"方法表的\",{\"1\":{\"332\":3}}],[\"方法表集合\",{\"0\":{\"332\":1}}],[\"方法数量\",{\"1\":{\"325\":1,\"332\":1}}],[\"方法包含了看门狗的主要逻辑\",{\"1\":{\"49\":1}}],[\"方法\",{\"0\":{\"506\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"564\":1,\"622\":1,\"623\":1,\"624\":1,\"710\":1},\"1\":{\"47\":1,\"49\":1,\"218\":1,\"340\":1,\"354\":2,\"359\":1,\"391\":3,\"425\":2,\"433\":1,\"435\":1,\"441\":1,\"446\":2,\"451\":1,\"494\":1,\"497\":1,\"506\":1,\"521\":1,\"523\":1,\"531\":1,\"533\":2,\"535\":4,\"536\":3,\"539\":2,\"541\":1,\"544\":1,\"552\":1,\"553\":1,\"557\":6,\"558\":3,\"561\":1,\"563\":1,\"564\":1,\"597\":1,\"605\":1,\"610\":1,\"618\":4,\"619\":3,\"621\":1,\"622\":1,\"629\":1,\"630\":2,\"632\":1,\"634\":1,\"656\":1,\"658\":2,\"661\":1,\"664\":1,\"680\":1,\"682\":4,\"698\":1,\"706\":1,\"711\":1,\"712\":3,\"713\":1,\"715\":1,\"729\":1,\"742\":3,\"749\":3,\"752\":1,\"753\":2,\"756\":1,\"767\":3,\"777\":1,\"778\":2,\"781\":1,\"782\":1,\"811\":1,\"812\":1,\"820\":2,\"825\":1,\"827\":2,\"848\":2,\"852\":1,\"862\":2,\"883\":2,\"884\":1,\"893\":1,\"897\":1,\"909\":1,\"911\":1,\"941\":2,\"975\":1,\"1002\":1,\"1007\":9,\"1008\":1,\"1011\":1,\"1012\":1,\"1013\":1,\"1014\":3,\"1015\":1,\"1016\":1,\"1019\":1,\"1035\":1,\"1036\":2,\"1038\":1,\"1040\":1,\"1047\":1,\"1166\":1,\"1308\":2}}],[\"方案\",{\"1\":{\"1375\":1}}],[\"方案只是在系统发生分区的时候放弃一致性\",{\"1\":{\"1074\":1}}],[\"方案的延伸\",{\"1\":{\"1079\":1}}],[\"方案的一个补充\",{\"1\":{\"1074\":1}}],[\"方案的优缺点\",{\"1\":{\"35\":2}}],[\"方案主要做了下面这些优化\",{\"1\":{\"42\":1}}],[\"方案使用\",{\"1\":{\"35\":1}}],[\"方式两种\",{\"1\":{\"1231\":1}}],[\"方式管理插件\",{\"1\":{\"1132\":1}}],[\"方式更新\",{\"1\":{\"1006\":1}}],[\"方式有两种\",{\"1\":{\"897\":1}}],[\"方式二\",{\"1\":{\"888\":1,\"937\":1}}],[\"方式一\",{\"1\":{\"888\":1,\"937\":1}}],[\"方式进行抢占式\",{\"1\":{\"820\":1}}],[\"方式的持久化\",{\"1\":{\"229\":1}}],[\"方式调用\",{\"1\":{\"41\":1}}],[\"方式\",{\"0\":{\"1308\":1},\"1\":{\"7\":1,\"231\":1,\"499\":1,\"631\":1}}],[\"数量即可\",{\"1\":{\"1240\":1}}],[\"数量来实现动态负载均衡\",{\"1\":{\"1199\":1}}],[\"数量以及\",{\"1\":{\"1199\":1}}],[\"数量为\",{\"1\":{\"919\":1}}],[\"数量减为\",{\"1\":{\"756\":1,\"911\":1}}],[\"数量的线程能自旋成功\",{\"1\":{\"749\":1}}],[\"数量\",{\"1\":{\"210\":1}}],[\"数量量巨大\",{\"1\":{\"207\":1}}],[\"数统计\",{\"1\":{\"207\":1}}],[\"数组长度的\",{\"1\":{\"1036\":1}}],[\"数组等方式实现了这个接口\",{\"1\":{\"791\":1}}],[\"数组里的元素\",{\"1\":{\"690\":1}}],[\"数组里最小的id为min\",{\"1\":{\"141\":1}}],[\"数组的大小\",{\"1\":{\"692\":1}}],[\"数组的大小默认是\",{\"1\":{\"690\":1}}],[\"数组的数据进行修改时\",{\"1\":{\"690\":1}}],[\"数组的结构\",{\"1\":{\"579\":1}}],[\"数组属于链表结构\",{\"1\":{\"688\":1}}],[\"数组结构组成\",{\"1\":{\"688\":1,\"690\":1}}],[\"数组结构和\",{\"1\":{\"688\":1,\"690\":1}}],[\"数组天然支持随机访问\",{\"1\":{\"658\":1}}],[\"数组地址值\",{\"1\":{\"634\":1}}],[\"数组转集合\",{\"0\":{\"634\":1}}],[\"数组元素相等\",{\"1\":{\"623\":1}}],[\"数组来实现小顶堆\",{\"1\":{\"644\":1}}],[\"数组来决定是否转换为红黑树\",{\"1\":{\"619\":1,\"622\":1}}],[\"数组来优化堆内存\",{\"1\":{\"485\":1}}],[\"数组和链表\",{\"1\":{\"618\":1,\"682\":1}}],[\"数组是最常用且最基本的容器之一\",{\"1\":{\"647\":1}}],[\"数组是\",{\"1\":{\"616\":1,\"645\":2,\"688\":1}}],[\"数组+链表+红黑树的数据结构来实现\",{\"1\":{\"688\":1,\"792\":1}}],[\"数组+链表组成的\",{\"1\":{\"645\":1}}],[\"数组+链表\",{\"1\":{\"616\":1,\"688\":2,\"691\":1}}],[\"数组中对象元素地址连续为什么可以提高性能\",{\"1\":{\"1184\":1}}],[\"数组中\",{\"1\":{\"1110\":1}}],[\"数组中的每个元素包含一个\",{\"1\":{\"688\":1}}],[\"数组中存放的数据\",{\"1\":{\"619\":2}}],[\"数组中每一格就是一个链表\",{\"1\":{\"618\":1,\"682\":1}}],[\"数组中每个元素的下标叫做\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"数组中取值\",{\"1\":{\"589\":1}}],[\"数组桶为空\",{\"1\":{\"577\":1}}],[\"数组初始化这个\",{\"1\":{\"571\":1}}],[\"数组容量为\",{\"1\":{\"558\":1}}],[\"数组容量都为\",{\"1\":{\"557\":1}}],[\"数组容量扩为\",{\"1\":{\"555\":1,\"558\":1}}],[\"数组类型原子类\",{\"0\":{\"766\":1}}],[\"数组类型\",{\"1\":{\"762\":1}}],[\"数组类没有对应的二进制字节流\",{\"1\":{\"351\":1}}],[\"数组类通过getclassloader\",{\"1\":{\"340\":1,\"351\":1}}],[\"数组类不是通过\",{\"1\":{\"340\":1,\"351\":2}}],[\"数组\",{\"0\":{\"649\":1},\"1\":{\"180\":1,\"184\":1,\"385\":1,\"421\":1,\"552\":1,\"555\":1,\"570\":1,\"571\":2,\"575\":3,\"579\":3,\"642\":2,\"656\":1,\"688\":4,\"690\":2}}],[\"数组内\",{\"1\":{\"141\":1}}],[\"数学和加密函数等\",{\"1\":{\"82\":1}}],[\"数学家莱布尼茨的一句话\",{\"1\":{\"41\":1}}],[\"数\",{\"1\":{\"38\":1,\"1142\":1,\"1197\":1}}],[\"数据不一致问题\",{\"1\":{\"1370\":1}}],[\"数据不一致的问题\",{\"1\":{\"145\":1}}],[\"数据一致性\",{\"1\":{\"1368\":1}}],[\"数据一致性问题\",{\"1\":{\"585\":1}}],[\"数据节点内容长度\",{\"1\":{\"1349\":1}}],[\"数据节点内容版本号\",{\"1\":{\"1349\":1}}],[\"数据节点\",{\"0\":{\"1349\":1},\"1\":{\"1391\":1}}],[\"数据节点的增删改查\",{\"0\":{\"1334\":1}}],[\"数据模型采用层次化的多叉树形结构\",{\"1\":{\"1348\":1}}],[\"数据模型\",{\"0\":{\"1348\":1,\"1382\":1},\"1\":{\"1348\":1,\"1381\":1}}],[\"数据发布\",{\"1\":{\"1346\":1}}],[\"数据存储结构与标准的\",{\"1\":{\"1382\":1}}],[\"数据存储+事件监听\",{\"1\":{\"1344\":1}}],[\"数据存储等领域\",{\"1\":{\"1170\":1}}],[\"数据集成等场景\",{\"1\":{\"1284\":1}}],[\"数据湖等周边生态\",{\"1\":{\"1236\":1}}],[\"数据会直接被跳过\",{\"1\":{\"1213\":1}}],[\"数据处理\",{\"1\":{\"1190\":1}}],[\"数据序列化层\",{\"1\":{\"1130\":1}}],[\"数据被更新\",{\"1\":{\"840\":1,\"989\":1}}],[\"数据丢失这个在\",{\"1\":{\"686\":1}}],[\"数据来操作堆上的具体对象\",{\"1\":{\"508\":1}}],[\"数据结构如下图所示\",{\"1\":{\"883\":1}}],[\"数据结构与算法之美\",{\"1\":{\"800\":1}}],[\"数据结构跟\",{\"1\":{\"691\":1}}],[\"数据结构\",{\"0\":{\"1005\":1},\"1\":{\"293\":1,\"552\":1,\"656\":1,\"883\":1}}],[\"数据结构可以作为一个简单的队列使用\",{\"1\":{\"249\":1}}],[\"数据保持一致\",{\"1\":{\"281\":1}}],[\"数据在\",{\"1\":{\"270\":2}}],[\"数据\",{\"1\":{\"249\":1,\"273\":1,\"668\":1,\"1033\":1,\"1035\":2,\"1202\":1}}],[\"数据的可靠性\",{\"1\":{\"234\":1}}],[\"数据量巨大的场景还是\",{\"1\":{\"190\":1,\"259\":1}}],[\"数据量太大\",{\"1\":{\"118\":1}}],[\"数据类型保存\",{\"1\":{\"249\":1}}],[\"数据类型概览\",{\"1\":{\"242\":1}}],[\"数据类型\",{\"0\":{\"252\":1},\"1\":{\"174\":1,\"195\":1,\"212\":1,\"245\":1,\"293\":1}}],[\"数据可能还没异步更新\",{\"1\":{\"147\":1}}],[\"数据更新\",{\"1\":{\"145\":1}}],[\"数据删除\",{\"1\":{\"145\":1}}],[\"数据总量不一致\",{\"0\":{\"129\":1}}],[\"数据内容不一致\",{\"0\":{\"128\":1}}],[\"数据表的主键列使用的就是主键索引\",{\"1\":{\"113\":1}}],[\"数据都保存在叶子节点中\",{\"1\":{\"100\":1}}],[\"数据是有序的\",{\"1\":{\"99\":1}}],[\"数据密集型应用系统设计\",{\"1\":{\"51\":1}}],[\"数据库插入法\",{\"1\":{\"1303\":1}}],[\"数据库层的分库分表工具和数据迁移工具等等\",{\"1\":{\"1218\":1}}],[\"数据库连接池\",{\"1\":{\"887\":1,\"932\":1}}],[\"数据库记录当前版本也为\",{\"1\":{\"840\":1,\"989\":1}}],[\"数据库记录\",{\"1\":{\"840\":1,\"989\":1}}],[\"数据库键空间\",{\"1\":{\"271\":1}}],[\"数据库中的大量数据在同一时间过期\",{\"1\":{\"313\":1}}],[\"数据库中的某个\",{\"1\":{\"271\":1}}],[\"数据库中的所有\",{\"1\":{\"266\":1}}],[\"数据库和缓存数据强一致场景\",{\"1\":{\"145\":1}}],[\"数据库隔离级别一般都高于该级别\",{\"1\":{\"132\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"125\":1}}],[\"数据库引擎的数据库或表才支持事务\",{\"1\":{\"124\":1}}],[\"数据库索引这个知识点在面试中基本上必问\",{\"1\":{\"93\":1}}],[\"数据库用户名\",{\"1\":{\"84\":1}}],[\"数据库主键的无序性会严重影响数据库性能\",{\"1\":{\"37\":1}}],[\"数据库主键的时候就非常不合适\",{\"1\":{\"37\":1}}],[\"数据库主键要尽量越短越好\",{\"1\":{\"37\":1}}],[\"数据库主键自增这种模式\",{\"1\":{\"34\":1}}],[\"数据库主键自增\",{\"0\":{\"33\":1},\"1\":{\"33\":1}}],[\"数据库压力更小\",{\"1\":{\"34\":1}}],[\"数据库的压力可想而知\",{\"1\":{\"313\":1}}],[\"数据库的完整性没有被破坏\",{\"1\":{\"125\":1}}],[\"数据库的号段模式对于数据库的访问次数更少\",{\"1\":{\"34\":1}}],[\"数据库的号段模式也是目前比较主流的一种分布式\",{\"1\":{\"34\":1}}],[\"数据库的自增主键已经没办法满足生成的主键唯一了\",{\"1\":{\"29\":1}}],[\"数据库号段模式的原理我们在上面已经介绍过了\",{\"1\":{\"42\":1}}],[\"数据库号段模式的优缺点\",{\"1\":{\"34\":1}}],[\"数据库号段模式\",{\"0\":{\"34\":1},\"1\":{\"34\":1}}],[\"数据库\",{\"0\":{\"32\":1},\"1\":{\"145\":1,\"242\":1,\"1085\":1,\"1388\":1},\"2\":{\"91\":1,\"121\":1,\"142\":1,\"148\":1,\"151\":1,\"154\":1,\"172\":1,\"197\":1,\"214\":1,\"222\":1,\"238\":1,\"275\":1,\"321\":1}}],[\"数据遍布在不同服务器上的数据库\",{\"1\":{\"29\":1}}],[\"数字\",{\"1\":{\"19\":1}}],[\"单点故障问题\",{\"1\":{\"1370\":1}}],[\"单一系统映像\",{\"1\":{\"1345\":1}}],[\"单一应用架构\",{\"1\":{\"1123\":1}}],[\"单个实例下所有的队列共用一个日志数据文件来存储消息\",{\"1\":{\"1315\":1}}],[\"单个文件由\",{\"1\":{\"1315\":1}}],[\"单个文件大小默认\",{\"1\":{\"1315\":1}}],[\"单个\",{\"1\":{\"1281\":1}}],[\"单个叶子节点\",{\"1\":{\"110\":1}}],[\"单台机器的平均健康时间\",{\"1\":{\"1116\":1}}],[\"单请求耗时\",{\"1\":{\"1062\":2}}],[\"单例模式了解吗\",{\"1\":{\"834\":1}}],[\"单核\",{\"0\":{\"819\":1},\"1\":{\"819\":1}}],[\"单核时执行时间\",{\"1\":{\"816\":1}}],[\"单核时代\",{\"1\":{\"816\":1}}],[\"单继承\",{\"1\":{\"518\":1}}],[\"单位为\",{\"1\":{\"478\":1}}],[\"单位字节\",{\"1\":{\"449\":1}}],[\"单位是毫秒\",{\"1\":{\"38\":1}}],[\"单纯依靠自定义类加载器没办法满足某些场景的要求\",{\"1\":{\"359\":1}}],[\"单线程使用\",{\"1\":{\"1286\":1}}],[\"单线程就能支撑每秒\",{\"1\":{\"1178\":1}}],[\"单线程程序和正确执行的多线程程序\",{\"1\":{\"974\":1}}],[\"单线程是可以的\",{\"1\":{\"693\":1}}],[\"单线程环境下\",{\"1\":{\"693\":1}}],[\"单线程\",{\"1\":{\"401\":1}}],[\"单线程编程容易并且更容易维护\",{\"1\":{\"266\":1}}],[\"单线程模型了解吗\",{\"0\":{\"265\":1}}],[\"单独部署在一台服务器上\",{\"1\":{\"1126\":1}}],[\"单独设置\",{\"1\":{\"767\":2}}],[\"单独抽了一篇文章来总结可能会导致\",{\"1\":{\"317\":1}}],[\"单独访问一个行可能需要\",{\"1\":{\"98\":1}}],[\"单独券\",{\"1\":{\"19\":1}}],[\"单机模式\",{\"1\":{\"1263\":2}}],[\"单机\",{\"1\":{\"29\":1,\"49\":1}}],[\"没事\",{\"1\":{\"1315\":1}}],[\"没事儿\",{\"1\":{\"1263\":1}}],[\"没人生产用单机模式\",{\"1\":{\"1263\":1}}],[\"没关系啊\",{\"1\":{\"1132\":1}}],[\"没过期的数据经过rehash重定位后所处的桶位置理论上更接近i=\",{\"1\":{\"1037\":1}}],[\"没被回收\",{\"1\":{\"1030\":1}}],[\"没搞懂的话\",{\"1\":{\"941\":1}}],[\"没超过最大值\",{\"1\":{\"624\":1}}],[\"没法回收\",{\"1\":{\"445\":1}}],[\"没写完就\",{\"1\":{\"89\":1}}],[\"没有比自己更小的节点\",{\"1\":{\"1388\":2}}],[\"没有哪一门技术是\",{\"1\":{\"1275\":1}}],[\"没有处理\",{\"1\":{\"1264\":1}}],[\"没有堆积的情况下\",{\"1\":{\"1258\":1}}],[\"没有定义特定接口或类型\",{\"1\":{\"1182\":1}}],[\"没有定论\",{\"1\":{\"1068\":1}}],[\"没有任何边界\",{\"1\":{\"1152\":1}}],[\"没有任何引用链相连的话\",{\"1\":{\"391\":1}}],[\"没有直接用\",{\"1\":{\"1131\":1}}],[\"没有所谓的中心节点\",{\"1\":{\"1084\":1}}],[\"没有遇到key过期的entry\",{\"1\":{\"1035\":1}}],[\"没有指向\",{\"1\":{\"1011\":1}}],[\"没有指定类型的话会报错\",{\"1\":{\"633\":1}}],[\"没有将\",{\"1\":{\"1011\":1}}],[\"没有的话抛出\",{\"1\":{\"1005\":1}}],[\"没有发生过任何\",{\"1\":{\"972\":1}}],[\"没有返回值也无法抛出异常\",{\"1\":{\"943\":1}}],[\"没有多线程的情况下\",{\"1\":{\"933\":1}}],[\"没有多余的引用\",{\"1\":{\"708\":1}}],[\"没有业务含义\",{\"1\":{\"894\":1,\"920\":1}}],[\"没有容量\",{\"1\":{\"889\":1,\"892\":1,\"937\":1,\"938\":1}}],[\"没有新任务提交\",{\"1\":{\"888\":1}}],[\"没有被外部强引用的情况下\",{\"1\":{\"884\":1}}],[\"没有被删除\",{\"1\":{\"272\":1}}],[\"没有线程获取写锁的情况下\",{\"1\":{\"871\":1}}],[\"没有实例化过才进入加锁代码\",{\"1\":{\"834\":1}}],[\"没有实现\",{\"1\":{\"658\":1}}],[\"没有区分这两种状态呢\",{\"1\":{\"820\":1}}],[\"没有意义\",{\"1\":{\"710\":1}}],[\"没有这样的机制\",{\"1\":{\"677\":1}}],[\"没有出现哈希冲突的时候为\",{\"1\":{\"632\":1}}],[\"没有抢到锁\",{\"1\":{\"604\":1}}],[\"没有初始化\",{\"1\":{\"576\":1}}],[\"没有使用任何引用链时\",{\"1\":{\"445\":1}}],[\"没有太大的关系\",{\"1\":{\"422\":1}}],[\"没有设置最大缓存数量和弱引用\",{\"1\":{\"412\":1}}],[\"没有事务回滚\",{\"1\":{\"281\":1}}],[\"没有原生的集群模式\",{\"1\":{\"245\":1}}],[\"没有外部依赖\",{\"1\":{\"242\":1}}],[\"没有办法实时或者秒级持久化数据\",{\"1\":{\"236\":1}}],[\"没有开启\",{\"1\":{\"229\":1}}],[\"没有\",{\"1\":{\"89\":1}}],[\"没有银弹\",{\"1\":{\"43\":1}}],[\"没有用过的内存放在另一边\",{\"1\":{\"503\":1}}],[\"没有用\",{\"1\":{\"38\":1}}],[\"没有具体业务含义\",{\"1\":{\"33\":1,\"34\":1,\"37\":1}}],[\"没有网关的话\",{\"1\":{\"1\":1}}],[\"没想到的是\",{\"1\":{\"29\":1}}],[\"商业机密啊\",{\"1\":{\"33\":1,\"34\":1}}],[\"商品系统\",{\"1\":{\"1125\":1}}],[\"商品推荐等接口\",{\"1\":{\"772\":1}}],[\"商品详情\",{\"1\":{\"772\":1}}],[\"商品数量为\",{\"1\":{\"257\":1}}],[\"商品信息\",{\"1\":{\"186\":1}}],[\"商品\",{\"1\":{\"28\":1,\"257\":1}}],[\"商家提升商品销量\",{\"1\":{\"19\":1}}],[\"唯一的写请求处理者\",{\"1\":{\"1378\":1}}],[\"唯一的一点劣势是有可能消息重复消费\",{\"1\":{\"1240\":1}}],[\"唯一的区别在于\",{\"1\":{\"1355\":1}}],[\"唯一的区别是\",{\"1\":{\"1194\":1}}],[\"唯一的区别就是入队失败时不会阻塞当前线程\",{\"1\":{\"536\":1}}],[\"唯一的短网址映射的\",{\"1\":{\"17\":1}}],[\"唯一渐进的日志标识符\",{\"1\":{\"302\":1}}],[\"唯一索引\",{\"1\":{\"104\":1}}],[\"唯一值\",{\"1\":{\"47\":1}}],[\"唯一\",{\"1\":{\"38\":1,\"643\":2}}],[\"唯一表示\",{\"1\":{\"28\":1}}],[\"日\",{\"1\":{\"412\":1}}],[\"日常开发中\",{\"1\":{\"28\":1,\"671\":1}}],[\"日志采集等场景\",{\"1\":{\"1240\":1}}],[\"日志一致的地方\",{\"1\":{\"1112\":1}}],[\"日志复制\",{\"0\":{\"1112\":1}}],[\"日志打印别再瞎配置了\",{\"1\":{\"486\":1}}],[\"日志的参数\",{\"1\":{\"483\":1}}],[\"日志分析新生代空间大小分配是否合理\",{\"1\":{\"479\":1}}],[\"日志模式\",{\"1\":{\"367\":1}}],[\"日志模块\",{\"0\":{\"89\":1}}],[\"日志只能用于归档\",{\"1\":{\"89\":1}}],[\"日志输出\",{\"1\":{\"73\":1}}],[\"日志输出以及协议转换等操作\",{\"1\":{\"73\":1}}],[\"日志跟踪\",{\"0\":{\"21\":1}}],[\"日志记录阻塞\",{\"0\":{\"160\":1}}],[\"日志记录\",{\"0\":{\"483\":1},\"1\":{\"2\":1}}],[\"日志\",{\"0\":{\"1110\":1},\"1\":{\"1\":2,\"236\":1,\"367\":1}}],[\"映射的短网址\",{\"1\":{\"24\":1}}],[\"常常简单的表述为\",{\"1\":{\"1068\":1}}],[\"常规操作\",{\"0\":{\"922\":1}}],[\"常规数据\",{\"1\":{\"254\":1}}],[\"常量和静态变量\",{\"1\":{\"436\":1}}],[\"常量会被加载到运行时常量池\",{\"1\":{\"344\":1}}],[\"常量\",{\"1\":{\"341\":1,\"420\":1,\"496\":1,\"813\":1,\"972\":1}}],[\"常量池引用等信息\",{\"1\":{\"812\":1}}],[\"常量池中存储的是对象还是引用呢\",{\"1\":{\"498\":1,\"511\":1}}],[\"常量池中每一项常量都是一个表\",{\"1\":{\"328\":1}}],[\"常量池表会在类加载后存放到方法区的运行时常量池中\",{\"1\":{\"497\":1}}],[\"常量池表\",{\"1\":{\"497\":1}}],[\"常量池主要存放两大常量\",{\"1\":{\"328\":1}}],[\"常量池计数器是从\",{\"1\":{\"328\":1}}],[\"常量池\",{\"0\":{\"328\":1},\"1\":{\"325\":2,\"328\":1}}],[\"常量池的数量是\",{\"1\":{\"328\":1}}],[\"常量池的数量\",{\"1\":{\"325\":1,\"328\":1}}],[\"常用来封装\",{\"1\":{\"900\":1}}],[\"常用于生产者\",{\"1\":{\"670\":1}}],[\"常用于多线程之间的数据共享\",{\"1\":{\"541\":1}}],[\"常用方法测试\",{\"0\":{\"593\":1,\"625\":1,\"733\":1}}],[\"常用\",{\"1\":{\"316\":1}}],[\"常用命令演示\",{\"0\":{\"1323\":1}}],[\"常用命令\",{\"0\":{\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1,\"202\":1,\"206\":1,\"210\":1},\"1\":{\"1324\":1}}],[\"常用的过期数据的删除策略就两个\",{\"1\":{\"272\":1}}],[\"常用的数据类型有哪些\",{\"0\":{\"253\":1}}],[\"常用的\",{\"1\":{\"24\":1,\"772\":1,\"1252\":1}}],[\"常被称为内存交换或者交换分区\",{\"1\":{\"168\":1}}],[\"常见概念解读\",{\"1\":{\"1335\":1}}],[\"常见命令的使用以及使用\",{\"1\":{\"1341\":1}}],[\"常见命令的使用以及\",{\"1\":{\"1319\":1}}],[\"常见规则有哪些\",{\"0\":{\"975\":1}}],[\"常见操作\",{\"0\":{\"775\":1}}],[\"常见同步工具类\",{\"0\":{\"745\":1}}],[\"常见使用场景示例\",{\"0\":{\"599\":1}}],[\"常见并发容器总结\",{\"0\":{\"791\":1},\"1\":{\"583\":1}}],[\"常见方法及测试\",{\"0\":{\"531\":1}}],[\"常见面试题\",{\"0\":{\"606\":1,\"714\":1},\"1\":{\"380\":1,\"489\":1}}],[\"常见阻塞原因总结这篇文章中我们提到\",{\"1\":{\"292\":1}}],[\"常见阻塞原因总结\",{\"1\":{\"284\":1,\"317\":1}}],[\"常见的消息队列有哪些\",{\"0\":{\"1234\":1}}],[\"常见的中间件还有\",{\"1\":{\"1218\":1}}],[\"常见的等待策略有下面这些\",{\"1\":{\"1183\":1}}],[\"常见的可以作为注册中心的组件有\",{\"1\":{\"1069\":1}}],[\"常见的指令重排序有下面\",{\"1\":{\"969\":1}}],[\"常见的三种线程模型\",{\"1\":{\"808\":1}}],[\"常见的线程模型有这三种\",{\"1\":{\"808\":1}}],[\"常见的创建\",{\"1\":{\"776\":1}}],[\"常见的遍历方式\",{\"0\":{\"687\":1}}],[\"常见的符号引用包括类符号引用\",{\"1\":{\"497\":1}}],[\"常见的垃圾回收器有哪些\",{\"1\":{\"380\":1}}],[\"常见的\",{\"1\":{\"366\":1}}],[\"常见的缓存读写策略有哪些\",{\"0\":{\"247\":1}}],[\"常见的全局过滤器如下图所示\",{\"1\":{\"75\":1}}],[\"常见的局部过滤器如下图所示\",{\"1\":{\"74\":1}}],[\"常见的路由断言规则如下图所示\",{\"1\":{\"70\":1}}],[\"常见的电商平台订单号大多是纯数字组成\",{\"1\":{\"18\":1}}],[\"常见分布式锁实现方案如下\",{\"1\":{\"62\":1}}],[\"常见解决方案\",{\"0\":{\"31\":1}}],[\"常见场景有\",{\"1\":{\"19\":1}}],[\"社区活跃度很高\",{\"1\":{\"1240\":1}}],[\"社区成熟等等\",{\"1\":{\"10\":1}}],[\"社招\",{\"1\":{\"1177\":1}}],[\"社交网络\",{\"1\":{\"24\":1}}],[\"相连\",{\"1\":{\"1281\":1}}],[\"相连的引用链\",{\"1\":{\"446\":1}}],[\"相连的对象\",{\"1\":{\"406\":1}}],[\"相匹配的队列中\",{\"1\":{\"1252\":1}}],[\"相匹配时\",{\"1\":{\"1249\":1}}],[\"相信大家对\",{\"1\":{\"1341\":1}}],[\"相信本文将是你打开消息队列大门的一板砖\",{\"1\":{\"1217\":1}}],[\"相信小伙伴们看完上面的讲解之后\",{\"1\":{\"1166\":1}}],[\"相信看了上面的解释\",{\"1\":{\"882\":1}}],[\"相信看了上面的对比之后\",{\"1\":{\"245\":1}}],[\"相似\",{\"1\":{\"727\":1}}],[\"相等的对象是否真的相同\",{\"1\":{\"680\":1}}],[\"相等\",{\"1\":{\"622\":1}}],[\"相较于和容量成正比的\",{\"1\":{\"702\":1}}],[\"相较于数组\",{\"1\":{\"647\":1}}],[\"相较于其他的并发容器\",{\"1\":{\"602\":1}}],[\"相较于非批量操作\",{\"1\":{\"286\":1}}],[\"相当于是内置了\",{\"1\":{\"1085\":1}}],[\"相当于目录服务\",{\"1\":{\"1069\":1,\"1134\":1}}],[\"相当于动态数组\",{\"1\":{\"549\":1}}],[\"相当大时\",{\"1\":{\"157\":2,\"301\":2}}],[\"相应的地址会从服务提供者地址列表中移除\",{\"1\":{\"1390\":1}}],[\"相应的\",{\"1\":{\"523\":1}}],[\"相应地就会造成\",{\"1\":{\"165\":1}}],[\"相互引用着对方之外\",{\"1\":{\"390\":1}}],[\"相同\",{\"1\":{\"953\":1,\"955\":1,\"1114\":1}}],[\"相同就直接覆盖\",{\"1\":{\"622\":2}}],[\"相同点\",{\"1\":{\"520\":1}}],[\"相同的类文件被不同的类加载器加载产生的是两个不同的类\",{\"1\":{\"358\":1}}],[\"相同二进制名称的类只会被加载一次\",{\"1\":{\"352\":1}}],[\"相对而言\",{\"1\":{\"480\":1,\"496\":1}}],[\"相对于其他消息的优先权\",{\"1\":{\"1248\":1}}],[\"相对于\",{\"1\":{\"407\":1,\"575\":1,\"684\":1,\"779\":1}}],[\"相对于长网址\",{\"1\":{\"24\":1}}],[\"相对来说\",{\"1\":{\"182\":1}}],[\"相比原文主要进行了下面这些完善\",{\"1\":{\"1267\":1}}],[\"相比其他消息队列主要的优势如下\",{\"1\":{\"1191\":1}}],[\"相比几年前来说\",{\"1\":{\"1122\":1}}],[\"相比与其他操作系统\",{\"1\":{\"895\":1,\"922\":1}}],[\"相比synchronized\",{\"1\":{\"862\":1}}],[\"相比起来具有更高的吞吐量\",{\"1\":{\"798\":1}}],[\"相比之下\",{\"1\":{\"584\":1,\"713\":1,\"793\":1,\"1184\":1}}],[\"相比\",{\"1\":{\"192\":1,\"195\":1,\"236\":1}}],[\"相比较于\",{\"1\":{\"178\":1}}],[\"相比于其他序列化框架性能更低\",{\"1\":{\"1147\":1}}],[\"相比于其他分布式协议\",{\"1\":{\"1090\":1}}],[\"相比于操作系统线程\",{\"1\":{\"1055\":1}}],[\"相比于乐观锁\",{\"1\":{\"985\":1}}],[\"相比于传统读写锁多出来的乐观读是stampedlock比\",{\"1\":{\"872\":1}}],[\"相比于hashmap来说\",{\"1\":{\"679\":1}}],[\"相比于之前的版本\",{\"1\":{\"619\":1,\"683\":1}}],[\"相比于\",{\"1\":{\"53\":1,\"176\":1,\"256\":1,\"618\":2,\"682\":2,\"1096\":1,\"1171\":1,\"1332\":1}}],[\"相比于基于数据库号段模式的简单架构方案\",{\"1\":{\"42\":1}}],[\"相比于数据库主键自增的方式\",{\"1\":{\"34\":1}}],[\"相关概念总结\",{\"1\":{\"1329\":1}}],[\"相关内容的时候基本都会碰到\",{\"1\":{\"1166\":1}}],[\"相关独占锁的知识点\",{\"1\":{\"999\":1}}],[\"相关推荐\",{\"1\":{\"853\":1}}],[\"相关构造方法\",{\"1\":{\"798\":1}}],[\"相关源码这里就不贴了\",{\"1\":{\"619\":1}}],[\"相关面试题\",{\"0\":{\"540\":1}}],[\"相关代码如下所示\",{\"1\":{\"357\":1}}],[\"相关文章推荐\",{\"1\":{\"316\":1,\"319\":1}}],[\"相关问题答案会在\",{\"1\":{\"1002\":1}}],[\"相关问题\",{\"1\":{\"273\":1,\"303\":1,\"498\":1}}],[\"相关\",{\"1\":{\"231\":1,\"233\":1,\"280\":1,\"281\":1}}],[\"相关命令\",{\"1\":{\"178\":2,\"182\":1,\"186\":1,\"190\":3,\"194\":2,\"203\":1,\"207\":1,\"211\":1}}],[\"相关的基础概念\",{\"1\":{\"1164\":1}}],[\"相关的配置\",{\"1\":{\"1130\":1}}],[\"相关的故事背景\",{\"1\":{\"1096\":1}}],[\"相关的实现是通过\",{\"1\":{\"841\":1,\"990\":1}}],[\"相关的知识点和问题\",{\"1\":{\"831\":1}}],[\"相关的知识\",{\"1\":{\"604\":1}}],[\"相关的方法\",{\"1\":{\"483\":1}}],[\"相关的问题\",{\"1\":{\"483\":1}}],[\"相关的问题比较多\",{\"1\":{\"263\":1,\"831\":1}}],[\"相关的堆信息\",{\"1\":{\"366\":1}}],[\"相关的一些\",{\"1\":{\"258\":1}}],[\"相关的命令\",{\"1\":{\"210\":1}}],[\"相关的命令非常少\",{\"1\":{\"206\":1}}],[\"相关的面试题为我的\",{\"1\":{\"150\":1,\"153\":1}}],[\"相关的面试题为我的知识星球\",{\"1\":{\"13\":1,\"65\":1}}],[\"相关的介绍即可\",{\"1\":{\"37\":1}}],[\"相关阅读\",{\"1\":{\"8\":1,\"162\":1,\"249\":1,\"251\":1,\"265\":1,\"266\":1,\"267\":1,\"342\":1,\"480\":1,\"631\":1,\"820\":1}}],[\"层核心方法的映射关系\",{\"1\":{\"1007\":1}}],[\"层面实现的\",{\"1\":{\"861\":1}}],[\"层面的东西\",{\"1\":{\"850\":1}}],[\"层面\",{\"1\":{\"820\":1,\"861\":1}}],[\"层主要包括连接器\",{\"1\":{\"90\":1}}],[\"层和引擎层\",{\"1\":{\"90\":1}}],[\"层和存储引擎层两部分\",{\"1\":{\"81\":1}}],[\"层实现的\",{\"1\":{\"89\":1}}],[\"层\",{\"0\":{\"82\":1},\"1\":{\"83\":1,\"1006\":1}}],[\"层需要通过\",{\"1\":{\"23\":1}}],[\"层处理这次请求产生的非服务调用日志记录\",{\"1\":{\"23\":1}}],[\"再根据索引中记录的消息的全局位置\",{\"1\":{\"1315\":1}}],[\"再加个酸辣土豆丝\",{\"1\":{\"1271\":1}}],[\"再通过电子邮件或短信通知用户订单成功\",{\"1\":{\"1220\":1}}],[\"再通过继承\",{\"1\":{\"708\":1}}],[\"再用通俗的话给大家说一下\",{\"1\":{\"1139\":1}}],[\"再推送数据给\",{\"1\":{\"1087\":1}}],[\"再推荐两篇不错的文章\",{\"1\":{\"284\":1}}],[\"再推荐一个可以帮助理解\",{\"1\":{\"205\":1}}],[\"再回到\",{\"1\":{\"1015\":1}}],[\"再判断当前节点的线程是否为null\",{\"1\":{\"1013\":1}}],[\"再看一下\",{\"1\":{\"1008\":1,\"1014\":1}}],[\"再看下公平锁源码中获锁的方式\",{\"1\":{\"1002\":1}}],[\"再看并发编程三个重要特性\",{\"0\":{\"977\":1}}],[\"再以\",{\"1\":{\"904\":1}}],[\"再以倒计时器\",{\"1\":{\"742\":1}}],[\"再举个简单的例子\",{\"1\":{\"881\":1}}],[\"再去获取\",{\"1\":{\"824\":1}}],[\"再深入到计算机底层来探讨\",{\"1\":{\"816\":1}}],[\"再插一嘴\",{\"1\":{\"753\":1}}],[\"再插入\",{\"1\":{\"622\":1}}],[\"再尝试让后继节点\",{\"1\":{\"710\":1}}],[\"再尝试从其他地方加载这个类\",{\"1\":{\"359\":1}}],[\"再让尾节点的前驱指针指向p\",{\"1\":{\"710\":1}}],[\"再来看一下从尾到头方向的迭代\",{\"1\":{\"732\":1}}],[\"再来看看如何解决上面的一系列问题吧\",{\"1\":{\"1276\":1}}],[\"再来看看\",{\"1\":{\"644\":1}}],[\"再来说说第二个问题\",{\"1\":{\"708\":1}}],[\"再分享一下\",{\"1\":{\"693\":1}}],[\"再执行相应节点指针指向的更改\",{\"1\":{\"654\":1}}],[\"再执行所有的命令\",{\"1\":{\"280\":1}}],[\"再修改指定节点的指针完成插入\",{\"1\":{\"654\":1,\"725\":1,\"729\":1}}],[\"再检查新容量是否超出了arraylist所定义的最大容量\",{\"1\":{\"553\":1}}],[\"再例如限制访问权限修饰符\",{\"1\":{\"515\":1}}],[\"再采用上述的\",{\"1\":{\"503\":1}}],[\"再细致一点有\",{\"1\":{\"495\":1}}],[\"再次创建\",{\"1\":{\"1263\":1}}],[\"再次获取线程池状态\",{\"1\":{\"941\":1}}],[\"再次检查计算得到的指定位置的\",{\"1\":{\"571\":1}}],[\"再次检查\",{\"1\":{\"571\":1}}],[\"再次添加就会被阻塞或者抛出异常\",{\"1\":{\"529\":1}}],[\"再次启动\",{\"1\":{\"451\":1}}],[\"再次经过过滤器处理\",{\"1\":{\"69\":1}}],[\"再在内存排序分页\",{\"1\":{\"412\":1}}],[\"再不理解就老了\",{\"1\":{\"360\":1}}],[\"再比如\",{\"1\":{\"359\":1}}],[\"再将服务端应答返回客户端\",{\"1\":{\"1253\":1}}],[\"再将这个\",{\"1\":{\"1112\":1}}],[\"再将运算得到的数据写回\",{\"1\":{\"968\":1}}],[\"再将inc\",{\"1\":{\"835\":2}}],[\"再将从index开始之后的所有成员后移一个位置\",{\"1\":{\"553\":1,\"561\":1}}],[\"再将信息存入到方法区\",{\"1\":{\"341\":1,\"496\":1}}],[\"再将缓存中对应的\",{\"1\":{\"316\":1}}],[\"再按顺序执行打包的所有命令\",{\"1\":{\"279\":1}}],[\"再把\",{\"1\":{\"145\":1}}],[\"再把数据放到\",{\"1\":{\"145\":1}}],[\"再对比字段值\",{\"1\":{\"117\":1}}],[\"再假设执行\",{\"1\":{\"89\":1}}],[\"再写\",{\"1\":{\"89\":1}}],[\"再调用引擎接口写入这行新数据\",{\"1\":{\"89\":1}}],[\"再调用\",{\"1\":{\"49\":1}}],[\"再开始往上涨\",{\"1\":{\"22\":1}}],[\"再一并返回给用户\",{\"1\":{\"2\":1}}],[\"后者就是我们今天所要讲的\",{\"1\":{\"1368\":1}}],[\"后者对运营商不利\",{\"1\":{\"1304\":1}}],[\"后者在磁盘中\",{\"1\":{\"135\":1}}],[\"后四种和\",{\"1\":{\"1231\":1}}],[\"后申请的线程可能会先获取到锁\",{\"1\":{\"858\":1}}],[\"后发现\",{\"1\":{\"834\":1}}],[\"后就处于\",{\"1\":{\"820\":1}}],[\"后记\",{\"0\":{\"788\":1}}],[\"后继指针\",{\"1\":{\"1005\":1}}],[\"后继引用为空\",{\"1\":{\"729\":1}}],[\"后继节点\",{\"1\":{\"727\":2,\"742\":1,\"904\":1}}],[\"后继节点断开联系\",{\"1\":{\"711\":3}}],[\"后要求\",{\"1\":{\"599\":1}}],[\"后执行\",{\"1\":{\"599\":1}}],[\"后文会详细介绍到\",{\"1\":{\"889\":1,\"917\":1,\"937\":1,\"971\":1,\"1344\":1}}],[\"后文会介绍到\",{\"1\":{\"535\":1}}],[\"后文会介绍具体的方法\",{\"1\":{\"356\":1}}],[\"后文中我会结合源码对这一过程进行分析\",{\"1\":{\"677\":1}}],[\"后文简称栈\",{\"1\":{\"493\":1}}],[\"后仍然存活的对象\",{\"1\":{\"444\":1}}],[\"后仍然能够存活\",{\"1\":{\"386\":1}}],[\"后进先出原则\",{\"1\":{\"441\":1}}],[\"后得到\",{\"1\":{\"425\":1}}],[\"后续调用将被忽略\",{\"1\":{\"777\":1}}],[\"后续有时间再慢慢消化\",{\"1\":{\"710\":1,\"711\":1}}],[\"后续通过\",{\"1\":{\"621\":1}}],[\"后续的处理策略是怎么样的呢\",{\"1\":{\"1002\":1}}],[\"后续的几个版本又对阻塞队列进行了不少的更新和完善\",{\"1\":{\"529\":1}}],[\"后续的算法都是对其不足进行改进得到\",{\"1\":{\"396\":1}}],[\"后续操作的时候\",{\"1\":{\"184\":1,\"195\":1}}],[\"后的接口顺序从左到右排列在接口索引集合中\",{\"1\":{\"330\":1}}],[\"后过期\",{\"1\":{\"270\":2}}],[\"后来捐赠给了\",{\"1\":{\"1367\":1}}],[\"后来才引入的\",{\"1\":{\"1147\":1}}],[\"后来加入了\",{\"1\":{\"1122\":1,\"1168\":1}}],[\"后来被应用到了\",{\"1\":{\"256\":1}}],[\"后来\",{\"1\":{\"244\":1,\"256\":1,\"351\":1}}],[\"后台线程有哪些\",{\"1\":{\"268\":1}}],[\"后台线程的详细介绍可以查看\",{\"1\":{\"268\":1}}],[\"后台线程调用\",{\"1\":{\"268\":1}}],[\"后台线程来释放\",{\"1\":{\"268\":1}}],[\"后台线程了解吗\",{\"0\":{\"268\":1}}],[\"后台线程\",{\"1\":{\"161\":1,\"231\":1}}],[\"后返回响应\",{\"1\":{\"146\":1}}],[\"后删除\",{\"1\":{\"145\":1}}],[\"后更新\",{\"1\":{\"145\":1}}],[\"后写\",{\"1\":{\"89\":2}}],[\"后端技术栈\",{\"1\":{\"1172\":1}}],[\"后端处理完结果后\",{\"1\":{\"69\":1}}],[\"后端服务会对请求进行处理\",{\"1\":{\"69\":1}}],[\"后面用到\",{\"1\":{\"1352\":1}}],[\"后面我还会提到哦\",{\"1\":{\"1281\":1}}],[\"后面我会串起来将整个\",{\"1\":{\"1166\":1}}],[\"后面才慢慢发展成了一款功能全面的高性能消息队列\",{\"1\":{\"1235\":1}}],[\"后面还有更详细的剖析\",{\"1\":{\"1031\":1}}],[\"后面还跟了一个链表\",{\"1\":{\"96\":1}}],[\"后面插入元素的时候\",{\"1\":{\"799\":1}}],[\"后面存放目标位置的元素\",{\"1\":{\"577\":1}}],[\"后面会一一详细讲解\",{\"1\":{\"1033\":1}}],[\"后面会提到\",{\"1\":{\"493\":1,\"921\":1}}],[\"后面会解释\",{\"1\":{\"480\":1}}],[\"后面会介绍到为什么是\",{\"1\":{\"677\":1}}],[\"后面会介绍到\",{\"1\":{\"402\":1}}],[\"后面会涉及\",{\"1\":{\"108\":1}}],[\"后面分配的对象如果能够存在\",{\"1\":{\"384\":1}}],[\"后面\",{\"1\":{\"368\":1}}],[\"后面再来获取锁的话\",{\"1\":{\"56\":1}}],[\"后面的文章会介绍到\",{\"1\":{\"1341\":1}}],[\"后面的元素位置都是相同的\",{\"1\":{\"572\":2}}],[\"后面的\",{\"1\":{\"22\":1}}],[\"后\",{\"1\":{\"38\":1,\"89\":1,\"267\":1,\"384\":1,\"425\":1,\"441\":1,\"444\":1,\"485\":1,\"686\":1,\"687\":1,\"820\":1,\"950\":1,\"951\":1,\"972\":1,\"1248\":1}}],[\"后回到\",{\"1\":{\"22\":1}}],[\"涨到\",{\"1\":{\"22\":1}}],[\"之所以能够如此快\",{\"1\":{\"1184\":1}}],[\"之上定义的下一代\",{\"1\":{\"1168\":1}}],[\"之上定义的应用层协议\",{\"1\":{\"1161\":1}}],[\"之上最近的\",{\"1\":{\"570\":2}}],[\"之上进行了封装\",{\"1\":{\"146\":1}}],[\"之间没有直接耦合\",{\"1\":{\"1222\":1}}],[\"之间方法的交互过程\",{\"1\":{\"1007\":1}}],[\"之间方法的关联之处\",{\"1\":{\"1007\":1}}],[\"之间如果要进行通信的话\",{\"1\":{\"972\":1}}],[\"之间的随机数\",{\"1\":{\"1141\":1}}],[\"之间的链接\",{\"1\":{\"731\":2}}],[\"之间的关系\",{\"1\":{\"708\":1,\"900\":1,\"1002\":1}}],[\"之间的比例为\",{\"1\":{\"485\":1}}],[\"之间的元素\",{\"1\":{\"193\":2}}],[\"之间虽有引用关系\",{\"1\":{\"391\":1}}],[\"之间\",{\"1\":{\"181\":1}}],[\"之后server2\",{\"1\":{\"1380\":1}}],[\"之后参与者就向协调者反馈是否准备好了\",{\"1\":{\"1370\":1}}],[\"之后再将内核缓冲区的数据\",{\"1\":{\"1311\":1}}],[\"之后再继续执行\",{\"1\":{\"753\":1}}],[\"之后数据通过\",{\"1\":{\"1311\":1}}],[\"之后你就需要去考虑了\",{\"1\":{\"1224\":1}}],[\"之后发送给它的\",{\"1\":{\"1115\":1}}],[\"之后可以成为这个\",{\"1\":{\"1112\":1}}],[\"之后才有\",{\"1\":{\"1068\":1}}],[\"之后才有的\",{\"1\":{\"544\":1,\"862\":1}}],[\"之后引进的\",{\"1\":{\"934\":1}}],[\"之后说明最后一个线程已经到达栅栏了\",{\"1\":{\"756\":1,\"911\":1}}],[\"之后没有任何机制再次对其设置值\",{\"1\":{\"751\":1,\"907\":1}}],[\"之后在解决哈希冲突时有了较大的变化\",{\"1\":{\"683\":1}}],[\"之后每次扩充\",{\"1\":{\"616\":1,\"677\":2}}],[\"之后仍然无法进行对象保存的操作\",{\"1\":{\"444\":1}}],[\"之后为何引入了多线程\",{\"0\":{\"267\":1}}],[\"之后新增了unlink\",{\"1\":{\"266\":1}}],[\"之后已经默认是开启了\",{\"1\":{\"229\":1}}],[\"之后备份日志的时候\",{\"1\":{\"89\":1}}],[\"之后\",{\"0\":{\"619\":1,\"683\":1,\"691\":1,\"1030\":1},\"1\":{\"69\":1,\"174\":1,\"226\":3,\"256\":1,\"293\":1,\"533\":1,\"604\":1,\"810\":1,\"847\":1,\"934\":1,\"968\":1,\"1085\":1,\"1151\":1,\"1200\":1,\"1224\":1,\"1235\":1,\"1256\":1,\"1344\":1}}],[\"之后的请求和响应都会复用这条连接\",{\"1\":{\"1158\":1}}],[\"之后的元空间\",{\"1\":{\"810\":1}}],[\"之后的方法才会被执行\",{\"1\":{\"756\":1,\"911\":1}}],[\"之后的语句不会被执行\",{\"1\":{\"752\":1}}],[\"之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小\",{\"1\":{\"388\":1}}],[\"之后的操作不会进行\",{\"1\":{\"288\":1}}],[\"之后的版本中就已经加入了对多线程的支持\",{\"1\":{\"266\":1}}],[\"之后的\",{\"0\":{\"854\":1},\"1\":{\"22\":1,\"683\":1}}],[\"之前也写过一篇专门的文章聊过这个问题\",{\"1\":{\"1152\":1}}],[\"之前也提到了它是负责加载\",{\"1\":{\"426\":1}}],[\"之前在项目中\",{\"1\":{\"909\":1}}],[\"之前为循环链表\",{\"1\":{\"552\":1,\"642\":1,\"656\":1}}],[\"之前为什么不使用多线程\",{\"0\":{\"266\":1},\"1\":{\"266\":1}}],[\"之前的\",{\"1\":{\"688\":1,\"1014\":1}}],[\"之前的内部结构\",{\"1\":{\"618\":1,\"682\":1}}],[\"之前的方法区实现\",{\"1\":{\"496\":1}}],[\"之前的检测获取到的数据如同鬼影一般\",{\"1\":{\"129\":1}}],[\"之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\",{\"1\":{\"480\":1,\"496\":1}}],[\"之前运行时常量池逻辑包含字符串常量池存放在方法区\",{\"1\":{\"393\":1}}],[\"之前老年代本身还有容纳新生代所有对象的剩余空间\",{\"1\":{\"388\":1}}],[\"之前主要还是单线程处理\",{\"1\":{\"266\":1}}],[\"之前就是这样定义的\",{\"1\":{\"256\":1}}],[\"之前对应的\",{\"1\":{\"231\":1}}],[\"之前值为\",{\"1\":{\"202\":1}}],[\"之前\",{\"0\":{\"618\":1,\"682\":1,\"690\":1},\"1\":{\"69\":1,\"117\":1,\"174\":1,\"251\":1,\"342\":1,\"388\":2,\"392\":1,\"498\":1,\"583\":1,\"616\":1,\"618\":1,\"645\":1,\"682\":1,\"793\":1,\"808\":1,\"873\":1,\"972\":1,\"1200\":1,\"1224\":1,\"1235\":1,\"1343\":1,\"1370\":1}}],[\"之前说过\",{\"1\":{\"19\":1}}],[\"之父也在\",{\"1\":{\"1068\":1}}],[\"之父\",{\"1\":{\"51\":1}}],[\"之外\",{\"1\":{\"35\":2,\"205\":1,\"285\":1,\"330\":1,\"781\":1}}],[\"按道理来说\",{\"1\":{\"895\":1,\"922\":1}}],[\"按先入先出的顺序执行队列中的任务\",{\"1\":{\"888\":1,\"937\":1}}],[\"按某一顺序申请资源\",{\"1\":{\"824\":1}}],[\"按顺序链接两个\",{\"1\":{\"781\":1}}],[\"按顺序依次执行每个任务\",{\"1\":{\"772\":1}}],[\"按顺序遍历\",{\"1\":{\"96\":1}}],[\"按自然排序的升序排序\",{\"1\":{\"662\":1,\"696\":1}}],[\"按特定的排队规则来确定先后顺序\",{\"1\":{\"640\":1}}],[\"按位异或\",{\"1\":{\"618\":1,\"682\":1}}],[\"按适当的顺序\",{\"1\":{\"553\":1}}],[\"按正确顺序\",{\"1\":{\"553\":1}}],[\"按指定集合的iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾\",{\"1\":{\"553\":1}}],[\"按下倒计时门闩\",{\"1\":{\"531\":1}}],[\"按钮\",{\"1\":{\"376\":1}}],[\"按钮可以强制应用程序执行一个\",{\"1\":{\"375\":1}}],[\"按时间点恢复\",{\"1\":{\"233\":1}}],[\"按表条件过滤后\",{\"1\":{\"120\":1}}],[\"按照如下设置即可\",{\"1\":{\"1299\":1}}],[\"按照消息保存机制滚动清理最早的消息数据\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"按照消费者组进行消费\",{\"1\":{\"251\":1}}],[\"按照\",{\"1\":{\"1129\":1}}],[\"按照上面所说的\",{\"1\":{\"1020\":1}}],[\"按照代码顺序\",{\"1\":{\"975\":1}}],[\"按照插入顺序迭代元素是它的默认行为\",{\"1\":{\"716\":1}}],[\"按照集合的迭代器返回的顺序创建一个包含指定集合元素的\",{\"1\":{\"587\":1}}],[\"按照它们由集合的迭代器返回的顺序\",{\"1\":{\"553\":1}}],[\"按照年龄从小到大对其所占用的大小进行累积\",{\"1\":{\"386\":1,\"495\":1}}],[\"按照双亲委派模型\",{\"1\":{\"359\":1}}],[\"按照这个来也没问题\",{\"1\":{\"356\":1}}],[\"按照一定策略\",{\"1\":{\"294\":1}}],[\"按照一系列固定的大小\",{\"1\":{\"218\":1}}],[\"按照正确逻辑\",{\"1\":{\"128\":1,\"129\":1}}],[\"按照从最佳类型到最坏类型进行排序\",{\"1\":{\"120\":1}}],[\"按照功能逻辑维度划分\",{\"0\":{\"104\":1}}],[\"按照数据模型维度划分\",{\"0\":{\"103\":1}}],[\"按照请求和响应可以分为两种\",{\"1\":{\"73\":1}}],[\"按照约定的编解码规则支撑上述需求\",{\"1\":{\"19\":1}}],[\"按每两位转成\",{\"1\":{\"22\":1}}],[\"8f25d057a5a9\",{\"1\":{\"1171\":1}}],[\"8的数据都会被回收\",{\"1\":{\"1040\":1}}],[\"8u191\",{\"1\":{\"767\":2}}],[\"8u20\",{\"1\":{\"485\":1}}],[\"8is\",{\"1\":{\"757\":4}}],[\"8536148\",{\"1\":{\"720\":1}}],[\"858\",{\"1\":{\"687\":1}}],[\"8之后的内部结构\",{\"1\":{\"619\":1,\"683\":1}}],[\"8`\",{\"1\":{\"558\":1}}],[\"8683452581122892189l\",{\"1\":{\"553\":1}}],[\"8m\",{\"1\":{\"480\":1}}],[\"8yk1\",{\"1\":{\"320\":1}}],[\"849551\",{\"1\":{\"298\":1}}],[\"80\",{\"1\":{\"293\":2,\"1155\":1,\"1157\":1}}],[\"8001\",{\"1\":{\"7\":1}}],[\"8核的建议设置为6个线程\",{\"1\":{\"267\":1}}],[\"8g\",{\"1\":{\"246\":1}}],[\"87\",{\"1\":{\"210\":3}}],[\"88\",{\"1\":{\"210\":1,\"767\":1}}],[\"8932\",{\"1\":{\"370\":1}}],[\"89000061669732844\",{\"1\":{\"210\":1}}],[\"89\",{\"1\":{\"210\":1}}],[\"81\",{\"1\":{\"205\":1,\"212\":1}}],[\"8\",{\"0\":{\"85\":1,\"445\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"468\":2,\"469\":1,\"470\":1,\"471\":1,\"574\":1,\"618\":1,\"619\":1,\"682\":1,\"683\":1,\"690\":1,\"691\":1,\"692\":1,\"926\":1},\"1\":{\"22\":1,\"37\":1,\"85\":1,\"127\":1,\"174\":1,\"184\":1,\"201\":1,\"202\":1,\"212\":1,\"217\":1,\"218\":1,\"256\":3,\"261\":1,\"327\":2,\"328\":2,\"353\":1,\"360\":1,\"366\":2,\"382\":1,\"386\":1,\"393\":1,\"400\":1,\"403\":4,\"440\":1,\"443\":2,\"449\":3,\"450\":1,\"453\":2,\"454\":1,\"455\":1,\"475\":1,\"480\":3,\"491\":4,\"495\":2,\"496\":4,\"507\":3,\"529\":1,\"531\":2,\"553\":2,\"558\":1,\"559\":2,\"586\":1,\"598\":1,\"600\":1,\"612\":1,\"616\":3,\"618\":6,\"619\":3,\"622\":1,\"630\":1,\"645\":3,\"653\":4,\"677\":3,\"680\":2,\"682\":6,\"683\":5,\"685\":1,\"686\":3,\"688\":7,\"691\":5,\"692\":3,\"708\":3,\"720\":1,\"727\":1,\"731\":1,\"772\":1,\"774\":1,\"792\":2,\"810\":2,\"864\":1,\"871\":1,\"876\":2,\"882\":3,\"901\":1,\"972\":1,\"975\":1,\"1027\":1,\"1184\":1,\"1200\":2,\"1235\":2,\"1315\":2,\"1321\":2,\"1322\":1,\"1344\":1}}],[\"产生数据不一致问题\",{\"1\":{\"1379\":1}}],[\"产生消息的一方\",{\"1\":{\"1196\":1}}],[\"产生一个新的\",{\"1\":{\"233\":1}}],[\"产生各种异常\",{\"1\":{\"165\":1}}],[\"产生的网络流量较大\",{\"1\":{\"163\":1,\"292\":1}}],[\"产生的时间\",{\"1\":{\"22\":1}}],[\"产生了幻读问题\",{\"1\":{\"129\":1}}],[\"产生规则\",{\"1\":{\"22\":1}}],[\"避免消息丢失\",{\"1\":{\"1204\":1}}],[\"避免网络消耗太大\",{\"1\":{\"1088\":1}}],[\"避免网络传输的数据量过大\",{\"1\":{\"287\":1}}],[\"避免在并发场景下的资源竞争问题\",{\"1\":{\"985\":1}}],[\"避免出现问题\",{\"1\":{\"985\":1}}],[\"避免出现内存占用过高的情况\",{\"1\":{\"588\":1}}],[\"避免因频繁创建和销毁线程而带来的性能开销\",{\"1\":{\"925\":1}}],[\"避免死锁就是在资源分配时\",{\"1\":{\"824\":1}}],[\"避免异常丢失或者出现不可控问题\",{\"1\":{\"786\":1}}],[\"避免程序一直原地等待耗时任务执行完成\",{\"1\":{\"773\":1,\"899\":1}}],[\"避免使用executors\",{\"1\":{\"917\":1}}],[\"避免使用\",{\"1\":{\"632\":1}}],[\"避免自己写代码的时候出现这些低级的问题\",{\"1\":{\"628\":1}}],[\"避免内存剧烈波动影响线上服务\",{\"1\":{\"412\":1}}],[\"避免\",{\"1\":{\"319\":1}}],[\"避免频繁创建关闭客户端连接\",{\"1\":{\"319\":1}}],[\"避免同时处理大量的请求\",{\"1\":{\"314\":1}}],[\"避免单机出现问题整个缓存服务都没办法使用\",{\"1\":{\"314\":1}}],[\"避免单点风险\",{\"1\":{\"1\":2}}],[\"避免阻塞主线程\",{\"1\":{\"289\":1,\"294\":1}}],[\"避免额外的检查开销\",{\"1\":{\"160\":1,\"232\":1}}],[\"避免了传统锁机制带来的竞争和延迟\",{\"1\":{\"1184\":1}}],[\"避免了伪共享问题\",{\"1\":{\"1184\":1}}],[\"避免了回调地狱\",{\"1\":{\"1055\":1}}],[\"避免了链表中的环形结构\",{\"1\":{\"685\":1}}],[\"避免了多线程写的时候会复制出多个副本出来\",{\"1\":{\"588\":1}}],[\"避免了我们的代码影响了\",{\"1\":{\"433\":1}}],[\"避免了频繁加锁互斥造成并发性能下降\",{\"1\":{\"141\":1}}],[\"避免了锁无法被释放\",{\"1\":{\"53\":1}}],[\"避免对系统正常运行造成影响\",{\"1\":{\"61\":1}}],[\"避免无效自旋\",{\"1\":{\"53\":1}}],[\"避免锁的误释放\",{\"1\":{\"47\":1}}],[\"避免重启机器或者机器故障后数据丢失\",{\"1\":{\"35\":1}}],[\"避免折行或超出字符限制\",{\"1\":{\"24\":1}}],[\"避免依赖外部服务\",{\"1\":{\"22\":1}}],[\"增强程序可移植性的\",{\"1\":{\"971\":1,\"973\":1,\"981\":2}}],[\"增强数据的散列性\",{\"1\":{\"19\":1}}],[\"增删改查操作中唯一一个重写的方法\",{\"1\":{\"710\":1}}],[\"增为\",{\"1\":{\"558\":2}}],[\"增大年轻代后\",{\"1\":{\"449\":1}}],[\"增量数据\",{\"1\":{\"233\":1}}],[\"增加积分服务\",{\"1\":{\"1367\":1}}],[\"增加诸如服务注册\",{\"1\":{\"1171\":1}}],[\"增加系统的性能开销\",{\"1\":{\"837\":1,\"986\":1,\"995\":1}}],[\"增加一些延迟时间\",{\"1\":{\"781\":1}}],[\"增加此\",{\"1\":{\"564\":1}}],[\"增加此arraylist实例的容量\",{\"1\":{\"553\":1}}],[\"增加的多线程主要是针对一些大键值对的删除操作的命令\",{\"1\":{\"266\":1}}],[\"增加内存\",{\"1\":{\"168\":1}}],[\"增加和删除可能需要通过一次或多次树旋转来重新平衡这个树\",{\"1\":{\"98\":1}}],[\"增加\",{\"1\":{\"42\":1,\"256\":1,\"316\":1,\"529\":3,\"708\":1}}],[\"增加多\",{\"1\":{\"34\":1,\"42\":1}}],[\"增加了消息类型\",{\"1\":{\"1267\":1}}],[\"增加了沟通交流成本\",{\"1\":{\"895\":1,\"922\":1}}],[\"增加了轮询\",{\"1\":{\"857\":1}}],[\"增加了系统的开销\",{\"1\":{\"819\":1}}],[\"增加了在队首和队尾进行插入和删除的方法\",{\"1\":{\"667\":1}}],[\"增加了一些高级功能\",{\"0\":{\"862\":1}}],[\"增加了一条双向链表\",{\"1\":{\"645\":1}}],[\"增加了一个权重参数\",{\"1\":{\"192\":1,\"195\":1}}],[\"增加了对数据库的压力\",{\"1\":{\"33\":1}}],[\"增加了没必要的风险\",{\"1\":{\"22\":1}}],[\"且在发送结束后销毁生产者\",{\"1\":{\"1290\":1}}],[\"且对消息的处理时机\",{\"1\":{\"1284\":1}}],[\"且不会对当前业务产生影响\",{\"1\":{\"1296\":1}}],[\"且不需要产生关联\",{\"1\":{\"1284\":1}}],[\"且不说能不能承受\",{\"1\":{\"1273\":1}}],[\"且不支持存储\",{\"1\":{\"669\":1}}],[\"且每条\",{\"1\":{\"1260\":1}}],[\"且并发数受系统资源限制\",{\"1\":{\"1260\":1}}],[\"且比目前主流的\",{\"1\":{\"1161\":1}}],[\"且key值不等于threadlocal1\",{\"1\":{\"1040\":1}}],[\"且碰到entry为null的数据\",{\"1\":{\"1036\":1}}],[\"且size超过了阈值\",{\"1\":{\"1036\":1}}],[\"且当前散列数组中entry的数量已经达到了列表的扩容阈值\",{\"1\":{\"1038\":1}}],[\"且当前线程获取锁成功\",{\"1\":{\"1012\":1}}],[\"且当前节点不未链表尾节点\",{\"1\":{\"710\":1}}],[\"且看\",{\"1\":{\"896\":1,\"923\":1}}],[\"且有剩余资源\",{\"1\":{\"744\":1,\"1007\":1}}],[\"且链表需要进行移除操作了\",{\"1\":{\"712\":1}}],[\"且链表尾部不为当前节点\",{\"1\":{\"710\":1}}],[\"且会占用额外的内存空间\",{\"1\":{\"588\":1}}],[\"且会阻塞用户请求向下游传递\",{\"1\":{\"22\":1}}],[\"且往往申请的内存比实际所用的内存更大\",{\"1\":{\"542\":1,\"672\":1}}],[\"且成功存到\",{\"1\":{\"531\":1}}],[\"且受制于物理内存大小\",{\"1\":{\"495\":1}}],[\"且之后每次\",{\"1\":{\"480\":1}}],[\"且数组中无外部引用对象\",{\"1\":{\"449\":1}}],[\"且\",{\"1\":{\"445\":1,\"446\":1,\"975\":1,\"1033\":1,\"1256\":1}}],[\"且线程独享\",{\"1\":{\"438\":1}}],[\"且最大长度为\",{\"1\":{\"201\":1}}],[\"且已生成的最大事务为300\",{\"1\":{\"141\":1}}],[\"且只有一个\",{\"1\":{\"112\":1}}],[\"且支持负载均衡转发\",{\"1\":{\"75\":1}}],[\"且商品的数量只有\",{\"1\":{\"60\":1}}],[\"且局部有规律\",{\"1\":{\"18\":1}}],[\"都为\",{\"1\":{\"1380\":1}}],[\"都返回了准备好了的消息\",{\"1\":{\"1370\":1}}],[\"都只能提供读服务\",{\"1\":{\"1355\":1}}],[\"都只会有一个\",{\"1\":{\"816\":1}}],[\"都务必保证全局唯一\",{\"1\":{\"1353\":1}}],[\"都拿出小本本记好了\",{\"1\":{\"1352\":1}}],[\"都一个唯一的路径标识\",{\"1\":{\"1348\":1}}],[\"都一样\",{\"1\":{\"403\":1}}],[\"都不是完美的解决方案\",{\"1\":{\"1304\":1}}],[\"都提供了事务相关的功能\",{\"1\":{\"1223\":1}}],[\"都提供了插件来丰富自己的功能\",{\"1\":{\"1132\":1}}],[\"都用\",{\"1\":{\"1155\":1}}],[\"都列出来不太现实\",{\"1\":{\"909\":1}}],[\"都被设置为\",{\"1\":{\"949\":1,\"953\":1}}],[\"都被\",{\"1\":{\"860\":1}}],[\"都有自己所属的\",{\"1\":{\"1382\":1}}],[\"都有唯一的\",{\"1\":{\"1260\":1}}],[\"都有一个表明自己在\",{\"1\":{\"1110\":1}}],[\"都有一段逻辑\",{\"1\":{\"1018\":1}}],[\"都有可能\",{\"1\":{\"972\":1}}],[\"都有关系\",{\"1\":{\"841\":1,\"990\":1}}],[\"都有过期策略\",{\"1\":{\"245\":1}}],[\"都拥有对象锁\",{\"1\":{\"826\":1}}],[\"都没有选择自定义线程池\",{\"1\":{\"784\":1}}],[\"都运行完了之后再继续执行\",{\"1\":{\"782\":1}}],[\"都运行完成之后再返回\",{\"1\":{\"782\":2}}],[\"都还未完成\",{\"1\":{\"781\":1}}],[\"都必须提供许可的数量\",{\"1\":{\"747\":1,\"905\":1}}],[\"都执行了一次\",{\"1\":{\"686\":1}}],[\"都继承自abstractmap\",{\"1\":{\"679\":1}}],[\"都实现了\",{\"1\":{\"668\":1}}],[\"都能保证这份数据的正确性和一致性\",{\"1\":{\"818\":1}}],[\"都能保证元素唯一\",{\"1\":{\"665\":1}}],[\"都能生成唯一\",{\"1\":{\"42\":1}}],[\"都初始化了负载因子\",{\"1\":{\"621\":1}}],[\"都看完了\",{\"1\":{\"604\":1}}],[\"都需要操作系统帮忙完成\",{\"1\":{\"847\":1}}],[\"都需要获取到锁才能进行操作\",{\"1\":{\"541\":1,\"797\":1}}],[\"都需要请求公共的\",{\"1\":{\"22\":1}}],[\"都可以到其它节点上去消费数据\",{\"1\":{\"1263\":1}}],[\"都可以实现高可用\",{\"1\":{\"1240\":1}}],[\"都可以看作是基于微内核架构设计的\",{\"1\":{\"1132\":1}}],[\"都可以用于实现定时任务调度\",{\"1\":{\"611\":1}}],[\"都可以优先考虑\",{\"1\":{\"405\":1}}],[\"都可以比较方便地使用\",{\"1\":{\"53\":1,\"1332\":1}}],[\"都会为其维护一个叫作\",{\"1\":{\"1350\":1}}],[\"都会自动把消息同步到多个实例的\",{\"1\":{\"1263\":1}}],[\"都会到\",{\"1\":{\"1199\":1}}],[\"都会带上最后一个\",{\"1\":{\"1114\":1}}],[\"都会随机化一个新的选举超时时间\",{\"1\":{\"1111\":1}}],[\"都会往自己的threadlocalmap里存\",{\"1\":{\"1029\":1}}],[\"都会导致栈帧被弹出\",{\"1\":{\"493\":1}}],[\"都会回收它的内存\",{\"1\":{\"392\":1,\"884\":1}}],[\"都会有一个栈帧被弹出\",{\"1\":{\"493\":1}}],[\"都会有\",{\"1\":{\"17\":1}}],[\"都属于新生代\",{\"1\":{\"382\":1,\"495\":1}}],[\"都属于可重入锁\",{\"1\":{\"50\":1}}],[\"都集中在\",{\"1\":{\"357\":1}}],[\"都在用一个我们不认识的概念去解释另外一个我们不认识的概念\",{\"1\":{\"1150\":1}}],[\"都在里面\",{\"1\":{\"353\":1}}],[\"都在同一个\",{\"1\":{\"286\":1,\"287\":1,\"288\":1}}],[\"都已经被反复使用和验证过\",{\"1\":{\"341\":1}}],[\"都将变为\",{\"1\":{\"231\":1}}],[\"都是在根节点下挂很多子节点\",{\"1\":{\"1382\":1}}],[\"都是由一系列使用斜杠\",{\"1\":{\"1348\":1}}],[\"都是能容忍短暂的乱序\",{\"1\":{\"1299\":1}}],[\"都是如此\",{\"1\":{\"1159\":1}}],[\"都是获取一个对象的属性相对于该对象在内存当中的偏移量\",{\"1\":{\"1011\":1}}],[\"都是位于\",{\"1\":{\"1002\":1}}],[\"都是基于主从架构实现高可用性\",{\"1\":{\"1240\":1}}],[\"都是基于\",{\"1\":{\"999\":1}}],[\"都是基于内存的数据库\",{\"1\":{\"245\":1}}],[\"都是先将共享变量从主内存拷贝到对应线程的工作内存中\",{\"1\":{\"972\":1}}],[\"都是异步执行的\",{\"1\":{\"781\":1}}],[\"都是线程不安全的\",{\"1\":{\"698\":1}}],[\"都是使用\",{\"1\":{\"651\":1}}],[\"都是一次只允许一个线程访问某个资源\",{\"1\":{\"747\":1,\"905\":1}}],[\"都是一个类似\",{\"1\":{\"579\":1}}],[\"都是一串数字\",{\"1\":{\"24\":1}}],[\"都是不同步的\",{\"1\":{\"552\":1,\"656\":1}}],[\"都是配置化的\",{\"1\":{\"523\":1}}],[\"都是\",{\"1\":{\"423\":1,\"665\":1,\"719\":1,\"1357\":1}}],[\"都是针对的是\",{\"1\":{\"380\":1,\"489\":1}}],[\"都是直接用\",{\"1\":{\"244\":1}}],[\"都是通过\",{\"1\":{\"229\":1}}],[\"都入\",{\"1\":{\"99\":1}}],[\"都对外提供服务\",{\"1\":{\"60\":1}}],[\"都要访问一次数据库\",{\"1\":{\"33\":1,\"34\":1}}],[\"组件\",{\"1\":{\"918\":1}}],[\"组件很像\",{\"1\":{\"265\":1}}],[\"组合在自定义同步组件的实现中\",{\"1\":{\"744\":1}}],[\"组合在一起就是整个\",{\"1\":{\"21\":1}}],[\"组合优于继承\",{\"1\":{\"356\":1}}],[\"组合\",{\"0\":{\"781\":1},\"1\":{\"356\":1,\"569\":1}}],[\"组成一个\",{\"1\":{\"1196\":1}}],[\"组成一个完整的链式调用\",{\"1\":{\"774\":1,\"901\":1}}],[\"组成的操作\",{\"1\":{\"694\":1}}],[\"组成的\",{\"1\":{\"616\":1}}],[\"组成命令参数的数组\",{\"1\":{\"302\":1}}],[\"组成过滤器链\",{\"1\":{\"69\":1}}],[\"组成如下\",{\"1\":{\"40\":1}}],[\"组成\",{\"1\":{\"19\":1,\"1354\":1}}],[\"则可以获取到读锁\",{\"1\":{\"1388\":1}}],[\"则可以避免该问题\",{\"1\":{\"128\":1}}],[\"则批准了\",{\"1\":{\"1375\":1}}],[\"则整个集群都不可用\",{\"1\":{\"1299\":1}}],[\"则到达该时刻后会有大量消息同时需要被处理\",{\"1\":{\"1285\":1}}],[\"则消息不会路由到这两个队列中\",{\"1\":{\"1252\":1}}],[\"则没有这个要求\",{\"1\":{\"1232\":1}}],[\"则没有这个链表\",{\"1\":{\"719\":1}}],[\"则拒绝投票给该\",{\"1\":{\"1114\":1}}],[\"则自己回退为\",{\"1\":{\"1111\":1}}],[\"则重新计算slot位置\",{\"1\":{\"1037\":1}}],[\"则结束当前的迭代操作\",{\"1\":{\"1036\":1}}],[\"则更新slottoexpunge\",{\"1\":{\"1036\":1}}],[\"则更新为0\",{\"1\":{\"535\":1}}],[\"则把前驱节点设置为singal看是否成功\",{\"1\":{\"1013\":1}}],[\"则与之前的方法相同\",{\"1\":{\"1011\":1}}],[\"则进入else\",{\"1\":{\"1013\":1}}],[\"则进入\",{\"1\":{\"1002\":1}}],[\"则创建一个新的线程执行任务\",{\"1\":{\"954\":1}}],[\"则创建一个节点加入阻塞队列\",{\"1\":{\"906\":1}}],[\"则创建一个节点加入等待队列\",{\"1\":{\"748\":1}}],[\"则打印日志\",{\"1\":{\"924\":1}}],[\"则使用空闲线程来处理\",{\"1\":{\"892\":1,\"938\":1}}],[\"则使用大页面内存\",{\"1\":{\"485\":1}}],[\"则会将\",{\"1\":{\"1112\":1}}],[\"则会将未过期的数据放到最靠近此位置的entry=null的桶中\",{\"1\":{\"1037\":1}}],[\"则会创建新的线程处理任务\",{\"1\":{\"937\":1}}],[\"则会优先使用可复用的线程\",{\"1\":{\"937\":1}}],[\"则会丢弃该任务\",{\"1\":{\"891\":1,\"936\":1}}],[\"则会进入\",{\"1\":{\"495\":1}}],[\"则新元素将覆盖掉最旧的元素\",{\"1\":{\"1184\":1}}],[\"则新的任务会被暂存在一个任务队列中\",{\"1\":{\"888\":1,\"937\":1}}],[\"则新容量则为integer\",{\"1\":{\"559\":1}}],[\"则新容量则为interger\",{\"1\":{\"553\":1}}],[\"则新容量则为`integer\",{\"1\":{\"558\":1}}],[\"则立即执行\",{\"1\":{\"888\":1,\"937\":1}}],[\"则其他线程请求获取该读锁会被阻塞\",{\"1\":{\"871\":1}}],[\"则其数值⼀旦在初始化之后便不能更改\",{\"1\":{\"521\":1}}],[\"则以原子方式将该引用和该标志的值设置为给定的更新值\",{\"1\":{\"843\":1,\"992\":1}}],[\"则以原子方式将该值设置为输入值\",{\"1\":{\"763\":1}}],[\"则以原子方式将\",{\"1\":{\"766\":1}}],[\"则获取令牌成功\",{\"1\":{\"748\":1,\"906\":1}}],[\"则获取锁成功\",{\"1\":{\"53\":1}}],[\"则表示当前客户端可以直接获取到写锁\",{\"1\":{\"1388\":1}}],[\"则表示锁获取失败\",{\"1\":{\"871\":1}}],[\"则表示锁可以被获取\",{\"1\":{\"851\":1}}],[\"则表示许可证数量不足\",{\"1\":{\"748\":1,\"906\":1}}],[\"则表示可以获取成功\",{\"1\":{\"748\":1,\"906\":1}}],[\"则让b直接指向后继节点a\",{\"1\":{\"711\":1}}],[\"则让后继节点指向前驱节点\",{\"1\":{\"710\":1}}],[\"则让前驱节点指向后继节点\",{\"1\":{\"710\":1}}],[\"则通过reject\",{\"1\":{\"941\":1}}],[\"则通过链表来实现\",{\"1\":{\"668\":1}}],[\"则通过父类的loadclass来加载该类\",{\"1\":{\"357\":1}}],[\"则不再进行重试\",{\"1\":{\"1210\":1}}],[\"则不允许对它执行\",{\"1\":{\"972\":1}}],[\"则不可以\",{\"1\":{\"649\":1}}],[\"则不会进入\",{\"1\":{\"558\":1}}],[\"则不会触发\",{\"1\":{\"233\":1}}],[\"则保持子树的树结构\",{\"1\":{\"624\":1}}],[\"则将数据放入该槽位中\",{\"1\":{\"1035\":1}}],[\"则将其设置为\",{\"1\":{\"767\":1}}],[\"则将当前请求资源的线程设置为有效的工作线程\",{\"1\":{\"742\":1,\"904\":1}}],[\"则将当前线程放入conditionobject的等待队列中\",{\"1\":{\"604\":1}}],[\"则将当前线程设置为独占线程\",{\"1\":{\"1002\":1}}],[\"则将当前线程设置为\",{\"1\":{\"604\":1}}],[\"则将当前线程打断并存入aqs队列中\",{\"1\":{\"535\":1}}],[\"则将\",{\"1\":{\"731\":2}}],[\"则将head指向p\",{\"1\":{\"710\":1}}],[\"则将子树转换为链表\",{\"1\":{\"624\":1}}],[\"则将最小容量扩容为最接近的2的幂次方大小作为初始化\",{\"1\":{\"621\":1}}],[\"则将冲突的值加到链表中即可\",{\"1\":{\"618\":1,\"682\":1}}],[\"则当前客户端无法获取到读锁\",{\"1\":{\"1388\":1}}],[\"则当前线程放弃更新\",{\"1\":{\"841\":1,\"990\":1}}],[\"则当前线程进入无限期等待\",{\"1\":{\"604\":1}}],[\"则当前进程的进程\",{\"1\":{\"484\":1}}],[\"则查看当前元素多久到期\",{\"1\":{\"604\":1}}],[\"则判断当前\",{\"1\":{\"604\":1}}],[\"则判断当前任务是否到期\",{\"1\":{\"604\":1}}],[\"则调q的offer方法将元素存放到优先队列中\",{\"1\":{\"603\":1}}],[\"则调\",{\"1\":{\"603\":1}}],[\"则调用worker内部的线程实例t的thread\",{\"1\":{\"941\":1}}],[\"则调用afternodeaccess\",{\"1\":{\"712\":1}}],[\"则调用afternodeaccess将当前元素移到链表末尾\",{\"1\":{\"710\":1}}],[\"则调用\",{\"1\":{\"712\":1}}],[\"则调用hugecapacity\",{\"1\":{\"553\":1}}],[\"则调用enqueue将元素入队\",{\"1\":{\"535\":1}}],[\"则调用findclass方法来加载该类\",{\"1\":{\"357\":1}}],[\"则调用启动类加载器来加载该类\",{\"1\":{\"357\":1}}],[\"则要执行树化方法\",{\"1\":{\"577\":1}}],[\"则利用\",{\"1\":{\"577\":1}}],[\"则遍历链表寻找位置\",{\"1\":{\"571\":1}}],[\"则初始化这个\",{\"1\":{\"571\":1}}],[\"则它不会更改\",{\"1\":{\"553\":1}}],[\"则紧跟在集合结束后的数组中的元素设置为null\",{\"1\":{\"553\":1}}],[\"则为\",{\"1\":{\"553\":2}}],[\"则返回其中\",{\"1\":{\"553\":1}}],[\"则返回true\",{\"1\":{\"553\":1,\"592\":1}}],[\"则返回\",{\"1\":{\"553\":2}}],[\"则该broker\",{\"1\":{\"1281\":1}}],[\"则该\",{\"1\":{\"1281\":1}}],[\"则该方法会直接返回\",{\"1\":{\"536\":3}}],[\"则该方法会一直阻塞\",{\"1\":{\"535\":2}}],[\"则该线程可以直接执行调用的方法即可重入\",{\"1\":{\"50\":1}}],[\"则直接抛出illegalargumentexception\",{\"1\":{\"534\":1}}],[\"则直接返回空\",{\"1\":{\"604\":2}}],[\"则直接返回出去\",{\"1\":{\"604\":1}}],[\"则直接返回null\",{\"1\":{\"537\":1}}],[\"则直接返回false\",{\"1\":{\"537\":1}}],[\"则直接返回\",{\"1\":{\"531\":1,\"537\":1,\"538\":1,\"1040\":1}}],[\"则由链表构成的队列\",{\"1\":{\"529\":1}}],[\"则在对其初始化之后便不能再让其指向另⼀个对象\",{\"1\":{\"521\":1}}],[\"则在多态调用中\",{\"1\":{\"519\":1}}],[\"则\",{\"1\":{\"496\":1,\"1281\":1,\"1349\":1,\"1380\":1}}],[\"则抛出outofmemoryerror异常\",{\"1\":{\"493\":2}}],[\"则抛出异常\",{\"1\":{\"357\":1,\"732\":2,\"941\":1,\"943\":1}}],[\"则年轻代对象会在survivor区进行多次复制\",{\"1\":{\"464\":1}}],[\"则年轻代对象不经过survivor区\",{\"1\":{\"464\":1}}],[\"则两个\",{\"1\":{\"449\":1}}],[\"则被放入\",{\"1\":{\"446\":1}}],[\"则虚拟机栈负责运行代码\",{\"1\":{\"437\":1}}],[\"则虚拟机会先查看\",{\"1\":{\"388\":1}}],[\"则默认指定了\",{\"1\":{\"403\":1}}],[\"则证明此对象是不可用的\",{\"1\":{\"391\":1}}],[\"则说明被其他线程修改\",{\"1\":{\"841\":1,\"990\":1}}],[\"则说明没被其他线程修改\",{\"1\":{\"841\":1,\"990\":1}}],[\"则说明我们需要最老的元素\",{\"1\":{\"712\":1}}],[\"则说明需要保证\",{\"1\":{\"710\":1}}],[\"则说明有任务没人认领\",{\"1\":{\"604\":1}}],[\"则说明有其他的客户端已经成功获取锁\",{\"1\":{\"53\":1,\"55\":1}}],[\"则说明正有线程作为leader并等待一个任务到期\",{\"1\":{\"604\":1}}],[\"则说明当前线程获取锁成功\",{\"1\":{\"1008\":1}}],[\"则说明当前链表只有一个节点\",{\"1\":{\"710\":1}}],[\"则说明当前链表只有一个节点p\",{\"1\":{\"710\":1}}],[\"则说明当前节点是尾节点\",{\"1\":{\"731\":1}}],[\"则说明当前节点是头节点\",{\"1\":{\"731\":1}}],[\"则说明当前节点是链表的首节点\",{\"1\":{\"710\":1}}],[\"则说明当前节点p在链表末端\",{\"1\":{\"711\":1}}],[\"则说明当前节点p是链表首节点\",{\"1\":{\"711\":1}}],[\"则说明当前节点\",{\"1\":{\"710\":1}}],[\"则说明当前节点在链表最末尾\",{\"1\":{\"710\":1}}],[\"则说明当前\",{\"1\":{\"604\":1}}],[\"则说明当前队列没有任何元素\",{\"1\":{\"604\":1}}],[\"则说明队列没有元素\",{\"1\":{\"536\":1}}],[\"则说明\",{\"1\":{\"535\":1}}],[\"则说明该对象是不可用的\",{\"1\":{\"445\":1}}],[\"则说明该类没有被加载过\",{\"1\":{\"357\":1}}],[\"则先触发该父类的初始化\",{\"1\":{\"344\":1}}],[\"则先扩展至所需大小再进行修改操作\",{\"1\":{\"256\":1}}],[\"则先更新\",{\"1\":{\"146\":1}}],[\"则正常\",{\"1\":{\"168\":1}}],[\"则是放我们真正需要传输的内容\",{\"1\":{\"1159\":1}}],[\"则是根据元素的增加而逐渐占用内存空间\",{\"1\":{\"542\":1,\"672\":1}}],[\"则是动态分配链表节点内存\",{\"1\":{\"542\":1,\"672\":1}}],[\"则是只更新缓存\",{\"1\":{\"147\":1}}],[\"则是\",{\"1\":{\"146\":1,\"825\":1}}],[\"则第一个非空unique列作为聚簇索引\",{\"1\":{\"113\":1}}],[\"则主键索引就是聚簇索引\",{\"1\":{\"113\":1}}],[\"则列值的组合必须唯一\",{\"1\":{\"104\":1}}],[\"则应用这条路由规则\",{\"1\":{\"75\":1}}],[\"则去掉\",{\"1\":{\"74\":1}}],[\"则映射第一个匹配成功的路由\",{\"1\":{\"71\":1}}],[\"则映射到指定的路由器\",{\"1\":{\"70\":1}}],[\"则需要添加到工作线程集合和启动新的worker\",{\"1\":{\"941\":1}}],[\"则需要对方都释放自己锁\",{\"1\":{\"869\":1}}],[\"则需要执行一次\",{\"1\":{\"653\":1}}],[\"则需要进行扩容\",{\"1\":{\"577\":1}}],[\"则需要依次执行每个写命令\",{\"1\":{\"236\":1}}],[\"则需要同时满足才能匹配\",{\"1\":{\"71\":1}}],[\"则需要预先生成\",{\"1\":{\"19\":1}}],[\"则锁被占有\",{\"1\":{\"50\":1}}],[\"则代表整个链路中不同服务内部的视图\",{\"1\":{\"21\":1}}],[\"无异步化\",{\"1\":{\"1292\":1}}],[\"无疑极大地减少了开发和联调的工作量\",{\"1\":{\"1272\":1}}],[\"无缝对接微服务\",{\"1\":{\"1236\":1}}],[\"无限弹性扩缩\",{\"1\":{\"1236\":1}}],[\"无消息丢失配置怎么实现\",{\"1\":{\"1214\":1}}],[\"无界的队列又存在内存溢出的风险\",{\"1\":{\"1179\":1}}],[\"无界\",{\"1\":{\"1179\":2}}],[\"无界队列\",{\"1\":{\"889\":2,\"892\":1,\"897\":1,\"937\":2,\"938\":1,\"949\":1,\"955\":1}}],[\"无锁设计\",{\"1\":{\"1184\":1}}],[\"无锁\",{\"1\":{\"1179\":2}}],[\"无锁状态\",{\"1\":{\"854\":1}}],[\"无非都是\",{\"1\":{\"1159\":1}}],[\"无人胜出\",{\"1\":{\"1111\":1}}],[\"无颜色的为\",{\"1\":{\"1003\":1}}],[\"无效\",{\"1\":{\"845\":1,\"994\":1}}],[\"无前后顺序关联\",{\"1\":{\"772\":1}}],[\"无符号右移\",{\"1\":{\"618\":1,\"682\":1}}],[\"无参构造函数创建的对象在这里计算容量和阈值\",{\"1\":{\"624\":1}}],[\"无参构造默认值是\",{\"1\":{\"570\":1}}],[\"无参构造中调用了有参构造\",{\"1\":{\"570\":1}}],[\"无参构造的\",{\"1\":{\"555\":1}}],[\"无参数构造\",{\"1\":{\"555\":1}}],[\"无用的类\",{\"1\":{\"394\":2}}],[\"无论客户端连到哪一个\",{\"1\":{\"1345\":1}}],[\"无论元数据还是\",{\"1\":{\"1263\":1}}],[\"无论这两个操作是否在同一个线程里\",{\"1\":{\"974\":1}}],[\"无论是读操作还是写操作\",{\"1\":{\"1388\":1}}],[\"无论是哪台服务器为客户端分配的\",{\"1\":{\"1353\":1}}],[\"无论是\",{\"1\":{\"968\":1}}],[\"无论是通过引用计数法判断对象引用数量\",{\"1\":{\"392\":1}}],[\"无论方法正常完成还是异常完成都算作方法结束\",{\"1\":{\"493\":1}}],[\"无论\",{\"1\":{\"480\":1}}],[\"无论请求经过的哪个服务出了故障或者处理过慢都会对前端造成影响\",{\"1\":{\"21\":1}}],[\"无法再添加\",{\"1\":{\"1256\":1}}],[\"无法直接访问其他线程的本地内存\",{\"1\":{\"972\":1}}],[\"无法及时响应其他任务\",{\"1\":{\"925\":1}}],[\"无法执行其他任务\",{\"1\":{\"785\":1}}],[\"无法得知当前任务剩余时长和任务优先级的比较\",{\"1\":{\"610\":1}}],[\"无法进行调整\",{\"1\":{\"496\":1}}],[\"无法保证消息的可靠性\",{\"1\":{\"1292\":1}}],[\"无法保证各个对象的调用顺序\",{\"1\":{\"446\":1}}],[\"无法保证所有的\",{\"1\":{\"286\":1,\"287\":1}}],[\"无法处理浮动垃圾\",{\"1\":{\"406\":1}}],[\"无法在任何地方通过反射访问该类的方法\",{\"1\":{\"394\":1}}],[\"无法存入\",{\"1\":{\"384\":1}}],[\"无法找到业务类\",{\"1\":{\"359\":1}}],[\"无法被父类加载器加载的类最终会通过这个方法被加载\",{\"1\":{\"354\":1,\"359\":1}}],[\"无法实现类似关系型数据库执行失败可以回滚的那种原子性效果\",{\"1\":{\"283\":1}}],[\"无法续期\",{\"1\":{\"49\":1}}],[\"无索引下推执行流程\",{\"1\":{\"117\":1}}],[\"无需管理生产者分组\",{\"1\":{\"1296\":1}}],[\"无需为每个主题都创建一个生产者\",{\"1\":{\"1289\":1}}],[\"无需业务去重\",{\"1\":{\"1285\":1}}],[\"无需网络通信\",{\"1\":{\"1181\":1}}],[\"无需死记硬背\",{\"1\":{\"972\":2}}],[\"无需修改代码轻松引入\",{\"1\":{\"896\":1,\"923\":1}}],[\"无需加锁也无需等待\",{\"1\":{\"838\":1,\"987\":1}}],[\"无需我们自己再手动实现\",{\"1\":{\"286\":1}}],[\"无需回表\",{\"1\":{\"115\":1}}],[\"无需手动维护路由配置\",{\"1\":{\"72\":1}}],[\"无需再去访问业务服务\",{\"1\":{\"2\":1}}],[\"无\",{\"1\":{\"42\":1}}],[\"无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加\",{\"1\":{\"664\":1}}],[\"无序性不等于随机性\",{\"1\":{\"664\":1}}],[\"无序性和不可重复性的含义是什么\",{\"0\":{\"664\":1}}],[\"无序集合\",{\"1\":{\"195\":1}}],[\"无序\",{\"1\":{\"37\":1,\"643\":1}}],[\"tcc\",{\"1\":{\"1304\":1}}],[\"tcp是什么\",{\"1\":{\"1152\":1}}],[\"tcp\",{\"0\":{\"1151\":1,\"1152\":1},\"1\":{\"1151\":3,\"1152\":6,\"1154\":4,\"1155\":2,\"1158\":2,\"1159\":2,\"1161\":3,\"1165\":1,\"1235\":1,\"1260\":5,\"1353\":1,\"1379\":1,\"1383\":1}}],[\"tcmalloc\",{\"1\":{\"218\":1}}],[\"tp\",{\"1\":{\"896\":1,\"923\":1}}],[\"tp999\",{\"1\":{\"41\":1}}],[\"tlmclass\",{\"1\":{\"1030\":2}}],[\"tl\",{\"1\":{\"683\":5}}],[\"tlabwastetargetpercent\",{\"1\":{\"470\":1}}],[\"tlab\",{\"0\":{\"470\":1},\"1\":{\"444\":1,\"503\":4}}],[\"t重写compareto方法实现按年龄来排序\",{\"1\":{\"663\":1}}],[\"t>>\",{\"1\":{\"658\":1}}],[\"t>\",{\"1\":{\"630\":1,\"779\":5,\"781\":4}}],[\"t3\",{\"1\":{\"604\":3}}],[\"t2\",{\"1\":{\"604\":3,\"834\":1,\"1030\":3}}],[\"tbase\",{\"1\":{\"573\":1}}],[\"tshift\",{\"1\":{\"573\":1}}],[\"tt>\",{\"1\":{\"571\":4}}],[\"ttl\",{\"1\":{\"177\":1,\"270\":1,\"273\":1,\"929\":1,\"1256\":1,\"1257\":2,\"1264\":1}}],[\"tm\",{\"1\":{\"403\":2}}],[\"t参数可以在输出信息上加一个\",{\"1\":{\"366\":1}}],[\"t1\",{\"1\":{\"357\":3,\"604\":8,\"834\":1}}],[\"t0\",{\"1\":{\"357\":2}}],[\"typical\",{\"1\":{\"351\":1}}],[\"typedef\",{\"1\":{\"271\":1}}],[\"types\",{\"0\":{\"1252\":1},\"1\":{\"174\":1,\"196\":3,\"205\":1,\"1249\":1,\"1251\":1}}],[\"type代表访问类型\",{\"1\":{\"120\":1}}],[\"type\",{\"1\":{\"34\":3,\"35\":3,\"120\":3,\"201\":2,\"256\":11,\"268\":4,\"293\":1,\"298\":1,\"351\":3,\"1159\":2,\"1252\":2}}],[\"type`\",{\"1\":{\"34\":5}}],[\"txt\",{\"1\":{\"328\":2,\"1310\":1,\"1311\":1}}],[\"tue\",{\"1\":{\"1349\":2}}],[\"tutorial\",{\"1\":{\"174\":1,\"196\":2}}],[\"tuser\",{\"1\":{\"117\":1}}],[\"tdbpz9olh6ifvv6ewqgsga\",{\"1\":{\"171\":1}}],[\"trimtosize\",{\"1\":{\"553\":1}}],[\"triple\",{\"1\":{\"1168\":1}}],[\"tripped\",{\"1\":{\"756\":2,\"911\":2}}],[\"trip\",{\"1\":{\"285\":1,\"756\":2,\"911\":2}}],[\"troubleshooting\",{\"1\":{\"377\":1}}],[\"treated\",{\"1\":{\"201\":1}}],[\"treemap<>\",{\"1\":{\"679\":2}}],[\"treemap<person\",{\"1\":{\"663\":2,\"679\":2}}],[\"treemap\",{\"0\":{\"679\":1},\"1\":{\"645\":1,\"646\":1,\"679\":13,\"683\":1,\"698\":1}}],[\"treenodes\",{\"1\":{\"708\":1}}],[\"treenode是存储红黑树节点\",{\"1\":{\"688\":1}}],[\"treenode\",{\"1\":{\"619\":1,\"622\":1,\"623\":1,\"624\":1,\"688\":1,\"708\":10,\"711\":1}}],[\"treenode<k\",{\"1\":{\"619\":7,\"622\":2,\"623\":1,\"624\":1,\"683\":2,\"688\":2,\"708\":1,\"711\":1}}],[\"treeifybin\",{\"1\":{\"577\":2,\"619\":2,\"622\":2,\"683\":4}}],[\"treeify\",{\"1\":{\"577\":2,\"619\":2,\"622\":1,\"683\":3,\"708\":2}}],[\"treebin通过root属性维护红黑树的根结点\",{\"1\":{\"688\":1}}],[\"treebin<k\",{\"1\":{\"577\":1,\"688\":1}}],[\"treebin\",{\"1\":{\"577\":1}}],[\"treeset\",{\"0\":{\"665\":1},\"1\":{\"192\":1,\"195\":1,\"643\":1,\"646\":1,\"665\":4,\"683\":1,\"698\":1}}],[\"tree索引\",{\"1\":{\"103\":1}}],[\"tree\",{\"1\":{\"97\":2,\"99\":1,\"708\":1}}],[\"traverse\",{\"1\":{\"571\":1}}],[\"trans\",{\"1\":{\"1304\":2}}],[\"transportlayer\",{\"1\":{\"1253\":1}}],[\"transport\",{\"1\":{\"1130\":1}}],[\"transmittable\",{\"1\":{\"929\":1}}],[\"transmittablethreadlocal类继承并加强了\",{\"1\":{\"929\":1}}],[\"transmittablethreadlocal\",{\"1\":{\"929\":2}}],[\"transferto\",{\"1\":{\"1311\":1}}],[\"transfer\",{\"1\":{\"1154\":1}}],[\"transferqueue\",{\"1\":{\"529\":1}}],[\"transform\",{\"1\":{\"351\":1}}],[\"translated\",{\"1\":{\"449\":1}}],[\"transient\",{\"1\":{\"331\":1,\"553\":1,\"589\":1,\"601\":1,\"619\":4,\"629\":1,\"632\":1}}],[\"transactional\",{\"1\":{\"1275\":1}}],[\"transactions\",{\"1\":{\"280\":1,\"320\":2}}],[\"transaction\",{\"1\":{\"125\":2,\"135\":1,\"280\":1}}],[\"tracked\",{\"1\":{\"298\":1}}],[\"tracid\",{\"1\":{\"22\":1}}],[\"tracing\",{\"0\":{\"20\":1}}],[\"traceid\",{\"0\":{\"22\":1},\"1\":{\"21\":2,\"22\":5,\"1045\":2}}],[\"trace\",{\"1\":{\"21\":3,\"22\":1,\"364\":1,\"370\":1,\"1209\":1}}],[\"true\",{\"1\":{\"56\":2,\"353\":1,\"354\":1,\"396\":1,\"498\":1,\"531\":5,\"533\":3,\"536\":2,\"537\":1,\"538\":1,\"553\":5,\"557\":1,\"558\":2,\"588\":2,\"592\":1,\"593\":1,\"603\":2,\"619\":2,\"622\":1,\"634\":1,\"680\":1,\"686\":2,\"705\":3,\"706\":2,\"709\":1,\"710\":4,\"712\":8,\"717\":1,\"718\":3,\"729\":1,\"731\":2,\"748\":3,\"752\":3,\"756\":1,\"767\":2,\"773\":1,\"780\":2,\"797\":1,\"841\":1,\"857\":1,\"865\":1,\"894\":1,\"899\":1,\"906\":1,\"911\":1,\"920\":1,\"940\":1,\"941\":5,\"946\":2,\"990\":1,\"1001\":1,\"1007\":5,\"1008\":1,\"1011\":2,\"1012\":3,\"1013\":1,\"1014\":3,\"1015\":4,\"1018\":4,\"1020\":1,\"1030\":5,\"1042\":1,\"1046\":1,\"1141\":1,\"1142\":2,\"1206\":1,\"1210\":2,\"1299\":1}}],[\"tryoptimisticread\",{\"1\":{\"871\":1}}],[\"tryconverttooptimisticread\",{\"1\":{\"871\":1}}],[\"tryconverttoreadlock\",{\"1\":{\"871\":1}}],[\"tryconverttowritelock\",{\"1\":{\"871\":1}}],[\"tryreleaseshared\",{\"1\":{\"744\":1,\"748\":4,\"752\":4,\"906\":1,\"1007\":2}}],[\"tryreleaseshared中的一种即可\",{\"1\":{\"743\":1}}],[\"tryrelease\",{\"1\":{\"743\":1,\"744\":1,\"1007\":6,\"1014\":3,\"1019\":2,\"1020\":1}}],[\"tryacquiresharednanos\",{\"1\":{\"752\":1}}],[\"tryacquireshared\",{\"1\":{\"743\":1,\"744\":1,\"748\":3,\"752\":3,\"906\":1,\"1007\":2}}],[\"tryacquire\",{\"1\":{\"742\":1,\"744\":1,\"749\":1,\"904\":2,\"1007\":9,\"1008\":3,\"1010\":1,\"1012\":2,\"1013\":1,\"1015\":1,\"1016\":3,\"1018\":1,\"1019\":1,\"1020\":1}}],[\"trylock\",{\"1\":{\"571\":4,\"1001\":1}}],[\"trying\",{\"1\":{\"56\":1}}],[\"try\",{\"1\":{\"53\":1,\"242\":1,\"357\":1,\"370\":2,\"531\":2,\"534\":2,\"535\":2,\"536\":3,\"537\":2,\"538\":1,\"553\":1,\"571\":1,\"576\":1,\"588\":1,\"591\":1,\"603\":1,\"604\":3,\"605\":1,\"749\":1,\"753\":1,\"756\":4,\"757\":3,\"765\":1,\"781\":3,\"782\":3,\"785\":2,\"823\":2,\"824\":1,\"835\":1,\"837\":1,\"861\":1,\"882\":1,\"909\":2,\"911\":4,\"924\":1,\"940\":1,\"941\":2,\"944\":2,\"986\":1,\"1001\":2,\"1011\":2,\"1012\":1,\"1013\":2,\"1014\":1,\"1015\":1,\"1020\":1,\"1030\":1,\"1047\":1,\"1062\":1,\"1293\":2}}],[\"toidentitystring\",{\"1\":{\"1142\":1}}],[\"toindex\",{\"1\":{\"553\":4,\"634\":1}}],[\"toe\",{\"1\":{\"756\":2,\"911\":2}}],[\"too\",{\"1\":{\"708\":1}}],[\"tool\",{\"1\":{\"364\":1,\"366\":1,\"377\":1,\"412\":2,\"1199\":1}}],[\"tools\",{\"1\":{\"164\":1,\"218\":1,\"293\":1,\"365\":1,\"386\":1}}],[\"tolerance\",{\"1\":{\"1067\":4,\"1068\":1,\"1368\":1}}],[\"tolerable\",{\"1\":{\"693\":1}}],[\"tolist\",{\"1\":{\"634\":2,\"909\":1}}],[\"tocopyin\",{\"1\":{\"587\":3}}],[\"todo\",{\"1\":{\"561\":1,\"749\":1,\"757\":4,\"767\":2,\"894\":1,\"920\":1}}],[\"toarray可能返回的不是object类型的数组所以加上下面的语句用于判断\",{\"1\":{\"553\":1}}],[\"toarray\",{\"1\":{\"553\":5,\"555\":2,\"560\":1,\"562\":1,\"587\":2,\"633\":5,\"634\":1,\"909\":1}}],[\"tonanos\",{\"1\":{\"537\":2,\"752\":1,\"890\":1,\"936\":1}}],[\"tostring\",{\"1\":{\"353\":1,\"619\":1,\"649\":2,\"780\":1,\"940\":1,\"1046\":1,\"1204\":1}}],[\"topicpartition\",{\"1\":{\"1210\":7}}],[\"topic\",{\"0\":{\"1196\":1},\"1\":{\"1194\":1,\"1196\":9,\"1197\":1,\"1199\":6,\"1202\":5,\"1204\":4,\"1206\":1,\"1209\":2,\"1210\":1,\"1213\":2,\"1229\":1,\"1238\":1,\"1240\":1,\"1249\":1,\"1250\":2,\"1252\":4,\"1259\":1,\"1279\":1,\"1280\":4,\"1281\":9,\"1293\":2,\"1299\":1,\"1304\":3,\"1312\":1,\"1314\":2,\"1315\":12,\"1344\":1}}],[\"topics\",{\"1\":{\"49\":1,\"218\":1,\"221\":1,\"224\":1,\"235\":1,\"280\":1,\"1199\":2,\"1209\":1,\"1213\":1}}],[\"topattern\",{\"1\":{\"882\":2}}],[\"toplace\",{\"1\":{\"443\":2}}],[\"top\",{\"1\":{\"293\":1,\"329\":1,\"412\":2}}],[\"totalweight\",{\"1\":{\"1141\":8,\"1142\":5}}],[\"totalmillis\",{\"1\":{\"1062\":11}}],[\"totalmemory\",{\"1\":{\"451\":4}}],[\"totalnum\",{\"1\":{\"974\":1}}],[\"total\",{\"1\":{\"293\":1,\"386\":3,\"451\":8,\"495\":3}}],[\"token\",{\"1\":{\"178\":1,\"254\":1,\"270\":1}}],[\"tomap\",{\"1\":{\"630\":4}}],[\"tomcat\",{\"1\":{\"359\":12,\"929\":3}}],[\"tom\",{\"1\":{\"106\":1}}],[\"to\",{\"1\":{\"51\":1,\"56\":1,\"86\":2,\"201\":2,\"218\":1,\"256\":1,\"293\":2,\"298\":3,\"302\":2,\"351\":3,\"354\":1,\"356\":4,\"368\":1,\"370\":4,\"444\":2,\"480\":3,\"483\":1,\"553\":6,\"558\":1,\"564\":1,\"571\":5,\"573\":1,\"577\":1,\"619\":1,\"693\":1,\"708\":3,\"710\":1,\"756\":3,\"765\":1,\"767\":2,\"772\":1,\"876\":1,\"882\":1,\"911\":3,\"941\":1,\"1011\":1,\"1014\":1,\"1053\":1,\"1088\":1,\"1209\":2,\"1257\":1,\"1293\":2,\"1333\":2}}],[\"t\",{\"1\":{\"49\":1,\"81\":1,\"86\":4,\"89\":1,\"125\":4,\"218\":2,\"256\":8,\"268\":1,\"353\":1,\"366\":1,\"386\":4,\"480\":1,\"483\":1,\"495\":4,\"553\":3,\"604\":1,\"621\":3,\"630\":4,\"632\":1,\"633\":2,\"634\":3,\"658\":1,\"693\":4,\"713\":4,\"778\":1,\"779\":16,\"780\":3,\"781\":3,\"882\":3,\"883\":7,\"894\":3,\"920\":3,\"941\":5,\"1011\":15,\"1014\":7,\"1030\":6,\"1031\":7}}],[\"tanxinyu\",{\"1\":{\"1117\":1}}],[\"tailoffset\",{\"1\":{\"1011\":5}}],[\"tail指向p\",{\"1\":{\"710\":1}}],[\"tail\",{\"1\":{\"710\":3,\"711\":2,\"1011\":17,\"1013\":1,\"1014\":3}}],[\"tair\",{\"1\":{\"233\":1}}],[\"target\",{\"1\":{\"677\":1,\"697\":2,\"1043\":1,\"1311\":2}}],[\"targetsurvivorratio\",{\"1\":{\"386\":1,\"444\":2,\"495\":1}}],[\"targetsurvivorratio=percent\",{\"1\":{\"386\":1}}],[\"tabat\",{\"1\":{\"577\":2,\"578\":1}}],[\"tab\",{\"1\":{\"571\":7,\"573\":4,\"576\":7,\"577\":10,\"578\":4,\"622\":9,\"623\":4,\"683\":7,\"686\":2,\"711\":2,\"1036\":22,\"1037\":14,\"1038\":3,\"1041\":3,\"1042\":3}}],[\"table中可能有一些key为null的entry数据被清理掉\",{\"1\":{\"1038\":1}}],[\"tablefield\",{\"1\":{\"1030\":3}}],[\"table未初始化或者长度为0\",{\"1\":{\"622\":1}}],[\"table未初始化\",{\"1\":{\"621\":1}}],[\"tablesizefor\",{\"1\":{\"621\":3,\"677\":2}}],[\"table\",{\"1\":{\"33\":1,\"34\":1,\"120\":3,\"386\":1,\"495\":1,\"497\":1,\"553\":2,\"564\":2,\"570\":1,\"571\":4,\"572\":2,\"573\":1,\"576\":8,\"577\":1,\"578\":1,\"619\":1,\"621\":2,\"622\":5,\"623\":1,\"624\":5,\"713\":1,\"1030\":1,\"1032\":2,\"1036\":3,\"1037\":1,\"1038\":3,\"1041\":3,\"1042\":1}}],[\"tag\",{\"1\":{\"328\":2,\"1293\":1,\"1315\":3}}],[\"takeindex向后挪动\",{\"1\":{\"535\":1}}],[\"takeindex\",{\"1\":{\"535\":3,\"536\":1,\"538\":1}}],[\"take方法内部调用了\",{\"1\":{\"535\":1}}],[\"take\",{\"1\":{\"298\":1,\"530\":1,\"531\":4,\"533\":1,\"535\":6,\"539\":1,\"599\":1,\"603\":1,\"604\":3,\"799\":1}}],[\"tasks\",{\"1\":{\"918\":2}}],[\"task6\",{\"1\":{\"782\":2,\"909\":2}}],[\"task3\",{\"1\":{\"781\":1}}],[\"task2\",{\"1\":{\"781\":7}}],[\"task1\",{\"1\":{\"599\":1,\"781\":6,\"782\":2,\"909\":2}}],[\"task\",{\"1\":{\"49\":2,\"599\":14,\"781\":2,\"820\":1,\"900\":2,\"909\":1,\"934\":2,\"943\":2,\"958\":1}}],[\"tid\",{\"1\":{\"1043\":1}}],[\"tips\",{\"1\":{\"456\":1}}],[\"times\",{\"1\":{\"1333\":1}}],[\"timeslice\",{\"1\":{\"820\":1}}],[\"timestamp\",{\"1\":{\"366\":1}}],[\"timed\",{\"1\":{\"756\":4,\"820\":2,\"911\":4}}],[\"timer\",{\"0\":{\"611\":1,\"962\":1},\"1\":{\"611\":3,\"962\":3}}],[\"timertask\",{\"0\":{\"611\":1},\"1\":{\"49\":1,\"611\":3}}],[\"time\",{\"1\":{\"56\":2,\"221\":1,\"268\":1,\"285\":1,\"293\":1,\"298\":2,\"302\":1,\"598\":1,\"713\":8,\"820\":4,\"940\":24,\"974\":1,\"1096\":2,\"1116\":1,\"1185\":1,\"1257\":1,\"1333\":3,\"1349\":2,\"1382\":2}}],[\"timeunit\",{\"1\":{\"49\":2,\"53\":1,\"56\":1,\"530\":1,\"533\":2,\"537\":4,\"539\":2,\"597\":1,\"599\":2,\"752\":1,\"757\":1,\"773\":1,\"774\":1,\"784\":1,\"785\":1,\"889\":3,\"890\":1,\"894\":1,\"899\":1,\"918\":1,\"920\":1,\"924\":1,\"927\":1,\"936\":1,\"937\":3,\"940\":3,\"944\":3,\"949\":2,\"953\":2,\"957\":2,\"958\":2,\"1001\":1,\"1062\":2}}],[\"timeoutblockingwaitstrategy\",{\"1\":{\"1183\":1}}],[\"timeoutexceptio\",{\"1\":{\"773\":1,\"899\":1}}],[\"timeoutexception\",{\"1\":{\"756\":3,\"773\":1,\"785\":2,\"899\":1,\"911\":3,\"944\":2}}],[\"timeout\",{\"1\":{\"49\":3,\"533\":2,\"537\":6,\"539\":2,\"752\":2,\"773\":1,\"774\":1,\"825\":1,\"899\":1,\"944\":3}}],[\"tinyid\",{\"0\":{\"42\":1},\"1\":{\"34\":1,\"42\":12}}],[\"thou\",{\"1\":{\"511\":1}}],[\"than和slowlog\",{\"1\":{\"302\":1}}],[\"than阈值的命令时\",{\"1\":{\"302\":1}}],[\"than\",{\"1\":{\"302\":3,\"354\":1,\"553\":1,\"564\":1,\"798\":1}}],[\"that\",{\"1\":{\"86\":1,\"298\":1,\"302\":2,\"351\":4,\"553\":1,\"571\":1,\"618\":2,\"682\":2,\"693\":4,\"941\":1}}],[\"thirdparty\",{\"1\":{\"70\":2}}],[\"thisthread\",{\"1\":{\"604\":3}}],[\"this\",{\"0\":{\"330\":1},\"1\":{\"49\":2,\"56\":2,\"302\":1,\"325\":1,\"330\":1,\"354\":1,\"356\":1,\"534\":4,\"535\":4,\"536\":3,\"537\":2,\"538\":3,\"553\":5,\"555\":4,\"558\":1,\"570\":4,\"571\":4,\"576\":1,\"588\":1,\"591\":1,\"599\":3,\"602\":1,\"603\":1,\"604\":2,\"605\":1,\"618\":1,\"619\":6,\"621\":5,\"622\":3,\"624\":1,\"663\":6,\"677\":3,\"679\":1,\"680\":1,\"682\":1,\"693\":1,\"706\":1,\"709\":1,\"711\":1,\"727\":3,\"728\":1,\"742\":1,\"752\":1,\"756\":6,\"767\":4,\"768\":4,\"798\":3,\"837\":1,\"848\":1,\"851\":1,\"865\":2,\"871\":2,\"883\":1,\"884\":1,\"890\":6,\"894\":3,\"900\":4,\"904\":1,\"911\":6,\"920\":3,\"934\":2,\"936\":6,\"940\":2,\"941\":1,\"986\":1,\"1001\":2,\"1011\":2,\"1012\":1,\"1015\":1,\"1031\":2,\"1043\":2,\"1210\":10}}],[\"thrift支持多种不同的编程语言\",{\"1\":{\"1171\":1}}],[\"thrift\",{\"0\":{\"1171\":1},\"1\":{\"1154\":1,\"1161\":1,\"1171\":4,\"1172\":1}}],[\"threallocal\",{\"1\":{\"883\":1}}],[\"threadbean\",{\"1\":{\"1062\":2}}],[\"thread中的init\",{\"1\":{\"1043\":1}}],[\"threadgroup\",{\"1\":{\"1043\":1}}],[\"thread>\",{\"1\":{\"1030\":1}}],[\"thread类有一个类型为threadlocal\",{\"1\":{\"1029\":1}}],[\"thread类源代码入手\",{\"1\":{\"883\":1}}],[\"thread2\",{\"1\":{\"1020\":3}}],[\"thread1\",{\"1\":{\"1020\":3}}],[\"threadnameprefix\",{\"1\":{\"894\":1,\"920\":1}}],[\"threadnum\",{\"1\":{\"749\":6,\"753\":5,\"757\":54,\"894\":2,\"909\":1,\"920\":2}}],[\"thread内部都是使用仅有的那个threadlocalmap\",{\"1\":{\"883\":1}}],[\"threadlocal1\",{\"1\":{\"1040\":1}}],[\"threadlocalhashcode\",{\"1\":{\"1032\":3,\"1036\":2,\"1037\":2,\"1038\":1,\"1041\":1}}],[\"threadlocal中有一个属性为hash\",{\"1\":{\"1032\":1}}],[\"threadlocal中的set方法原理如上图所示\",{\"1\":{\"1031\":1}}],[\"threadlocal中threadlocalmap的数据结构\",{\"1\":{\"1026\":1}}],[\"threadlocaldemo\",{\"1\":{\"1030\":1}}],[\"threadlocaltest\",{\"1\":{\"1028\":4}}],[\"threadlocal的强引用仍然是存在的\",{\"1\":{\"1030\":1}}],[\"threadlocal的\",{\"1\":{\"1026\":1}}],[\"threadlocal共用\",{\"1\":{\"929\":1}}],[\"threadlocal方法后最好手动调用remove\",{\"1\":{\"884\":1}}],[\"threadlocal内部类\",{\"1\":{\"883\":1}}],[\"threadlocal对象可以提供线程局部变量\",{\"1\":{\"1028\":1}}],[\"threadlocal对象\",{\"1\":{\"883\":1}}],[\"threadlocal<string>\",{\"1\":{\"1043\":2}}],[\"threadlocal<simpledateformat>\",{\"1\":{\"882\":3}}],[\"threadlocal<t>\",{\"1\":{\"1032\":1}}],[\"threadlocal<threadlocaltest>\",{\"1\":{\"1028\":1}}],[\"threadlocal<>\",{\"1\":{\"1030\":2,\"1043\":1}}],[\"threadlocal<\",{\"1\":{\"883\":1,\"884\":1,\"1032\":1,\"1036\":4,\"1037\":2,\"1038\":1,\"1041\":3}}],[\"threadlocal类的set\",{\"1\":{\"883\":1}}],[\"threadlocal类主要解决的就是让每个线程绑定自己的值\",{\"1\":{\"881\":1}}],[\"threadlocals\",{\"1\":{\"883\":4,\"1030\":1,\"1031\":1}}],[\"threadlocalmap有点类似hashmap的结构\",{\"1\":{\"1029\":1}}],[\"threadlocalmap有自己的独立实现\",{\"1\":{\"1029\":1}}],[\"threadlocalmap中过期\",{\"1\":{\"1026\":1}}],[\"threadlocalmap中hash算法很简单\",{\"1\":{\"1032\":1}}],[\"threadlocalmap中hash\",{\"1\":{\"1026\":1}}],[\"threadlocalmap是threadlocal的静态内部类\",{\"1\":{\"883\":1}}],[\"threadlocalmap的实例变量threadlocals\",{\"1\":{\"1029\":1}}],[\"threadlocalmap的扩容机制\",{\"1\":{\"1026\":1}}],[\"threadlocalmap的hash\",{\"1\":{\"1026\":1}}],[\"threadlocalmap的\",{\"1\":{\"883\":1}}],[\"threadlocalmap\",{\"0\":{\"1032\":1,\"1033\":1,\"1034\":1,\"1035\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1},\"1\":{\"883\":8,\"884\":3,\"1026\":2,\"1030\":3,\"1031\":2,\"1032\":2,\"1033\":1,\"1036\":2,\"1041\":1}}],[\"threadlocalexample\",{\"1\":{\"882\":3}}],[\"threadlocal\",{\"0\":{\"880\":1,\"881\":1,\"882\":1,\"883\":1,\"884\":1,\"929\":1,\"1025\":1,\"1028\":1,\"1029\":1,\"1031\":1,\"1044\":1,\"1045\":1},\"1\":{\"876\":4,\"881\":1,\"882\":5,\"883\":9,\"884\":3,\"929\":1,\"1026\":1,\"1028\":1,\"1030\":4,\"1036\":2,\"1041\":1,\"1043\":5,\"1045\":1}}],[\"threadlocalrandom\",{\"1\":{\"713\":4,\"1141\":2,\"1142\":2}}],[\"threadinfos\",{\"1\":{\"807\":2}}],[\"threadinfo\",{\"1\":{\"807\":5,\"1062\":3}}],[\"threadid\",{\"1\":{\"49\":3}}],[\"threadmxbean\",{\"1\":{\"807\":3,\"1062\":1}}],[\"threadpooltaskexecutor\",{\"1\":{\"891\":2,\"928\":2,\"936\":2,\"1047\":1}}],[\"threadpool\",{\"1\":{\"749\":3,\"753\":3,\"757\":6,\"835\":3,\"894\":1,\"909\":3,\"918\":7,\"920\":1}}],[\"threadpoolexecutordemo\",{\"1\":{\"940\":2}}],[\"threadpoolexecutorconfig\",{\"1\":{\"928\":1}}],[\"threadpoolexecutor提供了获取线程池当前的线程数和活跃线程数\",{\"1\":{\"918\":1}}],[\"threadpoolexecutor构造函数\",{\"1\":{\"897\":1}}],[\"threadpoolexecutor其他常见参数\",{\"1\":{\"890\":1,\"936\":1}}],[\"threadpoolexecutor\",{\"0\":{\"935\":1,\"940\":1},\"1\":{\"530\":1,\"784\":2,\"888\":1,\"889\":4,\"890\":2,\"891\":7,\"894\":1,\"896\":2,\"897\":1,\"917\":1,\"918\":2,\"920\":1,\"923\":2,\"927\":3,\"928\":11,\"934\":8,\"935\":1,\"936\":13,\"937\":5,\"939\":2,\"940\":5,\"941\":1,\"944\":1,\"949\":2,\"953\":2,\"957\":2,\"961\":3,\"964\":1,\"1015\":1,\"1019\":1}}],[\"threadcount\",{\"1\":{\"749\":2,\"753\":1,\"757\":4,\"909\":3}}],[\"threadcontextclassloader\",{\"1\":{\"359\":1}}],[\"threadfactorybuilder\",{\"1\":{\"894\":2,\"920\":2}}],[\"threadfactory\",{\"0\":{\"1060\":1},\"1\":{\"530\":2,\"890\":6,\"894\":8,\"920\":8,\"936\":6,\"949\":3,\"953\":3,\"957\":3,\"962\":1,\"1057\":1,\"1060\":1}}],[\"threads=1\",{\"1\":{\"929\":1}}],[\"threadstacksize\",{\"1\":{\"449\":2}}],[\"threads\",{\"1\":{\"267\":4,\"274\":2,\"370\":1,\"808\":2,\"882\":1,\"918\":1,\"940\":2,\"1053\":1}}],[\"thread\",{\"0\":{\"826\":1,\"827\":1,\"1058\":1,\"1059\":1},\"1\":{\"56\":4,\"266\":1,\"274\":2,\"359\":2,\"370\":18,\"435\":1,\"531\":4,\"576\":1,\"601\":1,\"604\":2,\"688\":1,\"742\":1,\"748\":1,\"749\":2,\"752\":1,\"753\":5,\"756\":2,\"757\":2,\"781\":3,\"782\":2,\"785\":1,\"820\":2,\"823\":14,\"824\":11,\"825\":1,\"826\":2,\"827\":1,\"835\":1,\"882\":29,\"883\":6,\"894\":3,\"904\":1,\"906\":1,\"911\":2,\"918\":1,\"920\":3,\"928\":1,\"929\":1,\"934\":1,\"940\":23,\"941\":2,\"944\":3,\"964\":1,\"971\":1,\"975\":1,\"1002\":1,\"1005\":1,\"1007\":2,\"1008\":1,\"1011\":10,\"1012\":2,\"1013\":2,\"1014\":3,\"1015\":5,\"1020\":4,\"1030\":6,\"1031\":3,\"1043\":3,\"1052\":1,\"1053\":2,\"1057\":3,\"1058\":1,\"1059\":3,\"1060\":4,\"1062\":32,\"1183\":3}}],[\"threaddata\",{\"1\":{\"56\":6}}],[\"three\",{\"1\":{\"705\":2,\"706\":2}}],[\"threshold实际上是存放的初始化容量\",{\"1\":{\"621\":1}}],[\"thresholdtolerance是动态调整的\",{\"1\":{\"385\":1}}],[\"threshold\",{\"1\":{\"220\":1,\"386\":2,\"495\":1,\"571\":3,\"572\":1,\"577\":2,\"619\":5,\"621\":7,\"622\":3,\"624\":7,\"658\":1,\"677\":1,\"683\":2,\"686\":3,\"708\":2,\"712\":1,\"1036\":3,\"1038\":7}}],[\"throughput\",{\"1\":{\"386\":1}}],[\"through\",{\"0\":{\"146\":1},\"1\":{\"146\":6,\"147\":2}}],[\"thrownexception\",{\"1\":{\"1212\":2}}],[\"throwable>\",{\"1\":{\"779\":4}}],[\"throwable\",{\"1\":{\"77\":1,\"524\":1,\"779\":1,\"780\":4}}],[\"throw\",{\"1\":{\"53\":1,\"56\":1,\"533\":2,\"534\":2,\"536\":2,\"553\":6,\"555\":1,\"559\":1,\"570\":1,\"571\":1,\"577\":1,\"621\":2,\"630\":1,\"634\":2,\"677\":2,\"713\":4,\"730\":2,\"731\":2,\"732\":3,\"748\":4,\"752\":2,\"756\":7,\"765\":1,\"780\":2,\"798\":1,\"890\":2,\"900\":1,\"906\":1,\"911\":7,\"936\":2,\"941\":2,\"1001\":1,\"1007\":1,\"1008\":1,\"1011\":1,\"1014\":1,\"1018\":2,\"1043\":1,\"1209\":1,\"1213\":1}}],[\"throws\",{\"1\":{\"49\":1,\"56\":2,\"357\":1,\"531\":1,\"533\":4,\"535\":2,\"537\":2,\"555\":1,\"571\":1,\"604\":1,\"748\":3,\"749\":2,\"752\":3,\"753\":2,\"756\":2,\"757\":4,\"773\":2,\"798\":1,\"835\":1,\"882\":1,\"899\":2,\"906\":2,\"909\":1,\"911\":2,\"927\":1,\"943\":2,\"1020\":1,\"1030\":1,\"1046\":1,\"1131\":1,\"1209\":1,\"1210\":1}}],[\"thesis\",{\"1\":{\"1117\":2}}],[\"theorem\",{\"1\":{\"1066\":1,\"1067\":1}}],[\"theory\",{\"1\":{\"758\":1,\"999\":1}}],[\"thewindkee\",{\"1\":{\"1030\":1}}],[\"them\",{\"1\":{\"708\":1}}],[\"they\",{\"1\":{\"201\":1,\"708\":2}}],[\"their\",{\"1\":{\"201\":1}}],[\"thencombine\",{\"1\":{\"781\":5,\"787\":1}}],[\"thencomposeasync\",{\"1\":{\"781\":2}}],[\"thencompose\",{\"1\":{\"781\":9,\"787\":1}}],[\"thenrunasync\",{\"1\":{\"779\":2}}],[\"thenrun\",{\"1\":{\"779\":7}}],[\"thenacceptasync\",{\"1\":{\"779\":2}}],[\"thenaccept\",{\"1\":{\"779\":6}}],[\"thenapplyasync\",{\"1\":{\"779\":2}}],[\"thenapply\",{\"1\":{\"779\":12}}],[\"then\",{\"1\":{\"47\":1,\"49\":1,\"351\":2}}],[\"the\",{\"1\":{\"41\":1,\"86\":2,\"201\":1,\"205\":1,\"218\":1,\"237\":1,\"256\":6,\"293\":3,\"298\":2,\"302\":4,\"334\":1,\"351\":11,\"356\":7,\"370\":1,\"386\":5,\"401\":2,\"407\":1,\"408\":1,\"480\":5,\"511\":3,\"553\":1,\"571\":15,\"572\":1,\"576\":1,\"677\":1,\"680\":1,\"693\":5,\"708\":2,\"756\":1,\"798\":2,\"876\":1,\"884\":1,\"911\":1,\"974\":1,\"1011\":3,\"1014\":1,\"1022\":1,\"1096\":3,\"1178\":2,\"1333\":2}}],[\"there\",{\"1\":{\"41\":1,\"218\":1,\"302\":1,\"571\":1}}],[\"twice\",{\"1\":{\"708\":1}}],[\"twitter\",{\"1\":{\"38\":1}}],[\"two\",{\"1\":{\"41\":1,\"570\":1,\"677\":1,\"705\":2,\"706\":1}}],[\"term\",{\"1\":{\"1109\":8,\"1111\":6,\"1112\":3,\"1114\":3}}],[\"terminated\",{\"1\":{\"820\":2}}],[\"terminator\",{\"1\":{\"256\":4}}],[\"teachernum\",{\"1\":{\"974\":2}}],[\"temvalue\",{\"1\":{\"763\":13,\"766\":10}}],[\"template\",{\"1\":{\"1046\":2}}],[\"temp\",{\"1\":{\"328\":2}}],[\"test2\",{\"1\":{\"764\":1}}],[\"test\",{\"1\":{\"687\":8,\"749\":3,\"753\":2,\"757\":4,\"764\":1,\"928\":1,\"1001\":2,\"1030\":2,\"1209\":6,\"1213\":1,\"1310\":1,\"1311\":1}}],[\"tellurdream\",{\"1\":{\"425\":1}}],[\"tenuring\",{\"1\":{\"386\":2,\"495\":1}}],[\"tendis\",{\"1\":{\"244\":5}}],[\"tencent\",{\"1\":{\"11\":1,\"876\":1}}],[\"textmessage\",{\"1\":{\"1226\":1,\"1231\":1}}],[\"text\",{\"1\":{\"103\":1,\"104\":1,\"882\":1,\"1154\":1}}],[\"technotes\",{\"1\":{\"386\":1}}],[\"techstacks\",{\"1\":{\"242\":1}}],[\"tech\",{\"1\":{\"11\":1,\"320\":1,\"758\":1,\"876\":1,\"982\":1,\"999\":1}}],[\"场景\",{\"1\":{\"561\":1,\"562\":1}}],[\"场景三\",{\"0\":{\"24\":1}}],[\"场景二\",{\"0\":{\"20\":1}}],[\"场景一\",{\"0\":{\"16\":1}}],[\"分散成了\",{\"1\":{\"1358\":1}}],[\"分散式发散消息\",{\"1\":{\"1083\":1}}],[\"分组内其它消费者会接替挂掉的消费者继续消费\",{\"1\":{\"1280\":1}}],[\"分隔开的每一段独立的字符串称为一个单词\",{\"1\":{\"1252\":1}}],[\"分隔的字符串\",{\"1\":{\"1252\":2}}],[\"分层式存储可在数据陈旧时\",{\"1\":{\"1238\":1}}],[\"分布在多个\",{\"1\":{\"1281\":1}}],[\"分布在不同的\",{\"1\":{\"1280\":1}}],[\"分布到不同的\",{\"1\":{\"1199\":1}}],[\"分布式与集群的区别\",{\"1\":{\"1391\":1}}],[\"分布式和集群\",{\"1\":{\"1367\":1}}],[\"分布式同步\",{\"1\":{\"1367\":1}}],[\"分布式一致性原理与实践\",{\"1\":{\"1349\":1,\"1363\":1}}],[\"分布式一致性的\",{\"1\":{\"1078\":1}}],[\"分布式组件\",{\"1\":{\"1218\":1}}],[\"分布式消息队列技术选型\",{\"0\":{\"1233\":1}}],[\"分布式消息队列\",{\"1\":{\"1180\":1}}],[\"分布式重要的就是面向服务\",{\"1\":{\"1125\":1}}],[\"分布式或者说\",{\"1\":{\"1125\":1}}],[\"分布式基础\",{\"0\":{\"1124\":1}}],[\"分布式服务架构下\",{\"1\":{\"1123\":1}}],[\"分布式共识可以帮助应对这些挑战\",{\"1\":{\"1104\":1}}],[\"分布式理论\",{\"2\":{\"1081\":1}}],[\"分布式协调\",{\"1\":{\"1344\":1,\"1346\":1}}],[\"分布式协调服务框架\",{\"1\":{\"1367\":1}}],[\"分布式协调服务\",{\"1\":{\"63\":1}}],[\"分布式协议\",{\"2\":{\"1094\":1,\"1102\":1,\"1119\":1}}],[\"分布式协议与算法实战\",{\"1\":{\"1078\":1,\"1092\":1}}],[\"分布式系统理论上不可能选择\",{\"1\":{\"1068\":1}}],[\"分布式系统中的一致性与共识算法\",{\"1\":{\"1100\":1}}],[\"分布式系统中的各个节点需要互相通信\",{\"1\":{\"1085\":1}}],[\"分布式系统中\",{\"1\":{\"1067\":1}}],[\"分布式系统出现网络分区的时候\",{\"1\":{\"1067\":1}}],[\"分布式系统下\",{\"1\":{\"60\":1,\"63\":1}}],[\"分布式限流器\",{\"1\":{\"249\":1}}],[\"分布式缓存的话\",{\"1\":{\"244\":1}}],[\"分布式缓存常见的技术选型方案有哪些\",{\"0\":{\"244\":1}}],[\"分布式事务的处理\",{\"1\":{\"1367\":1}}],[\"分布式事务等\",{\"1\":{\"1367\":1}}],[\"分布式事务等等\",{\"1\":{\"1316\":1}}],[\"分布式事务详解\",{\"1\":{\"1223\":2}}],[\"分布式事务示意图\",{\"1\":{\"1125\":1}}],[\"分布式事务\",{\"1\":{\"65\":1,\"1275\":1,\"1370\":1}}],[\"分布式事务常见解决方案总结\",{\"0\":{\"65\":1}}],[\"分布式键值存储系统比如\",{\"1\":{\"63\":1}}],[\"分布式读写锁\",{\"1\":{\"53\":1}}],[\"分布式不可重入排它锁\",{\"1\":{\"53\":2}}],[\"分布式可重入排它锁\",{\"1\":{\"53\":2}}],[\"分布式锁和分布式队列等功能\",{\"1\":{\"1344\":1,\"1346\":1}}],[\"分布式锁详解\",{\"1\":{\"249\":1,\"250\":1,\"1346\":1}}],[\"分布式锁来保证更新\",{\"1\":{\"145\":1}}],[\"分布式锁的实现方式有很多种\",{\"1\":{\"1388\":1}}],[\"分布式锁的实现也需要用到\",{\"1\":{\"1346\":1}}],[\"分布式锁的常见实现方式\",{\"1\":{\"63\":1}}],[\"分布式锁的常见实现方式有哪些\",{\"0\":{\"62\":1}}],[\"分布式锁的应该具备的条件\",{\"1\":{\"63\":1}}],[\"分布式锁的用途\",{\"1\":{\"63\":1}}],[\"分布式锁应该具备哪些条件\",{\"0\":{\"61\":1}}],[\"分布式锁介绍\",{\"0\":{\"59\":1}}],[\"分布式锁\",{\"0\":{\"1388\":1},\"1\":{\"53\":1,\"60\":2,\"178\":1,\"249\":1,\"254\":1,\"1341\":1,\"1346\":1,\"1381\":1}}],[\"分布式锁是基于\",{\"1\":{\"53\":1}}],[\"分布式锁服务就是正常的\",{\"1\":{\"51\":1}}],[\"分布式锁实现\",{\"1\":{\"47\":1}}],[\"分布式锁常见实现方案总结\",{\"0\":{\"45\":1},\"1\":{\"62\":1}}],[\"分布式id介绍\",{\"0\":{\"26\":1}}],[\"分布式id设计指南\",{\"0\":{\"15\":1}}],[\"分布式配置中心\",{\"1\":{\"13\":1}}],[\"分布式配置中心常见问题总结\",{\"0\":{\"13\":1}}],[\"分布式\",{\"0\":{\"27\":1,\"30\":1,\"31\":1},\"1\":{\"15\":1,\"29\":2,\"30\":2,\"43\":1,\"249\":1,\"1276\":1,\"1367\":3},\"2\":{\"12\":1,\"14\":1,\"25\":1,\"44\":1,\"58\":1,\"64\":1,\"66\":1,\"79\":1,\"1080\":1,\"1093\":1,\"1101\":1,\"1118\":1,\"1148\":1,\"1162\":1,\"1175\":1,\"1339\":1,\"1364\":1,\"1392\":1}}],[\"分布式链路追踪系统\",{\"1\":{\"8\":2}}],[\"分区\",{\"1\":{\"1068\":1,\"1070\":5,\"1074\":3,\"1106\":1,\"1194\":1,\"1196\":2,\"1197\":1,\"1202\":5,\"1205\":2,\"1206\":2,\"1280\":1,\"1298\":1}}],[\"分区容忍性三者你只能同时达到其中两个\",{\"1\":{\"1068\":1}}],[\"分区容错性\",{\"1\":{\"1067\":2}}],[\"分区的作用就是牺牲硬盘\",{\"1\":{\"168\":1}}],[\"分发处理给\",{\"1\":{\"807\":1}}],[\"分段锁的设计\",{\"1\":{\"692\":1}}],[\"分段锁来保证安全\",{\"1\":{\"692\":1}}],[\"分段锁\",{\"1\":{\"688\":1,\"691\":1,\"792\":1}}],[\"分段的数组+链表\",{\"1\":{\"688\":1}}],[\"分段复制\",{\"1\":{\"591\":1}}],[\"分代年龄\",{\"1\":{\"507\":1}}],[\"分代年龄等信息\",{\"1\":{\"505\":1}}],[\"分代收集\",{\"1\":{\"407\":1}}],[\"分代收集算法\",{\"0\":{\"399\":1}}],[\"分支上的最新的版本\",{\"1\":{\"1141\":1}}],[\"分支\",{\"1\":{\"492\":1}}],[\"分割为多个小\",{\"1\":{\"294\":1}}],[\"分割\",{\"1\":{\"294\":1}}],[\"分钟学会如何在\",{\"1\":{\"1204\":1}}],[\"分钟未支付直接取消\",{\"1\":{\"597\":1}}],[\"分钟后\",{\"1\":{\"272\":1}}],[\"分钟\",{\"1\":{\"272\":1,\"307\":1}}],[\"分钟内有效\",{\"1\":{\"270\":1}}],[\"分分钟直接\",{\"1\":{\"270\":1}}],[\"分配一个存储文件\",{\"1\":{\"1315\":1}}],[\"分配\",{\"1\":{\"503\":1,\"624\":1}}],[\"分配方式有\",{\"1\":{\"503\":1}}],[\"分配最小\",{\"1\":{\"478\":1}}],[\"分配了10m空间给数组\",{\"1\":{\"451\":1}}],[\"分配了1m空间给数组\",{\"1\":{\"451\":1}}],[\"分配失败\",{\"1\":{\"451\":1}}],[\"分配到的空间仅有\",{\"1\":{\"444\":1}}],[\"分配担保机制\",{\"1\":{\"384\":1}}],[\"分配内存空间\",{\"1\":{\"834\":1}}],[\"分配内存\",{\"0\":{\"503\":1}}],[\"分配内存的时候\",{\"1\":{\"384\":1}}],[\"分配内存会出现什么情况呢\",{\"1\":{\"384\":1}}],[\"分配好内存\",{\"1\":{\"256\":1}}],[\"分配指定大小的内存\",{\"1\":{\"218\":1}}],[\"分享一下\",{\"1\":{\"243\":1}}],[\"分析了\",{\"1\":{\"1267\":1,\"1316\":1}}],[\"分析一下到底是咋回事\",{\"1\":{\"941\":1}}],[\"分析一下\",{\"1\":{\"553\":1,\"586\":1,\"600\":1,\"727\":1}}],[\"分析工具jvisualvm等\",{\"1\":{\"516\":1}}],[\"分析\",{\"0\":{\"369\":1},\"1\":{\"412\":4}}],[\"分析功能\",{\"1\":{\"293\":1,\"298\":1}}],[\"分析服务\",{\"1\":{\"293\":1,\"298\":1}}],[\"分析或者写入操作\",{\"1\":{\"233\":1}}],[\"分析器\",{\"0\":{\"86\":1},\"1\":{\"81\":1,\"82\":1,\"90\":2}}],[\"分为好几种情况\",{\"1\":{\"1035\":1}}],[\"分为两种情况\",{\"1\":{\"141\":1}}],[\"分为\",{\"1\":{\"54\":1,\"1129\":1,\"1335\":1,\"1349\":1}}],[\"分别表示一级缓存\",{\"1\":{\"1184\":1}}],[\"分别对应着两个队列\",{\"1\":{\"1280\":1}}],[\"分别对应非叶子节点和叶子节点\",{\"1\":{\"109\":1}}],[\"分别对同一个共享变量进行操作\",{\"1\":{\"972\":1}}],[\"分别叫\",{\"1\":{\"968\":1}}],[\"分别添加1s\",{\"1\":{\"599\":1}}],[\"分别要求\",{\"1\":{\"599\":1}}],[\"分别称为泛型类\",{\"1\":{\"522\":1}}],[\"分别用来获取和设置线程的上下文类加载器\",{\"1\":{\"359\":1}}],[\"分别向对应的\",{\"1\":{\"286\":1}}],[\"分别为\",{\"1\":{\"231\":1,\"1252\":1,\"1315\":1,\"1372\":2}}],[\"分别是协调者和参与者\",{\"1\":{\"1370\":1}}],[\"分别是日志文件\",{\"1\":{\"133\":1}}],[\"分别是\",{\"1\":{\"23\":1,\"1361\":1,\"1378\":1,\"1380\":1}}],[\"分别具备以下特点\",{\"1\":{\"19\":1}}],[\"72m\",{\"1\":{\"1315\":1}}],[\"7292380\",{\"1\":{\"360\":1}}],[\"7前移之后\",{\"1\":{\"1040\":1}}],[\"7的数据都会前移\",{\"1\":{\"1040\":1}}],[\"7的数据到index=5中\",{\"1\":{\"1037\":1}}],[\"7121882245605883934\",{\"1\":{\"1150\":1}}],[\"71156910\",{\"1\":{\"996\":1}}],[\"7141160\",{\"1\":{\"913\":1}}],[\"78\",{\"1\":{\"996\":1}}],[\"783\",{\"1\":{\"231\":1}}],[\"739920a92d0d27e2053174ef2\",{\"1\":{\"982\":1}}],[\"7360\",{\"1\":{\"365\":2,\"370\":1}}],[\"7is\",{\"1\":{\"757\":4}}],[\"791\",{\"1\":{\"687\":1}}],[\"7972\",{\"1\":{\"365\":2,\"370\":1}}],[\"7031196740128768037\",{\"1\":{\"913\":1}}],[\"70\",{\"1\":{\"449\":1,\"451\":2,\"1155\":1}}],[\"7000\",{\"1\":{\"369\":2}}],[\"748\",{\"1\":{\"370\":2}}],[\"7567\",{\"1\":{\"713\":1}}],[\"75=1\",{\"1\":{\"570\":1}}],[\"75f\",{\"1\":{\"570\":1,\"619\":2,\"705\":1,\"706\":1}}],[\"75\",{\"1\":{\"293\":1,\"342\":1,\"570\":2,\"619\":2}}],[\"7之后可以使用mysql\",{\"1\":{\"84\":1}}],[\"7~8\",{\"1\":{\"35\":1}}],[\"7\",{\"0\":{\"444\":1,\"457\":1,\"458\":1,\"459\":1,\"467\":1,\"568\":1,\"692\":1,\"925\":1},\"1\":{\"19\":1,\"127\":1,\"128\":1,\"129\":1,\"174\":1,\"202\":4,\"231\":2,\"233\":3,\"236\":1,\"256\":1,\"283\":1,\"327\":1,\"328\":1,\"338\":2,\"342\":3,\"343\":2,\"382\":2,\"384\":1,\"393\":3,\"407\":1,\"427\":1,\"444\":2,\"480\":1,\"485\":1,\"491\":3,\"495\":3,\"496\":1,\"497\":1,\"498\":4,\"529\":1,\"531\":2,\"552\":1,\"569\":2,\"570\":1,\"598\":1,\"618\":4,\"622\":1,\"631\":1,\"642\":1,\"653\":6,\"656\":1,\"662\":10,\"682\":4,\"685\":1,\"686\":2,\"687\":1,\"688\":3,\"691\":1,\"692\":3,\"694\":1,\"708\":2,\"788\":1,\"792\":1,\"800\":1,\"882\":2,\"1011\":1,\"1035\":2,\"1122\":1,\"1140\":1,\"1141\":4,\"1143\":1,\"1144\":2,\"1257\":1,\"1330\":1,\"1335\":1}}],[\"前段时间有同学和我探讨起分布式的东西\",{\"1\":{\"1367\":1}}],[\"前一阶段获得的最新提议历史\",{\"1\":{\"1356\":1}}],[\"前几天\",{\"1\":{\"1341\":1}}],[\"前者对用户不友好\",{\"1\":{\"1304\":1}}],[\"前者是在内存中\",{\"1\":{\"135\":1}}],[\"前提是不存在拜占庭将军问题\",{\"1\":{\"1096\":1}}],[\"前置节点是头结点\",{\"1\":{\"1012\":1}}],[\"前驱指针\",{\"1\":{\"1005\":1}}],[\"前驱节点的waitstatus为\",{\"1\":{\"1012\":1}}],[\"前驱节点\",{\"1\":{\"742\":1,\"904\":1}}],[\"前驱结点\",{\"1\":{\"727\":2}}],[\"前后加起来大概\",{\"1\":{\"684\":1}}],[\"前后多次读取\",{\"0\":{\"128\":1,\"129\":1}}],[\"前面说了这么多的理论知识\",{\"1\":{\"1386\":1}}],[\"前面讲到\",{\"1\":{\"1252\":1}}],[\"前面我们也讲到了\",{\"1\":{\"861\":1}}],[\"前面一个例子的string类已经默认实现了comparable接口\",{\"1\":{\"663\":1}}],[\"前面的b+树节点分裂以及page的分裂\",{\"1\":{\"108\":1}}],[\"前言\",{\"0\":{\"381\":1,\"416\":1,\"490\":1,\"1026\":1}}],[\"前的\",{\"1\":{\"184\":1}}],[\"前\",{\"1\":{\"19\":1,\"22\":1,\"38\":1,\"708\":1,\"1184\":1}}],[\"年底贡献给\",{\"1\":{\"1276\":1}}],[\"年在\",{\"1\":{\"1178\":1}}],[\"年写的一篇文章\",{\"1\":{\"1178\":1}}],[\"年出来的\",{\"1\":{\"1160\":1}}],[\"年代\",{\"1\":{\"1155\":2,\"1379\":2}}],[\"年度\",{\"1\":{\"1122\":1}}],[\"年才诞生了一个比\",{\"1\":{\"1097\":1}}],[\"年重新发表论文\",{\"1\":{\"1096\":1}}],[\"年重写了之前的论文\",{\"1\":{\"1068\":1}}],[\"年提出了一种分布式系统共识算法\",{\"1\":{\"1097\":1}}],[\"年提出了一种分布式系统\",{\"1\":{\"1096\":1}}],[\"年之后\",{\"1\":{\"1068\":1}}],[\"年发表的论文\",{\"1\":{\"974\":1,\"1084\":1}}],[\"年老代大小\",{\"1\":{\"450\":1}}],[\"年龄\",{\"1\":{\"444\":2}}],[\"年龄就增加\",{\"1\":{\"386\":1}}],[\"年轻代占整个堆栈的\",{\"1\":{\"449\":1}}],[\"年轻代\",{\"1\":{\"449\":1}}],[\"年轻代最大值\",{\"1\":{\"449\":1}}],[\"年轻代大小\",{\"1\":{\"449\":1}}],[\"年轻代的介绍\",{\"0\":{\"444\":1}}],[\"年轻代又会分为eden和survivor区\",{\"1\":{\"443\":1}}],[\"年的时候\",{\"1\":{\"1096\":1}}],[\"年的\",{\"1\":{\"249\":1,\"1178\":2}}],[\"年后\",{\"1\":{\"40\":1,\"1066\":1}}],[\"年\",{\"1\":{\"19\":1,\"38\":1,\"412\":1,\"1066\":1,\"1072\":1,\"1096\":1,\"1155\":1}}],[\"号小于自己的\",{\"1\":{\"1111\":1}}],[\"号大于等于自己的\",{\"1\":{\"1111\":1}}],[\"号并且转换状态为\",{\"1\":{\"1111\":1}}],[\"号是过期的\",{\"1\":{\"1109\":1}}],[\"号比其他人小\",{\"1\":{\"1109\":1}}],[\"号段的长度\",{\"1\":{\"34\":1}}],[\"号段模式\",{\"1\":{\"24\":1,\"41\":1}}],[\"号\",{\"1\":{\"19\":1,\"1109\":3,\"1111\":2}}],[\"b在接收请求时会先判断请求的header中是否有traceid\",{\"1\":{\"1045\":1}}],[\"b的时候\",{\"1\":{\"1045\":1}}],[\"bf97a12\",{\"1\":{\"1030\":1}}],[\"b1\",{\"1\":{\"441\":2}}],[\"b12\",{\"1\":{\"403\":2}}],[\"bb\",{\"1\":{\"316\":1,\"498\":1}}],[\"bypass\",{\"1\":{\"871\":2}}],[\"by\",{\"1\":{\"302\":1,\"351\":3,\"370\":2,\"571\":1,\"618\":1,\"682\":1,\"720\":1,\"882\":1}}],[\"byte数组\",{\"1\":{\"1335\":1}}],[\"bytesmessage\",{\"1\":{\"1226\":1}}],[\"bytes\",{\"1\":{\"220\":1,\"293\":4}}],[\"byte\",{\"1\":{\"201\":1,\"212\":1,\"256\":1,\"261\":1,\"384\":9,\"451\":4,\"485\":1,\"493\":1,\"1231\":2}}],[\"brewer\",{\"1\":{\"1066\":2}}],[\"breakbarrier\",{\"1\":{\"756\":4,\"911\":4}}],[\"break\",{\"1\":{\"386\":1,\"495\":1,\"531\":1,\"571\":4,\"576\":1,\"577\":5,\"622\":2,\"683\":2,\"941\":1}}],[\"broadcast\",{\"1\":{\"1281\":1,\"1354\":1,\"1356\":1,\"1360\":1,\"1377\":1}}],[\"broadcasttime应该比electiontimeout小一个数量级\",{\"1\":{\"1116\":1}}],[\"broadcasttime\",{\"1\":{\"1116\":3}}],[\"broker重启情况下不会保证消息顺序性\",{\"1\":{\"1299\":1}}],[\"broker做了集群并且还进行了主从部署\",{\"1\":{\"1281\":1}}],[\"broker上\",{\"1\":{\"1281\":1}}],[\"broker又分布在不同的服务器中\",{\"1\":{\"1280\":1}}],[\"broker中\",{\"1\":{\"1280\":1}}],[\"brokers\",{\"1\":{\"1199\":3}}],[\"broker\",{\"0\":{\"1196\":1,\"1251\":1,\"1255\":1},\"1\":{\"1196\":5,\"1197\":1,\"1199\":9,\"1206\":2,\"1245\":1,\"1251\":4,\"1255\":2,\"1258\":1,\"1281\":32,\"1299\":1,\"1301\":4,\"1302\":1,\"1303\":1,\"1306\":2,\"1313\":2,\"1314\":1,\"1315\":2,\"1316\":1,\"1344\":1}}],[\"broken\",{\"1\":{\"756\":4,\"911\":4}}],[\"brokenbarrierexception\",{\"1\":{\"756\":4,\"757\":4,\"911\":4}}],[\"brown\",{\"1\":{\"633\":1}}],[\"browser\",{\"1\":{\"364\":1,\"1155\":2}}],[\"browse\",{\"1\":{\"24\":1}}],[\"brpop\",{\"1\":{\"251\":2}}],[\"blpop\",{\"1\":{\"251\":1}}],[\"blocked\",{\"1\":{\"820\":2}}],[\"block\",{\"1\":{\"749\":1,\"757\":4,\"799\":1}}],[\"blockingwaitstrategy\",{\"1\":{\"1183\":2}}],[\"blockingqueue阻塞的原因是其支持当队列没有元素时一直阻塞\",{\"1\":{\"670\":1}}],[\"blockingqueue<e>\",{\"1\":{\"533\":1,\"600\":1,\"670\":1,\"797\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"530\":1,\"890\":1,\"936\":1,\"941\":1}}],[\"blockingqueue\",{\"0\":{\"670\":1,\"671\":1,\"795\":1,\"796\":1},\"1\":{\"533\":7,\"541\":1,\"545\":2,\"597\":2,\"600\":1,\"670\":3,\"671\":1,\"791\":1,\"794\":1,\"796\":7,\"797\":2,\"799\":1}}],[\"blocking\",{\"1\":{\"499\":1}}],[\"bloch\",{\"1\":{\"656\":1,\"724\":1}}],[\"bloom\",{\"1\":{\"253\":1}}],[\"bloomfilter\",{\"1\":{\"213\":1}}],[\"bloking\",{\"1\":{\"251\":1}}],[\"blob\",{\"1\":{\"218\":1,\"256\":1,\"268\":1,\"1117\":2}}],[\"blobs\",{\"1\":{\"201\":1}}],[\"blogs\",{\"1\":{\"1178\":1}}],[\"blog\",{\"1\":{\"11\":2,\"69\":1,\"78\":1,\"334\":1,\"360\":1,\"409\":1,\"522\":1,\"612\":1,\"633\":1,\"876\":1,\"1030\":1}}],[\"bsd\",{\"1\":{\"242\":1}}],[\"bst\",{\"0\":{\"97\":1}}],[\"busyspinwaitstrategy\",{\"1\":{\"1183\":1}}],[\"bucket\",{\"1\":{\"619\":2,\"686\":1,\"702\":1,\"708\":3,\"711\":1,\"712\":2,\"713\":3}}],[\"bug\",{\"1\":{\"377\":1,\"1143\":1}}],[\"builder\",{\"1\":{\"1333\":1}}],[\"build\",{\"1\":{\"403\":2,\"894\":1,\"920\":1,\"1290\":2,\"1293\":2,\"1333\":1}}],[\"buildatscale\",{\"1\":{\"320\":1}}],[\"built\",{\"1\":{\"356\":1}}],[\"but\",{\"1\":{\"201\":1,\"351\":1,\"356\":1,\"693\":1,\"882\":1}}],[\"buf\",{\"1\":{\"161\":1,\"229\":1,\"256\":7}}],[\"buffers\",{\"1\":{\"1159\":1}}],[\"buffer\",{\"1\":{\"135\":1,\"147\":1,\"499\":1,\"1170\":1}}],[\"bgrewriteaof\",{\"1\":{\"162\":1,\"233\":1}}],[\"bgsave\",{\"1\":{\"158\":2,\"227\":1,\"236\":1}}],[\"being\",{\"1\":{\"1011\":2}}],[\"belong\",{\"1\":{\"756\":1,\"911\":1}}],[\"below\",{\"1\":{\"571\":1}}],[\"been\",{\"1\":{\"756\":1,\"911\":1}}],[\"become\",{\"1\":{\"708\":1}}],[\"because\",{\"1\":{\"708\":1}}],[\"benchmark\",{\"1\":{\"687\":2}}],[\"best\",{\"1\":{\"570\":1}}],[\"before\",{\"0\":{\"974\":1,\"975\":1,\"976\":1},\"1\":{\"356\":1,\"708\":4,\"710\":3,\"711\":3,\"971\":1,\"974\":20,\"975\":9,\"976\":2,\"981\":1,\"1011\":1}}],[\"bean\",{\"1\":{\"329\":1,\"928\":1,\"1211\":1}}],[\"be\",{\"1\":{\"302\":1,\"553\":1,\"564\":1,\"571\":4,\"693\":2,\"1043\":1,\"1333\":1}}],[\"between\",{\"1\":{\"237\":1,\"298\":1,\"693\":1,\"1116\":1,\"1333\":1}}],[\"behind\",{\"0\":{\"147\":1},\"1\":{\"147\":3}}],[\"begin\",{\"1\":{\"33\":1}}],[\"borker\",{\"1\":{\"1314\":1}}],[\"body\",{\"1\":{\"1159\":5}}],[\"boxed\",{\"1\":{\"634\":1}}],[\"bounded\",{\"1\":{\"618\":1,\"682\":1}}],[\"bounds\",{\"1\":{\"553\":1}}],[\"bookkeeper\",{\"1\":{\"1238\":1}}],[\"booklist\",{\"1\":{\"630\":4}}],[\"boot\",{\"1\":{\"1178\":2,\"1204\":1}}],[\"bootstrap\",{\"1\":{\"356\":2,\"432\":1,\"433\":1}}],[\"bootstrapclassloader\",{\"1\":{\"345\":1,\"353\":4,\"354\":1,\"357\":1,\"358\":2,\"359\":2}}],[\"boolean\",{\"1\":{\"49\":1,\"56\":1,\"353\":1,\"354\":2,\"357\":1,\"493\":1,\"533\":7,\"534\":2,\"536\":3,\"537\":1,\"538\":1,\"539\":4,\"553\":8,\"557\":1,\"571\":1,\"577\":1,\"588\":1,\"591\":2,\"592\":2,\"593\":1,\"603\":1,\"619\":2,\"621\":1,\"622\":2,\"629\":1,\"632\":2,\"634\":2,\"680\":3,\"686\":4,\"697\":1,\"705\":1,\"706\":2,\"709\":1,\"711\":2,\"712\":4,\"729\":1,\"731\":1,\"732\":2,\"742\":1,\"744\":4,\"747\":1,\"748\":2,\"752\":3,\"756\":2,\"762\":1,\"763\":1,\"766\":1,\"767\":13,\"773\":4,\"774\":4,\"777\":1,\"841\":3,\"843\":1,\"857\":2,\"862\":1,\"865\":2,\"899\":4,\"904\":1,\"905\":1,\"906\":1,\"911\":2,\"934\":1,\"941\":5,\"990\":3,\"992\":1,\"1006\":1,\"1007\":5,\"1008\":1,\"1011\":2,\"1012\":5,\"1013\":2,\"1014\":4,\"1015\":4,\"1020\":3,\"1030\":1,\"1042\":2,\"1043\":1,\"1046\":1,\"1141\":1,\"1142\":1,\"1210\":2}}],[\"boss\",{\"1\":{\"133\":1}}],[\"b却没有收到\",{\"1\":{\"125\":1}}],[\"b树索引是mysql中最常见的索引类型\",{\"1\":{\"103\":1}}],[\"b树的每个结点都存储了key和data\",{\"1\":{\"101\":1}}],[\"b+tree结构\",{\"1\":{\"114\":1}}],[\"b+tree的叶子节点存放的是主键字段值\",{\"1\":{\"113\":1}}],[\"b+tree\",{\"1\":{\"101\":1,\"114\":1}}],[\"b+树存在的数据总量\",{\"1\":{\"110\":1}}],[\"b+树叶子节点存储的是指向数据的指针\",{\"1\":{\"107\":1}}],[\"b+树叶子结点是一个链表\",{\"1\":{\"101\":1}}],[\"b+树查询路径都是从非叶子结点\",{\"1\":{\"101\":1}}],[\"b+树的data存储在叶子节点上\",{\"1\":{\"101\":1}}],[\"b+树是b树的一种优化\",{\"1\":{\"101\":1}}],[\"b+树与b\",{\"0\":{\"101\":1}}],[\"b+树\",{\"0\":{\"100\":1},\"1\":{\"98\":1,\"100\":1}}],[\"bash\",{\"1\":{\"1322\":1}}],[\"basicack\",{\"1\":{\"1261\":1}}],[\"basically\",{\"1\":{\"1073\":1}}],[\"basic\",{\"0\":{\"1098\":1},\"1\":{\"1097\":5,\"1098\":2,\"1099\":5,\"1256\":2}}],[\"basesleeptimems\",{\"1\":{\"1333\":1}}],[\"base理论三要素\",{\"1\":{\"1075\":1}}],[\"base理论详解\",{\"0\":{\"1065\":1}}],[\"baseconstant\",{\"1\":{\"1046\":1}}],[\"basecount\",{\"1\":{\"629\":1}}],[\"base\",{\"0\":{\"1072\":1,\"1074\":1,\"1075\":1},\"1\":{\"231\":3,\"233\":2,\"353\":1,\"1065\":1,\"1072\":1,\"1073\":2,\"1074\":2,\"1079\":1,\"1333\":2}}],[\"base64\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"basepath\",{\"1\":{\"56\":1}}],[\"banana\",{\"1\":{\"634\":2,\"732\":2,\"733\":5}}],[\"bank\",{\"1\":{\"135\":2}}],[\"batchremove\",{\"1\":{\"553\":2}}],[\"baoyinwang\",{\"1\":{\"522\":1}}],[\"baeldung\",{\"1\":{\"360\":1,\"475\":1,\"876\":2}}],[\"ballcat\",{\"1\":{\"293\":2}}],[\"balance=$80\",{\"1\":{\"840\":1,\"989\":1}}],[\"balance=$50\",{\"1\":{\"840\":1,\"989\":1}}],[\"balance=600\",{\"1\":{\"135\":1}}],[\"balance\",{\"1\":{\"135\":3,\"141\":2,\"840\":1,\"989\":1,\"1245\":1}}],[\"backoff\",{\"1\":{\"1210\":1,\"1212\":2,\"1213\":2}}],[\"backoffhandler\",{\"1\":{\"1210\":1}}],[\"backoffexecution\",{\"1\":{\"1210\":3}}],[\"backup\",{\"1\":{\"1011\":1,\"1014\":1}}],[\"back\",{\"1\":{\"281\":1,\"708\":1,\"1210\":3}}],[\"background\",{\"1\":{\"268\":1}}],[\"barriercommand\",{\"1\":{\"756\":2,\"911\":2}}],[\"barrieraction\",{\"1\":{\"756\":2,\"757\":2,\"911\":2}}],[\"barrier\",{\"1\":{\"755\":1,\"756\":1,\"910\":1,\"911\":1,\"969\":2,\"1184\":1}}],[\"barely\",{\"1\":{\"693\":1}}],[\"bar\",{\"1\":{\"206\":2}}],[\"baidu\",{\"1\":{\"24\":1}}],[\"b9bb\",{\"1\":{\"37\":1}}],[\"biconsumer\",{\"1\":{\"779\":1}}],[\"biconsumer<t\",{\"1\":{\"779\":2}}],[\"biconsumer<\",{\"1\":{\"779\":5}}],[\"biconsumer<m\",{\"1\":{\"630\":1}}],[\"bifunction<\",{\"1\":{\"630\":1,\"780\":3}}],[\"biokillthreads\",{\"1\":{\"268\":1}}],[\"bioolderjoboftype\",{\"1\":{\"268\":1}}],[\"biowaitstepoftype\",{\"1\":{\"268\":1}}],[\"biopendingjobsoftype\",{\"1\":{\"268\":1}}],[\"biocreatebackgroundjob\",{\"1\":{\"268\":1}}],[\"bioinit\",{\"1\":{\"268\":1}}],[\"bio\",{\"1\":{\"268\":10}}],[\"biggest\",{\"1\":{\"293\":5}}],[\"big\",{\"1\":{\"164\":1,\"205\":1,\"293\":1}}],[\"bigkeys\",{\"1\":{\"164\":2,\"293\":4}}],[\"bigkey\",{\"0\":{\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":1},\"1\":{\"163\":1,\"166\":1,\"291\":1,\"292\":3,\"293\":2,\"294\":3,\"320\":2}}],[\"bigint\",{\"1\":{\"33\":1,\"34\":1}}],[\"binding\",{\"1\":{\"1249\":3,\"1253\":1}}],[\"bindingkey\",{\"1\":{\"1249\":5,\"1252\":5}}],[\"bins\",{\"1\":{\"708\":4}}],[\"bincount\",{\"1\":{\"577\":6,\"622\":2,\"683\":2}}],[\"bin\",{\"1\":{\"364\":1,\"372\":1,\"577\":1,\"1322\":4}}],[\"binarysearch\",{\"1\":{\"658\":2,\"697\":1}}],[\"binaryoperator<u>\",{\"1\":{\"630\":1}}],[\"binary\",{\"1\":{\"97\":2,\"201\":1,\"351\":1}}],[\"binlog\",{\"1\":{\"89\":23,\"90\":1,\"236\":1,\"1299\":1}}],[\"biz\",{\"1\":{\"34\":3,\"35\":3}}],[\"bitfield\",{\"1\":{\"253\":1}}],[\"bitop\",{\"1\":{\"202\":1,\"203\":1,\"261\":2}}],[\"bitcount\",{\"1\":{\"202\":3,\"203\":1,\"261\":2}}],[\"bits\",{\"1\":{\"201\":1,\"256\":4}}],[\"bitmaps\",{\"1\":{\"201\":1}}],[\"bitmap\",{\"0\":{\"200\":1,\"261\":1},\"1\":{\"199\":1,\"201\":5,\"202\":2,\"212\":4,\"213\":1,\"242\":1,\"249\":1,\"253\":1,\"261\":5,\"294\":1}}],[\"bit\",{\"1\":{\"19\":1,\"38\":1,\"201\":4,\"212\":2,\"261\":2,\"403\":1,\"618\":1,\"682\":1}}],[\"b\",{\"0\":{\"99\":1},\"1\":{\"23\":2,\"99\":1,\"103\":1,\"141\":1,\"251\":1,\"370\":2,\"438\":1,\"441\":1,\"451\":2,\"531\":2,\"562\":2,\"634\":1,\"694\":7,\"710\":7,\"711\":9,\"823\":3,\"840\":5,\"848\":1,\"975\":2,\"989\":5,\"1085\":3,\"1087\":7,\"1105\":4,\"1151\":1,\"1155\":3,\"1161\":2,\"1165\":2,\"1304\":3,\"1321\":1,\"1322\":1,\"1335\":1,\"1336\":1,\"1379\":2}}],[\"代理\",{\"1\":{\"1196\":1}}],[\"代理类主要做的事情很简单\",{\"1\":{\"1166\":1}}],[\"代出来的协议\",{\"1\":{\"1155\":1}}],[\"代价就是会消耗更多的内存空间\",{\"1\":{\"838\":1,\"987\":1}}],[\"代码根据业务拆分之后更加便于维护和扩展\",{\"1\":{\"1126\":1}}],[\"代码演示\",{\"0\":{\"1028\":1}}],[\"代码的执行顺序未必就是编写代码时候的顺序\",{\"1\":{\"980\":1}}],[\"代码的执行效率\",{\"1\":{\"6\":1}}],[\"代码块中的\",{\"1\":{\"1013\":1}}],[\"代码块\",{\"1\":{\"851\":1}}],[\"代码块上都是是给\",{\"1\":{\"848\":1}}],[\"代码来源于\",{\"1\":{\"823\":1}}],[\"代码模拟了上图的死锁的情况\",{\"1\":{\"823\":1}}],[\"代码时程序计数器记录的才是下一条指令的地址\",{\"1\":{\"811\":1}}],[\"代码示例\",{\"1\":{\"753\":1}}],[\"代码如下\",{\"1\":{\"713\":1,\"807\":1,\"1031\":1}}],[\"代码量从原来\",{\"1\":{\"691\":1}}],[\"代码\",{\"1\":{\"593\":1,\"733\":1,\"1013\":1,\"1015\":1}}],[\"代码输出结果如下\",{\"1\":{\"531\":2}}],[\"代码中可以不赋初始值就直接使用\",{\"1\":{\"504\":1}}],[\"代码展示的话\",{\"1\":{\"307\":1}}],[\"代替\",{\"1\":{\"103\":2,\"104\":1,\"157\":1,\"301\":1,\"319\":1}}],[\"代表一个安装\",{\"1\":{\"1354\":1}}],[\"代表一类消息\",{\"1\":{\"1280\":1}}],[\"代表会话的超时时间\",{\"1\":{\"1353\":1}}],[\"代表任何已认证的用户\",{\"1\":{\"1351\":1}}],[\"代表了第一个文件\",{\"1\":{\"1315\":1}}],[\"代表了future执行的任务返回值的类型\",{\"1\":{\"773\":1,\"899\":1}}],[\"代表某一类的消费者\",{\"1\":{\"1280\":1}}],[\"代表某一类的生产者\",{\"1\":{\"1280\":1}}],[\"代表我们的消息被\",{\"1\":{\"1206\":1}}],[\"代表增加线程时判断当前线程数是否少于\",{\"1\":{\"941\":1}}],[\"代表抛出的异常\",{\"1\":{\"779\":1,\"780\":1}}],[\"代表返回的结果\",{\"1\":{\"779\":1,\"780\":1}}],[\"代表数组长度\",{\"1\":{\"684\":1}}],[\"代表\",{\"1\":{\"328\":1,\"353\":1,\"640\":2}}],[\"代表访问类型\",{\"1\":{\"120\":1}}],[\"代表单台机器每毫秒能够产生的最大\",{\"1\":{\"38\":1}}],[\"代表机器\",{\"1\":{\"35\":1}}],[\"代表是整个调用的根节点\",{\"1\":{\"23\":1}}],[\"代表本次调用在整个调用链路树中的位置\",{\"1\":{\"23\":1}}],[\"代表当前这个常量属于哪种常量类型\",{\"1\":{\"328\":1}}],[\"代表当前优惠方案的\",{\"1\":{\"19\":1}}],[\"代表当前兑换码是当前活动中第\",{\"1\":{\"19\":1}}],[\"每更新一次节点内容\",{\"1\":{\"1349\":1}}],[\"每收到一个请求后\",{\"1\":{\"1142\":1}}],[\"每上面一层链表都是下面一层的子集\",{\"1\":{\"800\":1}}],[\"每调用一次这个方法\",{\"1\":{\"753\":1}}],[\"每执行完一个子线程\",{\"1\":{\"742\":1}}],[\"每条线程都需要有一个独立的程序计数器\",{\"1\":{\"492\":1}}],[\"每\",{\"1\":{\"366\":1}}],[\"每隔段时间就随机选择某个其他节点\",{\"1\":{\"1087\":1}}],[\"每隔\",{\"1\":{\"366\":1}}],[\"每隔一段时间抽取一批\",{\"1\":{\"272\":1}}],[\"每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值\",{\"1\":{\"1303\":1}}],[\"每当创建一个threadlocal对象\",{\"1\":{\"1032\":1}}],[\"每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\",{\"1\":{\"972\":1}}],[\"每当虚拟机遇到一个使用到变量的指令时都会使用该指令\",{\"1\":{\"972\":1}}],[\"每当一个新的业务接入\",{\"1\":{\"1272\":1}}],[\"每当一个线程到了栅栏这里了\",{\"1\":{\"756\":1,\"911\":1}}],[\"每当一个任务线程执行完毕\",{\"1\":{\"753\":1}}],[\"每当一个类加载器接收到加载请求时\",{\"1\":{\"357\":1}}],[\"每当有一个地方引用它\",{\"1\":{\"390\":1}}],[\"每当\",{\"1\":{\"327\":1}}],[\"每月访问\",{\"1\":{\"207\":1}}],[\"每周\",{\"1\":{\"207\":1}}],[\"每秒同步一次\",{\"1\":{\"231\":1}}],[\"每秒访问量为\",{\"1\":{\"163\":1,\"292\":1}}],[\"每秒钟调用fsync函数同步一次aof文件\",{\"1\":{\"282\":1}}],[\"每秒钟调用\",{\"1\":{\"161\":1,\"231\":1}}],[\"每次消息投递的时候统计消息投递的延迟\",{\"1\":{\"1299\":1}}],[\"每次消费者组消费完会返回一个成功的响应\",{\"1\":{\"1280\":1}}],[\"每次重试的时间间隔为\",{\"1\":{\"1210\":2}}],[\"每次在真正消费完消息之后再自己手动提交\",{\"1\":{\"1205\":1}}],[\"每次添加消息到\",{\"1\":{\"1202\":1}}],[\"每次切换都需要纳秒量级的时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"每次使用它都到主存中进行读取\",{\"1\":{\"833\":2,\"979\":1}}],[\"每次使用其中的一块\",{\"1\":{\"397\":1}}],[\"每次拦截的线程数\",{\"1\":{\"756\":1,\"911\":1}}],[\"每次只有最多不超过\",{\"1\":{\"749\":1}}],[\"每次访问一个元素时\",{\"1\":{\"717\":1}}],[\"每次扩容和更改map结构的计数器\",{\"1\":{\"619\":1}}],[\"每次扩容之后容量都会变为原来的\",{\"1\":{\"558\":1}}],[\"每次写操作都需要通过\",{\"1\":{\"588\":1}}],[\"每次写操作都需要复制一份原始数据\",{\"1\":{\"585\":1}}],[\"每次写入数据或者修改数据之前都会把修改前的信息记录到\",{\"1\":{\"137\":1}}],[\"每次不加锁而是假设没有冲突而去完成某项操作\",{\"1\":{\"503\":1}}],[\"每次年轻代垃圾回收的最长时间\",{\"1\":{\"449\":1}}],[\"每次引用这个对象时计数器加一\",{\"1\":{\"445\":1}}],[\"每次根据允许的收集时间\",{\"1\":{\"407\":1}}],[\"每次收集都会有大量对象死去\",{\"1\":{\"399\":1}}],[\"每次构建不同的请求\",{\"1\":{\"307\":1}}],[\"每次有数据修改发生时都会调用fsync函数同步aof文件\",{\"1\":{\"282\":1}}],[\"每次都需要重新分配内存\",{\"1\":{\"256\":1}}],[\"每次\",{\"1\":{\"231\":1}}],[\"每次获取大\",{\"1\":{\"163\":1,\"292\":1}}],[\"每次获取\",{\"1\":{\"33\":1,\"34\":1}}],[\"每页保存的数据量\",{\"1\":{\"110\":1}}],[\"每位用户限购\",{\"1\":{\"60\":1}}],[\"每过\",{\"1\":{\"49\":1}}],[\"每一种实现都有其特定的使用场景\",{\"1\":{\"1304\":1}}],[\"每一把锁只锁容器其中一部分数据\",{\"1\":{\"688\":1,\"792\":1}}],[\"每一次写操作都需要复制一份原始数据\",{\"1\":{\"585\":1}}],[\"每一次方法调用都会有一个对应的栈帧被压入栈中\",{\"1\":{\"493\":1}}],[\"每一个条目共\",{\"1\":{\"1315\":1}}],[\"每一个客户端的请求都包含一条需要被复制状态机\",{\"1\":{\"1112\":1}}],[\"每一个事件成为\",{\"1\":{\"1110\":1}}],[\"每一个任期的开始都是一次选举\",{\"1\":{\"1109\":1}}],[\"每一个线程处理完之后就将\",{\"1\":{\"909\":1}}],[\"每一个线程对应一个用户\",{\"1\":{\"60\":1}}],[\"每一个\",{\"1\":{\"579\":1,\"1110\":1,\"1111\":1}}],[\"每一个对象多有getclass\",{\"1\":{\"523\":1}}],[\"每一个方法调用结束后\",{\"1\":{\"493\":1}}],[\"每一个键值对都属于一个\",{\"1\":{\"286\":1}}],[\"每一个虚线箭头表示回表一次\",{\"1\":{\"117\":1}}],[\"每一个优惠方案都有独立的一组兑换码\",{\"1\":{\"19\":1}}],[\"每一部分存储的数据都有特定的含义\",{\"1\":{\"38\":1}}],[\"每两位代表\",{\"1\":{\"22\":1}}],[\"每个表决者仅会\",{\"1\":{\"1373\":1}}],[\"每个表决者在\",{\"1\":{\"1373\":1}}],[\"每个提案者在提出提案时都会首先获取到一个\",{\"1\":{\"1373\":1}}],[\"每个机房的\",{\"1\":{\"1358\":1}}],[\"每个机房\",{\"1\":{\"1358\":1}}],[\"每个机器启动一个\",{\"1\":{\"1263\":1}}],[\"每个系统只要保证它自己那一部分的事务就行了\",{\"1\":{\"1304\":1}}],[\"每个消息之间都是相互独立的\",{\"1\":{\"1284\":1}}],[\"每个消费组在每个队列上维护一个消费位置\",{\"1\":{\"1280\":1}}],[\"每个主题中只存在一个队列也是可行的\",{\"1\":{\"1280\":1}}],[\"每个主题中都有多个队列\",{\"1\":{\"1280\":1}}],[\"每个信道对应一个线程使用\",{\"1\":{\"1260\":1}}],[\"每个信道在\",{\"1\":{\"1260\":1}}],[\"每个问题都不会扯太深入\",{\"1\":{\"1177\":1}}],[\"每个使用\",{\"1\":{\"1152\":1}}],[\"每个特点展开都能聊一篇文章\",{\"1\":{\"1152\":1}}],[\"每个团队可以负责一个服务的开发\",{\"1\":{\"1126\":1}}],[\"每个服务提供者的中特定方法都对应一个活跃数\",{\"1\":{\"1142\":1}}],[\"每个服务独立提供系统的某个核心服务\",{\"1\":{\"1123\":1}}],[\"每个服务器一定会处于以下三个状态中的一个\",{\"1\":{\"1108\":1}}],[\"每个服务器的状态机按照日志顺序处理已提交的命令\",{\"1\":{\"1106\":1}}],[\"每个服务内部也会生成自己的\",{\"1\":{\"21\":1}}],[\"每个日志最终包含相同顺序的请求\",{\"1\":{\"1106\":1}}],[\"每个server存储着一份包括命令序列的日志文件\",{\"1\":{\"1106\":1}}],[\"每个将军都有一个随机时间的倒计时器\",{\"1\":{\"1105\":1}}],[\"每个节点还可以拥有\",{\"1\":{\"1348\":1}}],[\"每个节点上都可以存储数据\",{\"1\":{\"1348\":1}}],[\"每个节点又保存了什么信息\",{\"1\":{\"1199\":1}}],[\"每个节点都会存储当前的\",{\"1\":{\"1109\":1}}],[\"每个节点都是一样的\",{\"1\":{\"1069\":1}}],[\"每个节点周期性地随机找一个节点互相同步彼此的信息\",{\"1\":{\"1084\":1}}],[\"每个节点最多包含m个孩子\",{\"1\":{\"99\":1}}],[\"每个子线程执行完后countdown\",{\"1\":{\"904\":1}}],[\"每个thread中都具备一个threadlocalmap\",{\"1\":{\"883\":1}}],[\"每个对象中都内置了一个\",{\"1\":{\"851\":1}}],[\"每个对象\",{\"1\":{\"826\":1}}],[\"每个线程在往threadlocal里放值的时候\",{\"1\":{\"1029\":1}}],[\"每个线程thread拥有一份自己的副本变量\",{\"1\":{\"1028\":1}}],[\"每个线程隔离\",{\"1\":{\"1026\":1}}],[\"每个线程只能操作自己本地内存中的变量\",{\"1\":{\"972\":1}}],[\"每个线程都有一个私有的本地内存\",{\"1\":{\"972\":1}}],[\"每个线程池还维护一些基本统计信息\",{\"1\":{\"887\":1,\"933\":1}}],[\"每个线程中对\",{\"1\":{\"835\":1}}],[\"每个线程调用\",{\"1\":{\"756\":1,\"911\":1}}],[\"每个线程的堆栈大小\",{\"1\":{\"449\":1}}],[\"每个插入操作都必须等待对应的删除操作\",{\"1\":{\"671\":1}}],[\"每个键最多映射到一个值\",{\"1\":{\"640\":1}}],[\"每个文件上限大小\",{\"1\":{\"483\":1}}],[\"每个父类加载器都会走一遍这个流程\",{\"1\":{\"357\":1}}],[\"每个数据节点在\",{\"1\":{\"54\":1,\"1348\":1}}],[\"每个\",{\"1\":{\"42\":1,\"326\":1,\"340\":1,\"351\":2,\"353\":1,\"356\":1,\"359\":2,\"688\":1,\"690\":2,\"749\":1,\"812\":1,\"1085\":1,\"1114\":1,\"1199\":2,\"1262\":1,\"1263\":1,\"1314\":1,\"1315\":1,\"1348\":1,\"1349\":1,\"1379\":1,\"1382\":2}}],[\"每个兑换码有自己的编号\",{\"1\":{\"19\":1}}],[\"每个后端都应该了解的\",{\"1\":{\"6\":1}}],[\"6844904151567040519\",{\"1\":{\"1025\":1}}],[\"6842045\",{\"1\":{\"688\":1}}],[\"626\",{\"1\":{\"762\":1}}],[\"6260652\",{\"1\":{\"555\":1,\"587\":1}}],[\"6is\",{\"1\":{\"757\":4}}],[\"67\",{\"1\":{\"713\":1}}],[\"666\",{\"1\":{\"767\":1}}],[\"667\",{\"1\":{\"687\":1}}],[\"662由\",{\"1\":{\"345\":1}}],[\"653\",{\"1\":{\"687\":1}}],[\"651\",{\"1\":{\"687\":1}}],[\"65536\",{\"1\":{\"570\":1}}],[\"6g\",{\"1\":{\"448\":1}}],[\"63208969074998\",{\"1\":{\"713\":1}}],[\"637378\",{\"1\":{\"298\":1}}],[\"6379\",{\"1\":{\"219\":1,\"293\":2,\"298\":1}}],[\"6379>\",{\"1\":{\"35\":3,\"48\":1,\"270\":3,\"280\":1,\"298\":1,\"302\":3}}],[\"6383\",{\"1\":{\"168\":1}}],[\"6919\",{\"1\":{\"687\":1}}],[\"6999798721269465102\",{\"1\":{\"545\":1}}],[\"69\",{\"1\":{\"38\":1}}],[\"6474562\",{\"1\":{\"687\":1}}],[\"64m\",{\"1\":{\"412\":1,\"450\":1,\"486\":1}}],[\"644618\",{\"1\":{\"409\":1}}],[\"646256\",{\"1\":{\"298\":1}}],[\"64bit\",{\"1\":{\"38\":1}}],[\"64\",{\"1\":{\"38\":1,\"233\":1,\"256\":2,\"403\":1,\"449\":2,\"451\":1,\"456\":1,\"480\":1,\"485\":1,\"616\":1,\"619\":2,\"622\":1,\"645\":1,\"677\":1,\"683\":4,\"1184\":2,\"1379\":1}}],[\"6\",{\"0\":{\"443\":1,\"449\":1,\"456\":1,\"466\":1,\"854\":1,\"924\":1,\"1117\":1},\"1\":{\"19\":1,\"49\":1,\"76\":1,\"117\":2,\"127\":1,\"128\":1,\"129\":1,\"171\":1,\"185\":1,\"202\":1,\"206\":2,\"213\":1,\"229\":1,\"245\":1,\"249\":1,\"264\":1,\"266\":1,\"267\":1,\"268\":3,\"273\":1,\"283\":1,\"298\":1,\"302\":1,\"327\":1,\"328\":1,\"344\":1,\"386\":2,\"388\":2,\"391\":1,\"444\":4,\"485\":1,\"498\":1,\"529\":1,\"531\":2,\"552\":1,\"598\":1,\"612\":1,\"619\":1,\"624\":1,\"634\":1,\"642\":1,\"653\":6,\"656\":1,\"668\":1,\"688\":1,\"766\":1,\"782\":2,\"792\":1,\"820\":1,\"841\":2,\"847\":1,\"854\":1,\"861\":1,\"882\":2,\"895\":1,\"909\":4,\"922\":1,\"990\":2,\"1011\":1,\"1040\":2,\"1144\":1,\"1349\":1,\"1357\":1,\"1358\":1}}],[\"61152\",{\"1\":{\"302\":1}}],[\"61518\",{\"1\":{\"298\":7}}],[\"61516\",{\"1\":{\"298\":2}}],[\"61\",{\"1\":{\"19\":1}}],[\"600\",{\"1\":{\"1178\":1}}],[\"6000\",{\"1\":{\"691\":1}}],[\"60001\",{\"1\":{\"373\":1}}],[\"60l\",{\"1\":{\"889\":1,\"937\":1,\"957\":2}}],[\"60s\",{\"1\":{\"270\":2}}],[\"60^12=130606940160000000000000\",{\"1\":{\"19\":1}}],[\"60\",{\"1\":{\"19\":2,\"177\":2,\"226\":1,\"270\":2,\"307\":1,\"757\":1,\"888\":1}}],[\"60e27b0e2078082a378ec5ed\",{\"1\":{\"11\":1}}],[\"位数字组成的数字串\",{\"1\":{\"1382\":1}}],[\"位数要便于操作\",{\"1\":{\"18\":1}}],[\"位可以简单理解为递增的事务\",{\"1\":{\"1379\":1}}],[\"位列开发框架和基础组件类项目的第\",{\"1\":{\"1122\":1}}],[\"位用于保存读锁的持有次数\",{\"1\":{\"1019\":1}}],[\"位保存写锁持有的次数\",{\"1\":{\"1019\":1}}],[\"位于硬盘或内存中\",{\"1\":{\"1253\":1}}],[\"位于中轴线上的为双方都用到的接口\",{\"1\":{\"1130\":1}}],[\"位于\",{\"1\":{\"773\":1,\"899\":1}}],[\"位移运算符比那些普通运算符的运算要快很多\",{\"1\":{\"558\":1}}],[\"位所以相当于\",{\"1\":{\"558\":1}}],[\"位相当于除以\",{\"1\":{\"558\":1}}],[\"位置对应的entry数据key为null\",{\"1\":{\"1035\":1}}],[\"位置元素的值\",{\"1\":{\"766\":4}}],[\"位置要么不变\",{\"1\":{\"572\":1}}],[\"位置赋值\",{\"1\":{\"571\":1}}],[\"位置已经有值了\",{\"1\":{\"571\":1}}],[\"位置的当前的值\",{\"1\":{\"766\":1}}],[\"位置的元素设置为newvalue\",{\"1\":{\"766\":1}}],[\"位置的元素值设置为输入值\",{\"1\":{\"766\":1}}],[\"位置的元素\",{\"1\":{\"605\":1}}],[\"位置的\",{\"1\":{\"571\":4}}],[\"位置的值\",{\"1\":{\"202\":2}}],[\"位置的值设置为\",{\"1\":{\"181\":1}}],[\"位置\",{\"1\":{\"535\":1,\"571\":1,\"572\":1,\"578\":1,\"1035\":1}}],[\"位以内的数据类型\",{\"1\":{\"442\":1}}],[\"位域\",{\"1\":{\"253\":1}}],[\"位来表示某个元素对应的值或者状态\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"位图\",{\"0\":{\"200\":1},\"1\":{\"213\":1,\"253\":1}}],[\"位和后\",{\"1\":{\"19\":1}}],[\"位足够\",{\"1\":{\"19\":1}}],[\"位表示事务\",{\"1\":{\"1379\":1}}],[\"位表示机器\",{\"1\":{\"38\":1}}],[\"位表示机房\",{\"1\":{\"38\":1}}],[\"位表示校验位\",{\"1\":{\"19\":1}}],[\"位表示\",{\"1\":{\"19\":2,\"1379\":1}}],[\"位的兑换码可以生成天量\",{\"1\":{\"19\":1}}],[\"位\",{\"1\":{\"19\":5,\"22\":4,\"37\":2,\"38\":7,\"108\":1,\"256\":1,\"444\":1,\"480\":1,\"485\":1,\"1315\":1,\"1379\":1}}],[\"个大脑都可能对外提供了服务\",{\"1\":{\"1358\":1}}],[\"个大脑\",{\"1\":{\"1358\":2}}],[\"个机房\",{\"1\":{\"1358\":1}}],[\"个子节点\",{\"1\":{\"1348\":1}}],[\"个子线程是并行执行的\",{\"1\":{\"904\":1}}],[\"个子线程开始执行任务\",{\"1\":{\"742\":1}}],[\"个子线程去执行\",{\"1\":{\"742\":1,\"904\":1}}],[\"个典型的应用场景来专门说说\",{\"1\":{\"1346\":1}}],[\"个条目组成\",{\"1\":{\"1315\":1}}],[\"个条件的无用类进行回收\",{\"1\":{\"394\":1}}],[\"个条件才能算是\",{\"1\":{\"394\":1}}],[\"个订单给查出来\",{\"1\":{\"1264\":1}}],[\"个订单都丢了\",{\"1\":{\"1264\":1}}],[\"个副本才算是被成功发送\",{\"1\":{\"1206\":1}}],[\"个副本\",{\"1\":{\"1206\":1}}],[\"个参数\",{\"1\":{\"1202\":1}}],[\"个消息对应的操作分别对应的数据库操作是\",{\"1\":{\"1202\":1}}],[\"个消息\",{\"1\":{\"1202\":1}}],[\"个将军\",{\"1\":{\"1105\":1}}],[\"个重要的角色\",{\"1\":{\"1098\":1}}],[\"个最重要的参数\",{\"1\":{\"890\":1,\"936\":1}}],[\"个常见的\",{\"1\":{\"796\":1}}],[\"个文件\",{\"1\":{\"782\":1,\"909\":1}}],[\"个输入对象然后进行\",{\"1\":{\"779\":2}}],[\"个功能\",{\"1\":{\"773\":1,\"899\":1}}],[\"个方法\",{\"1\":{\"773\":1,\"774\":1,\"899\":1}}],[\"个其他服务的接口\",{\"1\":{\"772\":1}}],[\"个的时候\",{\"1\":{\"757\":1}}],[\"个请求被处理完成之后\",{\"1\":{\"753\":1}}],[\"个实现也比较简单\",{\"1\":{\"709\":1}}],[\"个核心成员变量如下\",{\"1\":{\"601\":1}}],[\"个任务中如果有任务被执行完了\",{\"1\":{\"941\":1}}],[\"个任务会被放到等待队列中去\",{\"1\":{\"941\":1}}],[\"个任务同时执行\",{\"1\":{\"941\":1}}],[\"个任务都是没有执行顺序依赖的任务\",{\"1\":{\"782\":1,\"909\":1}}],[\"个任务\",{\"1\":{\"599\":1,\"941\":2}}],[\"个线程\",{\"1\":{\"949\":1}}],[\"个线程调用了countdown\",{\"1\":{\"908\":1}}],[\"个线程分别进行了\",{\"1\":{\"835\":1}}],[\"个线程分别是\",{\"1\":{\"604\":1}}],[\"个线程都调\",{\"1\":{\"753\":1}}],[\"个线程必须引用闭锁对象\",{\"1\":{\"753\":1}}],[\"个线程执行完毕\",{\"1\":{\"753\":1}}],[\"个线程阻塞在一个地方\",{\"1\":{\"751\":1,\"907\":1,\"909\":1}}],[\"个线程能获取到共享资源\",{\"1\":{\"747\":1,\"905\":1}}],[\"个线程中只有\",{\"1\":{\"747\":1,\"905\":1}}],[\"个线程来获取\",{\"1\":{\"747\":1,\"905\":1}}],[\"个线程会尝试获取可重入锁\",{\"1\":{\"604\":1}}],[\"个线程正在进行扩容\",{\"1\":{\"576\":1}}],[\"个线程并发写\",{\"1\":{\"690\":1}}],[\"个线程并发获取元素为例讲述\",{\"1\":{\"604\":1}}],[\"个线程并发\",{\"1\":{\"569\":1}}],[\"个构造方法将\",{\"1\":{\"709\":1}}],[\"个构造方法\",{\"1\":{\"534\":1}}],[\"个元素会被删除\",{\"1\":{\"706\":2}}],[\"个元素插入进\",{\"1\":{\"632\":1}}],[\"个元素进入\",{\"1\":{\"558\":1}}],[\"个元素时\",{\"1\":{\"557\":2,\"558\":1,\"706\":2}}],[\"个元素到\",{\"1\":{\"557\":1}}],[\"个元素都要执行向后位\",{\"1\":{\"552\":1,\"656\":1}}],[\"个元素之后的\",{\"1\":{\"552\":1,\"656\":1}}],[\"个元素的值\",{\"1\":{\"531\":1}}],[\"个元素消费完成之后\",{\"1\":{\"531\":1}}],[\"个元素\",{\"1\":{\"531\":2,\"557\":1,\"653\":2,\"654\":1,\"706\":1,\"725\":1,\"729\":1}}],[\"个元素后及时退出\",{\"1\":{\"531\":1}}],[\"个元素给消费者进行消费\",{\"1\":{\"531\":1}}],[\"个区域随着线程的生存而生存的\",{\"1\":{\"445\":1}}],[\"个步骤\",{\"1\":{\"427\":1,\"972\":1}}],[\"个要求\",{\"1\":{\"345\":1}}],[\"个调用\",{\"1\":{\"344\":1}}],[\"个阶段的顺序如下图所示\",{\"1\":{\"338\":1}}],[\"个阶段\",{\"1\":{\"338\":1}}],[\"个人认为\",{\"1\":{\"1388\":1}}],[\"个人\",{\"1\":{\"895\":1,\"922\":1}}],[\"个人做\",{\"1\":{\"895\":1,\"922\":1}}],[\"个人觉得\",{\"1\":{\"1370\":1}}],[\"个人觉得也没必要记\",{\"1\":{\"685\":1}}],[\"个人觉得使用\",{\"1\":{\"562\":1}}],[\"个人觉得不是特别准确\",{\"1\":{\"499\":1}}],[\"个人觉得翻译成单亲委派模型更好一些\",{\"1\":{\"356\":1}}],[\"个人感觉网上应该找不到总结的这么明明白白的文章了\",{\"1\":{\"307\":1}}],[\"个人建议不管是否开启\",{\"1\":{\"289\":1}}],[\"个人学习的话\",{\"1\":{\"242\":1}}],[\"个部分实现的\",{\"1\":{\"1166\":1}}],[\"个部分\",{\"1\":{\"265\":1,\"1097\":2}}],[\"个属性\",{\"1\":{\"256\":1}}],[\"个原因\",{\"1\":{\"218\":1}}],[\"个位\",{\"1\":{\"202\":1}}],[\"个不同的位\",{\"1\":{\"201\":1}}],[\"个孩子\",{\"1\":{\"99\":1}}],[\"个用户参与某个限时秒杀活动\",{\"1\":{\"60\":1}}],[\"个问题\",{\"1\":{\"42\":1}}],[\"个\",{\"1\":{\"37\":1,\"38\":1,\"60\":5,\"98\":1,\"163\":1,\"201\":1,\"206\":1,\"212\":1,\"251\":1,\"261\":1,\"291\":1,\"318\":1,\"569\":1,\"591\":1,\"730\":1,\"731\":1,\"1202\":2,\"1358\":3}}],[\"个字节和后\",{\"1\":{\"1184\":1}}],[\"个字节的填充\",{\"1\":{\"1184\":1}}],[\"个字节是主版本号\",{\"1\":{\"327\":1}}],[\"个字节是次版本号\",{\"1\":{\"327\":1}}],[\"个字节称为魔数\",{\"1\":{\"326\":1}}],[\"个字节\",{\"1\":{\"256\":1,\"1184\":1,\"1315\":1}}],[\"个字节存储\",{\"1\":{\"35\":1}}],[\"个字符串\",{\"1\":{\"37\":2}}],[\"个字符\",{\"1\":{\"19\":1}}],[\"个数据块\",{\"1\":{\"98\":1}}],[\"个数\",{\"1\":{\"19\":1}}],[\"个兑换码\",{\"1\":{\"19\":1}}],[\"个组件组成\",{\"1\":{\"7\":1}}],[\"共识协议标记为生产就绪的版本\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"共识是可容错系统中的一个基本问题\",{\"1\":{\"1106\":1}}],[\"共识\",{\"1\":{\"1096\":1}}],[\"共识算法允许一组节点像一个整体一样一起工作\",{\"1\":{\"1106\":1}}],[\"共识算法的作用是让分布式系统中的多个节点之间对某个提案\",{\"1\":{\"1097\":1}}],[\"共识算法\",{\"0\":{\"1106\":1},\"2\":{\"1094\":1,\"1102\":1,\"1119\":1}}],[\"共用的坑\",{\"0\":{\"929\":1}}],[\"共同进步\",{\"1\":{\"1319\":1,\"1341\":1}}],[\"共同完成\",{\"1\":{\"1103\":1}}],[\"共同的关注点\",{\"1\":{\"407\":1}}],[\"共同点\",{\"1\":{\"245\":1,\"825\":1}}],[\"共同关注\",{\"1\":{\"190\":1,\"259\":1}}],[\"共同好友\",{\"1\":{\"190\":1,\"259\":1}}],[\"共同喜好等功能\",{\"1\":{\"188\":1}}],[\"共同粉丝\",{\"1\":{\"188\":1,\"190\":1,\"259\":1}}],[\"共有五种实现方式\",{\"1\":{\"256\":1}}],[\"共有\",{\"1\":{\"174\":1}}],[\"共享和故障转移\",{\"1\":{\"1238\":1}}],[\"共享模式下尝试获取资源\",{\"1\":{\"748\":1}}],[\"共享模式下获取许可证\",{\"1\":{\"748\":1,\"906\":1}}],[\"共享方式\",{\"1\":{\"744\":2,\"1007\":2}}],[\"共享\",{\"1\":{\"743\":1}}],[\"共享变量\",{\"1\":{\"742\":1,\"904\":1}}],[\"共享锁和独占锁\",{\"1\":{\"1388\":1}}],[\"共享锁和独占锁有什么区别\",{\"0\":{\"867\":1}}],[\"共享锁\",{\"1\":{\"140\":1,\"867\":1,\"871\":1}}],[\"共享资源每次只给一个线程使用\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"共享资源未互斥访问导致出现问题\",{\"1\":{\"60\":1}}],[\"共\",{\"1\":{\"19\":1}}],[\"剔除大写字母\",{\"1\":{\"19\":1}}],[\"96\",{\"1\":{\"1209\":2}}],[\"9700\",{\"1\":{\"1209\":3}}],[\"918\",{\"1\":{\"1209\":3}}],[\"95\",{\"1\":{\"1209\":2,\"1380\":1}}],[\"98134\",{\"1\":{\"1185\":1}}],[\"94976168\",{\"1\":{\"996\":1}}],[\"941863\",{\"1\":{\"298\":1}}],[\"9411\",{\"1\":{\"7\":1}}],[\"9is\",{\"1\":{\"757\":4}}],[\"999\",{\"1\":{\"767\":1}}],[\"99\",{\"1\":{\"561\":1,\"1380\":2}}],[\"9256\",{\"1\":{\"370\":2}}],[\"9229\",{\"1\":{\"334\":1}}],[\"926945\",{\"1\":{\"298\":1}}],[\"9a9d\",{\"1\":{\"293\":2}}],[\"9095748\",{\"1\":{\"511\":1}}],[\"900\",{\"1\":{\"226\":1,\"384\":1}}],[\"9000\",{\"1\":{\"22\":2}}],[\"90\",{\"1\":{\"210\":1,\"1155\":1}}],[\"9~11\",{\"1\":{\"35\":1}}],[\"9\",{\"0\":{\"446\":1,\"469\":1},\"1\":{\"19\":1,\"328\":1,\"353\":1,\"400\":1,\"412\":1,\"486\":1,\"531\":2,\"598\":1,\"631\":1,\"653\":3,\"654\":1,\"662\":5,\"763\":1,\"882\":2,\"1141\":1,\"1144\":1,\"1208\":1,\"1210\":1,\"1253\":1,\"1327\":1}}],[\"5==0\",{\"1\":{\"1209\":1}}],[\"5=4\",{\"1\":{\"749\":1}}],[\"5～20ms\",{\"1\":{\"1116\":1}}],[\"5s\",{\"1\":{\"1062\":1,\"1076\":1}}],[\"5秒\",{\"1\":{\"835\":1}}],[\"5aeebd02518825672f19c546\",{\"1\":{\"801\":1}}],[\"5is\",{\"1\":{\"757\":4}}],[\"59\",{\"1\":{\"1327\":1,\"1329\":2,\"1330\":2}}],[\"590\",{\"1\":{\"687\":1}}],[\"594\",{\"1\":{\"687\":1}}],[\"58\",{\"1\":{\"1022\":1}}],[\"5880\",{\"1\":{\"713\":1}}],[\"584\",{\"1\":{\"687\":1}}],[\"5870bd44d153\",{\"1\":{\"274\":1}}],[\"5+\",{\"1\":{\"634\":1}}],[\"5倍\",{\"1\":{\"553\":1,\"558\":1}}],[\"57109429\",{\"1\":{\"511\":1}}],[\"550ms\",{\"1\":{\"1271\":1}}],[\"550\",{\"1\":{\"749\":1,\"753\":3,\"757\":2}}],[\"55994121\",{\"1\":{\"511\":1}}],[\"551671\",{\"1\":{\"298\":1}}],[\"5m\",{\"1\":{\"451\":1}}],[\"5xms=xmx\",{\"1\":{\"449\":1}}],[\"5e1505d0f265da5d5d744050\",{\"1\":{\"415\":1}}],[\"5g\",{\"1\":{\"412\":1,\"448\":1}}],[\"5197ms\",{\"1\":{\"1062\":1}}],[\"51374915\",{\"1\":{\"360\":1}}],[\"512\",{\"1\":{\"201\":2}}],[\"5358ms\",{\"1\":{\"1062\":1}}],[\"536\",{\"1\":{\"687\":1}}],[\"539619957\",{\"1\":{\"545\":1}}],[\"53bd815b\",{\"1\":{\"353\":1}}],[\"53~64\",{\"1\":{\"38\":1}}],[\"5分钟\",{\"1\":{\"226\":1}}],[\"509\",{\"1\":{\"1062\":2}}],[\"50578ms\",{\"1\":{\"1062\":1}}],[\"50\",{\"1\":{\"220\":3,\"386\":2,\"816\":1}}],[\"500=2500\",{\"1\":{\"835\":1}}],[\"500\",{\"1\":{\"287\":1,\"781\":1,\"835\":2,\"1062\":1,\"1303\":2}}],[\"500mb\",{\"1\":{\"220\":2}}],[\"5000l\",{\"1\":{\"944\":2}}],[\"5000\",{\"1\":{\"163\":1,\"291\":1,\"296\":1,\"940\":1}}],[\"56\",{\"1\":{\"177\":1,\"270\":1,\"1184\":1}}],[\"56696\",{\"1\":{\"22\":1}}],[\"5w\",{\"1\":{\"41\":1}}],[\"52\",{\"1\":{\"22\":1,\"293\":1}}],[\"5440\",{\"1\":{\"1143\":1}}],[\"54\",{\"1\":{\"19\":1}}],[\"5\",{\"0\":{\"174\":1,\"442\":1,\"448\":1,\"455\":1,\"465\":1,\"485\":1,\"573\":1,\"921\":1,\"1016\":1,\"1021\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1116\":1},\"1\":{\"19\":1,\"22\":1,\"37\":3,\"38\":2,\"83\":3,\"84\":1,\"106\":2,\"117\":2,\"127\":1,\"128\":1,\"129\":1,\"174\":3,\"177\":1,\"182\":1,\"185\":1,\"193\":2,\"199\":1,\"210\":2,\"219\":2,\"220\":1,\"230\":1,\"249\":1,\"251\":1,\"252\":2,\"253\":1,\"254\":1,\"256\":8,\"293\":1,\"298\":1,\"302\":2,\"307\":1,\"327\":1,\"328\":1,\"339\":1,\"345\":3,\"370\":4,\"404\":1,\"424\":1,\"444\":1,\"448\":1,\"451\":1,\"452\":1,\"478\":1,\"496\":1,\"515\":1,\"529\":2,\"531\":9,\"544\":1,\"558\":3,\"570\":1,\"583\":2,\"598\":1,\"631\":1,\"634\":1,\"653\":6,\"662\":5,\"663\":2,\"669\":1,\"687\":8,\"705\":2,\"731\":1,\"747\":2,\"749\":2,\"756\":1,\"757\":3,\"763\":1,\"766\":2,\"773\":1,\"774\":1,\"785\":2,\"793\":2,\"807\":1,\"823\":4,\"824\":6,\"835\":4,\"843\":1,\"845\":1,\"862\":1,\"882\":2,\"899\":1,\"905\":2,\"911\":1,\"924\":1,\"927\":1,\"928\":1,\"934\":1,\"940\":6,\"941\":5,\"943\":1,\"975\":1,\"992\":1,\"994\":1,\"1002\":1,\"1011\":1,\"1040\":1,\"1062\":1,\"1108\":1,\"1144\":1,\"1166\":1,\"1211\":1,\"1213\":3,\"1222\":1,\"1257\":1,\"1258\":1,\"1296\":1,\"1297\":1,\"1301\":1,\"1304\":1,\"1311\":1,\"1315\":1,\"1321\":2,\"1322\":1,\"1328\":1,\"1332\":1,\"1351\":1,\"1357\":1,\"1384\":1}}],[\"4k\",{\"1\":{\"1302\":1}}],[\"4kb\",{\"1\":{\"168\":2}}],[\"4v1ji6ryljr7jr9jsqe73a\",{\"1\":{\"1241\":1}}],[\"433619b6\",{\"1\":{\"1030\":1}}],[\"431\",{\"1\":{\"687\":1}}],[\"4w\",{\"1\":{\"941\":1}}],[\"47\",{\"1\":{\"940\":5}}],[\"4920797\",{\"1\":{\"758\":1,\"913\":1}}],[\"491\",{\"1\":{\"281\":1}}],[\"4is\",{\"1\":{\"757\":4}}],[\"4or\",{\"1\":{\"449\":1}}],[\"4831\",{\"1\":{\"293\":1}}],[\"4437\",{\"1\":{\"293\":2}}],[\"4476\",{\"1\":{\"168\":2}}],[\"4f2f\",{\"1\":{\"293\":2}}],[\"452\",{\"1\":{\"281\":1}}],[\"4585\",{\"1\":{\"37\":1}}],[\"40\",{\"1\":{\"449\":1,\"451\":2,\"684\":2,\"835\":1,\"1185\":1}}],[\"4069879562983946\",{\"1\":{\"210\":1}}],[\"4018\",{\"1\":{\"210\":1}}],[\"400\",{\"1\":{\"135\":2}}],[\"4096\",{\"1\":{\"38\":2}}],[\"42\",{\"1\":{\"940\":10}}],[\"426\",{\"1\":{\"687\":1}}],[\"421\",{\"1\":{\"391\":1}}],[\"42000\",{\"1\":{\"86\":1}}],[\"42~52\",{\"1\":{\"38\":1}}],[\"4c8g\",{\"1\":{\"41\":1}}],[\"418a15e3\",{\"1\":{\"1030\":1}}],[\"41\",{\"1\":{\"38\":1,\"1327\":1}}],[\"4122\",{\"1\":{\"37\":1}}],[\"4\",{\"0\":{\"235\":1,\"431\":1,\"441\":1,\"447\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":2,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"464\":2,\"465\":1,\"466\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"484\":1,\"572\":1,\"578\":1,\"920\":1,\"1015\":1,\"1017\":1,\"1018\":1,\"1019\":1,\"1020\":1,\"1112\":1},\"1\":{\"19\":1,\"22\":1,\"34\":1,\"35\":1,\"37\":7,\"49\":1,\"54\":1,\"99\":1,\"117\":4,\"127\":1,\"128\":1,\"129\":1,\"132\":1,\"185\":1,\"193\":2,\"224\":1,\"235\":1,\"246\":1,\"256\":3,\"264\":1,\"265\":1,\"266\":3,\"267\":1,\"273\":1,\"281\":1,\"282\":1,\"285\":2,\"289\":1,\"293\":3,\"294\":3,\"298\":2,\"301\":1,\"302\":1,\"326\":1,\"328\":1,\"334\":2,\"344\":1,\"345\":1,\"392\":1,\"444\":1,\"448\":1,\"449\":5,\"451\":2,\"452\":1,\"456\":1,\"499\":1,\"515\":1,\"531\":7,\"557\":1,\"591\":1,\"601\":1,\"604\":1,\"605\":1,\"618\":2,\"619\":1,\"634\":2,\"653\":6,\"662\":5,\"677\":1,\"682\":2,\"688\":1,\"705\":2,\"706\":4,\"709\":2,\"712\":1,\"762\":1,\"763\":2,\"766\":1,\"773\":1,\"788\":1,\"807\":1,\"882\":2,\"899\":1,\"940\":4,\"1001\":2,\"1033\":2,\"1036\":3,\"1038\":3,\"1040\":1,\"1122\":1,\"1202\":1,\"1249\":1,\"1252\":1,\"1296\":1,\"1297\":1,\"1304\":1,\"1308\":3,\"1310\":3,\"1315\":1,\"1335\":2,\"1349\":1,\"1357\":1}}],[\"以消费者分组的粒度管理订阅关系\",{\"1\":{\"1297\":1}}],[\"以离线的日志收集场景为例\",{\"1\":{\"1284\":1}}],[\"以在线的电商交易场景为例\",{\"1\":{\"1284\":1}}],[\"以减轻某个\",{\"1\":{\"1281\":1}}],[\"以减少搜索时间\",{\"1\":{\"616\":1,\"619\":1,\"622\":1,\"645\":1,\"677\":1,\"683\":1}}],[\"以减少增量重新分配的次数\",{\"1\":{\"564\":1}}],[\"以实现从多方面进行扩展\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"以免交易纠纷\",{\"1\":{\"1220\":1}}],[\"以可靠地在系统或应用程序之间获取数据\",{\"1\":{\"1190\":1}}],[\"以可重入的互斥锁\",{\"1\":{\"742\":1}}],[\"以本地调用的方式调用远程服务\",{\"1\":{\"1166\":1}}],[\"以主流的\",{\"1\":{\"1158\":1}}],[\"以典型的\",{\"1\":{\"1108\":1}}],[\"以保证数据的一致性\",{\"1\":{\"1069\":1}}],[\"以保证任务能够按照时间先后顺序执行\",{\"1\":{\"609\":1}}],[\"以当前的staleslot开始\",{\"1\":{\"1036\":1}}],[\"以当前节点\",{\"1\":{\"1035\":1}}],[\"以当前staleslot开始\",{\"1\":{\"1035\":1}}],[\"以index=7位起点开始遍历\",{\"1\":{\"1035\":1}}],[\"以非公平锁为例\",{\"1\":{\"1007\":2}}],[\"以来一直存在\",{\"1\":{\"943\":1}}],[\"以避免阻塞线程池中的线程\",{\"1\":{\"925\":1}}],[\"以避免程序崩溃或者无法正常退出\",{\"1\":{\"924\":1}}],[\"以避免程序长时间阻塞而导致性能问题\",{\"1\":{\"924\":1}}],[\"以避免收缩\",{\"1\":{\"485\":1}}],[\"以无参\",{\"1\":{\"748\":2,\"752\":1}}],[\"以无参数构造方法创建\",{\"1\":{\"555\":1}}],[\"以例\",{\"1\":{\"742\":1,\"904\":1}}],[\"以正确的顺序返回该列表中的元素的迭代器\",{\"1\":{\"553\":1}}],[\"以正确的顺序返回一个包含此列表中所有元素的数组\",{\"1\":{\"553\":1,\"562\":1}}],[\"以正确的顺序\",{\"1\":{\"553\":1}}],[\"以确保即使某些服务器发生故障\",{\"1\":{\"1106\":1}}],[\"以确保它至少可以容纳由minimum\",{\"1\":{\"564\":1}}],[\"以确保它至少能容纳元素的数量\",{\"1\":{\"553\":1}}],[\"以确保系统的高可用性和稳定性\",{\"1\":{\"297\":1}}],[\"以知道在添加第一个元素时容量需要增加多少\",{\"1\":{\"553\":1}}],[\"以防任何继承类修改它的含义\",{\"1\":{\"521\":1}}],[\"以外的内存\",{\"1\":{\"499\":1}}],[\"以堆为例\",{\"1\":{\"491\":1}}],[\"以满足实际业务的需求\",{\"1\":{\"787\":1}}],[\"以满足此值\",{\"1\":{\"449\":1}}],[\"以满足自己的特殊需求\",{\"1\":{\"353\":1}}],[\"以前每个线程堆栈大小为\",{\"1\":{\"449\":1,\"458\":1}}],[\"以前我们使用的大部分引用实际上都是强引用\",{\"1\":{\"392\":1}}],[\"以极高概率满足\",{\"1\":{\"407\":1}}],[\"以后在解决哈希冲突时有了较大的变化\",{\"1\":{\"619\":1,\"645\":1}}],[\"以后的\",{\"1\":{\"616\":1,\"677\":1,\"843\":1,\"992\":1}}],[\"以后可以用来查找泄漏\",{\"1\":{\"484\":1}}],[\"以后每个线程堆栈大小为\",{\"1\":{\"449\":1,\"458\":1}}],[\"以后\",{\"1\":{\"392\":1,\"688\":1,\"792\":1}}],[\"以缩短虚拟机类加载的时间\",{\"1\":{\"341\":1}}],[\"以用于描述某些场景专有的信息\",{\"1\":{\"333\":1}}],[\"以微秒为单位\",{\"1\":{\"302\":1}}],[\"以下文件夹结构借助\",{\"1\":{\"1199\":1}}],[\"以下源码来自\",{\"1\":{\"1141\":1}}],[\"以下图为例\",{\"1\":{\"712\":1}}],[\"以下内容摘自我的\",{\"1\":{\"680\":1}}],[\"以下参数可以帮助你实现\",{\"1\":{\"478\":1}}],[\"以下是一个简单的例子\",{\"1\":{\"1212\":1}}],[\"以下是根据\",{\"1\":{\"1208\":1}}],[\"以下是配置文件\",{\"1\":{\"298\":1}}],[\"以下是这段\",{\"1\":{\"218\":1}}],[\"以下可以考虑使用\",{\"1\":{\"294\":1}}],[\"以内\",{\"1\":{\"287\":1}}],[\"以一种易于理解和解析的格式包含所有操作的日志\",{\"1\":{\"236\":1}}],[\"以判断文件是否完整\",{\"1\":{\"234\":1}}],[\"以便让开发人员将精力集中在处理业务逻辑上\",{\"1\":{\"1343\":1}}],[\"以便让应用程序自己决定如何去获取所需的类\",{\"1\":{\"353\":1}}],[\"以便定位问题\",{\"1\":{\"1213\":1}}],[\"以便更好满足自己的需求\",{\"1\":{\"1131\":1}}],[\"以便于对后续内容的理解\",{\"1\":{\"1007\":1}}],[\"以便随后的\",{\"1\":{\"972\":2}}],[\"以便下次再切换回这个任务时\",{\"1\":{\"895\":1,\"922\":1}}],[\"以便异常能够传播到后续阶段\",{\"1\":{\"786\":1}}],[\"以便在内存不足的情况下执行\",{\"1\":{\"484\":1}}],[\"以便进行安全重启\",{\"1\":{\"220\":1}}],[\"以便后续进行管理和再分配\",{\"1\":{\"165\":1}}],[\"以此来完成\",{\"1\":{\"162\":1,\"233\":1}}],[\"以此类推\",{\"1\":{\"23\":1,\"110\":1,\"558\":1,\"1315\":1}}],[\"以上图为例\",{\"1\":{\"1252\":2}}],[\"以上图为例slottoexpunge被更新为\",{\"1\":{\"1035\":1}}],[\"以上的命令\",{\"1\":{\"157\":1,\"301\":1}}],[\"以上便是根据select\",{\"1\":{\"141\":1}}],[\"以\",{\"1\":{\"33\":1,\"34\":1,\"904\":1,\"1008\":1,\"1130\":7,\"1292\":2}}],[\"以万为单位\",{\"1\":{\"19\":1}}],[\"以及保存和提供\",{\"1\":{\"1344\":1}}],[\"以及消费者从\",{\"1\":{\"1251\":1}}],[\"以及多副本\",{\"1\":{\"1197\":1}}],[\"以及简单查看了其源码之后发现\",{\"1\":{\"1169\":1}}],[\"以及服务提供者被调用的方法的名称\",{\"1\":{\"1142\":1}}],[\"以及错误线程试图解锁操作时异常情况的处理\",{\"1\":{\"1019\":1}}],[\"以及各种\",{\"1\":{\"979\":1}}],[\"以及各种原子类实现原子性\",{\"1\":{\"978\":1}}],[\"以及继承自\",{\"1\":{\"934\":1}}],[\"以及队列中的任务数\",{\"1\":{\"918\":1}}],[\"以及e的前驱节点b和后继节点a\",{\"1\":{\"711\":1}}],[\"以及它的前驱节点\",{\"1\":{\"710\":1}}],[\"以及前驱节点和后继节点\",{\"1\":{\"710\":1}}],[\"以及适用场景\",{\"1\":{\"448\":1}}],[\"以及以前的版本中与\",{\"1\":{\"404\":1}}],[\"以及分析堆转储快照\",{\"1\":{\"377\":1}}],[\"以及被\",{\"1\":{\"353\":1}}],[\"以及共享库\",{\"1\":{\"219\":1}}],[\"以及重做日志文件\",{\"1\":{\"135\":1}}],[\"以及指向其子节点地址的指针\",{\"1\":{\"99\":1}}],[\"以及所有的内置函数\",{\"1\":{\"82\":1}}],[\"以及商业信息和用户手机号\",{\"1\":{\"18\":1}}],[\"以及\",{\"1\":{\"6\":1,\"19\":2,\"202\":1,\"249\":1,\"683\":1,\"711\":1,\"712\":1,\"800\":1,\"1002\":1,\"1196\":1,\"1391\":1}}],[\"京东零售开源的\",{\"1\":{\"298\":1}}],[\"京东零售的\",{\"1\":{\"298\":1}}],[\"京东卡\",{\"1\":{\"19\":1}}],[\"京东支付\",{\"1\":{\"17\":1}}],[\"瓶盖开奖\",{\"1\":{\"19\":1}}],[\"瓶装饮料经常会出现输入优惠编码兑换奖品\",{\"1\":{\"19\":1}}],[\"即无法重复创建同样的节点\",{\"1\":{\"1387\":1}}],[\"即客户端向服务端\",{\"1\":{\"1385\":1}}],[\"即上面我们说的三个角色的总称\",{\"1\":{\"1378\":1}}],[\"即阶段提交\",{\"1\":{\"1371\":1}}],[\"即当协调者发送\",{\"1\":{\"1370\":1}}],[\"即当程序创建一个类的实例对象\",{\"1\":{\"344\":1}}],[\"即提交事务或者回滚事务\",{\"1\":{\"1370\":1}}],[\"即所有服务的\",{\"1\":{\"1370\":1}}],[\"即该节点最后一次的更新时间\",{\"1\":{\"1349\":1}}],[\"即该节点最终一次更新时的事务\",{\"1\":{\"1349\":1}}],[\"即该节点的创建时间\",{\"1\":{\"1349\":1}}],[\"即该数据节点被创建时的事务\",{\"1\":{\"1349\":1}}],[\"即原语的执行必须是连续的\",{\"1\":{\"1344\":1}}],[\"即图示切换\",{\"1\":{\"1308\":2}}],[\"即顺序消息只能发送至类型为顺序消息的主题中\",{\"1\":{\"1286\":1}}],[\"即定时消息只能发送至类型为定时消息的主题中\",{\"1\":{\"1285\":1}}],[\"即轮询\",{\"1\":{\"1250\":1}}],[\"即立即进行重试\",{\"1\":{\"1210\":1}}],[\"即到\",{\"1\":{\"1199\":1}}],[\"即远程过程调用\",{\"1\":{\"1165\":1}}],[\"即一致性\",{\"1\":{\"1143\":1}}],[\"即一个变量如何从主内存拷贝到工作内存\",{\"1\":{\"972\":1}}],[\"即一个\",{\"1\":{\"453\":1}}],[\"即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时\",{\"1\":{\"1077\":1}}],[\"即slottoexpunge\",{\"1\":{\"1036\":1}}],[\"即slottoexpunge=i\",{\"1\":{\"1036\":1}}],[\"即共享内存\",{\"1\":{\"972\":1}}],[\"即它是无界的\",{\"1\":{\"957\":1}}],[\"即释放锁\",{\"1\":{\"904\":1}}],[\"即低优先级的任务长时间得不到执行\",{\"1\":{\"897\":1}}],[\"即值最小的元素优先出队\",{\"1\":{\"897\":1}}],[\"即永远不会阻塞\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"即最小不可拆分的操作\",{\"1\":{\"841\":1,\"990\":1}}],[\"即最先等待的线程能够最先访问到\",{\"1\":{\"797\":1}}],[\"即如果对队列加锁的成本较高则适合使用无锁的\",{\"1\":{\"794\":1}}],[\"即链表首部的元素\",{\"1\":{\"712\":1}}],[\"即链表的第一个元素\",{\"1\":{\"706\":1,\"712\":1}}],[\"即在整个集群中是唯一的编号\",{\"1\":{\"1373\":1}}],[\"即在链表首部的元素\",{\"1\":{\"712\":1}}],[\"即在运行时才把方法调用与方法实现关联起来\",{\"1\":{\"519\":1}}],[\"即将一个文件或者其它对象映射到进程的地址空间\",{\"1\":{\"1310\":1}}],[\"即将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"904\":1}}],[\"即将新元素作为链表的最后一个元素\",{\"1\":{\"729\":1}}],[\"即将最近未访问的元素排在链表首部\",{\"1\":{\"709\":1}}],[\"即将回收\",{\"1\":{\"446\":1}}],[\"即每个消费者组的消费位置\",{\"1\":{\"1315\":1}}],[\"即每个节点的左右子树深度相差不超过1\",{\"1\":{\"97\":1}}],[\"即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址\",{\"1\":{\"708\":1}}],[\"即treeify\",{\"1\":{\"708\":1}}],[\"即trx\",{\"1\":{\"141\":2}}],[\"即总是优先级最高的元素先出队\",{\"1\":{\"669\":1}}],[\"即调用put\",{\"1\":{\"604\":1}}],[\"即优先级最高的元素\",{\"1\":{\"603\":2}}],[\"即先创建一个新的数组来容纳新添加的元素\",{\"1\":{\"588\":1}}],[\"即写时复制\",{\"1\":{\"585\":1}}],[\"即读读不互斥\",{\"1\":{\"584\":1,\"793\":1}}],[\"即为上面\",{\"1\":{\"1005\":1}}],[\"即为当前\",{\"1\":{\"577\":1}}],[\"即为\",{\"1\":{\"558\":1,\"559\":1,\"1315\":1}}],[\"即向数组中添加第一个元素时\",{\"1\":{\"555\":1}}],[\"即数组的列表数量多于此元素\",{\"1\":{\"553\":1}}],[\"即对象监视器\",{\"1\":{\"544\":1,\"862\":1}}],[\"即对象指向它的类元数据的指针\",{\"1\":{\"507\":1}}],[\"即通过锁机制来实现线程安全\",{\"1\":{\"544\":1}}],[\"即通过字面我们就能知道其值的含义\",{\"1\":{\"497\":1}}],[\"即生产用的是putlock\",{\"1\":{\"542\":1,\"672\":1}}],[\"即生产和消费用的是同一个锁\",{\"1\":{\"542\":1,\"672\":1}}],[\"即从头到尾循环复用一个数组\",{\"1\":{\"535\":1}}],[\"即等待条件非空时挂起\",{\"1\":{\"535\":1}}],[\"即各个生产者或者消费者线程收到通知后\",{\"1\":{\"534\":1}}],[\"即代表当前元素入队失败直接抛异常\",{\"1\":{\"533\":1}}],[\"即添加的元素达到上限之后\",{\"1\":{\"529\":1}}],[\"即我们常说的\",{\"1\":{\"529\":1}}],[\"即没有内存碎片\",{\"1\":{\"503\":1}}],[\"即新生代占整个堆的\",{\"1\":{\"452\":1}}],[\"即例子中的年龄\",{\"1\":{\"444\":1}}],[\"即不能再被任何途径使用的对象\",{\"1\":{\"389\":1}}],[\"即不能读到相同的数据内容\",{\"1\":{\"128\":1}}],[\"即程序调用类的静态方法\",{\"1\":{\"344\":1}}],[\"即程序给类的静态变量赋值\",{\"1\":{\"344\":1}}],[\"即程序访问类的静态变量\",{\"1\":{\"344\":1}}],[\"即静态变量\",{\"1\":{\"342\":1}}],[\"即时编译器编译后的代码等数据\",{\"1\":{\"813\":1}}],[\"即时编译器编译后的代码缓存等数据\",{\"1\":{\"341\":1,\"496\":1}}],[\"即时生成\",{\"1\":{\"19\":1}}],[\"即扩展名为\",{\"1\":{\"324\":1}}],[\"即10毫秒\",{\"1\":{\"302\":1}}],[\"即发送数据给客户端\",{\"1\":{\"267\":1}}],[\"即以空字符\",{\"1\":{\"256\":1}}],[\"即min\",{\"1\":{\"141\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"125\":1}}],[\"即查询中使用到最左边的列\",{\"1\":{\"116\":1}}],[\"即explain的输出结果extra字段为usingindex时\",{\"1\":{\"115\":1}}],[\"即使在异常情况下也会保证消息的顺序性\",{\"1\":{\"1299\":1}}],[\"即使在可达性分析法中不可达的对象\",{\"1\":{\"391\":1}}],[\"即使处理速度慢一点也无所谓\",{\"1\":{\"1273\":1}}],[\"即使某个消息消费异常\",{\"1\":{\"1209\":1}}],[\"即使有一部分的server宕机了它们仍然能够继续运行\",{\"1\":{\"1106\":1}}],[\"即使其中的一些节点出现故障也能够继续工作下去\",{\"1\":{\"1106\":1}}],[\"即使面对故障\",{\"1\":{\"1106\":1}}],[\"即使无法做到强一致性\",{\"1\":{\"1074\":1}}],[\"即使操作\",{\"1\":{\"974\":1}}],[\"即使\",{\"1\":{\"949\":1}}],[\"即使链表是有序的\",{\"1\":{\"800\":1}}],[\"即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来\",{\"1\":{\"741\":1}}],[\"即使是在多个线程一起执行的时候\",{\"1\":{\"762\":1}}],[\"即使是单线程下也有可能会出现这种情况\",{\"1\":{\"631\":1}}],[\"即使是乱序添加\",{\"1\":{\"599\":1}}],[\"即使指定了初始化容量\",{\"1\":{\"621\":1}}],[\"即使笔者先提到\",{\"1\":{\"599\":1}}],[\"即使用abstract修饰的类\",{\"1\":{\"520\":1}}],[\"即使程序什么也不做\",{\"1\":{\"384\":1}}],[\"即使两个类来源于同一个\",{\"1\":{\"357\":1}}],[\"即使数据库发生故障也不应该对其有任何影响\",{\"1\":{\"281\":1}}],[\"即使客户端的释放锁的代码逻辑出现问题\",{\"1\":{\"61\":1}}],[\"即使多个线程不在同一个\",{\"1\":{\"60\":1}}],[\"即使部分\",{\"1\":{\"51\":1}}],[\"即同一时刻只允许一个线程访问共享资源\",{\"1\":{\"60\":1}}],[\"即\",{\"1\":{\"47\":1,\"118\":1,\"445\":1,\"558\":1,\"588\":1,\"742\":1,\"904\":1,\"1230\":1}}],[\"即可根据\",{\"1\":{\"1315\":1}}],[\"即可订阅该消息\",{\"1\":{\"1222\":1}}],[\"即可开发出并发安全的程序\",{\"1\":{\"971\":1}}],[\"即可免费领取个人原创的\",{\"1\":{\"835\":1}}],[\"即可以通过索引快速访问元素\",{\"1\":{\"655\":1,\"726\":1}}],[\"即可以支持反向查找和遍历\",{\"1\":{\"180\":1,\"195\":1}}],[\"即可实现多线程之间的生产和消费\",{\"1\":{\"530\":1}}],[\"即可实现配置的动态变更\",{\"1\":{\"72\":1}}],[\"即可找到目标\",{\"1\":{\"286\":1}}],[\"即可无限等待\",{\"1\":{\"251\":1}}],[\"即可表示\",{\"1\":{\"203\":1}}],[\"即可\",{\"1\":{\"34\":1,\"47\":1,\"220\":1,\"257\":1,\"359\":1,\"710\":2,\"711\":2,\"1142\":1,\"1211\":1}}],[\"即可完成订单支付的功能\",{\"1\":{\"17\":1}}],[\"即产生\",{\"1\":{\"22\":1}}],[\"兑换之后核销\",{\"1\":{\"19\":1}}],[\"兑换码序列号的空间范围决定了优惠活动可以发行的兑换码数目\",{\"1\":{\"19\":1}}],[\"兑换码序列号\",{\"1\":{\"19\":2}}],[\"兑换码不能使用在双\",{\"1\":{\"19\":1}}],[\"兑换码可以预先生成\",{\"1\":{\"19\":1}}],[\"兑换码组成成分分析\",{\"1\":{\"19\":1}}],[\"兑换码要求近可能简洁\",{\"1\":{\"19\":1}}],[\"兑换券属于广撒网的策略\",{\"1\":{\"19\":1}}],[\"兑换券是运营推广最常用的促销工具之一\",{\"1\":{\"19\":1}}],[\"兑换音乐会员年卡\",{\"1\":{\"19\":1}}],[\"星期这些自增长的属于作为订单号的设计的一部分元素\",{\"1\":{\"18\":1}}],[\"星期\",{\"1\":{\"18\":1}}],[\"过半机制是如何防止脑裂现象产生的\",{\"1\":{\"1358\":1}}],[\"过半写成功\",{\"1\":{\"1355\":2}}],[\"过度设计\",{\"1\":{\"1132\":1}}],[\"过度切换\",{\"1\":{\"889\":1}}],[\"过程中\",{\"1\":{\"1368\":1}}],[\"过程中经常需要接触到的一个概念\",{\"1\":{\"1349\":1}}],[\"过程大体如下\",{\"1\":{\"1011\":1}}],[\"过程\",{\"1\":{\"578\":1}}],[\"过期了\",{\"1\":{\"1109\":1}}],[\"过期\",{\"0\":{\"1037\":1,\"1042\":1},\"1\":{\"1256\":1}}],[\"过期的数据的删除策略了解么\",{\"0\":{\"272\":1}}],[\"过期字典\",{\"1\":{\"271\":1}}],[\"过期字典是存储在\",{\"1\":{\"271\":1}}],[\"过期字典的值是一个\",{\"1\":{\"271\":1}}],[\"过期字典的键指向\",{\"1\":{\"271\":1}}],[\"过期时间除了有助于缓解内存的消耗\",{\"1\":{\"270\":1}}],[\"过期时间设置\",{\"1\":{\"48\":1}}],[\"过期数据的删除策略只用了惰性删除\",{\"1\":{\"245\":1}}],[\"过长的订单号或易读性差的订单号会导致客服输入困难且易错率较高\",{\"1\":{\"18\":1}}],[\"过滤器\",{\"1\":{\"6\":1,\"73\":1,\"74\":1,\"75\":1}}],[\"任期用连续的数字表示\",{\"1\":{\"1109\":1}}],[\"任期\",{\"0\":{\"1109\":1},\"1\":{\"1109\":1}}],[\"任务超时处理等场景\",{\"1\":{\"1285\":1}}],[\"任务调度框架\",{\"1\":{\"1218\":1}}],[\"任务全部执行完了才会跳出来\",{\"1\":{\"940\":1}}],[\"任务的执行\",{\"1\":{\"934\":1}}],[\"任务顺序执行\",{\"1\":{\"933\":1}}],[\"任务在任务队列中排队等待执行\",{\"1\":{\"895\":1,\"922\":1}}],[\"任务从保存到再加载的过程就是一次上下文切换\",{\"1\":{\"895\":1,\"922\":1}}],[\"任务队列为\",{\"1\":{\"940\":1}}],[\"任务队列已经满了\",{\"1\":{\"893\":1,\"941\":1}}],[\"任务队列中存放的任务达到队列容量的时候\",{\"1\":{\"890\":1,\"936\":1}}],[\"任务队列未达到队列容量时\",{\"1\":{\"890\":1,\"936\":1}}],[\"任务队列\",{\"1\":{\"890\":1,\"936\":1,\"941\":1}}],[\"任务队列最大长度为\",{\"1\":{\"889\":2,\"917\":2,\"937\":2}}],[\"任务会被保存在一个任务队列中\",{\"1\":{\"888\":1,\"937\":1}}],[\"任务可以不需要等到线程创建就能立即执行\",{\"1\":{\"887\":1,\"933\":1}}],[\"任务执行的效率会有显著性的提高\",{\"1\":{\"816\":1}}],[\"任务执行期间我自己可以去做任何想做的事情\",{\"1\":{\"773\":1,\"899\":1}}],[\"任务组合操作accepteitherasync\",{\"1\":{\"781\":1}}],[\"任务3开始执行\",{\"1\":{\"781\":2}}],[\"任务2执行完毕\",{\"1\":{\"781\":2}}],[\"任务2开始执行\",{\"1\":{\"781\":2}}],[\"任务1执行完毕\",{\"1\":{\"781\":2}}],[\"任务1开始执行\",{\"1\":{\"781\":2}}],[\"任务分为\",{\"1\":{\"742\":1,\"904\":1}}],[\"任务\",{\"1\":{\"599\":1,\"934\":1}}],[\"任务到期时间\",{\"1\":{\"599\":1}}],[\"任务线程执行完成\",{\"1\":{\"289\":1}}],[\"任何一个\",{\"1\":{\"1371\":1}}],[\"任何时刻对\",{\"1\":{\"1069\":1}}],[\"任何时候计数器为\",{\"1\":{\"390\":1}}],[\"任何时候\",{\"1\":{\"341\":1}}],[\"任何场景下都适用的完美收集器存在\",{\"1\":{\"400\":1}}],[\"任何人实现的编译器都可以向属性表中写\",{\"1\":{\"333\":1}}],[\"任何浏览器打开\",{\"1\":{\"17\":1}}],[\"任意一个时刻\",{\"1\":{\"61\":1}}],[\"任意修改一个字符就能查询到另一个订单信息\",{\"1\":{\"18\":1}}],[\"公示也只是参考\",{\"1\":{\"895\":1}}],[\"公平模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"公平锁和非公平锁有什么区别\",{\"0\":{\"858\":1}}],[\"公平锁和非公平锁等高级功能\",{\"1\":{\"857\":1}}],[\"公平锁\",{\"1\":{\"50\":1,\"858\":1,\"1018\":1}}],[\"公司\",{\"1\":{\"1178\":1}}],[\"公司开源的一套\",{\"1\":{\"53\":1,\"1332\":1}}],[\"公司流水号等信息\",{\"1\":{\"18\":1}}],[\"公众号支付\",{\"1\":{\"17\":1}}],[\"编号大于自己本地\",{\"1\":{\"1373\":1}}],[\"编号不能透露公司的运营情况\",{\"1\":{\"18\":1}}],[\"编程语言也可以直接复用操作系统层面的内存模型\",{\"1\":{\"971\":1}}],[\"编程错误可以分成三类\",{\"1\":{\"524\":1}}],[\"编写的一个开源的消息队列\",{\"1\":{\"1245\":1}}],[\"编写测试程序\",{\"1\":{\"940\":1}}],[\"编写一个\",{\"1\":{\"7\":1}}],[\"编了个程\",{\"1\":{\"412\":1,\"486\":1}}],[\"编译器和处理器怎么进行重排序优化都行\",{\"1\":{\"974\":1}}],[\"编译器和处理器追求的是较少约束的弱内存模型\",{\"1\":{\"974\":1}}],[\"编译器和处理器的指令重排序的处理方式不一样\",{\"1\":{\"969\":1}}],[\"编译器等\",{\"1\":{\"969\":1}}],[\"编译器优化重排\",{\"1\":{\"969\":2}}],[\"编译器\",{\"1\":{\"833\":1,\"969\":1}}],[\"编译器的发展与逃逸分析技术逐渐成熟\",{\"1\":{\"495\":1}}],[\"编译好\",{\"1\":{\"425\":1}}],[\"编译后代码\",{\"1\":{\"420\":1}}],[\"编译\",{\"1\":{\"418\":1}}],[\"编译的相关信息\",{\"1\":{\"366\":1}}],[\"编译等运行数据\",{\"1\":{\"366\":1}}],[\"编译得来\",{\"1\":{\"351\":1}}],[\"编码的字符串\",{\"1\":{\"328\":1}}],[\"编码或者解码或者图片的路径\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"编码方案\",{\"1\":{\"19\":1}}],[\"编码空间由字符\",{\"1\":{\"19\":1}}],[\"售后等系统内部的订单流程处理和跟进\",{\"1\":{\"18\":1}}],[\"成批\",{\"1\":{\"1315\":1}}],[\"成员变量\",{\"1\":{\"742\":1,\"904\":1}}],[\"成为大将军\",{\"1\":{\"1105\":1}}],[\"成为新的\",{\"1\":{\"1085\":1}}],[\"成为没有任何引用指向的空对象\",{\"1\":{\"712\":1}}],[\"成为一个完整的阻塞队列\",{\"1\":{\"533\":1}}],[\"成为了\",{\"1\":{\"391\":1,\"1276\":1}}],[\"成本\",{\"1\":{\"285\":1,\"922\":1}}],[\"成本也比较高\",{\"1\":{\"285\":1}}],[\"成本和收益不成正比\",{\"1\":{\"51\":1}}],[\"成功之后应该是获取锁成功\",{\"1\":{\"1007\":1}}],[\"成功取消返回\",{\"1\":{\"773\":1,\"899\":1}}],[\"成功获取商品详情和物流信息之后\",{\"1\":{\"772\":1}}],[\"成功获取锁的客户端在出现故障之后\",{\"1\":{\"53\":1}}],[\"成功获取锁的客户端在执行完业务流程之后\",{\"1\":{\"53\":1}}],[\"成功到达链表末端\",{\"1\":{\"710\":1}}],[\"成功了就直接\",{\"1\":{\"577\":1}}],[\"成功则返回true\",{\"1\":{\"744\":3}}],[\"成功则返回\",{\"1\":{\"533\":1,\"1007\":2}}],[\"成功完成时\",{\"1\":{\"231\":1}}],[\"成功建立连接后\",{\"1\":{\"86\":1}}],[\"成功\",{\"1\":{\"48\":1,\"576\":1,\"1002\":1}}],[\"成单\",{\"1\":{\"18\":1}}],[\"成熟稳定\",{\"1\":{\"10\":1}}],[\"缩短了支付流程\",{\"1\":{\"17\":1}}],[\"很牛\",{\"1\":{\"1276\":1}}],[\"很快\",{\"1\":{\"1276\":1}}],[\"很快就忘记了\",{\"1\":{\"975\":1}}],[\"很好地服务了集团大大小小上千个应用\",{\"1\":{\"1276\":1}}],[\"很好\",{\"1\":{\"1271\":1}}],[\"很好的应用之一\",{\"1\":{\"1018\":1}}],[\"很重要的一个参数\",{\"1\":{\"1206\":1}}],[\"很可能存在\",{\"1\":{\"1144\":1}}],[\"很可能成为系统性能的瓶颈点\",{\"1\":{\"297\":1}}],[\"很精彩的一个案例\",{\"1\":{\"919\":1}}],[\"很不错哦\",{\"1\":{\"896\":1}}],[\"很实用\",{\"1\":{\"895\":1,\"922\":1}}],[\"很简单\",{\"1\":{\"827\":1,\"1031\":1,\"1142\":1,\"1375\":1}}],[\"很难通过复制来解决这个问题\",{\"1\":{\"484\":1}}],[\"很适合使用标志位来表示\",{\"1\":{\"331\":1}}],[\"很明显是不能的\",{\"1\":{\"843\":1,\"992\":1}}],[\"很明显这样做的目的是定义好了\",{\"1\":{\"533\":1}}],[\"很明显需要继承\",{\"1\":{\"354\":1}}],[\"很明显\",{\"1\":{\"147\":1,\"307\":1}}],[\"很相似\",{\"1\":{\"147\":1}}],[\"很多功能都依赖于它\",{\"1\":{\"1385\":1}}],[\"很多功能的实现依赖了\",{\"1\":{\"1341\":1}}],[\"很多顶级的开源项目都用到了\",{\"1\":{\"1344\":1}}],[\"很多事情是没有完美的方案的\",{\"1\":{\"1314\":1}}],[\"很多比较杠精的人就说\",{\"1\":{\"1193\":1}}],[\"很多软件同时支持多端\",{\"1\":{\"1155\":1,\"1161\":1}}],[\"很多公司也在开发\",{\"1\":{\"1132\":1}}],[\"很多初学者非常容易搞混\",{\"1\":{\"973\":1}}],[\"很多人喜欢拿\",{\"1\":{\"1169\":1}}],[\"很多人在实际项目中都会有类似这样的问题\",{\"1\":{\"919\":1}}],[\"很多人甚至可能都会觉得把线程池配置过大一点比较好\",{\"1\":{\"895\":1,\"922\":1}}],[\"很多人会误认为自增操作\",{\"1\":{\"835\":1}}],[\"很多开源框架都大量使用了\",{\"1\":{\"847\":1}}],[\"很多\",{\"1\":{\"819\":1}}],[\"很多计算可以分成多个阶段或步骤\",{\"1\":{\"774\":2,\"901\":1}}],[\"很多读者此时就会有这样一个疑问\",{\"1\":{\"708\":1}}],[\"很多同学可能会说了\",{\"1\":{\"694\":1}}],[\"很多框架\",{\"1\":{\"523\":1}}],[\"很多解决方案我也没太弄明白\",{\"1\":{\"316\":1}}],[\"很多文章里\",{\"1\":{\"256\":1}}],[\"很多小伙伴可能要问了\",{\"1\":{\"219\":1}}],[\"很多问题也就不成问题了\",{\"1\":{\"80\":1}}],[\"很多时候\",{\"1\":{\"30\":1,\"270\":1}}],[\"很多时候搜索订单相关信息的时候都是以订单\",{\"1\":{\"18\":1}}],[\"很多地方都要用到分布式\",{\"1\":{\"30\":1}}],[\"很丝滑\",{\"1\":{\"17\":1}}],[\"很少见到根据具体的业务场景去选型\",{\"1\":{\"15\":1}}],[\"文章地址\",{\"1\":{\"1178\":1}}],[\"文章传送门\",{\"1\":{\"1177\":1}}],[\"文章推荐\",{\"0\":{\"486\":1}}],[\"文章点赞\",{\"1\":{\"190\":1,\"259\":1}}],[\"文章信息\",{\"1\":{\"186\":1}}],[\"文件系统非常相似\",{\"1\":{\"1382\":1}}],[\"文件系统的权限控制\",{\"1\":{\"1351\":1}}],[\"文件系统路径非常相似\",{\"1\":{\"1348\":1}}],[\"文件系统最小单位块为4k\",{\"1\":{\"109\":1}}],[\"文件要设计成固定大小的长度呢\",{\"1\":{\"1315\":1}}],[\"文件采取定长设计\",{\"1\":{\"1315\":1}}],[\"文件夹的组织方式如下\",{\"1\":{\"1315\":1}}],[\"文件夹位置\",{\"1\":{\"909\":1}}],[\"文件可以看成是基于\",{\"1\":{\"1315\":1}}],[\"文件可以通过javap\",{\"1\":{\"328\":1}}],[\"文件名长度为\",{\"1\":{\"1315\":1}}],[\"文件读写等\",{\"1\":{\"925\":1}}],[\"文件读取这类都是\",{\"1\":{\"895\":1,\"922\":1}}],[\"文件配置\",{\"1\":{\"523\":1}}],[\"文件加载到内存\",{\"1\":{\"428\":1}}],[\"文件字节码内容加载到内存中\",{\"1\":{\"426\":1}}],[\"文件经过编译后变成\",{\"1\":{\"424\":1}}],[\"文件搬过来就是先丢到这一块上\",{\"1\":{\"420\":1}}],[\"文件全部搬进\",{\"1\":{\"419\":1}}],[\"文件分析历程转载\",{\"1\":{\"412\":1}}],[\"文件获取相关信息\",{\"1\":{\"341\":1,\"496\":1}}],[\"文件格式检查\",{\"1\":{\"341\":1}}],[\"文件格式验证这一阶段是基于该类的二进制字节流进行的\",{\"1\":{\"341\":1}}],[\"文件格式验证\",{\"1\":{\"341\":1}}],[\"文件呢\",{\"1\":{\"339\":1}}],[\"文件需要加载到虚拟机中之后才能运行和使用\",{\"1\":{\"339\":1}}],[\"文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式\",{\"1\":{\"332\":1}}],[\"文件存储的是每一次写命令\",{\"1\":{\"236\":1}}],[\"文件存储的内容是经过压缩的二进制数据\",{\"1\":{\"236\":1}}],[\"文件版本号\",{\"0\":{\"327\":1}}],[\"文件结构涉及到的一些组件\",{\"1\":{\"325\":1}}],[\"文件结构\",{\"1\":{\"325\":1}}],[\"文件结构总结\",{\"0\":{\"325\":1}}],[\"文件通过\",{\"1\":{\"325\":1}}],[\"文件二进制数据不使用\",{\"1\":{\"294\":1}}],[\"文件事件分派器\",{\"1\":{\"265\":1}}],[\"文件事件处理器\",{\"1\":{\"265\":2}}],[\"文件事件处理器既实现了高性能的网络通信模型\",{\"1\":{\"265\":1}}],[\"文件事件处理器使用\",{\"1\":{\"265\":1}}],[\"文件没有被重写\",{\"1\":{\"236\":1}}],[\"文件来解决一些问题\",{\"1\":{\"236\":1}}],[\"文件来找出\",{\"1\":{\"164\":1,\"293\":1}}],[\"文件是如何被运行的\",{\"0\":{\"418\":1}}],[\"文件是以特定的二进制格式保存的\",{\"1\":{\"236\":1}}],[\"文件是否完整\",{\"1\":{\"234\":1}}],[\"文件恢复数据\",{\"1\":{\"236\":1}}],[\"文件大很多\",{\"1\":{\"236\":1}}],[\"文件大小为\",{\"1\":{\"1315\":1}}],[\"文件大小增加了这个百分比值\",{\"1\":{\"233\":1}}],[\"文件大小小于该值\",{\"1\":{\"233\":1}}],[\"文件很小\",{\"1\":{\"236\":1}}],[\"文件开头\",{\"1\":{\"235\":1}}],[\"文件也有类似的校验机制来保证\",{\"1\":{\"234\":1}}],[\"文件内容进行\",{\"1\":{\"234\":1}}],[\"文件所保存的数据库状态一样\",{\"1\":{\"233\":1,\"236\":1}}],[\"文件和原有的\",{\"1\":{\"233\":1,\"236\":1}}],[\"文件被分为三种类型\",{\"1\":{\"231\":1}}],[\"文件拆分成多个\",{\"1\":{\"231\":1}}],[\"文件进行分析\",{\"1\":{\"236\":1}}],[\"文件进行检查\",{\"1\":{\"234\":1}}],[\"文件进行任何读入\",{\"1\":{\"233\":1}}],[\"文件进行数据恢复\",{\"1\":{\"230\":1}}],[\"文件进行重写\",{\"1\":{\"230\":1}}],[\"文件越来越大\",{\"1\":{\"230\":1}}],[\"文件重写期间\",{\"1\":{\"233\":1}}],[\"文件重写\",{\"1\":{\"230\":1}}],[\"文件重写操作\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件同步\",{\"1\":{\"230\":1}}],[\"文件同步数据\",{\"1\":{\"224\":1}}],[\"文件写入\",{\"1\":{\"230\":1}}],[\"文件写到一定大小后会切换到下一个\",{\"1\":{\"89\":1}}],[\"文件中根据\",{\"1\":{\"1315\":1}}],[\"文件中除了有类的版本\",{\"1\":{\"497\":1}}],[\"文件中的常量池详解\",{\"1\":{\"334\":1}}],[\"文件中的时间信息还可以实现\",{\"1\":{\"233\":1}}],[\"文件中其它的数据项目要求的顺序\",{\"1\":{\"333\":1}}],[\"文件中有定义\",{\"1\":{\"268\":1}}],[\"文件中以保证数据完整性\",{\"1\":{\"233\":1}}],[\"文件中\",{\"1\":{\"229\":1,\"230\":1,\"302\":1}}],[\"文件替换旧的\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件保存的数据库状态与现有的数据库状态一致\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件的运行\",{\"1\":{\"806\":1}}],[\"文件的常量池里保存有大量的符号引用比如方法引用的符号引用\",{\"1\":{\"493\":1}}],[\"文件的加载\",{\"1\":{\"426\":1}}],[\"文件的\",{\"1\":{\"426\":1}}],[\"文件的字节流中包含的信息符合\",{\"1\":{\"341\":1}}],[\"文件的版本号信息\",{\"1\":{\"327\":1}}],[\"文件的版本号\",{\"1\":{\"327\":1}}],[\"文件的头\",{\"1\":{\"326\":1}}],[\"文件的组成\",{\"1\":{\"325\":1}}],[\"文件的标志\",{\"1\":{\"325\":1,\"326\":1}}],[\"文件的工作不会阻塞主线程\",{\"1\":{\"236\":1}}],[\"文件的工作之后\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件的过程是比较繁重的\",{\"1\":{\"236\":1}}],[\"文件的正确性\",{\"1\":{\"234\":1}}],[\"文件的保存管理\",{\"1\":{\"233\":1}}],[\"文件的保存位置和\",{\"1\":{\"229\":1}}],[\"文件的时机\",{\"1\":{\"231\":1}}],[\"文件的位置相同\",{\"1\":{\"229\":1}}],[\"文件的末尾\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件期间\",{\"1\":{\"162\":1,\"233\":1}}],[\"文件时\",{\"1\":{\"161\":1}}],[\"文件\",{\"0\":{\"369\":1},\"1\":{\"161\":3,\"162\":1,\"231\":7,\"233\":2,\"234\":1,\"236\":1,\"268\":1,\"293\":1,\"326\":1,\"327\":2,\"328\":1,\"333\":1,\"351\":1,\"353\":1,\"357\":1,\"364\":1,\"368\":3,\"369\":1,\"412\":3,\"419\":1,\"455\":1,\"851\":1}}],[\"文库\",{\"1\":{\"19\":1}}],[\"文库的研发同学在这个思路上\",{\"1\":{\"17\":1}}],[\"文库会员支付示例\",{\"1\":{\"17\":1}}],[\"文档很详细\",{\"1\":{\"1236\":1}}],[\"文档中写到\",{\"1\":{\"354\":1}}],[\"文档的介绍\",{\"1\":{\"351\":1}}],[\"文档地址\",{\"1\":{\"218\":1,\"293\":1,\"298\":1}}],[\"文档已更改\",{\"1\":{\"128\":1}}],[\"文档\",{\"1\":{\"2\":2,\"787\":1}}],[\"内联汇编的形式实现的\",{\"1\":{\"841\":1,\"990\":1}}],[\"内执行\",{\"1\":{\"814\":1}}],[\"内核态线程\",{\"1\":{\"808\":1}}],[\"内核线程\",{\"1\":{\"808\":2}}],[\"内核通常为\",{\"1\":{\"230\":1}}],[\"内容概览\",{\"1\":{\"1173\":1}}],[\"内容为\",{\"1\":{\"1131\":1}}],[\"内容分析\",{\"1\":{\"325\":1}}],[\"内容简洁\",{\"1\":{\"19\":1}}],[\"内置线程安全队列\",{\"1\":{\"1179\":1}}],[\"内置线程安全队列的性能和内存安全问题\",{\"1\":{\"1179\":1}}],[\"内置的inheritablethreadlocal类\",{\"1\":{\"929\":1}}],[\"内置监控告警功能\",{\"1\":{\"896\":1,\"923\":1}}],[\"内置了延时队列\",{\"1\":{\"249\":1}}],[\"内置了多种优化过后的数据类型\",{\"1\":{\"243\":1}}],[\"内置了多种数据类型实现\",{\"1\":{\"242\":1}}],[\"内置浏览器中实现\",{\"1\":{\"17\":1}}],[\"内存映射机制\",{\"1\":{\"1315\":1}}],[\"内存容量相对较大\",{\"1\":{\"1184\":1}}],[\"内存级别的消息队列\",{\"1\":{\"1180\":1}}],[\"内存访问重排序的研究\",{\"1\":{\"982\":1}}],[\"内存结构和\",{\"1\":{\"973\":1}}],[\"内存系统重排\",{\"1\":{\"969\":1}}],[\"内存系统也会有\",{\"1\":{\"969\":1}}],[\"内存缓存不一致性的问题\",{\"1\":{\"968\":1}}],[\"内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题\",{\"1\":{\"968\":1}}],[\"内存看作外存的高速缓存\",{\"1\":{\"968\":1}}],[\"内存溢出\",{\"1\":{\"951\":1}}],[\"内存屏障\",{\"1\":{\"834\":1,\"969\":1,\"1184\":1}}],[\"内存模型和\",{\"1\":{\"973\":1}}],[\"内存模型定义来以下八种同步操作\",{\"1\":{\"972\":1}}],[\"内存模型的抽象示意图如下\",{\"1\":{\"972\":1}}],[\"内存模型下\",{\"1\":{\"972\":1}}],[\"内存模型\",{\"0\":{\"831\":1,\"967\":1},\"1\":{\"831\":2,\"833\":2,\"967\":2,\"968\":1,\"972\":2,\"982\":2}}],[\"内存等系统资源进行处理\",{\"1\":{\"821\":1}}],[\"内存泄露问题是怎么导致的\",{\"0\":{\"884\":1}}],[\"内存泄露的排查分析\",{\"1\":{\"412\":1,\"486\":1}}],[\"内存泄漏\",{\"1\":{\"817\":1}}],[\"内存是放不下的\",{\"1\":{\"684\":1}}],[\"内存地址不连续\",{\"1\":{\"655\":1,\"726\":1}}],[\"内存空间占用\",{\"1\":{\"552\":1,\"656\":1}}],[\"内存空间调整\",{\"1\":{\"412\":1}}],[\"内存占用\",{\"1\":{\"542\":1,\"585\":1,\"672\":1}}],[\"内存配置最佳实践\",{\"1\":{\"486\":1}}],[\"内存区域和内存模型是完全不一样的两个东西\",{\"1\":{\"973\":1}}],[\"内存区域和\",{\"0\":{\"973\":1}}],[\"内存区域\",{\"1\":{\"489\":1,\"810\":1}}],[\"内存区域常见配置参数\",{\"1\":{\"477\":1}}],[\"内存区域详解\",{\"1\":{\"341\":1,\"382\":1}}],[\"内存的分配和回收都是动态的\",{\"1\":{\"445\":1}}],[\"内存的访问速度是磁盘的上千倍\",{\"1\":{\"243\":1}}],[\"内存会划分为堆内存和非堆内存\",{\"1\":{\"443\":1}}],[\"内存中对象的分配与回收\",{\"1\":{\"382\":1}}],[\"内存监控\",{\"0\":{\"375\":1},\"1\":{\"375\":1}}],[\"内存\",{\"1\":{\"366\":1,\"377\":1,\"384\":1,\"515\":1,\"1178\":1}}],[\"内存淘汰机制了解么\",{\"0\":{\"273\":1}}],[\"内存淘汰机制\",{\"1\":{\"272\":1}}],[\"内存管理机制不用自己去处理指针\",{\"1\":{\"515\":1}}],[\"内存管理\",{\"0\":{\"269\":1}}],[\"内存管理>\",{\"1\":{\"221\":1}}],[\"内存数据库\",{\"1\":{\"242\":1}}],[\"内存分配完成后\",{\"1\":{\"504\":1}}],[\"内存分配并发问题\",{\"1\":{\"503\":1}}],[\"内存分配的两种方式\",{\"1\":{\"503\":1}}],[\"内存分配和回收都是确定的\",{\"1\":{\"445\":1}}],[\"内存分配和回收原则\",{\"0\":{\"383\":1}}],[\"内存分配\",{\"1\":{\"221\":1}}],[\"内存分配器为了存储数据实际申请使用的内存空间大小\",{\"1\":{\"219\":1}}],[\"内存相关的信息\",{\"1\":{\"219\":1}}],[\"内存单元示意图\",{\"1\":{\"218\":1}}],[\"内存碎片详解\",{\"1\":{\"303\":1}}],[\"内存碎片清理所占用\",{\"1\":{\"220\":2}}],[\"内存碎片占用空间达到\",{\"1\":{\"220\":1}}],[\"内存碎片率大于\",{\"1\":{\"220\":1}}],[\"内存碎片率太低该怎么办\",{\"1\":{\"219\":1}}],[\"内存碎片率可能存在小于\",{\"1\":{\"219\":1}}],[\"内存碎片率\",{\"1\":{\"219\":2}}],[\"内存碎片率的计算公式\",{\"1\":{\"219\":1}}],[\"内存碎片的信息\",{\"0\":{\"219\":1}}],[\"内存碎片产生比较常见的\",{\"1\":{\"218\":1}}],[\"内存碎片虽然不会影响\",{\"1\":{\"217\":1}}],[\"内存碎片\",{\"0\":{\"218\":1,\"220\":1,\"303\":1},\"1\":{\"217\":1,\"303\":2}}],[\"内存不可控的增长\",{\"1\":{\"168\":1}}],[\"内存不够用或者爆满的问题\",{\"1\":{\"168\":1}}],[\"内存交换\",{\"0\":{\"168\":1}}],[\"内部主要是使用基于\",{\"1\":{\"1311\":1}}],[\"内部没有复杂的线程封装\",{\"1\":{\"1293\":1}}],[\"内部没有被调用过\",{\"1\":{\"564\":1}}],[\"内部按最大吞吐量触发消息处理\",{\"1\":{\"1292\":1}}],[\"内部用内存队列做排队\",{\"1\":{\"1262\":1}}],[\"内部就是通过\",{\"1\":{\"1045\":1}}],[\"内部方法\",{\"1\":{\"1003\":1}}],[\"内部线程池时\",{\"1\":{\"928\":1}}],[\"内部线程池的坑\",{\"0\":{\"928\":1}}],[\"内部采用的是\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"内部代码我们就不分析了\",{\"1\":{\"794\":1}}],[\"内部类\",{\"1\":{\"748\":1}}],[\"内部类无效\",{\"1\":{\"521\":1}}],[\"内部维护了一个双向链表\",{\"1\":{\"716\":1,\"719\":1}}],[\"内部维护一个定长的数组用于存储元素\",{\"1\":{\"544\":1}}],[\"内部链表转红黑树时\",{\"1\":{\"708\":1}}],[\"内部基于动态数组实现\",{\"1\":{\"649\":1}}],[\"内部通过链表\",{\"1\":{\"791\":1}}],[\"内部通过一个\",{\"1\":{\"756\":1,\"911\":1}}],[\"内部通过setarray方法修改了array属性的值\",{\"1\":{\"589\":1}}],[\"内部通过getarray\",{\"1\":{\"589\":1}}],[\"内部可以很方便的获取锁\",{\"1\":{\"571\":1}}],[\"内部实现的一种方式\",{\"1\":{\"1381\":1}}],[\"内部实现也差不多\",{\"1\":{\"184\":1}}],[\"内部实际调用了\",{\"1\":{\"563\":1}}],[\"内部直接调用了\",{\"1\":{\"557\":1}}],[\"内部调用了\",{\"1\":{\"536\":1}}],[\"内部组件使用的类库\",{\"1\":{\"359\":1}}],[\"内部的\",{\"1\":{\"1184\":1}}],[\"内部的各个\",{\"1\":{\"1085\":1}}],[\"内部的方法基本都经过synchronized\",{\"1\":{\"677\":1}}],[\"内部的核心类库\",{\"1\":{\"353\":1}}],[\"内部的执行过程\",{\"1\":{\"81\":1}}],[\"内部单线程设计的简单性\",{\"1\":{\"265\":1}}],[\"内部做了非常多的性能优化\",{\"1\":{\"243\":1}}],[\"内部里嵌入\",{\"1\":{\"6\":1}}],[\"介绍到的内容都是最基本的操作\",{\"1\":{\"1319\":1}}],[\"介绍了\",{\"1\":{\"1316\":1,\"1349\":1}}],[\"介绍的挺不错\",{\"1\":{\"585\":1}}],[\"介绍下\",{\"1\":{\"489\":1}}],[\"介绍一下\",{\"1\":{\"380\":1}}],[\"介绍\",{\"0\":{\"27\":1,\"176\":1,\"180\":1,\"184\":1,\"188\":1,\"192\":1,\"201\":1,\"205\":1,\"209\":1,\"740\":1,\"747\":1,\"751\":1,\"755\":1,\"773\":1,\"774\":1,\"949\":1,\"953\":1,\"957\":1,\"961\":1,\"1097\":1,\"1342\":1},\"1\":{\"17\":1,\"41\":1,\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1,\"202\":1,\"206\":1,\"210\":1}}],[\"浏览器\",{\"1\":{\"1155\":1}}],[\"浏览器插件等很多信息\",{\"1\":{\"17\":1}}],[\"浏览器语言\",{\"1\":{\"17\":1}}],[\"浏览器渲染引擎\",{\"1\":{\"17\":1}}],[\"浏览器及版本\",{\"1\":{\"17\":1}}],[\"类源码中都无法解答\",{\"1\":{\"1002\":1}}],[\"类介绍\",{\"0\":{\"935\":1}}],[\"类都可以代表异步计算的结果\",{\"1\":{\"934\":1}}],[\"类都有一个引用指向加载它的\",{\"1\":{\"340\":1,\"351\":2}}],[\"类都有父类\",{\"1\":{\"330\":1}}],[\"类描述\",{\"1\":{\"934\":2}}],[\"类创建线程池\",{\"1\":{\"917\":1}}],[\"类来改进\",{\"1\":{\"909\":1}}],[\"类有个\",{\"1\":{\"1210\":1}}],[\"类有什么用\",{\"0\":{\"899\":1,\"901\":1}}],[\"类有两个关键的方法\",{\"1\":{\"354\":1}}],[\"类内部的\",{\"1\":{\"883\":1}}],[\"类实现的定制化的\",{\"1\":{\"883\":1}}],[\"类实现了接口\",{\"1\":{\"496\":1}}],[\"类在\",{\"1\":{\"882\":1}}],[\"类上锁\",{\"1\":{\"848\":1}}],[\"类加锁\",{\"1\":{\"848\":1}}],[\"类加载检查\",{\"0\":{\"502\":1}}],[\"类加载器将\",{\"1\":{\"420\":1}}],[\"类加载器在进行类加载的时候\",{\"1\":{\"357\":1,\"359\":1}}],[\"类加载器之间的父子关系一般不是以继承的关系来实现的\",{\"1\":{\"356\":1}}],[\"类加载器层次关系图\",{\"1\":{\"353\":1,\"356\":1}}],[\"类加载器总结\",{\"0\":{\"353\":1}}],[\"类加载器加载规则\",{\"0\":{\"352\":1}}],[\"类加载器还可以加载\",{\"1\":{\"351\":1}}],[\"类加载器的加载顺序\",{\"0\":{\"432\":1}}],[\"类加载器的流程\",{\"0\":{\"427\":1}}],[\"类加载器的介绍\",{\"0\":{\"426\":1}}],[\"类加载器的主要作用就是加载\",{\"1\":{\"351\":1}}],[\"类加载器的实例\",{\"1\":{\"345\":1}}],[\"类加载器应尝试定位或生成构成类定义的数据\",{\"1\":{\"351\":1}}],[\"类加载器是一个负责加载类的对象\",{\"1\":{\"351\":2}}],[\"类加载器从最底层开始往上的顺序是这样的\",{\"1\":{\"432\":1}}],[\"类加载器从\",{\"1\":{\"351\":1}}],[\"类加载器介绍\",{\"0\":{\"351\":1}}],[\"类加载器详解\",{\"0\":{\"348\":1}}],[\"类加载器有很多种\",{\"1\":{\"340\":1,\"356\":1}}],[\"类加载器\",{\"0\":{\"350\":1,\"419\":1},\"1\":{\"340\":2,\"360\":1,\"419\":1}}],[\"类加载过程的第一步\",{\"1\":{\"340\":1}}],[\"类加载过程\",{\"0\":{\"339\":1},\"1\":{\"339\":1,\"349\":2}}],[\"类加载过程详解\",{\"0\":{\"337\":1}}],[\"类就是用来解决\",{\"1\":{\"843\":1,\"992\":1}}],[\"类对象加锁\",{\"1\":{\"834\":1}}],[\"类提供了三个开箱即用的内存屏障相关的方法\",{\"1\":{\"834\":1}}],[\"类可以解决future\",{\"1\":{\"774\":1,\"901\":1}}],[\"类可以被动态加载到\",{\"1\":{\"351\":1}}],[\"类只是一个泛型接口\",{\"1\":{\"773\":1,\"899\":1}}],[\"类获取到耗时任务的执行结果\",{\"1\":{\"773\":1,\"899\":1}}],[\"类是个什么东西了\",{\"1\":{\"882\":1}}],[\"类是异步思想的典型运用\",{\"1\":{\"773\":1,\"899\":1}}],[\"类是否相同的具体规则\",{\"1\":{\"357\":1}}],[\"类主要利用\",{\"1\":{\"765\":1}}],[\"类使用示例\",{\"1\":{\"763\":1,\"766\":1,\"767\":3,\"768\":1}}],[\"类使用委托模型来搜索类和资源\",{\"1\":{\"356\":2}}],[\"类常用方法\",{\"1\":{\"763\":1,\"766\":1}}],[\"类比我们开发网站后台系统使用的缓存\",{\"1\":{\"968\":1}}],[\"类比于实现世界中的人类通过合作做某件事情\",{\"1\":{\"895\":1,\"922\":1}}],[\"类比于我们高考时候的考生编号的生成规则\",{\"1\":{\"18\":1}}],[\"类比int\",{\"1\":{\"697\":3}}],[\"类图\",{\"1\":{\"533\":1,\"549\":1,\"586\":1,\"727\":1}}],[\"类名\",{\"1\":{\"523\":1}}],[\"类级别属性\",{\"1\":{\"521\":1}}],[\"类构造器方法<clinit>\",{\"1\":{\"430\":1}}],[\"类后\",{\"1\":{\"425\":1}}],[\"类需要同时满足下面\",{\"1\":{\"394\":1}}],[\"类时\",{\"1\":{\"358\":1}}],[\"类中包含了一个数据节点的所有状态信息的字段\",{\"1\":{\"1349\":1}}],[\"类中实际有\",{\"1\":{\"1335\":1}}],[\"类中提供的四个构造方法\",{\"1\":{\"936\":1}}],[\"类中可以通过thread\",{\"1\":{\"883\":1}}],[\"类中有一个\",{\"1\":{\"883\":1}}],[\"类中读锁为什么不能升级为写锁\",{\"1\":{\"876\":1}}],[\"类中所有的\",{\"1\":{\"521\":1}}],[\"类中的相关源代码来看一下相关实现\",{\"1\":{\"949\":1}}],[\"类中的其他方法都是\",{\"1\":{\"744\":1}}],[\"类中的所有成员⽅法都会被隐式地指定为\",{\"1\":{\"521\":1}}],[\"类中的\",{\"1\":{\"354\":1,\"359\":1,\"391\":1,\"767\":1}}],[\"类中方法的符号引用\",{\"1\":{\"328\":1}}],[\"类文件\",{\"1\":{\"351\":1}}],[\"类文件结构详解\",{\"0\":{\"323\":1}}],[\"类卸载\",{\"0\":{\"345\":1}}],[\"类符号引用进行\",{\"1\":{\"343\":1}}],[\"类方法\",{\"1\":{\"343\":1}}],[\"类变量所使用的内存都应当在\",{\"1\":{\"342\":1}}],[\"类信息\",{\"1\":{\"341\":1,\"496\":1,\"972\":1}}],[\"类从被加载到虚拟机内存中开始到卸载出内存为止\",{\"1\":{\"338\":1}}],[\"类的时候需要用到\",{\"1\":{\"1182\":1}}],[\"类的相关字节码信息\",{\"1\":{\"851\":1}}],[\"类的详细介绍可以看这篇文章\",{\"1\":{\"841\":1,\"990\":1}}],[\"类的本地方法\",{\"1\":{\"825\":1}}],[\"类的静态本地方法\",{\"1\":{\"825\":1}}],[\"类的定义\",{\"1\":{\"774\":1,\"901\":1}}],[\"类的部分源码\",{\"1\":{\"765\":1}}],[\"类的\",{\"0\":{\"827\":1},\"1\":{\"630\":2,\"765\":1,\"883\":1,\"1210\":1}}],[\"类的属性\",{\"1\":{\"619\":1}}],[\"类的一个方法\",{\"1\":{\"446\":1}}],[\"类的源码\",{\"1\":{\"435\":1}}],[\"类的顺序也是有优先级的\",{\"1\":{\"432\":1}}],[\"类的类型信息的方法表\",{\"1\":{\"425\":1}}],[\"类的类型信息\",{\"1\":{\"425\":1}}],[\"类的信息放到方法区中\",{\"1\":{\"425\":1}}],[\"类的信息的\",{\"1\":{\"425\":1}}],[\"类的加载\",{\"1\":{\"425\":1}}],[\"类的话\",{\"1\":{\"358\":1}}],[\"类的字节码\",{\"1\":{\"351\":1,\"353\":1}}],[\"类的正确性检查\",{\"1\":{\"341\":1}}],[\"类的生命周期\",{\"0\":{\"338\":1}}],[\"类的父类索引都不为\",{\"1\":{\"330\":1}}],[\"类的继承关系由类索引\",{\"1\":{\"330\":1}}],[\"类索引用于确定这个类的全限定名\",{\"1\":{\"330\":1}}],[\"类索引\",{\"1\":{\"330\":1}}],[\"类访问和属性修饰符\",{\"1\":{\"329\":2}}],[\"类或接口的符号引用\",{\"1\":{\"328\":1}}],[\"类和接口的全限定名\",{\"1\":{\"328\":1}}],[\"类似数据库的连接池\",{\"1\":{\"1290\":1}}],[\"类似下面这样\",{\"1\":{\"1151\":1}}],[\"类似的情况其实在\",{\"1\":{\"1159\":1}}],[\"类似的问题\",{\"1\":{\"826\":1}}],[\"类似的概念还有\",{\"1\":{\"499\":1}}],[\"类似的说法出现在explain查询计划优化章节\",{\"1\":{\"115\":1}}],[\"类似我们前面讲的\",{\"1\":{\"376\":1}}],[\"类似地\",{\"1\":{\"234\":1}}],[\"类似\",{\"1\":{\"193\":2,\"364\":1,\"408\":1,\"690\":1,\"755\":1,\"910\":1,\"1158\":1,\"1298\":1,\"1328\":1}}],[\"类似键值对的形式\",{\"1\":{\"103\":1}}],[\"类似于广播模式\",{\"1\":{\"1194\":1,\"1229\":1}}],[\"类似于赛跑\",{\"1\":{\"753\":1}}],[\"类似于数学上的函数\",{\"1\":{\"640\":1}}],[\"类似于一个指针一样的\",{\"1\":{\"423\":1}}],[\"类似于\",{\"1\":{\"4\":1,\"168\":1,\"184\":1,\"192\":1,\"210\":1,\"236\":1,\"871\":2,\"1351\":1}}],[\"类\",{\"1\":{\"60\":1,\"329\":1,\"353\":1,\"358\":5,\"425\":1,\"498\":1,\"521\":1,\"600\":1,\"762\":1,\"848\":2,\"871\":1,\"939\":1,\"1057\":1,\"1131\":1,\"1166\":1}}],[\"类型常用在处理有优先级的任务\",{\"1\":{\"1252\":1}}],[\"类型常用来广播消息\",{\"1\":{\"1252\":1}}],[\"类型交换器\",{\"1\":{\"1252\":2}}],[\"类型是所有的交换机类型里面速度最快的\",{\"1\":{\"1252\":1}}],[\"类型是一种无序集合\",{\"1\":{\"188\":1}}],[\"类型信息的要求\",{\"1\":{\"341\":1}}],[\"类型存储较大的文件对应的二进制数据\",{\"1\":{\"292\":1}}],[\"类型上定义的一组面向位的操作\",{\"1\":{\"201\":1}}],[\"类型的消息\",{\"1\":{\"1304\":1}}],[\"类型的交换器性能会很差\",{\"1\":{\"1252\":1}}],[\"类型的交换器不依赖于路由键的匹配规则来路由消息\",{\"1\":{\"1252\":1}}],[\"类型的交换器相似\",{\"1\":{\"1252\":1}}],[\"类型的交换器在匹配规则上进行了扩展\",{\"1\":{\"1252\":1}}],[\"类型的交换器路由规则是完全匹配\",{\"1\":{\"1252\":1}}],[\"类型的交换器就会无视\",{\"1\":{\"1249\":1}}],[\"类型的成员变量来表示同步状态\",{\"1\":{\"1004\":1}}],[\"类型的对象\",{\"1\":{\"944\":1}}],[\"类型的变量\",{\"1\":{\"883\":1}}],[\"类型的getstate\",{\"1\":{\"742\":1,\"904\":1}}],[\"类型的数组\",{\"1\":{\"649\":1}}],[\"类型的数据存储的数值代表的是另一块内存的起始地址\",{\"1\":{\"392\":1}}],[\"类型的数据结构更加适合用来做消息队列\",{\"1\":{\"249\":1}}],[\"类型的数据\",{\"1\":{\"245\":1}}],[\"类型的文件主要三步\",{\"1\":{\"339\":1}}],[\"类型的标志位\",{\"1\":{\"328\":1}}],[\"类型的整数\",{\"1\":{\"271\":1}}],[\"类型的底层实现并不是\",{\"1\":{\"256\":1}}],[\"类型的\",{\"1\":{\"163\":1,\"184\":1,\"195\":1,\"231\":1,\"291\":1,\"649\":1,\"1252\":2}}],[\"类型的查询效率更高\",{\"1\":{\"18\":1}}],[\"类型相对\",{\"1\":{\"18\":1}}],[\"类型等等\",{\"1\":{\"18\":1}}],[\"类型\",{\"1\":{\"17\":1,\"56\":1,\"73\":2,\"256\":1,\"328\":1,\"329\":1,\"485\":1,\"493\":1,\"705\":1,\"1335\":1}}],[\"udp\",{\"1\":{\"1151\":3,\"1154\":1,\"1165\":1}}],[\"umd\",{\"1\":{\"982\":1}}],[\"u>\",{\"1\":{\"630\":1,\"779\":6,\"780\":3}}],[\"u>>\",{\"1\":{\"630\":1}}],[\"util包下面的所有的集合类都是\",{\"1\":{\"631\":1}}],[\"util\",{\"1\":{\"353\":1,\"429\":1,\"529\":1,\"583\":2,\"597\":1,\"598\":1,\"625\":5,\"629\":1,\"630\":2,\"631\":1,\"634\":6,\"661\":1,\"740\":1,\"762\":2,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"773\":1,\"791\":1,\"793\":1,\"838\":2,\"882\":1,\"894\":3,\"899\":1,\"903\":1,\"920\":3,\"940\":4,\"944\":3,\"964\":1,\"987\":2,\"1002\":2,\"1006\":1,\"1008\":3,\"1011\":5,\"1012\":5,\"1013\":2,\"1014\":6,\"1015\":3,\"1018\":3,\"1022\":1,\"1132\":1,\"1252\":2}}],[\"utf\",{\"1\":{\"328\":1}}],[\"utf8\",{\"1\":{\"328\":1}}],[\"u1\",{\"1\":{\"328\":1}}],[\"u2\",{\"1\":{\"325\":11,\"327\":2,\"328\":1,\"329\":1,\"330\":4,\"331\":1,\"332\":1,\"333\":1}}],[\"u4\",{\"1\":{\"325\":1,\"326\":1}}],[\"using\",{\"1\":{\"338\":1,\"576\":1,\"624\":1}}],[\"usages\",{\"1\":{\"708\":1}}],[\"usage\",{\"1\":{\"293\":1}}],[\"usually\",{\"1\":{\"293\":1,\"298\":1,\"553\":1,\"558\":1}}],[\"usegcoverheadlimit\",{\"1\":{\"484\":1}}],[\"useparalleloldgc\",{\"1\":{\"403\":1}}],[\"uses\",{\"1\":{\"356\":1}}],[\"used\",{\"1\":{\"219\":3,\"256\":5,\"273\":4,\"298\":2,\"302\":1,\"706\":1,\"708\":1}}],[\"use\",{\"1\":{\"35\":1,\"53\":1,\"86\":2,\"235\":1,\"293\":2,\"298\":2,\"386\":1,\"459\":1,\"571\":1,\"708\":2,\"765\":1,\"972\":2,\"1053\":1}}],[\"users\",{\"1\":{\"365\":2,\"367\":5,\"368\":3,\"369\":3,\"370\":2}}],[\"username\",{\"1\":{\"1351\":1}}],[\"usernum\",{\"1\":{\"974\":2}}],[\"usern\",{\"1\":{\"262\":1}}],[\"user3\",{\"1\":{\"210\":5}}],[\"user1\",{\"1\":{\"210\":10,\"262\":1}}],[\"userinfokey\",{\"1\":{\"185\":8}}],[\"user4\",{\"1\":{\"96\":1}}],[\"user2\",{\"1\":{\"96\":2,\"210\":7,\"262\":1}}],[\"user\",{\"1\":{\"17\":1,\"96\":1,\"125\":4,\"218\":1,\"280\":1,\"708\":1,\"768\":8,\"1178\":1}}],[\"uptime\",{\"1\":{\"1140\":1}}],[\"upon\",{\"1\":{\"619\":1}}],[\"up\",{\"1\":{\"201\":1}}],[\"updatemaxthreadnum\",{\"1\":{\"1062\":2}}],[\"updateperson\",{\"1\":{\"767\":3}}],[\"updates\",{\"1\":{\"765\":1}}],[\"update\",{\"1\":{\"34\":1,\"49\":1,\"89\":4,\"135\":2,\"218\":2,\"388\":2,\"742\":2,\"763\":2,\"766\":2,\"841\":4,\"904\":2,\"990\":4,\"1006\":1,\"1011\":3}}],[\"uv\",{\"0\":{\"262\":1},\"1\":{\"190\":1,\"207\":1,\"259\":1,\"262\":4,\"294\":1}}],[\"u\",{\"1\":{\"84\":1,\"571\":8,\"573\":2,\"576\":1,\"630\":1,\"777\":1,\"778\":1,\"779\":2,\"871\":2}}],[\"uri\",{\"1\":{\"75\":1,\"1142\":2}}],[\"url\",{\"1\":{\"70\":1,\"74\":2,\"1120\":1,\"1140\":4,\"1141\":2,\"1142\":6}}],[\"uuid\",{\"0\":{\"37\":1},\"1\":{\"37\":28,\"1046\":1,\"1389\":2}}],[\"unfairsync\",{\"1\":{\"1002\":1}}],[\"unparksuccessor\",{\"1\":{\"1013\":1,\"1014\":5}}],[\"unpark\",{\"1\":{\"742\":1,\"904\":1,\"1014\":1}}],[\"unaryoperator<e>\",{\"1\":{\"634\":1}}],[\"untreeify\",{\"1\":{\"619\":1,\"624\":2}}],[\"until\",{\"1\":{\"480\":2,\"756\":1,\"911\":1}}],[\"unstarted\",{\"1\":{\"1059\":3}}],[\"unsupportedoperationexception\",{\"1\":{\"634\":7,\"748\":1,\"752\":1,\"1008\":1}}],[\"unsafe\",{\"1\":{\"570\":1,\"571\":5,\"573\":2,\"742\":1,\"765\":6,\"834\":1,\"841\":2,\"904\":1,\"990\":2,\"1011\":6}}],[\"unsigned\",{\"1\":{\"33\":1,\"256\":7,\"268\":2}}],[\"unclean\",{\"1\":{\"1206\":3}}],[\"uncontended\",{\"1\":{\"871\":1}}],[\"uncommitted\",{\"1\":{\"125\":1,\"132\":2}}],[\"unchecked\",{\"1\":{\"535\":1,\"536\":1,\"553\":2,\"570\":1,\"571\":1,\"576\":1,\"624\":1}}],[\"undefined\",{\"1\":{\"811\":1}}],[\"under\",{\"1\":{\"511\":1,\"708\":1}}],[\"undo段位于系统表空间内\",{\"1\":{\"141\":1}}],[\"undo存放在数据库内部的一个特殊段\",{\"1\":{\"141\":1}}],[\"undo日志版本链为\",{\"1\":{\"141\":1}}],[\"undo日志保存了记录修改前的数据\",{\"1\":{\"141\":1}}],[\"undo日志\",{\"1\":{\"141\":1}}],[\"undo\",{\"0\":{\"134\":1,\"138\":1},\"1\":{\"133\":1,\"137\":3,\"138\":2,\"141\":1,\"1370\":1,\"1371\":1}}],[\"unknown\",{\"1\":{\"370\":2}}],[\"unlimited\",{\"1\":{\"496\":1}}],[\"unlinklast\",{\"1\":{\"731\":1}}],[\"unlinkfirst\",{\"1\":{\"731\":1}}],[\"unlink\",{\"1\":{\"294\":1,\"619\":1,\"654\":1,\"711\":1,\"731\":7,\"732\":1}}],[\"unloading\",{\"1\":{\"338\":1}}],[\"unlocked\",{\"1\":{\"871\":1}}],[\"unlock\",{\"1\":{\"49\":1,\"534\":1,\"535\":2,\"536\":3,\"537\":2,\"538\":1,\"571\":1,\"588\":1,\"591\":1,\"603\":1,\"604\":2,\"605\":1,\"756\":1,\"835\":1,\"837\":1,\"861\":1,\"904\":1,\"911\":1,\"941\":1,\"972\":4,\"986\":1,\"1001\":2,\"1007\":2,\"1014\":1,\"1020\":2}}],[\"unused\",{\"1\":{\"256\":4}}],[\"uniquifying\",{\"1\":{\"894\":1,\"920\":1}}],[\"uniqueinstance\",{\"1\":{\"834\":13}}],[\"uniquevalue\",{\"1\":{\"47\":2,\"48\":2}}],[\"unique\",{\"1\":{\"33\":1,\"37\":1,\"120\":3}}],[\"unicomposestage\",{\"1\":{\"781\":3}}],[\"unihandlestage\",{\"1\":{\"780\":3}}],[\"uniwhencompletestage\",{\"1\":{\"779\":3}}],[\"unirunstage\",{\"1\":{\"779\":3}}],[\"uniacceptstage\",{\"1\":{\"779\":3}}],[\"uniapplystage\",{\"1\":{\"779\":3}}],[\"unix\",{\"1\":{\"271\":1,\"302\":1,\"364\":1,\"365\":1,\"386\":1,\"895\":1,\"922\":1,\"1348\":1,\"1351\":1,\"1382\":1}}],[\"units\",{\"1\":{\"687\":2}}],[\"unit\",{\"1\":{\"56\":2,\"478\":3,\"479\":3,\"530\":1,\"533\":2,\"537\":6,\"539\":2,\"597\":1,\"599\":3,\"752\":2,\"773\":1,\"774\":1,\"890\":3,\"899\":1,\"936\":3,\"940\":1,\"944\":2}}],[\"universally\",{\"1\":{\"37\":1}}],[\"ua\",{\"1\":{\"17\":2}}],[\"uint\",{\"1\":{\"386\":3,\"495\":3}}],[\"uint64\",{\"1\":{\"256\":2}}],[\"uint32\",{\"1\":{\"256\":2}}],[\"uint16\",{\"1\":{\"256\":2}}],[\"uint8\",{\"1\":{\"256\":2}}],[\"uidgenerator\",{\"0\":{\"40\":1},\"1\":{\"38\":1,\"40\":5}}],[\"uid\",{\"1\":{\"17\":1}}],[\"ui\",{\"1\":{\"7\":1}}],[\"链接上建立成百上千个信道来达到多个线程处理\",{\"1\":{\"1260\":1}}],[\"链接上的信道数量没有限制\",{\"1\":{\"1260\":1}}],[\"链接上的虚拟链接\",{\"1\":{\"1260\":1}}],[\"链接的创建和销毁开销较大\",{\"1\":{\"1260\":1}}],[\"链接\",{\"0\":{\"429\":1}}],[\"链接时\",{\"1\":{\"17\":1}}],[\"链表长度\",{\"1\":{\"733\":2}}],[\"链表长度超过一定阈值时\",{\"1\":{\"692\":1}}],[\"链表内容\",{\"1\":{\"733\":8}}],[\"链表上的节点个数达到树化的阈值是\",{\"1\":{\"708\":1}}],[\"链表上的节点个数达到树化的阈值\",{\"1\":{\"708\":1}}],[\"链表首元素就是最近最少被访问的元素\",{\"1\":{\"706\":1}}],[\"链表的长度大于\",{\"1\":{\"683\":1}}],[\"链表到红黑树的转换\",{\"1\":{\"683\":1}}],[\"链表需要遍历到特定位置才能访问特定位置的元素\",{\"1\":{\"658\":1}}],[\"链表散列\",{\"1\":{\"618\":1,\"682\":1}}],[\"链表则是主要为了解决哈希冲突而存在的\",{\"1\":{\"616\":1,\"645\":2,\"688\":1}}],[\"链表会转换成红黑树\",{\"1\":{\"575\":1,\"688\":1}}],[\"链表头插法\",{\"1\":{\"571\":1}}],[\"链表\",{\"1\":{\"180\":1,\"184\":1,\"575\":2,\"579\":2,\"688\":2,\"702\":1}}],[\"链的方式提供了网关基本的功能\",{\"1\":{\"5\":1,\"68\":1}}],[\"云里雾里的很难受\",{\"1\":{\"1150\":1}}],[\"云闪付等\",{\"1\":{\"17\":1}}],[\"云原生基础设施适配\",{\"1\":{\"1120\":1}}],[\"云原生友好\",{\"1\":{\"10\":1}}],[\"云原生\",{\"1\":{\"7\":1,\"8\":1,\"1236\":1}}],[\"钱包\",{\"1\":{\"17\":2}}],[\"支付成功后会得到\",{\"1\":{\"19\":1}}],[\"支付\",{\"1\":{\"17\":1,\"1299\":1}}],[\"支付支付\",{\"1\":{\"17\":1}}],[\"支付宝\",{\"1\":{\"17\":3}}],[\"支持比较好\",{\"1\":{\"1332\":1}}],[\"支持按照时间回溯消费\",{\"1\":{\"1306\":1}}],[\"支持按照元素访问顺序排序\",{\"1\":{\"702\":1}}],[\"支持顺序投递和并发投递\",{\"1\":{\"1297\":1}}],[\"支持同一个生产者向多个主题发送消息\",{\"1\":{\"1289\":1}}],[\"支持以\",{\"1\":{\"1281\":1}}],[\"支持分布式集群方式部署\",{\"1\":{\"1281\":2}}],[\"支持可扩展\",{\"1\":{\"1245\":1}}],[\"支持高并发\",{\"1\":{\"1245\":1}}],[\"支持强一致性\",{\"1\":{\"1240\":1}}],[\"支持消息类型\",{\"1\":{\"1231\":2}}],[\"支持消息重试\",{\"1\":{\"1213\":1}}],[\"支持消息持久化以及\",{\"1\":{\"249\":1}}],[\"支持双向流\",{\"1\":{\"1170\":1}}],[\"支持音频视频\",{\"1\":{\"1159\":1}}],[\"支持哪些序列化方式呢\",{\"0\":{\"1146\":1}}],[\"支持代码配置\",{\"1\":{\"1130\":1}}],[\"支持公平锁和非公平锁\",{\"1\":{\"1002\":1}}],[\"支持多租户\",{\"1\":{\"1238\":1,\"1240\":1}}],[\"支持多种协议\",{\"1\":{\"1237\":1}}],[\"支持多种消息类型\",{\"1\":{\"1231\":1}}],[\"支持多种等待策略\",{\"1\":{\"1179\":1}}],[\"支持多种序列化方式\",{\"1\":{\"1146\":1}}],[\"支持多种加锁方式\",{\"1\":{\"1001\":1}}],[\"支持多种使用模式\",{\"1\":{\"896\":1,\"923\":1}}],[\"支持多个客户端连接的关键\",{\"1\":{\"265\":1}}],[\"支持多个\",{\"1\":{\"42\":1}}],[\"支持线程池动态变更\",{\"1\":{\"896\":1,\"923\":1}}],[\"支持从两端插入和删除元素\",{\"1\":{\"727\":1}}],[\"支持遍历时会按照插入顺序有序进行迭代\",{\"1\":{\"702\":1}}],[\"支持优先级排序的无界阻塞队列\",{\"1\":{\"671\":1}}],[\"支持插入\",{\"1\":{\"649\":1}}],[\"支持泛型\",{\"1\":{\"647\":1}}],[\"支持添加\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"支持阻塞和非阻塞两种获取和新增元素的方式\",{\"1\":{\"543\":1}}],[\"支持重新分配哈希槽吗\",{\"1\":{\"318\":1}}],[\"支持手动释放\",{\"1\":{\"256\":1}}],[\"支持发布订阅模型\",{\"1\":{\"245\":1}}],[\"支持数据的持久化\",{\"1\":{\"245\":1}}],[\"支持更多的编程语言\",{\"1\":{\"245\":1}}],[\"支持更复杂的应用场景\",{\"1\":{\"245\":1}}],[\"支持更丰富的数据类型\",{\"1\":{\"245\":1}}],[\"支持秒级数据丢失\",{\"1\":{\"236\":1}}],[\"支持持久化\",{\"1\":{\"224\":1,\"242\":1,\"282\":1}}],[\"支持限流吗\",{\"0\":{\"76\":1}}],[\"支持修改\",{\"1\":{\"49\":1}}],[\"支持\",{\"1\":{\"42\":1,\"83\":1,\"210\":1,\"251\":1,\"366\":1,\"552\":1,\"656\":1,\"668\":1,\"1168\":1,\"1231\":1,\"1238\":1,\"1245\":1}}],[\"支持两种不同的持久化方式\",{\"1\":{\"35\":1}}],[\"支持等方式来进一步优化\",{\"1\":{\"34\":1}}],[\"支持的语言更多\",{\"1\":{\"1171\":1}}],[\"支持的序列化协议\",{\"1\":{\"1146\":1}}],[\"支持的同步\",{\"1\":{\"698\":2}}],[\"支持的并发量不大\",{\"1\":{\"33\":1}}],[\"支持的插件更多\",{\"1\":{\"10\":1}}],[\"支持校验\",{\"1\":{\"19\":1}}],[\"支持预先生成\",{\"1\":{\"19\":1}}],[\"支持用后核销\",{\"1\":{\"19\":1}}],[\"支持热更新\",{\"1\":{\"10\":1}}],[\"支持参数映射与校验逻辑\",{\"1\":{\"2\":1}}],[\"微核心都会采用\",{\"1\":{\"1132\":1}}],[\"微内核架构包含两类组件\",{\"1\":{\"1132\":1}}],[\"微内核架构模式\",{\"1\":{\"1132\":1}}],[\"微内核系统可让用户添加额外的应用如插件\",{\"1\":{\"1132\":1}}],[\"微内核只负责组装插件\",{\"1\":{\"1132\":1}}],[\"微内核\",{\"1\":{\"1132\":1}}],[\"微妙\",{\"1\":{\"302\":1}}],[\"微博和手机上传播\",{\"1\":{\"24\":1}}],[\"微信搜\",{\"1\":{\"835\":1}}],[\"微信支付\",{\"1\":{\"17\":1}}],[\"微信\",{\"1\":{\"17\":2}}],[\"微服务处理完请求后\",{\"1\":{\"73\":1}}],[\"微服务为什么要用到\",{\"1\":{\"11\":1}}],[\"微服务背景下\",{\"1\":{\"1\":1}}],[\"二段式策略\",{\"1\":{\"1183\":1}}],[\"二选一\",{\"1\":{\"1151\":1}}],[\"二者的任务队列永远不会被放满\",{\"1\":{\"892\":1,\"938\":1}}],[\"二进制\",{\"1\":{\"1231\":1}}],[\"二进制应用层协议\",{\"1\":{\"1230\":1}}],[\"二进制就是11\",{\"1\":{\"572\":1}}],[\"二进制安全\",{\"1\":{\"256\":1}}],[\"二是因为很多面试官自己比较熟悉这两个理论\",{\"1\":{\"1065\":1}}],[\"二是\",{\"1\":{\"141\":1}}],[\"二级缓存\",{\"1\":{\"299\":1,\"1184\":1}}],[\"二级\",{\"1\":{\"111\":1}}],[\"二级索引占用的空间会比聚簇索引小很多\",{\"1\":{\"114\":1}}],[\"二级索引\",{\"0\":{\"114\":1},\"1\":{\"105\":1}}],[\"二叉搜索树\",{\"0\":{\"97\":1},\"1\":{\"97\":2}}],[\"二\",{\"0\":{\"89\":1,\"426\":1}}],[\"二维码本质是一个短网址\",{\"1\":{\"17\":1}}],[\"二维码的本质是一个字符串\",{\"1\":{\"17\":1}}],[\"二次开发门槛较高\",{\"1\":{\"6\":1}}],[\"指出该消息可能需要持久性存储\",{\"1\":{\"1248\":1}}],[\"指出对于一个分布式系统来说\",{\"1\":{\"1067\":1}}],[\"指示\",{\"1\":{\"484\":1}}],[\"指向系统\",{\"1\":{\"1304\":1}}],[\"指向另一个已经移除队列的\",{\"1\":{\"1013\":1}}],[\"指向分配的内存地址\",{\"1\":{\"834\":1}}],[\"指向当前节点\",{\"1\":{\"732\":1}}],[\"指向新节点\",{\"1\":{\"729\":1}}],[\"指向的位置不同\",{\"1\":{\"1011\":1}}],[\"指向的前一个节点\",{\"1\":{\"727\":1}}],[\"指向的下一个节点\",{\"1\":{\"727\":1}}],[\"指向的下一个元素\",{\"1\":{\"713\":1}}],[\"指向后继节点\",{\"1\":{\"711\":2}}],[\"指向后一个节点\",{\"1\":{\"657\":1}}],[\"指向前驱节点\",{\"1\":{\"710\":2,\"711\":1}}],[\"指向前一个节点\",{\"1\":{\"657\":1}}],[\"指向最后一个节点\",{\"1\":{\"657\":1,\"1011\":1}}],[\"指向\",{\"1\":{\"657\":1,\"710\":1,\"731\":2,\"1011\":3}}],[\"指向下一个处于\",{\"1\":{\"1005\":1}}],[\"指向下一个节点\",{\"1\":{\"619\":1,\"732\":1}}],[\"指向下一行我们需要执行的代码\",{\"1\":{\"423\":1}}],[\"指向准备执行优先级最高的线程\",{\"1\":{\"601\":1}}],[\"指向方法区中的\",{\"1\":{\"425\":1}}],[\"指向关键字值的子树\",{\"1\":{\"100\":1}}],[\"指用户线程与垃圾收集线程同时执行\",{\"1\":{\"402\":1}}],[\"指多条垃圾收集线程并行工作\",{\"1\":{\"402\":1}}],[\"指多个字段上创建的索引\",{\"1\":{\"104\":1}}],[\"指发生在老年代的\",{\"1\":{\"375\":1,\"387\":1}}],[\"指发生新生代的的垃圾收集动作\",{\"1\":{\"375\":1}}],[\"指令并行重排和内存系统重排都属于是处理器级别的指令重排序\",{\"1\":{\"969\":1}}],[\"指令并行重排\",{\"1\":{\"969\":2}}],[\"指令重排序可能会导致一些问题\",{\"1\":{\"969\":1,\"980\":1,\"981\":1}}],[\"指令重排序可以保证串行语义一致\",{\"1\":{\"969\":1,\"980\":1,\"981\":1}}],[\"指令重排序\",{\"0\":{\"969\":1},\"1\":{\"969\":1}}],[\"指令重排在单线程环境下不会出现问题\",{\"1\":{\"834\":1}}],[\"指令和\",{\"1\":{\"852\":1,\"853\":1}}],[\"指令后\",{\"1\":{\"851\":1}}],[\"指令来释放锁\",{\"1\":{\"851\":1}}],[\"指令来看一下类的访问标志\",{\"1\":{\"329\":1}}],[\"指令来看一下其常量池中的信息\",{\"1\":{\"328\":1}}],[\"指令以及两个\",{\"1\":{\"851\":1}}],[\"指令则指明同步代码块的结束位置\",{\"1\":{\"851\":1,\"853\":1}}],[\"指令指向同步代码块的开始位置\",{\"1\":{\"851\":1,\"853\":1}}],[\"指令有两个作用\",{\"1\":{\"844\":1,\"993\":1}}],[\"指令那么效率会有一定的提升\",{\"1\":{\"844\":1,\"993\":1}}],[\"指令之后会接着执行\",{\"1\":{\"506\":1}}],[\"指令时\",{\"1\":{\"502\":1,\"851\":1}}],[\"指令时会初始化类\",{\"1\":{\"344\":4}}],[\"指令\",{\"1\":{\"319\":1,\"851\":2,\"852\":1,\"853\":2,\"969\":1,\"996\":1}}],[\"指的是\",{\"1\":{\"1011\":1}}],[\"指的是一个线程能够对一个临界资源重复加锁\",{\"1\":{\"1001\":1}}],[\"指的是一个二维码可以使用支付宝或者微信进行扫码支付\",{\"1\":{\"17\":1}}],[\"指的是线程可以再次获取自己的内部锁\",{\"1\":{\"860\":1}}],[\"指的是系统能够按照某种线程推进顺序\",{\"1\":{\"824\":1}}],[\"指的是数组的长度\",{\"1\":{\"618\":1,\"682\":1}}],[\"指的是让\",{\"1\":{\"289\":1,\"294\":1}}],[\"指定多个\",{\"1\":{\"1197\":1,\"1199\":1,\"1202\":1}}],[\"指定是单个事件发布者模式还是多个事件发布者模式\",{\"1\":{\"1182\":1}}],[\"指定队列最大的容量\",{\"1\":{\"799\":1}}],[\"指定时间内没有返回计算结果就抛出\",{\"1\":{\"773\":1,\"899\":1}}],[\"指定位置删除\",{\"1\":{\"653\":1}}],[\"指定位置插入\",{\"1\":{\"653\":1,\"654\":1,\"725\":1}}],[\"指定了返回数组的类型\",{\"1\":{\"633\":1}}],[\"指定超时时间内阻塞\",{\"1\":{\"539\":2}}],[\"指定超时时间内阻塞式获取和新增元素\",{\"0\":{\"537\":1}}],[\"指定的时候是可以要求数据同步到所有节点的\",{\"1\":{\"1263\":1}}],[\"指定的索引表示初始调用将返回的第一个元素为next\",{\"1\":{\"553\":1}}],[\"指定的\",{\"1\":{\"432\":1,\"1385\":1}}],[\"指定元素排名\",{\"1\":{\"194\":2,\"258\":1}}],[\"指定\",{\"1\":{\"157\":1,\"301\":1,\"451\":1,\"479\":1,\"621\":2}}],[\"指针的操作\",{\"1\":{\"1014\":1}}],[\"指针并未断开\",{\"1\":{\"1014\":1}}],[\"指针比较安全\",{\"1\":{\"1013\":1}}],[\"指针不安全\",{\"1\":{\"1013\":1}}],[\"指针进行操作\",{\"1\":{\"1013\":1}}],[\"指针进行操作呢\",{\"1\":{\"1013\":1}}],[\"指针进行了操作\",{\"1\":{\"1013\":1}}],[\"指针和\",{\"1\":{\"1011\":1}}],[\"指针是\",{\"1\":{\"1011\":1}}],[\"指针置为\",{\"1\":{\"731\":2}}],[\"指针快速定位到当前节点的后继节点\",{\"1\":{\"713\":1}}],[\"指针指向\",{\"1\":{\"1011\":1}}],[\"指针指向尾节点\",{\"1\":{\"1011\":1}}],[\"指针指向上一个节点\",{\"1\":{\"732\":1}}],[\"指针指向当前节点的前一个节点\",{\"1\":{\"731\":1}}],[\"指针指向当前节点的下一个节点\",{\"1\":{\"731\":1}}],[\"指针指向当前节点\",{\"1\":{\"713\":1}}],[\"指针指向了\",{\"1\":{\"712\":1}}],[\"指针指向前驱节点\",{\"1\":{\"711\":1}}],[\"指针即指向链表末端的指针指向\",{\"1\":{\"710\":1}}],[\"指针使节点具备双向链表的特性\",{\"1\":{\"708\":1}}],[\"指针碰撞\",{\"1\":{\"503\":2}}],[\"指针大小在innodb源码中为6字节\",{\"1\":{\"110\":1}}],[\"指针\",{\"1\":{\"108\":1,\"1013\":2,\"1014\":1}}],[\"指运营同学组织的每一场运营活动都有不同的兑换码\",{\"1\":{\"19\":1}}],[\"指标\",{\"1\":{\"5\":1,\"68\":1}}],[\"指标等方面进行监控并提供配套的告警机制\",{\"1\":{\"2\":1}}],[\"服务设计成幂等的\",{\"1\":{\"1303\":1}}],[\"服务实例\",{\"1\":{\"1251\":1}}],[\"服务节点\",{\"0\":{\"1255\":1},\"1\":{\"1251\":1}}],[\"服务进行异步的消息传输\",{\"1\":{\"1226\":1}}],[\"服务通信到流量管控等几乎所有的服务治理能力\",{\"1\":{\"1168\":1}}],[\"服务通常是集群化部署的\",{\"1\":{\"51\":1}}],[\"服务发现等功能\",{\"1\":{\"1171\":1}}],[\"服务发现\",{\"0\":{\"1157\":1},\"1\":{\"1157\":1,\"1168\":1}}],[\"服务发送请求\",{\"1\":{\"1046\":1}}],[\"服务都会挂掉吗\",{\"0\":{\"1137\":1}}],[\"服务代理层\",{\"1\":{\"1130\":1}}],[\"服务消费端\",{\"1\":{\"1166\":2}}],[\"服务消费者\",{\"1\":{\"1390\":1}}],[\"服务消费者可以直连服务提供者\",{\"1\":{\"1137\":1}}],[\"服务消费者和提供者会定时发送统计数据到监控中心\",{\"1\":{\"1128\":1}}],[\"服务消费\",{\"1\":{\"1129\":1}}],[\"服务注册与发现的注册中心\",{\"1\":{\"1128\":1}}],[\"服务运行容器\",{\"1\":{\"1128\":1}}],[\"服务访问压力以及时长统计\",{\"1\":{\"1123\":1}}],[\"服务间依赖关系变得错踪复杂\",{\"1\":{\"1123\":1}}],[\"服务越来越多\",{\"1\":{\"1123\":1}}],[\"服务调用链路生成\",{\"1\":{\"1123\":1}}],[\"服务调用关系越来越复杂\",{\"1\":{\"1123\":1}}],[\"服务自动注册和发现\",{\"1\":{\"1122\":1}}],[\"服务自己来写入缓存的\",{\"1\":{\"146\":1}}],[\"服务自己更新\",{\"1\":{\"146\":1}}],[\"服务网格解决方案\",{\"1\":{\"1085\":1}}],[\"服务提供端\",{\"1\":{\"1166\":1}}],[\"服务提供者\",{\"1\":{\"1390\":1}}],[\"服务提供者宕机后\",{\"0\":{\"1135\":1}}],[\"服务提供者和消费者只在启动时与注册中心交互\",{\"1\":{\"1069\":1,\"1134\":1}}],[\"服务提供\",{\"1\":{\"1129\":1}}],[\"服务提供短网址的唯一标志参数\",{\"1\":{\"17\":1}}],[\"服务接收请求\",{\"1\":{\"1046\":1}}],[\"服务当前不可用导致缓存删除失败的话\",{\"1\":{\"316\":1}}],[\"服务不可用的情况\",{\"1\":{\"314\":1}}],[\"服务不兼容新版本的\",{\"1\":{\"236\":1}}],[\"服务话\",{\"1\":{\"299\":1}}],[\"服务的服务器都会在内存中维护当前的服务器状态\",{\"1\":{\"1354\":1}}],[\"服务的服务器\",{\"1\":{\"1354\":1}}],[\"服务的高可用性\",{\"1\":{\"1206\":1}}],[\"服务的话\",{\"1\":{\"293\":1,\"298\":1}}],[\"服务的具体实现\",{\"1\":{\"16\":1}}],[\"服务干宕机\",{\"1\":{\"236\":1}}],[\"服务可能就就挂掉了\",{\"1\":{\"147\":1}}],[\"服务可以通过数字\",{\"1\":{\"24\":1}}],[\"服务来负责\",{\"1\":{\"147\":1}}],[\"服务负责将此数据读取和写入\",{\"1\":{\"146\":1}}],[\"服务\",{\"0\":{\"1322\":1},\"1\":{\"75\":2,\"494\":1,\"812\":1,\"1045\":2,\"1157\":1,\"1165\":1,\"1322\":3}}],[\"服务处理后\",{\"1\":{\"69\":1}}],[\"服务处理\",{\"1\":{\"69\":1}}],[\"服务端首先会为每个客户端都分配一个\",{\"1\":{\"1353\":1}}],[\"服务端同样无法感知\",{\"1\":{\"1292\":1}}],[\"服务端是无法感知的\",{\"1\":{\"1292\":1}}],[\"服务端按照消费结果更新消费进度\",{\"1\":{\"1292\":1}}],[\"服务端将消息重新写入普通存储引擎\",{\"1\":{\"1285\":1}}],[\"服务端不会直接构建消息索引\",{\"1\":{\"1285\":1}}],[\"服务端不会立刻返回结果\",{\"1\":{\"251\":1}}],[\"服务端标记当前消息已经被处理\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"服务端侧已经消费的数据没有成功提交\",{\"1\":{\"1207\":1}}],[\"服务端\",{\"1\":{\"1166\":5,\"1222\":1,\"1284\":1,\"1296\":1,\"1297\":2}}],[\"服务端支持实现的\",{\"1\":{\"287\":1}}],[\"服务端会将事件通知到感兴趣的客户端上去\",{\"1\":{\"55\":1,\"1352\":1}}],[\"服务端才通过前端获取用户\",{\"1\":{\"17\":1}}],[\"服务器在负责进行消息广播\",{\"1\":{\"1361\":1}}],[\"服务器完成了和\",{\"1\":{\"1361\":1}}],[\"服务器完成了状态同步之后\",{\"1\":{\"1361\":1}}],[\"服务器的数据状态保持一致\",{\"1\":{\"1361\":1}}],[\"服务器的状态同步\",{\"1\":{\"1361\":1}}],[\"服务器的状态\",{\"1\":{\"1108\":1}}],[\"服务器个数大于宕掉的个数的话整个\",{\"1\":{\"1357\":1}}],[\"服务器之后\",{\"1\":{\"1357\":1}}],[\"服务器出现网络中断\",{\"1\":{\"1356\":1,\"1361\":1}}],[\"服务器最新的数据提供读服务\",{\"1\":{\"1354\":1}}],[\"服务器从服务器通过异步复制的方式获取\",{\"1\":{\"1354\":1}}],[\"服务器作为主服务器提供写服务\",{\"1\":{\"1354\":1}}],[\"服务器发送请求并接受响应\",{\"1\":{\"1353\":1}}],[\"服务器与客户端的之间的一个\",{\"1\":{\"1353\":1}}],[\"服务器上\",{\"1\":{\"1199\":1,\"1345\":1}}],[\"服务器上的共识模块从客户端接收命令并将它们添加到日志中\",{\"1\":{\"1106\":1}}],[\"服务器列表记录的节点\",{\"1\":{\"1199\":1}}],[\"服务器集群举例\",{\"1\":{\"1108\":1}}],[\"服务器也可以在共享状态上达成一致\",{\"1\":{\"1106\":1}}],[\"服务器和网络故障也很常见\",{\"1\":{\"1104\":1}}],[\"服务器节点组成的集合\",{\"1\":{\"1069\":1}}],[\"服务器是\",{\"1\":{\"359\":1}}],[\"服务器为了能够优先加载\",{\"1\":{\"359\":1}}],[\"服务器检测到执行时间超过\",{\"1\":{\"302\":1}}],[\"服务器一次性执行完成\",{\"1\":{\"283\":1}}],[\"服务器进行网络交互\",{\"1\":{\"279\":1}}],[\"服务器中其他同样以单线程方式运行的模块进行对接\",{\"1\":{\"265\":1}}],[\"服务器每秒可以执行的查询次数\",{\"1\":{\"246\":1}}],[\"服务器用新的\",{\"1\":{\"162\":1,\"233\":1}}],[\"服务器会将重写缓冲区中的所有内容追加到新\",{\"1\":{\"162\":1,\"233\":1}}],[\"服务器会维护一个\",{\"1\":{\"162\":1}}],[\"服务器实例\",{\"1\":{\"23\":1}}],[\"服务器\",{\"1\":{\"22\":1,\"287\":1,\"364\":1,\"369\":1,\"929\":1,\"1218\":1,\"1251\":1,\"1254\":1,\"1255\":1,\"1356\":1,\"1357\":3,\"1361\":2}}],[\"服务器依次可以识别出客户使用的操作系统及版本\",{\"1\":{\"17\":1}}],[\"服务生成\",{\"1\":{\"22\":1}}],[\"服务必要的特性之外\",{\"1\":{\"18\":1}}],[\"服务和动态网关\",{\"1\":{\"6\":1}}],[\"进阶\",{\"0\":{\"1366\":1}}],[\"进阶一下\",{\"1\":{\"853\":1}}],[\"进化成了\",{\"1\":{\"579\":1}}],[\"进第\",{\"1\":{\"557\":1}}],[\"进一步划分的目的是更好地回收内存\",{\"1\":{\"495\":1}}],[\"进一步探讨业务场景中对\",{\"1\":{\"15\":1}}],[\"进入第三阶段参与者都会进行事务的提交操作\",{\"1\":{\"1371\":1}}],[\"进入第三层和第四层的等待队列处理\",{\"1\":{\"1003\":1}}],[\"进入该方法后\",{\"1\":{\"1013\":1}}],[\"进入到\",{\"1\":{\"1012\":1}}],[\"进入同步代码前要获得\",{\"1\":{\"848\":2}}],[\"进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态\",{\"1\":{\"820\":1}}],[\"进入下一次循环将任务return出去\",{\"1\":{\"604\":1}}],[\"进入无限期等待\",{\"1\":{\"604\":1}}],[\"进入循环\",{\"1\":{\"537\":1}}],[\"进入\",{\"1\":{\"483\":1,\"557\":1,\"558\":1,\"559\":1,\"1003\":1,\"1322\":1}}],[\"进行状态监控和回调\",{\"1\":{\"1390\":1}}],[\"进行节点状态的监听\",{\"1\":{\"1388\":1}}],[\"进行投票选举的时候会比较\",{\"1\":{\"1380\":1}}],[\"进行限制\",{\"1\":{\"1351\":1}}],[\"进行分割的路径表示\",{\"1\":{\"1348\":1}}],[\"进行内存映射\",{\"1\":{\"1310\":1}}],[\"进行内存分配\",{\"1\":{\"503\":1}}],[\"进行内存分配的时候\",{\"1\":{\"218\":1}}],[\"进行交互\",{\"1\":{\"1231\":1}}],[\"进行编程\",{\"1\":{\"1151\":1}}],[\"进行通信\",{\"1\":{\"1085\":1,\"1281\":1,\"1356\":1}}],[\"进行修复\",{\"1\":{\"1078\":2}}],[\"进行启发式过期数据清理\",{\"1\":{\"1036\":1}}],[\"进行rehash\",{\"1\":{\"1036\":1}}],[\"进行探测式数据清理工作\",{\"1\":{\"1035\":1}}],[\"进行定义\",{\"1\":{\"1030\":1}}],[\"进行额外的判断处理\",{\"1\":{\"1015\":1}}],[\"进行解锁\",{\"1\":{\"1007\":1}}],[\"进行更加直观的比较\",{\"1\":{\"1001\":1}}],[\"进行重排序不会影响代码的执行结果\",{\"1\":{\"974\":1}}],[\"进行比较\",{\"1\":{\"841\":2,\"990\":2,\"1001\":1,\"1011\":1,\"1114\":1}}],[\"进行读取操作之后\",{\"1\":{\"835\":1}}],[\"进行原子更新时可能出现的\",{\"1\":{\"762\":2,\"767\":2}}],[\"进行递减\",{\"1\":{\"752\":2}}],[\"进行操作\",{\"1\":{\"742\":1,\"904\":1,\"1151\":1}}],[\"进行移除\",{\"1\":{\"712\":1}}],[\"进行复合操作\",{\"1\":{\"694\":1}}],[\"进行遍历去重或者判断包含操作\",{\"1\":{\"632\":1}}],[\"进行遍历操作之外\",{\"1\":{\"631\":1}}],[\"进行了封装\",{\"1\":{\"900\":1}}],[\"进行了一次自增操作后\",{\"1\":{\"835\":1}}],[\"进行了整合\",{\"1\":{\"624\":1}}],[\"进行了改进\",{\"1\":{\"40\":1}}],[\"进行\",{\"1\":{\"621\":1}}],[\"进行table初始化\",{\"1\":{\"621\":1}}],[\"进行基于时间的调度更加方便和灵活\",{\"1\":{\"598\":1}}],[\"进行扩容处理\",{\"1\":{\"621\":1}}],[\"进行扩容\",{\"1\":{\"571\":3,\"622\":1,\"624\":1}}],[\"进行调优\",{\"1\":{\"450\":1}}],[\"进行存储\",{\"1\":{\"438\":1}}],[\"进行加锁操作\",{\"1\":{\"1007\":1}}],[\"进行加载\",{\"1\":{\"433\":1}}],[\"进行加密\",{\"1\":{\"353\":1}}],[\"进行总结补充\",{\"1\":{\"380\":1,\"489\":1}}],[\"进行设置的话\",{\"1\":{\"359\":1}}],[\"进行删除的呢\",{\"1\":{\"272\":1}}],[\"进行运算\",{\"1\":{\"202\":1}}],[\"进行有序排列\",{\"1\":{\"192\":1,\"195\":1}}],[\"进行完整的表扫描\",{\"1\":{\"120\":1}}],[\"进\",{\"1\":{\"109\":1}}],[\"进程利用系统资源的整体效率\",{\"1\":{\"816\":1}}],[\"进程示例图片\",{\"1\":{\"806\":1}}],[\"进程是程序的一次执行过程\",{\"1\":{\"806\":1}}],[\"进程是否开启打印\",{\"1\":{\"367\":1}}],[\"进程的情况\",{\"1\":{\"816\":1}}],[\"进程的内存使用情况\",{\"1\":{\"372\":1}}],[\"进程的全部参数和系统属性\",{\"1\":{\"367\":1}}],[\"进程的启动类\",{\"1\":{\"364\":1}}],[\"进程\",{\"0\":{\"365\":1},\"1\":{\"365\":1,\"425\":1}}],[\"进程号\",{\"1\":{\"168\":1}}],[\"进程异常重启\",{\"1\":{\"89\":1}}],[\"进程中只有一个线程\",{\"1\":{\"816\":1}}],[\"进程中也能获取到同一把锁\",{\"1\":{\"60\":1}}],[\"进程中\",{\"1\":{\"60\":1}}],[\"进程共享同一份资源的话\",{\"1\":{\"60\":1,\"63\":1}}],[\"进程上\",{\"1\":{\"60\":1,\"63\":1}}],[\"进程内的多个线程对本地共享资源的访问\",{\"1\":{\"60\":1}}],[\"进程访问\",{\"1\":{\"47\":1}}],[\"进而提高程序的性能\",{\"1\":{\"1184\":1}}],[\"进而导致程序在多线程下执行可能出现问题\",{\"1\":{\"969\":1}}],[\"进而导致数据覆盖的问题\",{\"1\":{\"686\":1}}],[\"进而导致分布式锁直接失效\",{\"1\":{\"48\":1}}],[\"进而使得查询元素的操作陷入死循环无法结束\",{\"1\":{\"685\":1}}],[\"进而实现\",{\"1\":{\"359\":1}}],[\"进而实现共享资源的互斥访问\",{\"1\":{\"60\":1}}],[\"进而有效减小网络开销\",{\"1\":{\"285\":1}}],[\"进而\",{\"1\":{\"246\":1}}],[\"进而保证锁不会因为超时而被释放\",{\"1\":{\"49\":1}}],[\"进而造成共享资源无法再被其他线程\",{\"1\":{\"47\":1}}],[\"进制运算\",{\"1\":{\"558\":1}}],[\"进制数字\",{\"1\":{\"37\":1}}],[\"进制即可得到常见的\",{\"1\":{\"22\":1}}],[\"进制\",{\"1\":{\"19\":1}}],[\"进⾏负载转发以达到⾼可⽤\",{\"1\":{\"1\":1}}],[\"本来好好的两个系统之间的调用\",{\"1\":{\"1275\":1}}],[\"本篇文章由\",{\"1\":{\"1244\":1}}],[\"本篇文章核心为\",{\"1\":{\"999\":1}}],[\"本篇文章主要阐述\",{\"1\":{\"999\":1}}],[\"本篇不做展开\",{\"1\":{\"74\":1}}],[\"本案例来源自\",{\"1\":{\"919\":1}}],[\"本质来讲\",{\"1\":{\"1231\":1}}],[\"本质释放锁的地方\",{\"1\":{\"1014\":1}}],[\"本质上不算是协议\",{\"1\":{\"1161\":1}}],[\"本质上是提高了线程的执行效率\",{\"1\":{\"1055\":1}}],[\"本质上都会执行\",{\"1\":{\"1007\":1}}],[\"本质上就是调用一下\",{\"1\":{\"603\":1}}],[\"本质也是创建一个\",{\"1\":{\"961\":1}}],[\"本质其实还是在考察求职者对于线程池以及阻塞队列的掌握\",{\"1\":{\"897\":1}}],[\"本地事务和存储消息到消息队列才是同一个事务\",{\"1\":{\"1304\":1}}],[\"本地运行演示\",{\"1\":{\"1030\":1}}],[\"本地内存是\",{\"1\":{\"972\":1}}],[\"本地内存存储了该线程以读\",{\"1\":{\"972\":1}}],[\"本地内存\",{\"1\":{\"972\":2}}],[\"本地内存中\",{\"1\":{\"299\":1}}],[\"本地方法\",{\"1\":{\"1154\":1}}],[\"本地方法被执行的时候\",{\"1\":{\"494\":1}}],[\"本地方法接口\",{\"1\":{\"422\":1}}],[\"本地方法栈和程序计数器\",{\"0\":{\"435\":1}}],[\"本地方法栈\",{\"0\":{\"494\":1},\"1\":{\"391\":1,\"422\":1,\"445\":2,\"491\":1,\"810\":1,\"812\":1}}],[\"本地锁在这种情况下就没办法正常工作了\",{\"1\":{\"60\":1}}],[\"本地锁\",{\"1\":{\"60\":2}}],[\"本次\",{\"1\":{\"231\":1}}],[\"本身同意\",{\"1\":{\"1374\":1}}],[\"本身仍然是可用的\",{\"1\":{\"1354\":1,\"1362\":1}}],[\"本身没有直接支持延迟队列的功能\",{\"1\":{\"1257\":1}}],[\"本身队列的特性来实现\",{\"1\":{\"1257\":1}}],[\"本身是没有延迟队列的\",{\"1\":{\"1257\":1}}],[\"本身支持很多的协议\",{\"1\":{\"1245\":1}}],[\"本身就提供了\",{\"1\":{\"1131\":1}}],[\"本身就是一个分布式程序\",{\"1\":{\"1362\":1}}],[\"本身就是一个\",{\"1\":{\"7\":1}}],[\"本身节点值\",{\"1\":{\"727\":1}}],[\"本身不需要修改\",{\"1\":{\"510\":1}}],[\"本身设置的固定大小上限\",{\"1\":{\"496\":1}}],[\"本身的类和\",{\"1\":{\"359\":1}}],[\"本身会极大的节省储存空间\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"本文不光会涉及到\",{\"1\":{\"1341\":1}}],[\"本文都将带你搞懂消息队列的一些基本理论\",{\"1\":{\"1217\":1}}],[\"本文中的很多链接已经失效\",{\"1\":{\"1120\":1}}],[\"本文部分内容来自\",{\"1\":{\"1051\":1}}],[\"本文源码基于jdk\",{\"1\":{\"1027\":1}}],[\"本文将围绕这些问题使用图文方式来剖析threadlocal的点点滴滴\",{\"1\":{\"1026\":1}}],[\"本文来自小白\",{\"1\":{\"1150\":1}}],[\"本文来自一枝花算不算浪漫投稿\",{\"1\":{\"1025\":1}}],[\"本文来自公众号\",{\"1\":{\"567\":1}}],[\"本文仅介绍了可重入锁\",{\"1\":{\"1021\":1}}],[\"本文会从应用层逐渐深入到原理层\",{\"1\":{\"999\":1}}],[\"本文转载自\",{\"1\":{\"999\":1}}],[\"本文由\",{\"1\":{\"475\":1,\"1103\":1,\"1267\":1}}],[\"本文基于\",{\"1\":{\"380\":1,\"489\":1}}],[\"本文只讨论其核心功能\",{\"1\":{\"351\":1}}],[\"本文整理完善自\",{\"1\":{\"156\":1}}],[\"本文重构完善自6000\",{\"1\":{\"67\":1}}],[\"本文主要介绍的是分布式\",{\"1\":{\"43\":1}}],[\"本文结合一些使用场景\",{\"1\":{\"15\":1}}],[\"网站的规模越来越大\",{\"1\":{\"1123\":1}}],[\"网站\",{\"1\":{\"190\":1,\"259\":1}}],[\"网站后台就会判断客户的扫码环境\",{\"1\":{\"17\":1}}],[\"网卡软中断等网络问题也可能会导致\",{\"1\":{\"170\":1}}],[\"网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时\",{\"1\":{\"1353\":1}}],[\"网络协议进行通信的服务器和客户端组成\",{\"1\":{\"1235\":1}}],[\"网络波动一次你\",{\"1\":{\"1204\":1}}],[\"网络传输的实现方式有很多种比如最近基本的\",{\"1\":{\"1166\":1}}],[\"网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端\",{\"1\":{\"1166\":1}}],[\"网络传输\",{\"1\":{\"1166\":1}}],[\"网络传输层\",{\"1\":{\"1130\":1}}],[\"网络链接\",{\"1\":{\"1139\":1}}],[\"网络分区\",{\"1\":{\"1067\":1}}],[\"网络通信等\",{\"1\":{\"819\":1}}],[\"网络没有问题的情况下\",{\"1\":{\"412\":1}}],[\"网络\",{\"1\":{\"340\":1}}],[\"网络阻塞\",{\"1\":{\"292\":1}}],[\"网络延迟\",{\"1\":{\"170\":1}}],[\"网络问题\",{\"0\":{\"170\":1}}],[\"网上关于\",{\"1\":{\"1208\":1}}],[\"网上似乎还没有专门写这方面的文章\",{\"1\":{\"916\":1}}],[\"网上有现成的代码\",{\"1\":{\"293\":1}}],[\"网上有现成的工具\",{\"1\":{\"164\":1}}],[\"网上有很多分布式锁相关的文章\",{\"1\":{\"59\":1}}],[\"网上绝大多数的分布式\",{\"1\":{\"15\":1}}],[\"网址长度也有些长\",{\"1\":{\"24\":1}}],[\"网关可以再次进行处理\",{\"1\":{\"73\":1}}],[\"网关可以为我们提供请求转发\",{\"1\":{\"1\":1}}],[\"网关会自动感知并相应地调整路由规则\",{\"1\":{\"72\":1}}],[\"网关的鼻祖\",{\"1\":{\"10\":1}}],[\"网关相比\",{\"1\":{\"8\":1}}],[\"网关服务\",{\"1\":{\"2\":1}}],[\"网关服务外层通过\",{\"1\":{\"1\":1}}],[\"网关\",{\"1\":{\"2\":1,\"8\":1,\"11\":2}}],[\"网关作为业务服务的调用方\",{\"1\":{\"2\":1}}],[\"网关能提供哪些功能\",{\"0\":{\"2\":1}}],[\"网关主要做了两件事情\",{\"1\":{\"1\":1}}],[\"网关示意图\",{\"1\":{\"1\":1}}],[\"生与云\",{\"1\":{\"1236\":1}}],[\"生命周期内\",{\"1\":{\"345\":1}}],[\"生产消息的时候会进行轮询\",{\"1\":{\"1299\":1}}],[\"生产消息的一方\",{\"1\":{\"1248\":1}}],[\"生产消息放入多个队列中\",{\"1\":{\"1278\":1}}],[\"生产消息到指定主题中\",{\"1\":{\"1272\":1}}],[\"生产消息整个过程定义为一个原子操作\",{\"1\":{\"1223\":1}}],[\"生产者就不能再给这个主节点生产消息了\",{\"1\":{\"1314\":1}}],[\"生产者就会被阻塞\",{\"1\":{\"530\":1}}],[\"生产者是匿名的\",{\"1\":{\"1296\":1}}],[\"生产者分组\",{\"0\":{\"1296\":1}}],[\"生产者和消费者定期会向\",{\"1\":{\"1281\":1}}],[\"生产者和消费者只与\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"生产者每次生产消息之后是指定主题中的某个队列发送消息的\",{\"1\":{\"1280\":1}}],[\"生产者组\",{\"1\":{\"1280\":2}}],[\"生产者到\",{\"1\":{\"1261\":1}}],[\"生产者将消息发送到交换器\",{\"1\":{\"1255\":1}}],[\"生产者将消息发送给交换器\",{\"1\":{\"1253\":1}}],[\"生产者将消息发送给交换器时\",{\"1\":{\"1249\":1}}],[\"生产者将消息发给交换器的时候\",{\"1\":{\"1249\":1}}],[\"生产者把消息交由\",{\"1\":{\"1248\":1}}],[\"生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息\",{\"1\":{\"1222\":1}}],[\"生产者负责发送消息\",{\"1\":{\"1218\":1}}],[\"生产者代码\",{\"1\":{\"1209\":1}}],[\"生产者才会接收到来自服务器的响应\",{\"1\":{\"1206\":1}}],[\"生产者发送消失败\",{\"1\":{\"1204\":1}}],[\"生产者发现队列中可以存放数据\",{\"1\":{\"535\":1}}],[\"生产者成功发送消息到topic\",{\"1\":{\"1204\":1}}],[\"生产者成功发送消息到\",{\"1\":{\"1204\":1}}],[\"生产者丢失消息的情况\",{\"0\":{\"1204\":1}}],[\"生产者线程会被阻塞\",{\"1\":{\"796\":1}}],[\"生产者线程会向队列中添加数据\",{\"1\":{\"670\":1}}],[\"生产者线程会调用\",{\"1\":{\"544\":2}}],[\"生产者\",{\"0\":{\"1248\":1},\"1\":{\"535\":1,\"796\":1,\"1182\":1,\"1196\":1,\"1204\":2,\"1206\":1,\"1218\":1,\"1222\":3,\"1248\":1,\"1249\":1,\"1254\":1}}],[\"生产者添加元素\",{\"1\":{\"531\":11}}],[\"生产者在这里只会生产\",{\"1\":{\"531\":1}}],[\"生产者生产太快或者消费者消费太慢\",{\"1\":{\"1305\":1}}],[\"生产者生产速度远远大于消费者消费速度\",{\"1\":{\"535\":1}}],[\"生产者生产完会使用\",{\"1\":{\"531\":1}}],[\"生产者生产消息到\",{\"1\":{\"1281\":1}}],[\"生产者生产消息\",{\"1\":{\"251\":1}}],[\"生产者可以继续填充数据了\",{\"1\":{\"530\":1}}],[\"生产事故\",{\"1\":{\"412\":1}}],[\"生产问题\",{\"0\":{\"304\":1}}],[\"生产环境上\",{\"1\":{\"483\":1}}],[\"生产环境中建议谨慎使用该命令\",{\"1\":{\"298\":1}}],[\"生产环境下的\",{\"1\":{\"51\":1}}],[\"生成线程快照的目的主要是定位线程长时间出现停顿的原因\",{\"1\":{\"370\":1}}],[\"生成虚拟机当前时刻的线程快照\",{\"0\":{\"370\":1},\"1\":{\"364\":1}}],[\"生成堆转储快照\",{\"0\":{\"368\":1},\"1\":{\"364\":1}}],[\"生成方案都总结了一波\",{\"1\":{\"43\":1}}],[\"生成方式\",{\"1\":{\"34\":1}}],[\"生成系统\",{\"1\":{\"41\":1}}],[\"生成器\",{\"1\":{\"40\":1,\"42\":1}}],[\"生成算法\",{\"1\":{\"38\":1}}],[\"生成速度比较快\",{\"1\":{\"37\":1,\"38\":1}}],[\"生成\",{\"1\":{\"37\":2,\"135\":2,\"236\":1}}],[\"生成有规律性\",{\"1\":{\"35\":1}}],[\"生成分布式\",{\"1\":{\"30\":1}}],[\"生成的唯一\",{\"1\":{\"40\":2}}],[\"生成的\",{\"1\":{\"22\":1,\"24\":1,\"30\":1,\"38\":1}}],[\"生成的兑换码都具有唯一性\",{\"1\":{\"19\":1}}],[\"生成规则\",{\"0\":{\"22\":1,\"23\":1}}],[\"生成服务比如\",{\"1\":{\"24\":1}}],[\"生成服务的文章\",{\"1\":{\"15\":1}}],[\"生成服务的技术原理和项目实战\",{\"1\":{\"15\":1}}],[\"生成服务\",{\"1\":{\"15\":1}}],[\"生态友好\",{\"1\":{\"1236\":1}}],[\"生态丰富\",{\"1\":{\"10\":1}}],[\"生态丰富的网关系统\",{\"1\":{\"7\":1}}],[\"生态系统的一员\",{\"1\":{\"1341\":1}}],[\"生态系统还是社区活跃度来说都是最优秀的\",{\"1\":{\"1172\":1}}],[\"生态系统兼容性无可匹敌\",{\"1\":{\"1191\":1}}],[\"生态系统兼容\",{\"1\":{\"10\":1}}],[\"生态系统中的网关\",{\"1\":{\"5\":1,\"68\":1}}],[\"生态工具对接都十分方便\",{\"1\":{\"8\":1}}],[\"生态对其支持更加友好\",{\"1\":{\"5\":1,\"68\":1}}],[\"生态本身就有很多现成的过滤器供我们使用\",{\"1\":{\"4\":1}}],[\"原语\",{\"1\":{\"1344\":1}}],[\"原出处不明\",{\"1\":{\"1244\":1}}],[\"原创不易\",{\"1\":{\"1026\":1}}],[\"原则表达的意义其实并不是一个操作发生在另外一个操作的前面\",{\"1\":{\"974\":1}}],[\"原则的定义\",{\"1\":{\"974\":1}}],[\"原则的设计思想\",{\"1\":{\"974\":1}}],[\"原则的设计思想其实非常简单\",{\"1\":{\"974\":1}}],[\"原则的诞生是为了程序员和编译器\",{\"1\":{\"974\":1}}],[\"原则是什么\",{\"0\":{\"974\":1}}],[\"原则\",{\"1\":{\"971\":1,\"974\":1}}],[\"原值为\",{\"1\":{\"841\":1,\"990\":1}}],[\"原来的值\",{\"1\":{\"765\":1}}],[\"原来数组的长度\",{\"1\":{\"588\":1}}],[\"原始值的数据流\",{\"1\":{\"1226\":1}}],[\"原始数组\",{\"1\":{\"662\":2}}],[\"原始读取不可重复\",{\"1\":{\"128\":1}}],[\"原索引放到bucket里\",{\"1\":{\"624\":1}}],[\"原索引+oldcap放到bucket里\",{\"1\":{\"624\":1}}],[\"原索引+oldcap\",{\"1\":{\"624\":1}}],[\"原索引\",{\"1\":{\"624\":1}}],[\"原因是\",{\"1\":{\"1315\":1}}],[\"原因\",{\"1\":{\"1204\":1}}],[\"原因如下\",{\"1\":{\"1014\":1}}],[\"原因可能会是堆内存设置的大小过小\",{\"1\":{\"444\":1}}],[\"原因同样是无法保证所有的\",{\"1\":{\"288\":1}}],[\"原因类似\",{\"1\":{\"287\":1}}],[\"原生批量操作命令是\",{\"1\":{\"287\":1}}],[\"原生批量操作命令是原子操作\",{\"1\":{\"287\":1}}],[\"原生批量操作命令不可以\",{\"1\":{\"287\":1}}],[\"原生批量操作命令和\",{\"1\":{\"287\":1}}],[\"原生批量操作命令\",{\"0\":{\"286\":1},\"1\":{\"319\":1}}],[\"原生的\",{\"1\":{\"124\":1,\"1131\":1}}],[\"原子广播协议的内容\",{\"1\":{\"1391\":1}}],[\"原子广播协议\",{\"1\":{\"1377\":1}}],[\"原子广播\",{\"1\":{\"1360\":1}}],[\"原子更新长整形字段的更新器\",{\"1\":{\"768\":1}}],[\"原子更新长整型字段的更新器\",{\"1\":{\"762\":1}}],[\"原子更新整形字段的更新器\",{\"1\":{\"768\":1}}],[\"原子更新整型字段的更新器\",{\"1\":{\"762\":1}}],[\"原子更新引用类型里的字段的更新器\",{\"1\":{\"768\":1}}],[\"原子更新引用类型里的字段\",{\"1\":{\"762\":1}}],[\"原子更新带有版本号的引用类型\",{\"1\":{\"762\":1,\"767\":1}}],[\"原子更新带有标记的引用类型\",{\"1\":{\"762\":1,\"767\":1}}],[\"原子类部分的内容我单独写了一篇文章来总结\",{\"1\":{\"875\":1}}],[\"原子类\",{\"0\":{\"875\":1}}],[\"原子类介绍\",{\"0\":{\"762\":1}}],[\"原子类总结\",{\"0\":{\"761\":1},\"1\":{\"875\":1}}],[\"原子类等\",{\"1\":{\"529\":1}}],[\"原子地\",{\"1\":{\"742\":1,\"904\":1}}],[\"原子操作将workcount的数量加1\",{\"1\":{\"941\":1}}],[\"原子操作特征的类\",{\"1\":{\"762\":1}}],[\"原子操作\",{\"1\":{\"288\":1,\"841\":1,\"990\":1}}],[\"原子操作也无法保证了\",{\"1\":{\"286\":1}}],[\"原子性问题\",{\"1\":{\"1370\":1}}],[\"原子性\",{\"0\":{\"978\":1},\"1\":{\"125\":3,\"133\":1,\"281\":2,\"1345\":1}}],[\"原子顺序递增\",{\"1\":{\"35\":1}}],[\"原文\",{\"1\":{\"1150\":1}}],[\"原文地址\",{\"1\":{\"69\":1,\"415\":1,\"567\":1,\"1025\":1}}],[\"原文传送门\",{\"1\":{\"15\":1}}],[\"原理图解\",{\"0\":{\"1035\":1}}],[\"原理概览\",{\"0\":{\"1004\":1}}],[\"原理剖析\",{\"1\":{\"999\":1}}],[\"原理了解吗\",{\"0\":{\"883\":1}}],[\"原理即可\",{\"1\":{\"874\":1}}],[\"原理比较类似\",{\"1\":{\"874\":1}}],[\"原理与实践\",{\"1\":{\"788\":1}}],[\"原理的理解\",{\"1\":{\"741\":1}}],[\"原理的工具\",{\"1\":{\"205\":1}}],[\"原理可不能少\",{\"1\":{\"604\":1}}],[\"原理\",{\"0\":{\"741\":1,\"748\":1,\"752\":1,\"756\":1},\"1\":{\"360\":1,\"503\":2,\"1021\":1,\"1166\":1}}],[\"原理也比较简单\",{\"1\":{\"49\":1}}],[\"原理介绍\",{\"1\":{\"42\":1}}],[\"原理介绍和应用\",{\"1\":{\"11\":1}}],[\"我记得\",{\"1\":{\"1390\":1}}],[\"我咋知道我的小纸条有没有传到我想要传递的那个人手中呢\",{\"1\":{\"1369\":1}}],[\"我将一个秒杀服务\",{\"1\":{\"1367\":1}}],[\"我将这篇文章的部分内容整理到了这里\",{\"1\":{\"15\":1}}],[\"我现在\",{\"1\":{\"1375\":1}}],[\"我现在换一种方式\",{\"1\":{\"1367\":1}}],[\"我现在有一个秒杀服务\",{\"1\":{\"1367\":1}}],[\"我现在整个调用流程就有点\",{\"1\":{\"1271\":1}}],[\"我发现有些同学并不是能把\",{\"1\":{\"1367\":1}}],[\"我发现缓存雪崩这名字起的有点意思\",{\"1\":{\"313\":1}}],[\"我通过\",{\"1\":{\"1349\":1}}],[\"我对于\",{\"1\":{\"1341\":1}}],[\"我突然问自己\",{\"1\":{\"1341\":1}}],[\"我本人在大学曾经使用\",{\"1\":{\"1341\":1}}],[\"我讲的你们还记得吗\",{\"1\":{\"1316\":1}}],[\"我首先想大家介绍\",{\"1\":{\"1315\":1}}],[\"我直接照搬过来就当科普了\",{\"1\":{\"1306\":1}}],[\"我再发这个消息\",{\"1\":{\"1303\":1}}],[\"我给出一张官网的架构图\",{\"1\":{\"1281\":1}}],[\"我还使用\",{\"1\":{\"1341\":1}}],[\"我还得普及一下关于\",{\"1\":{\"1281\":1}}],[\"我还没讲呢\",{\"1\":{\"1276\":1}}],[\"我来向大家分别解释一下这四个角色是干啥的\",{\"1\":{\"1281\":1}}],[\"我来分别介绍一下他们\",{\"1\":{\"1280\":1}}],[\"我来举个\",{\"1\":{\"1271\":1}}],[\"我相信你会有所收获的\",{\"1\":{\"1279\":1}}],[\"我相信大家在各种平台上也都看到过\",{\"1\":{\"1150\":1}}],[\"我画了张图\",{\"1\":{\"1304\":1}}],[\"我画了一个简单的\",{\"1\":{\"968\":1}}],[\"我画一张图给大家理解\",{\"1\":{\"1278\":1}}],[\"我中间加了个消息队列\",{\"1\":{\"1275\":1}}],[\"我上面所讲的\",{\"1\":{\"1272\":1}}],[\"我上面讲了消息队列可以实现异步\",{\"1\":{\"1224\":1}}],[\"我是不是又得改代码\",{\"1\":{\"1272\":1}}],[\"我用户购票在购票系统的时候其实就已经完成了购买\",{\"1\":{\"1271\":1}}],[\"我用到了\",{\"1\":{\"909\":1}}],[\"我不能直接进行通信吗\",{\"1\":{\"1271\":1}}],[\"我不推荐你在实际项目中使用\",{\"1\":{\"1169\":1}}],[\"我也在我的多篇文章中提到了这个概念\",{\"1\":{\"1217\":1}}],[\"我写了\",{\"1\":{\"1173\":1}}],[\"我推荐你考虑一下\",{\"1\":{\"1172\":1}}],[\"我懂\",{\"1\":{\"1150\":1}}],[\"我\",{\"1\":{\"1150\":1}}],[\"我想这个对于后端开发的朋友肯定不陌生\",{\"1\":{\"1383\":1}}],[\"我想你们可能都吐了\",{\"1\":{\"1370\":1}}],[\"我想起了我刚工作的时候\",{\"1\":{\"1150\":1}}],[\"我想并不会\",{\"1\":{\"895\":1,\"922\":1}}],[\"我就优先把请求给活跃数少的服务提供者处理\",{\"1\":{\"1142\":1}}],[\"我就可以\",{\"1\":{\"773\":1,\"899\":1}}],[\"我这么说吧\",{\"1\":{\"1142\":1}}],[\"我这里不多分析了\",{\"1\":{\"1143\":1}}],[\"我这里把一些比较重要的点再提一下\",{\"1\":{\"1128\":1}}],[\"我这里就不多做介绍了\",{\"1\":{\"180\":1}}],[\"我这里就不过多介绍\",{\"1\":{\"35\":1}}],[\"我这里以注册中心来探讨一下\",{\"1\":{\"1069\":1}}],[\"我这里以\",{\"1\":{\"49\":1}}],[\"我这里也先以\",{\"1\":{\"45\":1}}],[\"我这里也不过多介绍\",{\"1\":{\"40\":1}}],[\"我凭什么修改啊\",{\"1\":{\"1096\":1}}],[\"我当年参加面试的时候\",{\"1\":{\"1065\":1}}],[\"我的项目中多个业务需要用到线程池\",{\"1\":{\"919\":1}}],[\"我有一个任务\",{\"1\":{\"773\":1,\"899\":1}}],[\"我已经到达了屏障\",{\"1\":{\"756\":1,\"911\":1}}],[\"我我们再来看看阻塞队列中非阻塞的入队和出队方法\",{\"1\":{\"531\":1}}],[\"我会在后面的章节介绍到\",{\"1\":{\"1166\":1}}],[\"我会在方法区这部分内容详细介绍到\",{\"1\":{\"495\":1}}],[\"我会分享一些我看到的相关的案例\",{\"1\":{\"412\":1}}],[\"我个人比较喜欢用发布者\",{\"1\":{\"1182\":1}}],[\"我个人更倾向于是前者\",{\"1\":{\"396\":1}}],[\"我个人觉得引入缓存之后\",{\"1\":{\"316\":1}}],[\"我觉得\",{\"1\":{\"1191\":1}}],[\"我觉得理解为桩实际不太好\",{\"1\":{\"1166\":1}}],[\"我觉得将系统拆分成分布式之后不光便于系统扩展和维护\",{\"1\":{\"1126\":1}}],[\"我觉得一般我们提\",{\"1\":{\"1123\":1}}],[\"我觉得这明显是有问题的\",{\"1\":{\"895\":1,\"922\":1}}],[\"我觉得还是和底层数据结构有关\",{\"1\":{\"658\":1}}],[\"我觉得主要原因有\",{\"1\":{\"266\":1}}],[\"我觉得写得挺不错\",{\"1\":{\"265\":1}}],[\"我司用了\",{\"1\":{\"249\":1}}],[\"我司的一个项目\",{\"1\":{\"29\":1}}],[\"我专门找到了\",{\"1\":{\"1178\":1}}],[\"我专门画了一张图来展示\",{\"1\":{\"535\":1}}],[\"我专门画了一个图方便大家理解\",{\"1\":{\"181\":1}}],[\"我专门写了一篇文章来详细介绍这两种方案\",{\"1\":{\"62\":1}}],[\"我在学习\",{\"1\":{\"1341\":1}}],[\"我在架构那里提到了\",{\"1\":{\"1315\":1}}],[\"我在上面\",{\"1\":{\"1329\":1}}],[\"我在上面也说了\",{\"1\":{\"656\":1,\"724\":1}}],[\"我在上文中提到的\",{\"1\":{\"1312\":1}}],[\"我在后面的源码中会提到\",{\"1\":{\"1142\":1}}],[\"我在后面介绍的美团的线程池参数动态配置这种方案就非常不错\",{\"1\":{\"895\":1}}],[\"我在这篇\",{\"1\":{\"923\":1}}],[\"我在java\",{\"1\":{\"896\":1}}],[\"我在我的开源项目\",{\"1\":{\"777\":1}}],[\"我在之前的一个项目中就遇到一个类似的坑\",{\"1\":{\"634\":1}}],[\"我在前面提到过\",{\"1\":{\"289\":1}}],[\"我在前面介绍\",{\"1\":{\"160\":1,\"232\":1}}],[\"我在\",{\"1\":{\"180\":1,\"286\":1,\"1192\":1,\"1346\":1}}],[\"我基本上已经把最常见的分布式\",{\"1\":{\"43\":1}}],[\"我自己就主动提前去获取下一个号段\",{\"1\":{\"41\":1}}],[\"我简单举一个分库分表的例子\",{\"1\":{\"29\":1}}],[\"我们同样也是让\",{\"1\":{\"1390\":1}}],[\"我们想对集群中的每台机器的运行时状态进行数据采集\",{\"1\":{\"1390\":1}}],[\"我们想要实现最终一致性就要靠\",{\"1\":{\"1087\":1}}],[\"我们之前提到过\",{\"1\":{\"1389\":1}}],[\"我们肯定需要先暂停服务变为\",{\"1\":{\"1380\":1}}],[\"我们整个集群如何保证数据一致性\",{\"1\":{\"1380\":1}}],[\"我们首先来了解一下在\",{\"1\":{\"1378\":1}}],[\"我们首先可能会想到采用\",{\"1\":{\"684\":1}}],[\"我们所有服务的数据处理要么都成功要么都失败\",{\"1\":{\"1370\":1}}],[\"我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了\",{\"1\":{\"1370\":1}}],[\"我们此时创建一个字节数组看看\",{\"1\":{\"451\":1}}],[\"我们介绍到使用其通常被用于实现诸如数据发布\",{\"1\":{\"1346\":1}}],[\"我们这儿就变成动物园了\",{\"1\":{\"1343\":1}}],[\"我们这里提到的消息队列稍微有点区别\",{\"1\":{\"1218\":1}}],[\"我们这里再来详细介绍一下\",{\"1\":{\"1208\":1}}],[\"我们这里说的\",{\"1\":{\"1167\":1}}],[\"我们这里假设有\",{\"1\":{\"747\":1,\"905\":1}}],[\"我们这里希望任务可以按照我们预期的时间执行\",{\"1\":{\"599\":1}}],[\"我们这里会用两个线程分别模拟生产者和消费者\",{\"1\":{\"531\":1}}],[\"我们这里以阿里巴巴推荐的使用\",{\"1\":{\"940\":1}}],[\"我们这里以\",{\"1\":{\"491\":1,\"729\":1,\"1085\":1}}],[\"我们这里启动\",{\"1\":{\"251\":1}}],[\"我们这里重点关注一下这个\",{\"1\":{\"37\":1}}],[\"我们结合着图来理解一下\",{\"1\":{\"1315\":1}}],[\"我们上文提到过\",{\"1\":{\"1281\":1}}],[\"我们上面讲重排序的时候也提到过\",{\"1\":{\"980\":1}}],[\"我们上面讲解了\",{\"1\":{\"939\":1}}],[\"我们上面讲的扩容操作以及add\",{\"1\":{\"560\":1}}],[\"我们上面提到了用户线程和内核线程\",{\"1\":{\"808\":1}}],[\"我们上面的代码示例中\",{\"1\":{\"784\":1}}],[\"我们上面也说了两者的区别\",{\"1\":{\"940\":1}}],[\"我们上面也提到了\",{\"1\":{\"709\":1,\"897\":1}}],[\"我们上面也讲到了过了\",{\"1\":{\"684\":1}}],[\"我们理解起\",{\"1\":{\"1281\":1}}],[\"我们理解一下\",{\"1\":{\"1011\":1}}],[\"我们购买系统作为一个生产者去生产这条消息放入消息队列\",{\"1\":{\"1272\":1}}],[\"我们后面的发送短信\",{\"1\":{\"1272\":1}}],[\"我们又添加了一个发送邮件\",{\"1\":{\"1272\":1}}],[\"我们又该如何回收这些垃圾呢\",{\"1\":{\"446\":1}}],[\"我们写个伪代码简单概括一下\",{\"1\":{\"1272\":1}}],[\"我们写一个简单的方法测试以下\",{\"1\":{\"561\":1}}],[\"我们告诉服务员我们要吃什么然后玩手机\",{\"1\":{\"1271\":1}}],[\"我们告诉服务员来一碗牛肉面加个荷包蛋\",{\"1\":{\"1271\":1}}],[\"我们工作赚钱了有钱去饭店吃饭了\",{\"1\":{\"1271\":1}}],[\"我们等待的时间也会相应的变长\",{\"1\":{\"1271\":1}}],[\"我们和食堂大妈就是一个同步的模型\",{\"1\":{\"1271\":1}}],[\"我们省略中间的网络通信时间消耗\",{\"1\":{\"1271\":1}}],[\"我们当时就直接丢弃数据了\",{\"1\":{\"1264\":1}}],[\"我们比较常用的是发布\",{\"1\":{\"1222\":1}}],[\"我们比较熟悉的\",{\"1\":{\"359\":1}}],[\"我们提到了\",{\"1\":{\"1208\":1}}],[\"我们最开始也说了我们发送的消息会被发送到\",{\"1\":{\"1206\":1}}],[\"我们手动关闭自动提交\",{\"1\":{\"1205\":1}}],[\"我们检查失败的原因之后重新发送即可\",{\"1\":{\"1204\":1}}],[\"我们发送的消息都被放在了这里\",{\"1\":{\"1202\":1}}],[\"我们发送的消息会被发送到\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"我们发现\",{\"1\":{\"561\":1}}],[\"我们得想个办法将它也转为二进制\",{\"1\":{\"1159\":1}}],[\"我们得到了最终的结果\",{\"1\":{\"777\":1}}],[\"我们回到文章标题的问题\",{\"1\":{\"1154\":1}}],[\"我们回过头来看网络的分层图\",{\"1\":{\"1154\":1}}],[\"我们平时调用一个\",{\"1\":{\"1154\":1}}],[\"我们用的比较多\",{\"1\":{\"1154\":1}}],[\"我们便可以获取到对应的活跃数\",{\"1\":{\"1142\":1}}],[\"我们便可以知道\",{\"1\":{\"325\":1}}],[\"我们生产者发送\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"我们生成\",{\"1\":{\"1141\":1}}],[\"我们生活中根本就不会用它\",{\"1\":{\"70\":1}}],[\"我们屏蔽掉的这些细节就依赖对应的\",{\"1\":{\"1129\":1}}],[\"我们刚刚说了\",{\"1\":{\"1275\":1}}],[\"我们刚刚提到了分布式这个概念\",{\"1\":{\"1123\":1}}],[\"我们刚刚也提到过了执行\",{\"1\":{\"934\":1}}],[\"我们希望这种情况仅占全部时间的很小一部分\",{\"1\":{\"1116\":1}}],[\"我们希望能够一次性将阻塞队列的结果存到列表中再进行批量操作\",{\"1\":{\"531\":1}}],[\"我们并不需要自己实现基于\",{\"1\":{\"1099\":1}}],[\"我们能不能使用\",{\"1\":{\"1389\":1}}],[\"我们能不能\",{\"1\":{\"1273\":1}}],[\"我们能够在一个确定的时间范围内实现各个节点数据的最终一致性\",{\"1\":{\"1087\":1}}],[\"我们能做的就是根据具体应用场景选择适合自己的垃圾收集器\",{\"1\":{\"400\":1}}],[\"我们大概就能知道\",{\"1\":{\"1084\":1}}],[\"我们是不是可以\",{\"1\":{\"1387\":1}}],[\"我们是不是可以通过\",{\"1\":{\"1272\":1}}],[\"我们是必须要实现的\",{\"1\":{\"1068\":1}}],[\"我们是通过传入匿名内部类的方式实现的\",{\"1\":{\"679\":1}}],[\"我们是通过过期时间来避免锁无法被释放导致死锁问题的\",{\"1\":{\"54\":1}}],[\"我们非常有必要将这两个理论搞懂\",{\"1\":{\"1065\":1}}],[\"我们现在使用了\",{\"1\":{\"1299\":1}}],[\"我们现在经常提到\",{\"1\":{\"1191\":1}}],[\"我们现在项目中日志记录用的是elk+logstash\",{\"1\":{\"1045\":1}}],[\"我们现实生活中也有各种\",{\"1\":{\"28\":1}}],[\"我们以get\",{\"1\":{\"1040\":1}}],[\"我们以oldtab\",{\"1\":{\"1038\":1}}],[\"我们以市民表的联合索引\",{\"1\":{\"117\":1}}],[\"我们假设expungestaleentry\",{\"1\":{\"1037\":1}}],[\"我们接着再看下源码\",{\"1\":{\"1036\":1}}],[\"我们自己可以尝试下\",{\"1\":{\"1032\":1}}],[\"我们日常开发中使用并发的场景太多\",{\"1\":{\"1021\":1}}],[\"我们很容易得知\",{\"1\":{\"1018\":1}}],[\"我们从上面学习知道了在\",{\"1\":{\"1299\":1}}],[\"我们从上图看到b树和二分搜索树有一点相似的地方\",{\"1\":{\"99\":1}}],[\"我们从负载均衡的这四个字就能明显感受到它的意义\",{\"1\":{\"1139\":1}}],[\"我们从这里可以看到\",{\"1\":{\"1014\":1}}],[\"我们已经知道了\",{\"1\":{\"1299\":1}}],[\"我们已经剖析了加锁过程中的基本流程\",{\"1\":{\"1014\":1}}],[\"我们已经没有什么理由可以选择使用\",{\"1\":{\"245\":1}}],[\"我们逐行来分析这个方法的原理\",{\"1\":{\"1013\":1}}],[\"我们将这个服务部署在了多台服务器上\",{\"1\":{\"1139\":1}}],[\"我们将这个实现类的路径写入到resources\",{\"1\":{\"1131\":1}}],[\"我们将接口的实现类放在配置文件中\",{\"1\":{\"1131\":1}}],[\"我们将加锁和解锁的交互流程单独拎出来强调一下\",{\"1\":{\"1007\":1}}],[\"我们将所有可达对象\",{\"1\":{\"396\":1}}],[\"我们可能创建删除了临时节点\",{\"1\":{\"1390\":1}}],[\"我们可能会存在这种疑问\",{\"1\":{\"1002\":1}}],[\"我们可选项一般也就tcp\",{\"1\":{\"1151\":1}}],[\"我们可以为每条机器创建临时节点\",{\"1\":{\"1390\":1}}],[\"我们可以为每个消费者创建一个单独的队列\",{\"1\":{\"1193\":1}}],[\"我们可以为每个锁关联一个可重入计数器和一个占有它的线程\",{\"1\":{\"50\":1}}],[\"我们可以让多个客户端同时创建一个临时节点\",{\"1\":{\"1388\":1}}],[\"我们可以完全\",{\"1\":{\"1387\":1}}],[\"我们可以\",{\"1\":{\"1387\":1}}],[\"我们可以直接根据队列的消息序号\",{\"1\":{\"1315\":1}}],[\"我们可以先检查\",{\"1\":{\"1305\":1}}],[\"我们可以从多个角度去思考解决这个问题\",{\"1\":{\"1305\":1}}],[\"我们可以理解为\",{\"1\":{\"1280\":1}}],[\"我们可以采取一个方案\",{\"1\":{\"1264\":1}}],[\"我们可以随便截个图直观看下\",{\"1\":{\"1159\":1}}],[\"我们可以在运行的时候\",{\"1\":{\"1131\":1}}],[\"我们可以用\",{\"1\":{\"1123\":1}}],[\"我们可以将整个\",{\"1\":{\"1166\":1}}],[\"我们可以将信息传播给网络或集群中的所有成员\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"我们可以将缓存的\",{\"1\":{\"609\":1}}],[\"我们可以多配置一些线程\",{\"1\":{\"895\":1,\"922\":1}}],[\"我们可以肯定的一点是线程池大小设置过大或者过小都会有问题\",{\"1\":{\"895\":1,\"922\":1}}],[\"我们可以结合内置线程池来分析\",{\"1\":{\"892\":1,\"938\":1}}],[\"我们可以定制策略来处理任务\",{\"1\":{\"890\":1,\"936\":1}}],[\"我们可以创建多种类型的\",{\"1\":{\"888\":1,\"937\":1}}],[\"我们可以把消息队列看作是一个存放消息的容器\",{\"1\":{\"1218\":1}}],[\"我们可以把\",{\"1\":{\"883\":1}}],[\"我们可以把当前更新失败的\",{\"1\":{\"316\":1}}],[\"我们可以通过节点是否已经失去连接来判断\",{\"1\":{\"1387\":1}}],[\"我们可以通过修改\",{\"1\":{\"1006\":1}}],[\"我们可以通过\",{\"1\":{\"807\":1,\"895\":1,\"900\":1,\"922\":1,\"1204\":1}}],[\"我们可以通过下面两个参数来减少对\",{\"1\":{\"220\":1}}],[\"我们可以调用\",{\"1\":{\"777\":1}}],[\"我们可以封装一个简易版的\",{\"1\":{\"706\":1}}],[\"我们可以重写compareto\",{\"1\":{\"661\":1}}],[\"我们可以看到在整个图中有\",{\"1\":{\"1280\":1}}],[\"我们可以看到threadlocalmap中table的数据情况\",{\"1\":{\"1037\":1}}],[\"我们可以看到从\",{\"1\":{\"711\":1}}],[\"我们可以看到这个类重写的方法有哪些\",{\"1\":{\"634\":1}}],[\"我们可以看到这个接口同样继承了\",{\"1\":{\"533\":1}}],[\"我们可以看出向\",{\"1\":{\"564\":1}}],[\"我们可以看出\",{\"1\":{\"293\":1}}],[\"我们可以更好地利用虚拟内存硬件资源\",{\"1\":{\"485\":1}}],[\"我们可以设置参数\",{\"1\":{\"484\":1}}],[\"我们可以尝试对\",{\"1\":{\"450\":1}}],[\"我们可以自己定义一个类加载器\",{\"1\":{\"359\":1}}],[\"我们可以自定义过滤器来处理请求\",{\"1\":{\"4\":1}}],[\"我们可以对应上面第四种情况的原理图来再回顾下\",{\"1\":{\"1036\":1}}],[\"我们可以对\",{\"1\":{\"353\":1}}],[\"我们可以选择在合适的时机短暂执行\",{\"1\":{\"298\":1}}],[\"我们可以利用\",{\"1\":{\"283\":1,\"287\":1}}],[\"我们可以很方便地完成很多复杂的业务场景比如通过\",{\"1\":{\"249\":1}}],[\"我们可以轻松实现两个位置距离的计算\",{\"1\":{\"209\":1}}],[\"我们可以想到的一个解决办法就是\",{\"1\":{\"48\":1}}],[\"我们可以使用节点的全路径作为命名方式了\",{\"1\":{\"1389\":1}}],[\"我们可以使用一些\",{\"1\":{\"1305\":1}}],[\"我们可以使用传入\",{\"1\":{\"705\":1}}],[\"我们可以使用它将一个数组转换为一个\",{\"1\":{\"634\":1}}],[\"我们可以使用\",{\"1\":{\"35\":1,\"287\":1,\"302\":1,\"1123\":1}}],[\"我们着重从这两者的加锁过程来理解一下它们与\",{\"1\":{\"1002\":1}}],[\"我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水\",{\"1\":{\"1271\":1}}],[\"我们看到上面debug中的referent=null\",{\"1\":{\"1030\":1}}],[\"我们看下面这段代码\",{\"1\":{\"974\":1}}],[\"我们看看这两种方式会有什么问题\",{\"1\":{\"89\":1}}],[\"我们甚至可以把\",{\"1\":{\"968\":1}}],[\"我们先搞明白\",{\"1\":{\"1276\":1}}],[\"我们先讲下探测式清理\",{\"1\":{\"1037\":1}}],[\"我们先看下nextindex\",{\"1\":{\"1036\":1}}],[\"我们先看下threadlocal使用示例\",{\"1\":{\"1028\":1}}],[\"我们先将\",{\"1\":{\"1001\":1}}],[\"我们先要从\",{\"1\":{\"967\":1}}],[\"我们先来想想分布式事务到底有什么问题呢\",{\"1\":{\"1370\":1}}],[\"我们先来了解一下两个名词概念\",{\"1\":{\"1277\":1}}],[\"我们先来聊聊\",{\"1\":{\"708\":1}}],[\"我们先来看下从头到尾方向的迭代\",{\"1\":{\"732\":1}}],[\"我们先来看看\",{\"1\":{\"533\":1,\"1343\":1}}],[\"我们先来看看基于数据库号段模式的简单架构方案\",{\"1\":{\"42\":1}}],[\"我们先来看一下各种书籍和博客上一般推荐的配置线程池参数的方式\",{\"1\":{\"921\":1}}],[\"我们先来看一下\",{\"1\":{\"307\":1}}],[\"我们配置的核心线程数为\",{\"1\":{\"941\":1}}],[\"我们使用threadlocal的时候\",{\"1\":{\"1043\":1}}],[\"我们使用反射的方式来看看gc后threadlocal中的数据情况\",{\"1\":{\"1030\":1}}],[\"我们使用\",{\"1\":{\"941\":1}}],[\"我们使用包装类型数组就可以解决这个问题\",{\"1\":{\"634\":1}}],[\"我们要判断消息发送的结果\",{\"1\":{\"1204\":1}}],[\"我们要思考如何保证\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"我们要考虑选择\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"我们要读取处理\",{\"1\":{\"909\":1}}],[\"我们要将链表首节点移除\",{\"1\":{\"712\":1}}],[\"我们调用\",{\"1\":{\"896\":1,\"923\":1}}],[\"我们调用的是threadlocalmap类对应的\",{\"1\":{\"883\":1}}],[\"我们足以通过猜测得出结论\",{\"1\":{\"883\":1}}],[\"我们创建对应的实现类\",{\"1\":{\"1131\":1}}],[\"我们创建的变量是可以被任何一个线程访问并修改的\",{\"1\":{\"881\":1}}],[\"我们创建索引的字段应该是查询操作非常频繁的字段\",{\"1\":{\"119\":1}}],[\"我们分析一下上面的代码为什么避免了死锁的发生\",{\"1\":{\"824\":1}}],[\"我们对于\",{\"1\":{\"1013\":1}}],[\"我们对于抽象类\",{\"1\":{\"533\":1}}],[\"我们对线程\",{\"1\":{\"824\":1}}],[\"我们定义了请求的数量为\",{\"1\":{\"753\":1}}],[\"我们定义了一个\",{\"1\":{\"329\":1}}],[\"我们\",{\"1\":{\"724\":1}}],[\"我们直接将\",{\"1\":{\"711\":1}}],[\"我们直接在\",{\"1\":{\"708\":1}}],[\"我们则需要将当前节点移到链表尾部\",{\"1\":{\"710\":1}}],[\"我们按照顺序往\",{\"1\":{\"704\":1}}],[\"我们主要根据集合的特点来选择合适的集合\",{\"1\":{\"646\":1}}],[\"我们有很多服务是部署在不同系统之间的\",{\"1\":{\"1304\":1}}],[\"我们有\",{\"1\":{\"632\":1}}],[\"我们来解释下述源码\",{\"1\":{\"1014\":1}}],[\"我们来分析每一种情况的流程\",{\"1\":{\"1013\":1}}],[\"我们来结合源码分析一下\",{\"1\":{\"683\":1}}],[\"我们来看看\",{\"1\":{\"1156\":1}}],[\"我们来看一个例子\",{\"1\":{\"1043\":1}}],[\"我们来看最长的那个\",{\"1\":{\"936\":1}}],[\"我们来看\",{\"1\":{\"630\":1}}],[\"我们来看执行器和\",{\"1\":{\"89\":1}}],[\"我们来仔细分析一下\",{\"1\":{\"557\":1}}],[\"我们把这些权重值分布在坐标区间会得到\",{\"1\":{\"1141\":1}}],[\"我们把这个数字\",{\"1\":{\"22\":1}}],[\"我们把它从empty\",{\"1\":{\"553\":1}}],[\"我们即可以通过元素的序号快速获取元素对象\",{\"1\":{\"549\":1}}],[\"我们继续深入查看一下\",{\"1\":{\"535\":1}}],[\"我们继续看看阻塞获取队列元素的\",{\"1\":{\"535\":1}}],[\"我们继续看看\",{\"1\":{\"533\":1}}],[\"我们到源码中一探究竟\",{\"1\":{\"533\":1}}],[\"我们前\",{\"1\":{\"531\":1}}],[\"我们前面也说说了\",{\"1\":{\"354\":1}}],[\"我们前面说的事件监听器其实监听的就是这个子节点删除事件\",{\"1\":{\"53\":1}}],[\"我们设置了一个大小为\",{\"1\":{\"531\":1}}],[\"我们设置保存的缓存数据的时候都会设置一个过期时间\",{\"1\":{\"270\":1}}],[\"我们不能默认在调用send方法发送消息之后消息发送成功了\",{\"1\":{\"1204\":1}}],[\"我们不需要了解底层网络编程的具体细节\",{\"1\":{\"1165\":1}}],[\"我们不需要自己手动实现\",{\"1\":{\"50\":1}}],[\"我们不应该仅仅局限在\",{\"1\":{\"1070\":1}}],[\"我们不妨看看\",{\"1\":{\"535\":1}}],[\"我们不妨先看看其构造函数\",{\"1\":{\"534\":1}}],[\"我们不妨基于下面几个实例了解以下\",{\"1\":{\"531\":1}}],[\"我们只用一个线程的话\",{\"1\":{\"816\":1}}],[\"我们只需要关心消息是否送达了队列\",{\"1\":{\"1272\":1}}],[\"我们只需要存放元素值时\",{\"1\":{\"646\":1}}],[\"我们只需调用\",{\"1\":{\"530\":1}}],[\"我们只要获取数组中的所有entry对象\",{\"1\":{\"625\":1}}],[\"我们只要输入待查找的键即\",{\"1\":{\"96\":1}}],[\"我们称这类内存区域为\",{\"1\":{\"492\":1}}],[\"我们会判断前置节点的状态来决定是否要将当前线程挂起\",{\"1\":{\"1012\":1}}],[\"我们会使用下面这个构造方法\",{\"1\":{\"534\":1}}],[\"我们会尝试在队列用\",{\"1\":{\"531\":1}}],[\"我们会发现现在的\",{\"1\":{\"451\":1}}],[\"我们会听说过\",{\"1\":{\"422\":1}}],[\"我们执行下面的代码\",{\"1\":{\"451\":1}}],[\"我们经常使用的分布式缓存\",{\"1\":{\"1085\":1}}],[\"我们经常需要并行运行多个互不相关的任务\",{\"1\":{\"782\":1}}],[\"我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中\",{\"1\":{\"224\":1}}],[\"我们经常说的栈帧数据\",{\"1\":{\"441\":1}}],[\"我们的消费者和生产者直接和多个\",{\"1\":{\"1281\":1}}],[\"我们的系统中的某个服务的访问量特别大\",{\"1\":{\"1139\":1}}],[\"我们的程序运行在操作系统之上\",{\"1\":{\"968\":1}}],[\"我们的\",{\"1\":{\"508\":1,\"1281\":2,\"1299\":1}}],[\"我们的参数应该这样来写\",{\"1\":{\"478\":1,\"479\":1}}],[\"我们的代码肯定会报错\",{\"1\":{\"433\":1}}],[\"我们的业务场景就是需要某个数据只在某一时间段内存在\",{\"1\":{\"270\":1}}],[\"我们如何判断一个常量是废弃常量呢\",{\"1\":{\"393\":1}}],[\"我们如何为不同的数据节点生成全局唯一主键呢\",{\"1\":{\"29\":1}}],[\"我们下面会通过\",{\"1\":{\"370\":1}}],[\"我们项目中有一些用到了\",{\"1\":{\"359\":1}}],[\"我们编写的每一个方法都会放到\",{\"1\":{\"422\":1}}],[\"我们编写的\",{\"1\":{\"353\":1}}],[\"我们常见的一些\",{\"1\":{\"1132\":1}}],[\"我们常见的一码付\",{\"1\":{\"17\":1}}],[\"我们常常听到消息队列这个关键词\",{\"1\":{\"1217\":1}}],[\"我们常常\",{\"1\":{\"1030\":1}}],[\"我们常用内置库\",{\"1\":{\"353\":1}}],[\"我们也可以利用临时节点的创建来实现\",{\"1\":{\"1388\":1}}],[\"我们也可以创建\",{\"1\":{\"934\":1}}],[\"我们也得在主系统删除某些接口调用\",{\"1\":{\"1272\":1}}],[\"我们也会经常拿它跟\",{\"1\":{\"1191\":1}}],[\"我们也能打破由双亲委派模型\",{\"1\":{\"340\":1}}],[\"我们也就提高了系统整体的并发\",{\"1\":{\"246\":1}}],[\"我们尽量要准守一些常见的规范\",{\"1\":{\"319\":1}}],[\"我们让缓存数据的过期时间变短\",{\"1\":{\"316\":1}}],[\"我们无法预估所有\",{\"1\":{\"298\":1}}],[\"我们应该显示地给我们的线程池命名\",{\"1\":{\"917\":1}}],[\"我们应该允许多个线程同时访问\",{\"1\":{\"584\":1,\"793\":1}}],[\"我们应该尽量避免将耗时任务提交到线程池中执行\",{\"1\":{\"925\":1}}],[\"我们应该尽量避免\",{\"1\":{\"292\":1}}],[\"我们应该根据业务的具体需求来选择\",{\"1\":{\"52\":1}}],[\"我们都习惯把消息中间件成为消息队列\",{\"1\":{\"1277\":1}}],[\"我们都要在主系统调用新接口\",{\"1\":{\"1272\":1}}],[\"我们都是不建议使用\",{\"1\":{\"1179\":1}}],[\"我们都是基于\",{\"1\":{\"249\":1}}],[\"我们都可以有相应的解决方案\",{\"1\":{\"1045\":1}}],[\"我们都知道\",{\"1\":{\"601\":1,\"708\":2}}],[\"我们都尽量给\",{\"1\":{\"289\":1}}],[\"我们虽然经常说\",{\"1\":{\"268\":1}}],[\"我们建议使用\",{\"1\":{\"255\":1}}],[\"我们认为\",{\"1\":{\"219\":1}}],[\"我们还记得上面进行rehash\",{\"1\":{\"1038\":1}}],[\"我们还是以先原理图后源码讲解的方式来一步步梳理\",{\"1\":{\"1037\":1}}],[\"我们还可以自行扩展负载均衡策略\",{\"1\":{\"1140\":1}}],[\"我们还可以利用\",{\"1\":{\"918\":1}}],[\"我们还可以利用或者参考现成的异步任务编排框架\",{\"1\":{\"787\":1}}],[\"我们还可以使用\",{\"1\":{\"164\":1}}],[\"我们还要注意entry\",{\"1\":{\"1029\":1}}],[\"我们还要从布隆过滤器的原理来说\",{\"1\":{\"307\":1}}],[\"我们还要搞懂其中的原理\",{\"1\":{\"145\":1}}],[\"我们还很有可能会直接通过\",{\"1\":{\"30\":1}}],[\"我们总是会用到事务\",{\"1\":{\"124\":1}}],[\"我们一直使用的线程\",{\"1\":{\"1053\":1}}],[\"我们一定要说清楚这两个步骤\",{\"1\":{\"1038\":1}}],[\"我们一个页中存放16384\",{\"1\":{\"110\":1}}],[\"我们一般也不会考虑使用\",{\"1\":{\"1147\":1}}],[\"我们一般也会对\",{\"1\":{\"38\":1}}],[\"我们一般会为\",{\"1\":{\"1206\":1}}],[\"我们一般会在代码里使用\",{\"1\":{\"1151\":1}}],[\"我们一般会给反熵设计一个闭环\",{\"1\":{\"1089\":1}}],[\"我们一般会选择基于\",{\"1\":{\"45\":1}}],[\"我们一般理解的双亲都是父母\",{\"1\":{\"356\":1}}],[\"我们一般很少会使用它\",{\"1\":{\"37\":1}}],[\"我们就得重新去修改代码\",{\"1\":{\"1272\":1}}],[\"我们就以\",{\"1\":{\"1263\":1}}],[\"我们就有一种很简单的保证消息消费顺序的方法\",{\"1\":{\"1202\":1}}],[\"我们就选择对应的服务器来处理请求\",{\"1\":{\"1141\":1}}],[\"我们就分析上面的输出内容来简单分析一下线程池原理\",{\"1\":{\"941\":1}}],[\"我们就要重写compareto\",{\"1\":{\"661\":1}}],[\"我们就会发现\",{\"1\":{\"560\":1}}],[\"我们就知道了\",{\"1\":{\"533\":1}}],[\"我们就可以使用send\",{\"1\":{\"1151\":1}}],[\"我们就可以使用阻塞队列的\",{\"1\":{\"531\":1}}],[\"我们就可以愉快的对这个\",{\"1\":{\"1151\":1}}],[\"我们就可以同时保证\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"我们就可以清楚看到\",{\"1\":{\"806\":1}}],[\"我们就可以改变传统双亲委派模型的执行流程\",{\"1\":{\"359\":1}}],[\"我们就开始重点讨论本篇文章所要介绍的并发容器\",{\"1\":{\"531\":1}}],[\"我们就需要在存取时上锁\",{\"1\":{\"601\":1}}],[\"我们就需要在每个服务中单独实现\",{\"1\":{\"1\":1}}],[\"我们就需要对这些\",{\"1\":{\"381\":1}}],[\"我们就隔一段时间进行重试\",{\"1\":{\"316\":1}}],[\"我们就不应该使用二叉树\",{\"1\":{\"98\":1}}],[\"我们在将消息存入消息队列之后我们就可以直接返回了\",{\"1\":{\"1271\":1}}],[\"我们在给大妈发送需要的信息之后我们是\",{\"1\":{\"1271\":1}}],[\"我们在上面提到过\",{\"1\":{\"1231\":1}}],[\"我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序\",{\"1\":{\"1202\":1}}],[\"我们在使用mysql中看到的只是输入一条语句\",{\"1\":{\"81\":1}}],[\"我们在初始化\",{\"1\":{\"1182\":1}}],[\"我们在程序运行过程中读取配置文件\",{\"1\":{\"1131\":1}}],[\"我们在\",{\"1\":{\"1016\":1,\"1335\":1}}],[\"我们在代码中模拟了\",{\"1\":{\"941\":1}}],[\"我们在项目中一般是不会使用到\",{\"1\":{\"656\":1,\"724\":1}}],[\"我们在实际开发的时候要确保开发的的\",{\"1\":{\"327\":1}}],[\"我们在商场买东西一码付二维码\",{\"1\":{\"16\":1}}],[\"我们捕获全局异常只需要在项目中配置\",{\"1\":{\"77\":1}}],[\"我们通常建议不要使用\",{\"1\":{\"251\":1}}],[\"我们通常使用\",{\"1\":{\"60\":1}}],[\"我们通常是将\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"我们通过前面的代码输出结果可以看出\",{\"1\":{\"941\":1}}],[\"我们通过创建了一个结果值类型为\",{\"1\":{\"777\":1}}],[\"我们通过下面的架构图来整体了解一下\",{\"1\":{\"1003\":1}}],[\"我们通过下面的代码即可证明\",{\"1\":{\"835\":1}}],[\"我们通过下面的代码实际测试以下这个方法的效果\",{\"1\":{\"564\":1}}],[\"我们通过下面的方式即可\",{\"1\":{\"33\":1,\"34\":1}}],[\"我们通过\",{\"1\":{\"35\":1,\"42\":1}}],[\"我们再前面也讲了\",{\"1\":{\"1315\":1}}],[\"我们再次回到一开始我们使用同步调用系统的情况\",{\"1\":{\"1273\":1}}],[\"我们再通过\",{\"1\":{\"773\":1,\"899\":1}}],[\"我们再看一下java\",{\"1\":{\"634\":1}}],[\"我们再来对比一下\",{\"1\":{\"622\":1}}],[\"我们再来对比一下上面提到的这些获取和新增元素的方法\",{\"1\":{\"539\":1}}],[\"我们再来通过例子探究一下grow\",{\"1\":{\"558\":1}}],[\"我们再来看set是如何实现的\",{\"1\":{\"1035\":1}}],[\"我们再来看一个真实的事故案例\",{\"1\":{\"919\":1}}],[\"我们再来看一下\",{\"1\":{\"307\":1}}],[\"我们再来看看另外一个比较重要的概念\",{\"1\":{\"969\":1}}],[\"我们再来看看两者底层数据结构的对比图\",{\"1\":{\"688\":1}}],[\"我们再来看看非阻塞的获取元素方法\",{\"1\":{\"604\":1}}],[\"我们再来看看阻塞队列的一个比较特殊的操作\",{\"1\":{\"531\":1}}],[\"我们再来看看\",{\"1\":{\"38\":1,\"974\":1}}],[\"我们再简单分析一下\",{\"1\":{\"37\":1}}],[\"我们知道每个数据节点在\",{\"1\":{\"1349\":1}}],[\"我们知道在发布订阅模式中一般会涉及到多个消费者组\",{\"1\":{\"1280\":1}}],[\"我们知道运行我们主业务的服务器配置一般会比较好\",{\"1\":{\"1273\":1}}],[\"我们知道分布式事务的解决方案之一就是\",{\"1\":{\"1223\":1}}],[\"我们知道如果模块之间不存在直接调用\",{\"1\":{\"1222\":1}}],[\"我们知道操作系统中的进程通信的一种很重要的方式就是消息队列\",{\"1\":{\"1218\":1}}],[\"我们知道消息在被追加到\",{\"1\":{\"1205\":1}}],[\"我们知道原子是构成一般物质的最小单位\",{\"1\":{\"762\":1}}],[\"我们知道位运算的速度远远快于整除运算\",{\"1\":{\"553\":1,\"558\":1}}],[\"我们知道一个\",{\"1\":{\"301\":1}}],[\"我们知道事务具有四大特性\",{\"1\":{\"281\":1}}],[\"我们知道\",{\"1\":{\"35\":1,\"201\":1,\"212\":1,\"261\":1,\"698\":1,\"792\":1,\"1202\":1,\"1206\":1}}],[\"我们没有使用\",{\"1\":{\"33\":1}}],[\"我们需要了解整个集群中有多少机器在工作\",{\"1\":{\"1390\":1}}],[\"我们需要处理的仅仅是将同一语义下的消息放入同一个队列\",{\"1\":{\"1299\":1}}],[\"我们需要告诉食堂大妈\",{\"1\":{\"1271\":1}}],[\"我们需要将生产者产生的消息分发给多个消费者\",{\"1\":{\"1193\":1}}],[\"我们需要将其装进一个\",{\"1\":{\"419\":1}}],[\"我们需要考虑底层传输方式\",{\"1\":{\"1165\":1}}],[\"我们需要动态代理来屏蔽远程调用的细节吧\",{\"1\":{\"1129\":1}}],[\"我们需要用到\",{\"1\":{\"1099\":1}}],[\"我们需要用到分布式锁\",{\"1\":{\"60\":1}}],[\"我们需要搞清楚java的四种引用类型\",{\"1\":{\"1030\":1}}],[\"我们需要首先分析一下\",{\"1\":{\"941\":1}}],[\"我们需要根据键值获取到元素值时就选用\",{\"1\":{\"646\":1}}],[\"我们需要的就是判断\",{\"1\":{\"307\":1}}],[\"我们需要不断轮询去调用\",{\"1\":{\"251\":1}}],[\"我们需要使用互斥操作对共享资源进行保护\",{\"1\":{\"60\":1}}],[\"我们需要持久化数据\",{\"1\":{\"35\":1}}],[\"我们需要对系统中的各种数据使用\",{\"1\":{\"28\":1}}],[\"我们需要保障网关服务的高可用\",{\"1\":{\"1\":1}}],[\"面对内存不足错误是非常常见的\",{\"1\":{\"484\":1}}],[\"面试手册\",{\"1\":{\"835\":1}}],[\"面试突击\",{\"1\":{\"835\":1}}],[\"面试中问的比较少\",{\"1\":{\"870\":1}}],[\"面试中也问的比较少\",{\"1\":{\"864\":1}}],[\"面试中面试官经常会说\",{\"1\":{\"834\":1}}],[\"面试中回答要点即可\",{\"1\":{\"544\":1}}],[\"面试不是背题\",{\"1\":{\"741\":1}}],[\"面试官让你给他讲讲对于\",{\"1\":{\"1341\":1}}],[\"面试官几乎是必定会问这两个分布式相关的理论\",{\"1\":{\"1065\":1}}],[\"面试官也得服\",{\"1\":{\"612\":1}}],[\"面试官可能会紧接着就追问\",{\"1\":{\"145\":1}}],[\"面试官可能会结合具体的业务场景来考察你对分布式\",{\"1\":{\"43\":1}}],[\"面试的时候可能会被问到的哦\",{\"1\":{\"37\":1}}],[\"面试指北\",{\"1\":{\"13\":1,\"65\":1,\"150\":1,\"153\":1,\"194\":1,\"258\":1}}],[\"面向连接\",{\"1\":{\"1152\":1}}],[\"面向接口代理的高性能\",{\"1\":{\"1122\":1}}],[\"面向对象\",{\"0\":{\"518\":1},\"1\":{\"515\":1}}],[\"面向我们用户的加载器\",{\"1\":{\"353\":1}}],[\"面向\",{\"1\":{\"2\":1}}],[\"付费\",{\"0\":{\"13\":1,\"65\":1,\"150\":1,\"153\":1,\"736\":1},\"1\":{\"286\":1,\"318\":1,\"1085\":1,\"1223\":1}}],[\"f1\",{\"1\":{\"1379\":2}}],[\"fd\",{\"1\":{\"1151\":1}}],[\"fst\",{\"1\":{\"1146\":1,\"1147\":1}}],[\"fsync完成后线程返回\",{\"1\":{\"282\":1}}],[\"fsync用于强制刷新系统内核缓冲区\",{\"1\":{\"230\":1}}],[\"fsync间隔为\",{\"1\":{\"161\":1,\"231\":1}}],[\"fsync\",{\"1\":{\"161\":11,\"230\":6,\"231\":8,\"236\":1,\"268\":4}}],[\"fsync策略\",{\"1\":{\"161\":1,\"229\":1,\"231\":1,\"282\":1}}],[\"f5\",{\"1\":{\"1123\":1}}],[\"feigninvokeinterceptor\",{\"1\":{\"1046\":1}}],[\"feign\",{\"0\":{\"1046\":1},\"1\":{\"1167\":1}}],[\"fence\",{\"1\":{\"969\":2}}],[\"feature\",{\"1\":{\"293\":1,\"298\":1}}],[\"fn\",{\"1\":{\"779\":6,\"780\":6,\"781\":6}}],[\"fh\",{\"1\":{\"577\":4}}],[\"fgc\",{\"1\":{\"480\":1}}],[\"fpye1b839\",{\"1\":{\"320\":1}}],[\"f6cdb384\",{\"1\":{\"293\":2}}],[\"flag\",{\"1\":{\"331\":2,\"332\":2,\"367\":7,\"449\":1}}],[\"flags\",{\"0\":{\"329\":1},\"1\":{\"256\":7,\"325\":1,\"329\":1,\"331\":1}}],[\"float\",{\"1\":{\"328\":1,\"493\":1,\"570\":2,\"571\":1,\"619\":2,\"621\":5,\"624\":3,\"677\":2,\"709\":2}}],[\"flush\",{\"1\":{\"1313\":2}}],[\"flushdisktype\",{\"1\":{\"1313\":1}}],[\"flushdb\",{\"1\":{\"166\":1,\"266\":1}}],[\"flushall\",{\"1\":{\"166\":1,\"266\":1}}],[\"francisq\",{\"1\":{\"1267\":1,\"1303\":4,\"1366\":1}}],[\"framework<\",{\"1\":{\"1332\":1}}],[\"framework\",{\"1\":{\"777\":1,\"1022\":1,\"1130\":1}}],[\"fragmentation\",{\"1\":{\"219\":5}}],[\"fruit\",{\"1\":{\"732\":4,\"733\":2}}],[\"frequency\",{\"1\":{\"298\":1,\"697\":1,\"708\":1}}],[\"frequently\",{\"1\":{\"273\":2,\"298\":2}}],[\"freememory\",{\"1\":{\"451\":4}}],[\"freeing\",{\"1\":{\"268\":1}}],[\"free后台线程释放大对象\",{\"1\":{\"268\":1}}],[\"free\",{\"1\":{\"256\":2,\"268\":1,\"289\":3,\"294\":2,\"451\":5,\"490\":1,\"1014\":3}}],[\"fromindex\",{\"1\":{\"553\":3,\"634\":3}}],[\"fromplace\",{\"1\":{\"443\":1}}],[\"from\",{\"1\":{\"34\":2,\"81\":1,\"86\":2,\"117\":1,\"120\":3,\"125\":2,\"135\":1,\"141\":1,\"351\":1,\"369\":1,\"444\":1,\"480\":1,\"634\":5}}],[\"ft指的是要添加s个元素所需的最小的容量\",{\"1\":{\"621\":1}}],[\"ft=s\",{\"1\":{\"621\":1}}],[\"ft\",{\"1\":{\"210\":1,\"621\":3,\"624\":3}}],[\"functionalinterface\",{\"1\":{\"778\":2,\"779\":2,\"943\":2,\"1210\":1}}],[\"function<\",{\"1\":{\"630\":2,\"779\":3,\"781\":3}}],[\"function\",{\"1\":{\"618\":1,\"682\":1,\"779\":1}}],[\"functions\",{\"1\":{\"283\":2,\"1238\":2}}],[\"fully\",{\"1\":{\"871\":1}}],[\"fullfence\",{\"1\":{\"834\":1}}],[\"fullgc40\",{\"1\":{\"486\":1}}],[\"fullgc\",{\"1\":{\"450\":2,\"451\":1}}],[\"full\",{\"1\":{\"375\":2,\"380\":1,\"384\":1,\"387\":2,\"388\":2,\"444\":3,\"479\":1,\"480\":2,\"498\":1,\"533\":2,\"536\":1,\"1011\":1,\"1014\":1}}],[\"fulltext\",{\"1\":{\"120\":1}}],[\"future接口\",{\"1\":{\"900\":1}}],[\"futuretask相当于对callable\",{\"1\":{\"900\":1}}],[\"futuretask\",{\"1\":{\"900\":7,\"913\":1,\"934\":7,\"944\":2}}],[\"futures\",{\"1\":{\"782\":2}}],[\"future1\",{\"1\":{\"782\":6}}],[\"future2\",{\"1\":{\"778\":2,\"782\":7}}],[\"future<string>\",{\"1\":{\"944\":2}}],[\"future<\",{\"1\":{\"900\":1}}],[\"future<t>\",{\"1\":{\"774\":1,\"900\":1,\"901\":1}}],[\"future<v>\",{\"1\":{\"773\":1,\"899\":1}}],[\"future\",{\"0\":{\"773\":1,\"898\":1,\"899\":1,\"900\":1},\"1\":{\"49\":2,\"773\":6,\"774\":5,\"777\":3,\"778\":2,\"779\":8,\"780\":4,\"781\":2,\"785\":2,\"899\":6,\"900\":3,\"901\":3,\"934\":3,\"944\":3,\"1204\":2}}],[\"fowler\",{\"1\":{\"1178\":1}}],[\"follower跟随者\",{\"1\":{\"1378\":1}}],[\"followers\",{\"1\":{\"1356\":2,\"1379\":1}}],[\"follower\",{\"1\":{\"1108\":4,\"1109\":1,\"1110\":1,\"1111\":5,\"1112\":12,\"1114\":1,\"1115\":1,\"1197\":4,\"1206\":8,\"1355\":4,\"1356\":2,\"1361\":1,\"1378\":2,\"1379\":4,\"1380\":9}}],[\"follows\",{\"1\":{\"708\":1}}],[\"following\",{\"1\":{\"302\":1,\"1356\":1,\"1380\":2}}],[\"four\",{\"1\":{\"705\":2,\"706\":2}}],[\"found\",{\"1\":{\"11\":1,\"13\":2,\"24\":1,\"43\":1,\"45\":1,\"57\":1,\"59\":1,\"63\":1,\"65\":2,\"78\":1,\"147\":1,\"150\":2,\"153\":2,\"171\":1,\"196\":1,\"213\":1,\"221\":1,\"237\":1,\"240\":1,\"274\":1,\"277\":1,\"293\":4,\"320\":1,\"334\":1,\"345\":1,\"360\":1,\"370\":2,\"377\":1,\"409\":1,\"412\":1,\"472\":1,\"486\":1,\"489\":1,\"511\":1,\"545\":1,\"548\":1,\"564\":1,\"579\":1,\"593\":1,\"612\":1,\"615\":1,\"625\":1,\"634\":1,\"637\":1,\"672\":1,\"675\":1,\"698\":1,\"720\":1,\"723\":1,\"733\":1,\"736\":2,\"758\":1,\"769\":1,\"788\":1,\"801\":1,\"804\":1,\"827\":1,\"830\":1,\"876\":1,\"879\":1,\"913\":1,\"929\":1,\"964\":1,\"982\":1,\"996\":1,\"1022\":1,\"1048\":1,\"1079\":1,\"1092\":1,\"1100\":1,\"1117\":1,\"1147\":1,\"1161\":1,\"1174\":1,\"1185\":1,\"1214\":1,\"1241\":1,\"1264\":1,\"1316\":1,\"1338\":1,\"1363\":1,\"1391\":1}}],[\"fox\",{\"1\":{\"633\":1}}],[\"foo\",{\"1\":{\"206\":2}}],[\"forpath\",{\"1\":{\"1335\":8,\"1336\":2,\"1337\":3,\"1338\":1}}],[\"for循环一直碰到entry为null才会结束\",{\"1\":{\"1036\":1}}],[\"for循环执行完毕\",{\"1\":{\"1036\":1}}],[\"for循环迭代\",{\"1\":{\"1035\":1}}],[\"foreach\",{\"1\":{\"631\":2,\"634\":1,\"679\":1,\"1210\":1,\"1293\":1}}],[\"foreach获取map中所有的值\",{\"1\":{\"625\":1}}],[\"foreach获取map中所有的键\",{\"1\":{\"625\":1}}],[\"forname\",{\"1\":{\"344\":1,\"523\":1}}],[\"formatter\",{\"1\":{\"882\":27}}],[\"format=b\",{\"1\":{\"368\":1}}],[\"format\",{\"1\":{\"334\":1,\"1030\":1}}],[\"forces\",{\"1\":{\"302\":1}}],[\"forkjoinpool\",{\"1\":{\"779\":1}}],[\"fork\",{\"1\":{\"158\":1,\"162\":1,\"227\":1}}],[\"for\",{\"1\":{\"86\":1,\"293\":1,\"298\":1,\"351\":5,\"356\":2,\"364\":4,\"368\":1,\"370\":2,\"386\":3,\"391\":1,\"449\":2,\"480\":4,\"531\":1,\"534\":1,\"553\":9,\"561\":1,\"564\":3,\"571\":3,\"572\":6,\"573\":1,\"577\":3,\"592\":1,\"604\":1,\"619\":1,\"621\":1,\"622\":3,\"624\":1,\"625\":4,\"629\":1,\"631\":2,\"632\":3,\"634\":2,\"649\":1,\"663\":1,\"677\":1,\"683\":2,\"688\":3,\"704\":1,\"705\":1,\"706\":1,\"712\":1,\"713\":4,\"730\":2,\"731\":2,\"732\":3,\"748\":2,\"749\":1,\"752\":1,\"753\":3,\"756\":1,\"757\":2,\"765\":1,\"766\":1,\"807\":1,\"835\":2,\"882\":1,\"909\":1,\"911\":1,\"940\":1,\"941\":2,\"1001\":1,\"1011\":1,\"1012\":1,\"1013\":1,\"1014\":1,\"1015\":1,\"1020\":1,\"1030\":1,\"1036\":4,\"1037\":1,\"1038\":2,\"1042\":1,\"1062\":1,\"1084\":1,\"1141\":2,\"1142\":3,\"1209\":2,\"1290\":1}}],[\"fanout\",{\"1\":{\"1249\":2,\"1252\":5}}],[\"facebook\",{\"1\":{\"1171\":1}}],[\"factory\",{\"1\":{\"1060\":3,\"1132\":2,\"1211\":4}}],[\"factor\",{\"1\":{\"570\":3,\"618\":1,\"619\":1,\"621\":4,\"624\":1,\"677\":2,\"682\":1,\"1206\":4}}],[\"faq\",{\"1\":{\"982\":2}}],[\"fals\",{\"1\":{\"731\":1}}],[\"false\",{\"1\":{\"56\":1,\"342\":1,\"353\":1,\"357\":1,\"396\":2,\"531\":3,\"534\":1,\"536\":3,\"537\":2,\"538\":3,\"539\":2,\"553\":2,\"571\":1,\"577\":1,\"591\":1,\"592\":1,\"619\":1,\"621\":2,\"622\":1,\"664\":1,\"686\":2,\"705\":2,\"709\":4,\"712\":1,\"731\":2,\"748\":1,\"749\":1,\"752\":3,\"756\":4,\"767\":2,\"773\":1,\"807\":2,\"841\":1,\"857\":1,\"865\":1,\"871\":2,\"897\":1,\"899\":1,\"906\":1,\"911\":4,\"918\":1,\"928\":1,\"941\":10,\"990\":1,\"1007\":4,\"1011\":1,\"1012\":3,\"1013\":1,\"1014\":3,\"1015\":4,\"1030\":1,\"1042\":1,\"1062\":2,\"1141\":1,\"1142\":1,\"1184\":1,\"1206\":3,\"1207\":1,\"1210\":1,\"1256\":1}}],[\"faileddelivery\",{\"1\":{\"1210\":1}}],[\"failedrecord\",{\"1\":{\"1210\":5}}],[\"failedrecordtracker\",{\"1\":{\"1210\":1}}],[\"failed\",{\"1\":{\"780\":1,\"941\":1,\"1012\":3,\"1013\":3,\"1015\":3,\"1293\":2}}],[\"fail\",{\"1\":{\"631\":7,\"767\":2,\"1085\":4}}],[\"failures\",{\"1\":{\"1116\":1,\"1210\":7}}],[\"failure\",{\"1\":{\"388\":1,\"451\":1,\"1011\":1,\"1014\":1,\"1292\":1}}],[\"fairsync\",{\"1\":{\"747\":1,\"748\":2,\"857\":2,\"865\":1,\"905\":1,\"1002\":3,\"1018\":1}}],[\"fair\",{\"1\":{\"50\":1,\"534\":5,\"747\":2,\"857\":2,\"862\":1,\"865\":2,\"905\":2}}],[\"far\",{\"1\":{\"293\":2}}],[\"fastremove\",{\"1\":{\"553\":3}}],[\"fast\",{\"1\":{\"243\":2,\"553\":3,\"631\":5,\"1011\":1,\"1014\":1,\"1097\":2}}],[\"fa5e\",{\"1\":{\"37\":1}}],[\"f\",{\"1\":{\"23\":2,\"446\":2,\"571\":3,\"577\":10,\"730\":3,\"731\":3,\"782\":2}}],[\"fixedbackoff\",{\"1\":{\"1210\":2,\"1211\":7,\"1212\":1}}],[\"fixedthreadpool的源码可以看出创建的\",{\"1\":{\"951\":1}}],[\"fixedthreadpool的execute\",{\"1\":{\"950\":1}}],[\"fixedthreadpool最多只能创建核心线程数的线程\",{\"1\":{\"892\":1,\"938\":1}}],[\"fixedthreadpool\",{\"0\":{\"948\":1,\"951\":1},\"1\":{\"888\":1,\"889\":1,\"892\":1,\"917\":1,\"937\":2,\"938\":1,\"949\":3,\"950\":1,\"951\":3,\"953\":1,\"955\":2}}],[\"fixed\",{\"1\":{\"798\":1}}],[\"five\",{\"1\":{\"705\":2}}],[\"firstweight\",{\"1\":{\"1142\":3}}],[\"firsttask\",{\"1\":{\"941\":7}}],[\"firstvalue\",{\"1\":{\"883\":1,\"1031\":2,\"1032\":2}}],[\"firstkey\",{\"1\":{\"883\":1,\"1032\":3}}],[\"first\",{\"1\":{\"407\":2,\"571\":10,\"604\":7,\"623\":9,\"680\":1,\"688\":1,\"712\":5,\"729\":2,\"730\":2,\"731\":5,\"1011\":1}}],[\"firstnettydemo\",{\"1\":{\"365\":2}}],[\"fifo\",{\"1\":{\"280\":1,\"665\":2,\"667\":1,\"742\":1,\"747\":1,\"798\":1,\"905\":1,\"1004\":2,\"1016\":1,\"1069\":1,\"1286\":1}}],[\"fieldref\",{\"1\":{\"328\":1}}],[\"fields\",{\"0\":{\"331\":1},\"1\":{\"293\":1,\"325\":3,\"331\":3,\"621\":1,\"1011\":1}}],[\"field2\",{\"1\":{\"185\":3}}],[\"field1\",{\"1\":{\"185\":3}}],[\"field\",{\"1\":{\"184\":1,\"185\":6,\"195\":1,\"257\":4,\"286\":1,\"325\":1,\"331\":3,\"1030\":7}}],[\"finished\",{\"1\":{\"824\":1,\"940\":2}}],[\"finish\",{\"1\":{\"749\":1,\"753\":2,\"756\":1,\"757\":22,\"909\":1,\"911\":1}}],[\"find查找\",{\"1\":{\"578\":1}}],[\"findbootstrapclassornull\",{\"1\":{\"357\":1}}],[\"findloadedclass\",{\"1\":{\"357\":1}}],[\"findclass\",{\"1\":{\"354\":4,\"357\":2,\"359\":1}}],[\"findstaticvarhandle\",{\"1\":{\"344\":1}}],[\"find\",{\"1\":{\"293\":1,\"298\":1,\"356\":2,\"570\":1,\"578\":1}}],[\"finance\",{\"1\":{\"135\":1}}],[\"final修饰类\",{\"1\":{\"521\":1}}],[\"final修饰方法\",{\"1\":{\"521\":1}}],[\"final修饰变量\",{\"1\":{\"521\":1}}],[\"final修饰的静态常量\",{\"1\":{\"520\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"889\":1,\"937\":1,\"953\":2}}],[\"finalization\",{\"1\":{\"391\":1}}],[\"finalize\",{\"1\":{\"391\":6,\"446\":9,\"483\":1,\"807\":1}}],[\"finalizer\",{\"1\":{\"368\":1,\"807\":1}}],[\"final\",{\"1\":{\"56\":4,\"77\":1,\"328\":1,\"329\":1,\"331\":1,\"342\":2,\"344\":1,\"351\":1,\"352\":2,\"353\":2,\"356\":1,\"521\":5,\"534\":1,\"535\":4,\"536\":4,\"537\":2,\"538\":3,\"553\":5,\"555\":2,\"558\":1,\"564\":2,\"570\":3,\"571\":2,\"576\":1,\"577\":1,\"588\":1,\"589\":1,\"591\":1,\"601\":3,\"603\":1,\"604\":2,\"605\":1,\"618\":1,\"619\":18,\"621\":1,\"622\":1,\"623\":1,\"624\":1,\"629\":1,\"634\":3,\"677\":1,\"680\":1,\"682\":1,\"683\":1,\"686\":2,\"688\":4,\"693\":1,\"706\":1,\"708\":1,\"711\":1,\"712\":1,\"713\":6,\"729\":4,\"730\":2,\"731\":5,\"742\":4,\"744\":1,\"747\":1,\"748\":7,\"749\":3,\"752\":3,\"753\":3,\"756\":4,\"757\":6,\"763\":6,\"765\":2,\"766\":6,\"767\":16,\"841\":3,\"882\":2,\"894\":4,\"896\":1,\"904\":4,\"905\":1,\"906\":2,\"909\":3,\"911\":4,\"920\":4,\"923\":1,\"940\":4,\"941\":6,\"990\":3,\"1002\":4,\"1006\":4,\"1007\":2,\"1008\":3,\"1011\":3,\"1012\":5,\"1013\":3,\"1014\":3,\"1015\":4,\"1028\":1,\"1032\":2,\"1141\":1,\"1142\":2,\"1210\":2,\"1333\":2}}],[\"finally\",{\"0\":{\"472\":1},\"1\":{\"53\":1,\"534\":1,\"535\":2,\"536\":3,\"537\":2,\"538\":1,\"571\":1,\"576\":1,\"588\":2,\"591\":1,\"603\":1,\"604\":3,\"605\":1,\"753\":1,\"756\":2,\"782\":2,\"835\":1,\"837\":1,\"861\":1,\"909\":1,\"911\":2,\"941\":2,\"986\":1,\"1001\":2,\"1012\":1,\"1013\":2,\"1015\":1,\"1020\":1,\"1047\":1}}],[\"fintopia\",{\"1\":{\"11\":1}}],[\"fill\",{\"1\":{\"697\":1}}],[\"filename\",{\"1\":{\"1315\":1}}],[\"filechannel\",{\"1\":{\"1310\":5,\"1311\":2}}],[\"filepath\",{\"1\":{\"909\":2}}],[\"filepaths\",{\"1\":{\"909\":2}}],[\"filefutures\",{\"1\":{\"909\":3}}],[\"filed\",{\"1\":{\"523\":1}}],[\"file=c\",{\"1\":{\"368\":1}}],[\"file\",{\"1\":{\"11\":1,\"13\":2,\"24\":1,\"35\":1,\"43\":1,\"45\":1,\"57\":1,\"59\":1,\"63\":1,\"65\":2,\"78\":1,\"147\":1,\"150\":2,\"153\":2,\"171\":1,\"196\":1,\"213\":1,\"221\":1,\"224\":1,\"229\":1,\"237\":1,\"240\":1,\"265\":5,\"268\":2,\"274\":1,\"277\":1,\"282\":1,\"320\":1,\"334\":2,\"345\":1,\"351\":3,\"360\":1,\"368\":1,\"369\":1,\"377\":1,\"409\":1,\"412\":1,\"472\":1,\"486\":1,\"489\":1,\"511\":1,\"545\":1,\"548\":1,\"564\":1,\"579\":1,\"593\":1,\"612\":1,\"615\":1,\"625\":1,\"634\":1,\"637\":1,\"672\":1,\"675\":1,\"698\":1,\"720\":1,\"723\":1,\"733\":1,\"736\":2,\"758\":1,\"769\":1,\"788\":1,\"801\":1,\"804\":1,\"827\":1,\"830\":1,\"876\":1,\"879\":1,\"913\":1,\"929\":1,\"964\":1,\"982\":1,\"996\":1,\"1022\":1,\"1048\":1,\"1079\":1,\"1092\":1,\"1100\":1,\"1117\":1,\"1147\":1,\"1161\":1,\"1174\":1,\"1185\":1,\"1214\":1,\"1241\":1,\"1264\":1,\"1315\":1,\"1316\":1,\"1338\":1,\"1363\":1,\"1391\":1}}],[\"filterexpressiontype\",{\"1\":{\"1293\":1}}],[\"filterexpression\",{\"1\":{\"1293\":4}}],[\"filtered\",{\"1\":{\"120\":1}}],[\"filters\",{\"1\":{\"69\":2,\"74\":1,\"75\":1}}],[\"filter\",{\"1\":{\"5\":1,\"68\":1,\"69\":2,\"73\":2,\"78\":2,\"253\":1,\"523\":1,\"631\":2}}],[\"参与者收到中断请求后则会\",{\"1\":{\"1371\":1}}],[\"参与者收到中断请求之后会立即中断事务\",{\"1\":{\"1371\":1}}],[\"参与者收到\",{\"1\":{\"1371\":1}}],[\"参与者收到预提交请求后\",{\"1\":{\"1371\":1}}],[\"参与者收到请求后会根据自身情况查看是否能执行事务\",{\"1\":{\"1371\":1}}],[\"参与者收到之后如果能处理那么它将会进行事务的处理但并不提交\",{\"1\":{\"1370\":1}}],[\"参与者收到之后将会\",{\"1\":{\"1370\":1}}],[\"参与选举过程中的投票\",{\"1\":{\"1355\":1}}],[\"参与消息传递的双方称为\",{\"1\":{\"1218\":1}}],[\"参与秒杀的商品\",{\"1\":{\"296\":1}}],[\"参见\",{\"1\":{\"359\":1,\"386\":1,\"393\":1,\"480\":1,\"495\":1,\"687\":1,\"708\":1,\"762\":1,\"895\":1,\"922\":1,\"968\":1,\"1007\":1,\"1069\":1}}],[\"参数等组装成能够进行网络传输的消息体\",{\"1\":{\"1166\":1}}],[\"参数是我们使用的时候自己传递的\",{\"1\":{\"949\":1}}],[\"参数是被复制的数组和复制的长度\",{\"1\":{\"553\":1}}],[\"参数可以传入任务队列\",{\"1\":{\"897\":1}}],[\"参数可以调整\",{\"1\":{\"449\":2,\"451\":2}}],[\"参数指定按照访问顺序迭代元素\",{\"1\":{\"717\":1}}],[\"参数不能为空\",{\"1\":{\"634\":1}}],[\"参数里的\",{\"1\":{\"572\":1}}],[\"参数配置说明\",{\"1\":{\"486\":1}}],[\"参数配置\",{\"1\":{\"476\":1}}],[\"参数名称\",{\"1\":{\"449\":1}}],[\"参数的默认值由原来的\",{\"1\":{\"1206\":1}}],[\"参数的时间单位\",{\"1\":{\"890\":1,\"936\":1}}],[\"参数的问题\",{\"1\":{\"444\":1}}],[\"参数的设置值是否允许担保失败\",{\"1\":{\"388\":1}}],[\"参数总结\",{\"1\":{\"412\":1}}],[\"参数来设置\",{\"1\":{\"498\":1}}],[\"参数来根据生成对象的速率动态调整\",{\"1\":{\"443\":1}}],[\"参数来关闭大部分的类验证措施\",{\"1\":{\"341\":1}}],[\"参数来查找\",{\"1\":{\"293\":1,\"298\":1}}],[\"参数命令也会增加\",{\"1\":{\"298\":1}}],[\"参数设置耗时命令的最大记录条数\",{\"1\":{\"302\":1}}],[\"参数设置耗时命令的阈值\",{\"1\":{\"302\":1}}],[\"参数设置为\",{\"1\":{\"298\":1,\"1207\":1}}],[\"参数设置的阈值\",{\"1\":{\"385\":1}}],[\"参数设置的堆区域大小和\",{\"1\":{\"385\":1}}],[\"参数设置的\",{\"1\":{\"229\":1}}],[\"参数\",{\"1\":{\"298\":1,\"365\":1,\"368\":1,\"403\":1,\"480\":1,\"485\":2,\"534\":1,\"1252\":1}}],[\"参数控制扫描的频率\",{\"1\":{\"293\":1}}],[\"参数开启\",{\"1\":{\"229\":1}}],[\"参数查找大\",{\"1\":{\"164\":1}}],[\"参数校验等等\",{\"1\":{\"69\":1}}],[\"参数校验\",{\"1\":{\"1\":1,\"2\":1,\"570\":1}}],[\"参考了美团技术团队的高性能队列\",{\"1\":{\"1184\":1}}],[\"参考了多方的资料\",{\"1\":{\"472\":1}}],[\"参考资料\",{\"0\":{\"1022\":1},\"1\":{\"1172\":1}}],[\"参考java\",{\"1\":{\"838\":1,\"987\":1}}],[\"参考这篇文章\",{\"1\":{\"788\":1}}],[\"参考文献\",{\"0\":{\"545\":1,\"612\":1,\"720\":1}}],[\"参考文章\",{\"1\":{\"90\":1,\"120\":1,\"141\":1}}],[\"参考答案\",{\"1\":{\"303\":1,\"318\":1}}],[\"参考图1\",{\"1\":{\"141\":1}}],[\"参考维基百科对于\",{\"1\":{\"37\":1}}],[\"参考\",{\"0\":{\"11\":1,\"78\":1,\"171\":1,\"196\":1,\"213\":1,\"221\":1,\"237\":1,\"274\":1,\"320\":1,\"334\":1,\"409\":1,\"511\":1,\"758\":1,\"769\":1,\"801\":1,\"876\":1,\"913\":1,\"964\":1,\"982\":1,\"996\":1,\"1092\":1,\"1100\":1,\"1117\":1,\"1185\":1,\"1214\":1,\"1241\":1,\"1363\":1},\"1\":{\"345\":1,\"391\":1,\"522\":1,\"1140\":1,\"1240\":1}}],[\"存取高效\",{\"1\":{\"684\":1}}],[\"存取是线程安全的\",{\"1\":{\"601\":1}}],[\"存不下\",{\"1\":{\"444\":1}}],[\"存活下来的对象移动到\",{\"1\":{\"444\":1}}],[\"存入队列中\",{\"1\":{\"316\":1}}],[\"存放消息的容器称为\",{\"1\":{\"1279\":1}}],[\"存放在消息队列中的消息并不一定会立即被处理\",{\"1\":{\"1232\":1}}],[\"存放在数据库的话\",{\"1\":{\"30\":1}}],[\"存放线程池中所有的\",{\"1\":{\"941\":1}}],[\"存放线程池的运行状态\",{\"1\":{\"941\":1}}],[\"存放数据的\",{\"1\":{\"883\":1}}],[\"存放元素到hashmap中时用来与其他元素hash值比较\",{\"1\":{\"619\":1}}],[\"存放元素的个数\",{\"1\":{\"619\":1}}],[\"存放具体元素的集\",{\"1\":{\"619\":1}}],[\"存放具体属性具体内容\",{\"1\":{\"331\":1}}],[\"存放属性的个数\",{\"1\":{\"331\":1}}],[\"存放一份到\",{\"1\":{\"299\":1}}],[\"存放的数据会很分散\",{\"1\":{\"619\":1}}],[\"存放的数据不能重复的场景\",{\"1\":{\"259\":1}}],[\"存放的是整个对象\",{\"1\":{\"255\":1}}],[\"存起来的\",{\"1\":{\"89\":1}}],[\"存在持续自旋的风险\",{\"1\":{\"1183\":1}}],[\"存在某种排队等候机制\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"存在的一系列问题\",{\"1\":{\"1371\":1}}],[\"存在的一些\",{\"1\":{\"1143\":1}}],[\"存在的其中一个原因\",{\"1\":{\"971\":1}}],[\"存在的话才会走下面的流程\",{\"1\":{\"307\":1}}],[\"存在其他线程修改的情况\",{\"1\":{\"693\":1}}],[\"存在两种情况\",{\"1\":{\"693\":1}}],[\"存在阻塞时\",{\"1\":{\"687\":1}}],[\"存在\",{\"1\":{\"571\":1}}],[\"存在于数据库中\",{\"1\":{\"309\":1,\"311\":1}}],[\"存在read\",{\"1\":{\"285\":1}}],[\"存在一个线程操作该\",{\"1\":{\"693\":1}}],[\"存在一定的误差\",{\"1\":{\"205\":1,\"212\":1}}],[\"存在一些缺陷\",{\"1\":{\"178\":1}}],[\"存在缓存中\",{\"1\":{\"85\":1}}],[\"存在数据库单点问题\",{\"1\":{\"33\":1,\"34\":1}}],[\"存在单点风险问题\",{\"1\":{\"1083\":1}}],[\"存在单点风险\",{\"1\":{\"10\":1}}],[\"存储机制\",{\"0\":{\"1315\":1}}],[\"存储和转发消息\",{\"1\":{\"1247\":1}}],[\"存储和计算最佳解决方案\",{\"1\":{\"1238\":1}}],[\"存储了\",{\"1\":{\"900\":1}}],[\"存储键值对\",{\"1\":{\"678\":1}}],[\"存储的数据类型多种多样且数量不确定\",{\"1\":{\"647\":1}}],[\"存储的元素不可重复的\",{\"1\":{\"640\":1}}],[\"存储的元素是有序的\",{\"1\":{\"640\":2}}],[\"存储的是序列化后的对象数据\",{\"1\":{\"255\":1}}],[\"存储的是\",{\"1\":{\"242\":1}}],[\"存储的是连续的二进制数字\",{\"1\":{\"201\":1,\"261\":1}}],[\"存储元素的数组\",{\"1\":{\"619\":1}}],[\"存储结构\",{\"0\":{\"569\":1,\"575\":1},\"1\":{\"569\":1,\"575\":1,\"688\":2,\"690\":1,\"691\":1}}],[\"存储更好呢\",{\"0\":{\"257\":1}}],[\"存储更节省内存\",{\"1\":{\"178\":1}}],[\"存储具有多层嵌套的对象时也方便很多\",{\"1\":{\"255\":1}}],[\"存储相对来说更加节省内存\",{\"1\":{\"255\":1}}],[\"存储对象数据更好呢\",{\"0\":{\"255\":1}}],[\"存储对象信息是用\",{\"1\":{\"196\":1}}],[\"存储实际大小\",{\"1\":{\"219\":1}}],[\"存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间\",{\"1\":{\"218\":1}}],[\"存储\",{\"1\":{\"94\":1,\"257\":1,\"550\":2,\"640\":1,\"650\":2,\"972\":1,\"1238\":1,\"1315\":1,\"1362\":1}}],[\"存储引擎层则负责数据的存储和提取\",{\"1\":{\"83\":1}}],[\"存储引擎层\",{\"0\":{\"83\":1}}],[\"存储引擎\",{\"1\":{\"81\":1}}],[\"存储消耗空间大\",{\"1\":{\"37\":1}}],[\"存储消耗空间小\",{\"1\":{\"33\":1,\"34\":1}}],[\"存储系统\",{\"1\":{\"8\":1}}],[\"存储数据库\",{\"1\":{\"244\":1}}],[\"存储数据的结构\",{\"1\":{\"96\":1}}],[\"存储数据\",{\"1\":{\"7\":1}}],[\"而三个比四个还少一个\",{\"1\":{\"1380\":1}}],[\"而假设我们现在有四个\",{\"1\":{\"1380\":1}}],[\"而低\",{\"1\":{\"1379\":1}}],[\"而后面没收到的则不会进行事务提交\",{\"1\":{\"1370\":1}}],[\"而为什么要去解决数据一致性的问题\",{\"1\":{\"1369\":1}}],[\"而为了解决数据一致性问题\",{\"1\":{\"1369\":1}}],[\"而为了节省栈帧空间\",{\"1\":{\"442\":1}}],[\"而上述前者就是\",{\"1\":{\"1368\":1}}],[\"而如果\",{\"1\":{\"1374\":1}}],[\"而如果在第一阶段并不是所有参与者都返回了准备好了的消息\",{\"1\":{\"1370\":1}}],[\"而如果他直接不回答你\",{\"1\":{\"1368\":1}}],[\"而如果空间不足会再申请多块内存空间\",{\"1\":{\"444\":1}}],[\"而学生是系统中的一个个独立的子系统\",{\"1\":{\"1368\":1}}],[\"而选出自己的\",{\"1\":{\"1358\":1}}],[\"而集群被割裂成几个小集群\",{\"1\":{\"1358\":1}}],[\"而根据生产者指定的\",{\"1\":{\"1315\":1}}],[\"而当会话终结时\",{\"1\":{\"1362\":1}}],[\"而当主节点重启之后\",{\"1\":{\"1314\":1}}],[\"而当前帐户余额字段\",{\"1\":{\"840\":1,\"989\":1}}],[\"而同步复制和异步复制主要是指的\",{\"1\":{\"1314\":1}}],[\"而异步刷盘往往是开启一个线程去异步地执行刷盘操作\",{\"1\":{\"1313\":1}}],[\"而短信系统\",{\"1\":{\"1273\":1}}],[\"而短信系统这玩意又不是很有必要\",{\"1\":{\"1271\":1}}],[\"而我为什么反驳同学所说的分布式就是加机器呢\",{\"1\":{\"1367\":1}}],[\"而我现在因为同步调用\",{\"1\":{\"1271\":1}}],[\"而我现在通过同步调用非要让整个请求拉长时间\",{\"1\":{\"1271\":1}}],[\"而我们如何通过\",{\"1\":{\"1381\":1}}],[\"而我们的\",{\"1\":{\"1202\":1}}],[\"而我们自定义的类加载器的实例是可以被回收的\",{\"1\":{\"345\":1}}],[\"而分布式怕是一个很古老的概念了吧\",{\"1\":{\"1269\":1}}],[\"而分布式系统的代码根据业务被拆分\",{\"1\":{\"1126\":1}}],[\"而相对应的队列逻辑只是\",{\"1\":{\"1250\":1}}],[\"而消费者拉取消息进行消费的时候只需要根据\",{\"1\":{\"1315\":1}}],[\"而消费者线程会从队列中取出数据进行处理\",{\"1\":{\"670\":1}}],[\"而消息头则由一系列的可选属性组成\",{\"1\":{\"1248\":1}}],[\"而各个\",{\"1\":{\"1197\":1,\"1199\":1}}],[\"而各线程则不一定\",{\"1\":{\"810\":1}}],[\"而加锁的的队列势必会影响性能\",{\"1\":{\"1179\":1}}],[\"而内部集群的微服务之间则采用\",{\"1\":{\"1161\":1}}],[\"而像异步同步复制策略仅仅是影响到了\",{\"1\":{\"1314\":1}}],[\"而像\",{\"1\":{\"1161\":1}}],[\"而数字本身也能直接转为二进制\",{\"1\":{\"1159\":1}}],[\"而数据行保存在其他位置\",{\"1\":{\"107\":1}}],[\"而建立连接的前提是\",{\"1\":{\"1157\":1}}],[\"而直接使用裸\",{\"1\":{\"1155\":1}}],[\"而已\",{\"1\":{\"1154\":1,\"1262\":1}}],[\"而基于\",{\"1\":{\"1154\":1}}],[\"而今天我们需要关注的是\",{\"1\":{\"1152\":1}}],[\"而谣言传播\",{\"1\":{\"1089\":1}}],[\"而inheritablethreadlocal是在new\",{\"1\":{\"1043\":1}}],[\"而index\",{\"1\":{\"1040\":1}}],[\"而index=4的槽位已经有了数据\",{\"1\":{\"1040\":1}}],[\"而启发式清理被作者定义为\",{\"1\":{\"1042\":1}}],[\"而此时\",{\"1\":{\"1380\":1}}],[\"而此时你的银行卡只有\",{\"1\":{\"124\":1}}],[\"而此位置已经有了数据\",{\"1\":{\"1037\":1}}],[\"而槽位\",{\"1\":{\"1033\":1}}],[\"而没有对\",{\"1\":{\"1013\":1}}],[\"而另外一个线程还继续使用它在寄存器中的变量值的拷贝\",{\"1\":{\"972\":1}}],[\"而正确结果应该是\",{\"1\":{\"968\":1}}],[\"而使用\",{\"1\":{\"944\":1}}],[\"而子任务等待父任务释放线程池资源\",{\"1\":{\"919\":1}}],[\"而一个\",{\"1\":{\"895\":1,\"922\":1}}],[\"而threadlocalmap中并没有链表结构\",{\"1\":{\"1029\":1}}],[\"而threadlocalmap可以存储以threadlocal为\",{\"1\":{\"883\":1}}],[\"而take\",{\"1\":{\"535\":1}}],[\"而双方都不释放\",{\"1\":{\"869\":1}}],[\"而写锁最多只能同时被一个线程持有\",{\"1\":{\"865\":1}}],[\"而访问非静态\",{\"1\":{\"848\":1}}],[\"而线程池是线程复用的逻辑\",{\"1\":{\"1043\":1}}],[\"而线程在处理\",{\"1\":{\"895\":1,\"922\":1}}],[\"而线程\",{\"1\":{\"848\":1}}],[\"而操作系统实现线程之间的切换时需要从用户态转换到内核态\",{\"1\":{\"847\":1}}],[\"而操作系统可以帮我们完成和硬件进行交互的工作\",{\"1\":{\"417\":1}}],[\"而创建多个线程\",{\"1\":{\"816\":1}}],[\"而多线程并发编程正是开发高并发系统的基础\",{\"1\":{\"816\":1}}],[\"而多线程下无法容忍\",{\"1\":{\"693\":1}}],[\"而进程正相反\",{\"1\":{\"810\":1}}],[\"而跳表内所有的元素都是排序的\",{\"1\":{\"800\":1}}],[\"而就查询的性能而言\",{\"1\":{\"800\":1}}],[\"而对于前面已经批准过该提案的\",{\"1\":{\"1374\":1}}],[\"而对于分布式来说\",{\"1\":{\"1367\":1}}],[\"而对于短信系统来说并不是我们的主要业务\",{\"1\":{\"1273\":1}}],[\"而对于跳表\",{\"1\":{\"800\":1}}],[\"而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可\",{\"1\":{\"800\":1}}],[\"而对象头部分正好是\",{\"1\":{\"507\":1}}],[\"而synchronized只能是非公平锁\",{\"1\":{\"862\":1}}],[\"而synchronized关键字就相当于整个\",{\"1\":{\"544\":1,\"862\":1}}],[\"而semaphore\",{\"1\":{\"747\":1,\"905\":1}}],[\"而这里面就有\",{\"1\":{\"1155\":1}}],[\"而这里头提到的\",{\"1\":{\"1152\":1}}],[\"而这个\",{\"1\":{\"1012\":1,\"1249\":1}}],[\"而这些内容只能是二进制\",{\"1\":{\"1159\":1}}],[\"而这些处理方式均依赖于第五层的基础数据提供层\",{\"1\":{\"1003\":1}}],[\"而这些问题的答案\",{\"1\":{\"1002\":1}}],[\"而这些模板方法会调用使用者重写的方法\",{\"1\":{\"744\":1}}],[\"而这种修改还没有提交到数据库中\",{\"1\":{\"127\":1}}],[\"而linkedlist\",{\"1\":{\"668\":1}}],[\"而linkedblockingqueue\",{\"1\":{\"542\":1,\"672\":1}}],[\"而array创建时必须指定大小\",{\"1\":{\"649\":1}}],[\"而arraylist的扩容机制避免了这种情况\",{\"1\":{\"553\":1}}],[\"而java\",{\"1\":{\"631\":1}}],[\"而扩容这个过程涉及到\",{\"1\":{\"619\":1}}],[\"而其他那些优先级低的任务只能无限期等待\",{\"1\":{\"601\":1}}],[\"而其他调用者所见到的最初的资源仍然保持不变\",{\"1\":{\"585\":1}}],[\"而其中某个\",{\"1\":{\"296\":1}}],[\"而每个消费者组在每个队列中的消费位置都是不同的\",{\"1\":{\"1280\":1}}],[\"而每个栈帧中都拥有\",{\"1\":{\"493\":1}}],[\"而每一个\",{\"1\":{\"569\":1}}],[\"而condition实例的signalall\",{\"1\":{\"544\":1,\"862\":1}}],[\"而最核心的构造方法就是下方这一个\",{\"1\":{\"534\":1}}],[\"而由泛型附加的类型信息对\",{\"1\":{\"522\":1}}],[\"而由系统的实际可用空间来控制\",{\"1\":{\"496\":1}}],[\"而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息\",{\"1\":{\"509\":1}}],[\"而元空间使用的是本地内存\",{\"1\":{\"496\":1}}],[\"而本地方法栈则为虚拟机使用到的\",{\"1\":{\"494\":1,\"812\":1}}],[\"而做出的改变\",{\"1\":{\"443\":1}}],[\"而虚拟机堆负责存储数据\",{\"1\":{\"437\":1}}],[\"而有些数据量大\",{\"1\":{\"412\":1}}],[\"而垃圾收集器运行在另一个\",{\"1\":{\"402\":1}}],[\"而老年代的对象存活几率是比较高的\",{\"1\":{\"399\":1}}],[\"而并不是和对象一样不使用了就会必然被回收\",{\"1\":{\"394\":1}}],[\"而要判定一个类是否是\",{\"1\":{\"394\":1}}],[\"而要想使用这\",{\"1\":{\"344\":1}}],[\"而在每个队列中都保存了\",{\"1\":{\"1315\":1}}],[\"而在整个互联网领域\",{\"1\":{\"1303\":1}}],[\"而在当前的\",{\"1\":{\"972\":1}}],[\"而在这种情况下多出来的一个线程就可以充分利用\",{\"1\":{\"895\":1,\"922\":1}}],[\"而在hashmap的putval\",{\"1\":{\"680\":1}}],[\"而在\",{\"1\":{\"342\":1,\"820\":1,\"1304\":1,\"1314\":1,\"1315\":1}}],[\"而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的\",{\"1\":{\"141\":1}}],[\"而该方法不存在时\",{\"1\":{\"341\":1}}],[\"而该对象不再包含该字段时\",{\"1\":{\"341\":1}}],[\"而字段叫什么名字\",{\"1\":{\"331\":1}}],[\"而字符空间有\",{\"1\":{\"19\":1}}],[\"而符号引用则属于编译原理方面的概念\",{\"1\":{\"328\":1}}],[\"而删除缓存这一步失败的情况的话\",{\"1\":{\"316\":1}}],[\"而你存储数据实际只需要使用\",{\"1\":{\"217\":1}}],[\"而事务99满足99\",{\"1\":{\"141\":1}}],[\"而查到对应的数据\",{\"1\":{\"109\":1}}],[\"而不同服务之间又需要进行调用\",{\"1\":{\"1304\":1}}],[\"而不需要再次访问内存\",{\"1\":{\"1184\":1}}],[\"而不需要实时保证系统数据的强一致性\",{\"1\":{\"1078\":1}}],[\"而不会产生一致性问题\",{\"1\":{\"1106\":1}}],[\"而不占用太多的\",{\"1\":{\"819\":1}}],[\"而不依赖于操作系统\",{\"1\":{\"808\":1}}],[\"而不是用来存储业务数据的\",{\"1\":{\"1348\":1}}],[\"而不是每个消费者都收到所有的消息并处理\",{\"1\":{\"1250\":1}}],[\"而不是被永久性地丢弃\",{\"1\":{\"1213\":1}}],[\"而不是永远放弃一致性\",{\"1\":{\"1074\":1}}],[\"而不是直接在主存中进行读写\",{\"1\":{\"972\":1}}],[\"而不是线程池中的线程执行\",{\"1\":{\"891\":1}}],[\"而不是对立的存在\",{\"1\":{\"855\":1}}],[\"而不是让异常处理过于冗长或重复\",{\"1\":{\"786\":1}}],[\"而不是让异常影响正常的业务逻辑\",{\"1\":{\"786\":1}}],[\"而不是让异常被忽略或终止\",{\"1\":{\"786\":1}}],[\"而不是让异常被吞噬或丢失\",{\"1\":{\"786\":1}}],[\"而不是预期的\",{\"1\":{\"694\":1}}],[\"而不是基于随机的概率\",{\"1\":{\"1087\":1}}],[\"而不是基于线程的同步\",{\"1\":{\"485\":1}}],[\"而不是基本类型\",{\"1\":{\"634\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"616\":1,\"645\":1,\"677\":1,\"683\":2}}],[\"而不是虚拟机\",{\"1\":{\"499\":1}}],[\"而不是你写的\",{\"1\":{\"358\":1}}],[\"而不是\",{\"1\":{\"342\":1,\"629\":1,\"631\":1,\"1052\":1}}],[\"而不包括实例变量\",{\"1\":{\"342\":1}}],[\"而不使用地址值作为指针\",{\"1\":{\"108\":1}}],[\"而不保存数据\",{\"1\":{\"106\":1}}],[\"而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新\",{\"1\":{\"72\":1}}],[\"而是专门定制了一致性协议叫做\",{\"1\":{\"1377\":1}}],[\"而是引入了\",{\"1\":{\"1355\":1}}],[\"而是应该每个消息中间件都需要去解决的\",{\"1\":{\"1298\":1}}],[\"而是接下来的系统作为消费者去\",{\"1\":{\"1272\":1}}],[\"而是大量的数据会直接搞丢\",{\"1\":{\"1264\":1}}],[\"而是等待特定时间后\",{\"1\":{\"1257\":1}}],[\"而是等待下一个任务\",{\"1\":{\"886\":1}}],[\"而是个远端服务器暴露出来的一个方法remotefunc\",{\"1\":{\"1154\":1}}],[\"而是一种调用方式\",{\"1\":{\"1161\":1}}],[\"而是一种\",{\"1\":{\"1154\":1}}],[\"而是对\",{\"1\":{\"1131\":1}}],[\"而是需要可以的设计一个闭环\",{\"1\":{\"1087\":1}}],[\"而是它的一个弱引用\",{\"1\":{\"1029\":1}}],[\"而是调用了无参构造函数的节点\",{\"1\":{\"1011\":1}}],[\"而是将消息路由到所有绑定到该交换器的队列中\",{\"1\":{\"1249\":1}}],[\"而是将任务回退给调用者\",{\"1\":{\"891\":1}}],[\"而是将它们放到队列\",{\"1\":{\"280\":1}}],[\"而是会将定时消息单独存储在定时存储系统中\",{\"1\":{\"1285\":1}}],[\"而是会按照延迟的时间长短对任务进行排序\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"而是会等待\",{\"1\":{\"890\":1,\"936\":1}}],[\"而是会先创建底层数组的副本\",{\"1\":{\"585\":1,\"793\":1}}],[\"而是会先存到boffer\",{\"1\":{\"136\":1}}],[\"而是基于\",{\"1\":{\"871\":1,\"874\":1}}],[\"而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务\",{\"1\":{\"1390\":1}}],[\"而是直接将文件的数据传输到\",{\"1\":{\"1311\":1}}],[\"而是直接继承\",{\"1\":{\"711\":1,\"712\":1}}],[\"而是直接用\",{\"1\":{\"688\":1,\"792\":1}}],[\"而是直接返回\",{\"1\":{\"536\":1}}],[\"而是根据发送的消息内容中的\",{\"1\":{\"1252\":1}}],[\"而是根据数据的哈希值决定的\",{\"1\":{\"664\":1}}],[\"而是根据需要去动态加载\",{\"1\":{\"352\":1}}],[\"而是数组对象本身\",{\"1\":{\"634\":1}}],[\"而是说队列的大小默认为\",{\"1\":{\"529\":1}}],[\"而是委派给父类去完成\",{\"1\":{\"433\":1}}],[\"而是否能够运行则由\",{\"1\":{\"426\":1}}],[\"而是让所有存活的对象向一端移动\",{\"1\":{\"398\":1}}],[\"而是由虚拟机根据当前的堆内存情况和历史数据动态决定\",{\"1\":{\"385\":1}}],[\"而是用当前线程的上下文类加载器\",{\"1\":{\"359\":1}}],[\"而是每个类加载器加载自己的话就会出现一些问题\",{\"1\":{\"358\":1}}],[\"而是把这个请求委派给父类加载器去完成\",{\"1\":{\"357\":1,\"359\":1}}],[\"而是通过\",{\"1\":{\"499\":1,\"889\":1,\"937\":1}}],[\"而是通过一定的概率统计方法预估基数值\",{\"1\":{\"205\":1}}],[\"而是通常使用组合关系来复用父加载器的代码\",{\"1\":{\"356\":1}}],[\"而是\",{\"1\":{\"340\":1,\"351\":1,\"575\":1,\"634\":1,\"688\":1,\"1155\":1,\"1268\":1,\"1382\":1}}],[\"而是自己编写了\",{\"1\":{\"256\":1}}],[\"而是自己构建了一种\",{\"1\":{\"176\":1}}],[\"而是在\",{\"1\":{\"201\":1}}],[\"而是在前一个节点注册一个事件监听器\",{\"1\":{\"55\":1}}],[\"而是在前一个节点比如\",{\"1\":{\"53\":1}}],[\"而是改为异步批量的方式来更新\",{\"1\":{\"147\":1}}],[\"而是设置记录的delete\",{\"1\":{\"141\":1}}],[\"而是保存着主键值\",{\"1\":{\"106\":1}}],[\"而是要使用\",{\"1\":{\"98\":1}}],[\"而是使用\",{\"1\":{\"33\":1,\"1359\":1}}],[\"而无需重新获得锁\",{\"1\":{\"50\":1}}],[\"而且更重要的是\",{\"1\":{\"1389\":1}}],[\"而且挂的没超过半数的时候\",{\"1\":{\"1380\":1}}],[\"而且要求消息复制半数以上节点的效率和直接异步复制还是有一定的差距的\",{\"1\":{\"1314\":1}}],[\"而且要保证执行前父类的<clinit>\",{\"1\":{\"430\":1}}],[\"而且他必须要使用三个节点或以上\",{\"1\":{\"1314\":1}}],[\"而且经历过双十一的实践就行了\",{\"1\":{\"1276\":1}}],[\"而且也不实用\",{\"1\":{\"1252\":1}}],[\"而且也可能导致\",{\"1\":{\"499\":1}}],[\"而且分布式可以任意扩展\",{\"1\":{\"1240\":1}}],[\"而且版本迭代很慢\",{\"1\":{\"1240\":1}}],[\"而且网上的资料也比较少\",{\"1\":{\"1169\":1}}],[\"而且在\",{\"1\":{\"1068\":1}}],[\"而且在面试中会经常被问到\",{\"1\":{\"827\":1}}],[\"而且状态<=0\",{\"1\":{\"1014\":1}}],[\"而且并发编程可能会遇到很多问题\",{\"1\":{\"817\":1}}],[\"而且可以选择拷贝的起点和长度以及放入新数组中的位置\",{\"1\":{\"563\":1}}],[\"而且是\",{\"1\":{\"544\":1,\"862\":1}}],[\"而且运行代价高昂\",{\"1\":{\"446\":1}}],[\"而且它们一直在被引用从而长时间垃圾收集无法收集它们\",{\"1\":{\"444\":1}}],[\"而且当老年区执行了\",{\"1\":{\"444\":1}}],[\"而且占用内存空间小到基本可以忽略不计\",{\"1\":{\"435\":1}}],[\"而且不存在方法体\",{\"1\":{\"435\":1}}],[\"而且不用用户选择商品输入金额\",{\"1\":{\"17\":1}}],[\"而且有一定的缩进而已\",{\"1\":{\"418\":1}}],[\"而且没有额外的空间对它进行分配担保\",{\"1\":{\"399\":1}}],[\"而且\",{\"1\":{\"245\":1,\"251\":1,\"324\":1,\"377\":1,\"564\":1,\"1011\":1,\"1172\":1,\"1278\":1}}],[\"而且这样即使出现系统崩溃\",{\"1\":{\"231\":1}}],[\"而且支持\",{\"1\":{\"224\":1,\"282\":1}}],[\"而且会阻塞当前释放内存的应用程序\",{\"1\":{\"165\":1}}],[\"而且年龄是\",{\"1\":{\"117\":1}}],[\"而且像时间\",{\"1\":{\"18\":1}}],[\"而\",{\"0\":{\"861\":1},\"1\":{\"10\":2,\"37\":1,\"54\":1,\"89\":1,\"117\":1,\"146\":1,\"147\":1,\"167\":1,\"218\":1,\"232\":1,\"236\":1,\"245\":3,\"287\":3,\"332\":1,\"358\":1,\"359\":1,\"424\":1,\"445\":1,\"503\":2,\"510\":1,\"529\":1,\"533\":1,\"542\":2,\"543\":2,\"552\":2,\"583\":1,\"601\":1,\"604\":1,\"607\":1,\"611\":2,\"649\":1,\"651\":1,\"656\":2,\"657\":1,\"658\":2,\"668\":1,\"672\":2,\"677\":1,\"708\":1,\"719\":2,\"727\":1,\"755\":1,\"793\":1,\"796\":1,\"806\":1,\"825\":1,\"855\":1,\"884\":2,\"910\":1,\"934\":1,\"1002\":1,\"1033\":1,\"1154\":1,\"1155\":3,\"1157\":1,\"1158\":1,\"1159\":1,\"1161\":1,\"1231\":4,\"1272\":1,\"1280\":2,\"1281\":1,\"1315\":3,\"1343\":1,\"1379\":1,\"1380\":1,\"1390\":1}}],[\"而非当前的线程\",{\"1\":{\"826\":1}}],[\"而非公平性则是指访问\",{\"1\":{\"797\":1}}],[\"而非堆内存则为永久代\",{\"1\":{\"443\":1}}],[\"而非\",{\"1\":{\"5\":1,\"68\":1,\"708\":1}}],[\"下文说了具体原因\",{\"1\":{\"1335\":1}}],[\"下文中我会介绍大部分常见方法的使用\",{\"1\":{\"774\":1}}],[\"下载\",{\"1\":{\"1321\":1}}],[\"下游按需从服务端订阅消息并按照本地消费逻辑处理下游任务\",{\"1\":{\"1284\":1}}],[\"下创建属于自己的节点\",{\"1\":{\"1199\":1}}],[\"下次再复用\",{\"1\":{\"1158\":1}}],[\"下的队列消息在\",{\"1\":{\"1315\":1}}],[\"下的队列来保证顺序性的\",{\"1\":{\"1314\":1}}],[\"下的\",{\"1\":{\"1196\":1}}],[\"下的安全性\",{\"1\":{\"1106\":1}}],[\"下的所有子节点信息\",{\"1\":{\"1328\":1}}],[\"下的所有\",{\"1\":{\"353\":1}}],[\"下标越界检查\",{\"1\":{\"729\":1,\"730\":1,\"731\":1}}],[\"下标是从\",{\"1\":{\"708\":1}}],[\"下一个问题就会聊到\",{\"1\":{\"825\":1}}],[\"下一波执行开始\",{\"1\":{\"756\":1,\"911\":1}}],[\"下一次插入则需要\",{\"1\":{\"535\":1}}],[\"下一层分为\",{\"1\":{\"524\":1}}],[\"下一般为\",{\"1\":{\"161\":1,\"231\":1}}],[\"下是数据类型默认的零值\",{\"1\":{\"342\":1}}],[\"下可以基本是可以满足持久性要求的\",{\"1\":{\"282\":1}}],[\"下图就是我的本地\",{\"1\":{\"1199\":1}}],[\"下图就是主从架构的\",{\"1\":{\"1085\":1}}],[\"下图是\",{\"1\":{\"634\":1,\"810\":1,\"1069\":1,\"1130\":1}}],[\"下图来自于introduction\",{\"1\":{\"1088\":1}}],[\"下图来自\",{\"1\":{\"496\":1}}],[\"下图来源于百亿规模\",{\"1\":{\"2\":1}}],[\"下图中的\",{\"1\":{\"391\":1}}],[\"下图中每个参数具体的含义\",{\"1\":{\"219\":1}}],[\"下图所示的\",{\"1\":{\"382\":1,\"495\":1}}],[\"下图展示了生产者将消息存入\",{\"1\":{\"1251\":1}}],[\"下图展示了\",{\"1\":{\"1172\":1}}],[\"下图展示了不同的语言被不同的编译器编译成\",{\"1\":{\"324\":1}}],[\"下图展示的各种类加载器之间的层次关系被称为类加载器的\",{\"1\":{\"356\":1}}],[\"下\",{\"0\":{\"277\":1,\"675\":1,\"879\":1},\"1\":{\"146\":1,\"147\":1,\"286\":1,\"288\":1,\"359\":1}}],[\"下不适用\",{\"1\":{\"77\":1}}],[\"下最小的子节点\",{\"1\":{\"53\":1}}],[\"下单\",{\"1\":{\"18\":1}}],[\"下单生成的订单号\",{\"1\":{\"16\":1}}],[\"下面选\",{\"1\":{\"1346\":1}}],[\"下面再来介绍一下\",{\"1\":{\"1251\":1}}],[\"下面再给大家介绍一下什么是分布式\",{\"1\":{\"1123\":1}}],[\"下面所有示例图中\",{\"1\":{\"1033\":1}}],[\"下面代码来源自\",{\"1\":{\"1030\":1}}],[\"下面列出了\",{\"1\":{\"1019\":1}}],[\"下面列举几点\",{\"1\":{\"585\":1}}],[\"下面提供了几个访问这个字段的方法\",{\"1\":{\"1006\":1}}],[\"下面通过伪代码\",{\"1\":{\"1001\":1}}],[\"下面通过源码来看看\",{\"1\":{\"957\":1}}],[\"下面通过一个例子来说明线程死锁\",{\"1\":{\"823\":1}}],[\"下面看看singlethreadexecutor\",{\"1\":{\"953\":1}}],[\"下面会详细解释线程是何时以及怎样被加入进等待队列中的\",{\"1\":{\"1008\":1}}],[\"下面会涉及到\",{\"1\":{\"941\":1}}],[\"下面会分析到这个方法\",{\"1\":{\"621\":1}}],[\"下面让我们实战一下\",{\"1\":{\"939\":1}}],[\"下面简单演示一下如何在项目中实际使用\",{\"1\":{\"882\":1}}],[\"下面简单对比一下二者\",{\"1\":{\"10\":1}}],[\"下面来思考这样一个问题\",{\"1\":{\"810\":1}}],[\"下面主要介绍一下\",{\"1\":{\"796\":1}}],[\"下面咱们来看一个简单的案例\",{\"1\":{\"777\":1}}],[\"下面给大家一个示例供大家参考\",{\"1\":{\"741\":1}}],[\"下面给出了源代码\",{\"1\":{\"677\":1}}],[\"下面给出各种联接类型\",{\"1\":{\"120\":1}}],[\"下面\",{\"1\":{\"688\":1}}],[\"下面有示意图\",{\"1\":{\"688\":1,\"792\":1}}],[\"下面有介绍到\",{\"1\":{\"552\":1,\"656\":1}}],[\"下面又有三个主要的子接口\",{\"1\":{\"639\":1}}],[\"下面梳理下具体流程\",{\"1\":{\"571\":1}}],[\"下面在我们分析\",{\"1\":{\"555\":1}}],[\"下面就用到了arraycopy\",{\"1\":{\"553\":1}}],[\"下面介绍几个基于\",{\"1\":{\"745\":1}}],[\"下面介绍两个基础的计算方法\",{\"1\":{\"445\":1}}],[\"下面介绍到的三种模式各有优劣\",{\"1\":{\"144\":1}}],[\"下面的内容来源于\",{\"1\":{\"1349\":1}}],[\"下面的内容非常重要哦\",{\"1\":{\"1347\":1}}],[\"下面的代码会报错\",{\"1\":{\"1335\":1}}],[\"下面的代码表示同一时刻\",{\"1\":{\"747\":1,\"905\":1}}],[\"下面的\",{\"1\":{\"432\":1}}],[\"下面详细介绍一下\",{\"1\":{\"325\":1}}],[\"下面单独对\",{\"1\":{\"316\":1}}],[\"下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和\",{\"1\":{\"1141\":1}}],[\"下面这个方法保证了\",{\"1\":{\"677\":1}}],[\"下面这张是\",{\"1\":{\"974\":1}}],[\"下面这张图摘自\",{\"1\":{\"1182\":1}}],[\"下面这张图是\",{\"1\":{\"1179\":1}}],[\"下面这张图是通过\",{\"1\":{\"325\":1}}],[\"下面这张图可以加深你对线程池中各个参数的相互关系的理解\",{\"1\":{\"890\":1,\"936\":1}}],[\"下面这张图片总结的挺不错的\",{\"1\":{\"243\":1}}],[\"下面这些对创建非常重要\",{\"1\":{\"936\":1}}],[\"下面这部分内容参考了极客时间专栏\",{\"1\":{\"800\":1}}],[\"下面这段内容摘自\",{\"1\":{\"1343\":1}}],[\"下面这段内容摘自阿里开发者的从\",{\"1\":{\"233\":1}}],[\"下面这段话摘自维基百科对负载均衡的定义\",{\"1\":{\"1139\":1}}],[\"下面这段话摘自\",{\"1\":{\"377\":1}}],[\"下面我列举一些属性解释\",{\"1\":{\"1382\":1}}],[\"下面我先来介绍一下\",{\"1\":{\"1380\":1}}],[\"下面我将给你们一一解释\",{\"1\":{\"1312\":1}}],[\"下面我会一一介绍上图中的一些概念\",{\"1\":{\"1247\":1}}],[\"下面我以一个常见的面试题为例讲解一下\",{\"1\":{\"834\":1}}],[\"下面我们就来简单地演示一下\",{\"1\":{\"1332\":1}}],[\"下面我们从\",{\"1\":{\"1012\":1}}],[\"下面我们会从整体到细节\",{\"1\":{\"1003\":1}}],[\"下面我们会对\",{\"1\":{\"1002\":1}}],[\"下面我们要讲到的是阻塞队列\",{\"1\":{\"796\":1}}],[\"下面我们结合源码来简单看看\",{\"1\":{\"756\":1,\"911\":1}}],[\"下面我们对迭代器\",{\"1\":{\"732\":1}}],[\"下面我们来简单对比一下两者\",{\"1\":{\"1232\":1}}],[\"下面我们来简单看看\",{\"1\":{\"774\":1,\"901\":1}}],[\"下面我们来对\",{\"1\":{\"1084\":1,\"1097\":1}}],[\"下面我们来看看它的源码\",{\"1\":{\"941\":1}}],[\"下面我们来看一下每个\",{\"1\":{\"1349\":1}}],[\"下面我们来看一下这个策略模式下的缓存读写步骤\",{\"1\":{\"145\":1}}],[\"下面我们来看一个获取\",{\"1\":{\"353\":1}}],[\"下面我们来总结一下使用注意事项\",{\"1\":{\"634\":1}}],[\"下面我们来解释一下原因\",{\"1\":{\"630\":1}}],[\"下面我们来详细的了解一下\",{\"1\":{\"500\":1}}],[\"下面我们来进行实际测试一下\",{\"1\":{\"384\":1}}],[\"下面我们主要从\",{\"1\":{\"246\":1}}],[\"下面我们先来详细介绍一下这两个机制\",{\"1\":{\"141\":1}}],[\"下面我首先讲实现事务功能的三个技术\",{\"1\":{\"133\":1}}],[\"下面是该数据节点的一些状态信息\",{\"1\":{\"1349\":1}}],[\"下面是该知识点的扩展内容\",{\"1\":{\"810\":1}}],[\"下面是这个函数中判断是否重试的逻辑\",{\"1\":{\"1210\":1}}],[\"下面是二者使用的简单对比\",{\"1\":{\"649\":1}}],[\"下面是维基百科对\",{\"1\":{\"585\":1}}],[\"下面是arraylist的扩容机制\",{\"1\":{\"553\":1}}],[\"下面是一段消费的日志\",{\"1\":{\"1209\":1}}],[\"下面是一个简单的\",{\"1\":{\"918\":1}}],[\"下面是一个线程死锁的代码\",{\"1\":{\"370\":1}}],[\"下面是一些建议\",{\"1\":{\"786\":1}}],[\"下面是一些常用参数\",{\"1\":{\"480\":1,\"496\":1}}],[\"下面是正文\",{\"1\":{\"412\":1}}],[\"下面是其他比较常用的慢查询相关的命令\",{\"1\":{\"302\":1}}],[\"下面是两种常见的方法\",{\"1\":{\"289\":1}}],[\"下面是我对分布式锁画的一张示意图\",{\"1\":{\"60\":1}}],[\"下面是我对本地锁画的一张示意图\",{\"1\":{\"60\":1}}],[\"下面是\",{\"1\":{\"37\":1,\"629\":1,\"796\":1,\"1373\":1}}],[\"下面展开分析下订单系统中不同场景的\",{\"1\":{\"16\":1}}],[\"更大的\",{\"1\":{\"1375\":1}}],[\"更推荐的方式是通过下面这行代码\",{\"1\":{\"1335\":1}}],[\"更推荐使用这个注解来完成重试\",{\"1\":{\"1213\":1}}],[\"更有不可思议的万亿级消息通过\",{\"1\":{\"1276\":1}}],[\"更有效的方法来存储多个数据对象\",{\"1\":{\"647\":1}}],[\"更是编程和架构的精华\",{\"1\":{\"1274\":1}}],[\"更适合做\",{\"1\":{\"1380\":1}}],[\"更适合做消息队列一些\",{\"1\":{\"182\":1}}],[\"更适合于企业级的开发\",{\"1\":{\"1245\":1}}],[\"更像是一个精简版的\",{\"1\":{\"1169\":1}}],[\"更能提高整个系统的性能\",{\"1\":{\"1126\":1}}],[\"更长的\",{\"1\":{\"1114\":1}}],[\"更具体点来说\",{\"1\":{\"1097\":1}}],[\"更具体地说\",{\"1\":{\"1074\":1}}],[\"更准确地来说\",{\"1\":{\"974\":1}}],[\"更准确点来说是悲观锁\",{\"1\":{\"60\":1}}],[\"更强大\",{\"1\":{\"857\":1}}],[\"更强大的脚本\",{\"1\":{\"283\":1}}],[\"更灵活\",{\"1\":{\"857\":1}}],[\"更好\",{\"1\":{\"668\":1}}],[\"更进一步地实现了这一思想\",{\"1\":{\"584\":1,\"793\":1}}],[\"更正\",{\"1\":{\"480\":1}}],[\"更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程\",{\"1\":{\"401\":1}}],[\"更加节省带宽\",{\"1\":{\"1170\":1}}],[\"更加复杂和强大\",{\"1\":{\"755\":1,\"910\":1}}],[\"更加高效\",{\"1\":{\"719\":1}}],[\"更加厉害的是\",{\"1\":{\"584\":1,\"793\":1}}],[\"更加没有万能的垃圾收集器\",{\"1\":{\"400\":1}}],[\"更加友好\",{\"1\":{\"272\":1}}],[\"更改的结果就会被持久化\",{\"1\":{\"1345\":1}}],[\"更改用户会员等级\",{\"1\":{\"1202\":1}}],[\"更改商品数量直接修改对应的\",{\"1\":{\"257\":1}}],[\"更改小明的年龄为30岁\",{\"1\":{\"128\":1}}],[\"更快的重启以及解决\",{\"1\":{\"236\":1}}],[\"更方便操作\",{\"1\":{\"180\":1,\"195\":1}}],[\"更多指的是各个服务以及系统内部各个组件\",{\"1\":{\"1218\":1}}],[\"更多用于\",{\"1\":{\"1155\":1,\"1161\":1}}],[\"更多关于线程池源码分析的内容推荐这篇文章\",{\"1\":{\"941\":1}}],[\"更多关于布隆过滤器的内容可以看我的这篇原创\",{\"1\":{\"307\":1}}],[\"更多的空间\",{\"1\":{\"552\":1,\"656\":1}}],[\"更多\",{\"1\":{\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1}}],[\"更新系统状态\",{\"1\":{\"1355\":1}}],[\"更新节点数据的权限\",{\"1\":{\"1384\":1}}],[\"更新节点数据\",{\"1\":{\"1351\":1}}],[\"更新节点数据内容\",{\"0\":{\"1326\":1,\"1337\":1},\"1\":{\"1337\":1}}],[\"更新记录\",{\"1\":{\"1235\":1,\"1236\":1,\"1237\":1,\"1238\":1}}],[\"更新创建的平台最大线程数\",{\"1\":{\"1062\":1}}],[\"更新探测清理过期数据的开始下标为\",{\"1\":{\"1036\":1}}],[\"更新entry数据\",{\"1\":{\"1035\":1}}],[\"更新失败的话\",{\"1\":{\"1013\":1}}],[\"更新当前工作线程的最大容量\",{\"1\":{\"941\":1}}],[\"更新值\",{\"1\":{\"841\":1,\"990\":1}}],[\"更新为\",{\"1\":{\"840\":1,\"989\":1}}],[\"更新的对象属性必须使用\",{\"1\":{\"768\":1}}],[\"更新操作时提供\",{\"1\":{\"765\":1}}],[\"更新putindex\",{\"1\":{\"535\":1}}],[\"更新下一次put或者offer或用add方法添加到队列底层数组的位置\",{\"1\":{\"534\":1}}],[\"更新重试机制\",{\"1\":{\"316\":1}}],[\"更新\",{\"1\":{\"145\":3,\"316\":1,\"535\":2,\"1114\":1}}],[\"更新余额等\",{\"1\":{\"124\":1}}],[\"更新语句执行流程如下\",{\"1\":{\"90\":1}}],[\"更新完成\",{\"1\":{\"89\":1}}],[\"更新流程还涉及两个重要的日志模块\",{\"1\":{\"89\":1}}],[\"更新之后重新\",{\"1\":{\"34\":1}}],[\"更优秀一些\",{\"1\":{\"10\":1}}],[\"更早\",{\"1\":{\"5\":1,\"68\":1}}],[\"重复调用问题\",{\"1\":{\"1303\":1}}],[\"重复提交表单数据的问题\",{\"1\":{\"1303\":1}}],[\"重复消费\",{\"0\":{\"1303\":1},\"1\":{\"1316\":1}}],[\"重复创建线程池的坑\",{\"0\":{\"927\":1}}],[\"重传等原因造成的\",{\"1\":{\"1069\":1}}],[\"重排序\",{\"1\":{\"969\":1}}],[\"重心优化系统性能瓶颈相关的业务\",{\"1\":{\"919\":1}}],[\"重量级锁状态\",{\"1\":{\"854\":1}}],[\"重量级锁\",{\"1\":{\"847\":1,\"996\":1}}],[\"重试策略\",{\"1\":{\"1333\":1}}],[\"重试之间等待的初始时间\",{\"1\":{\"1333\":1}}],[\"重试间隔\",{\"1\":{\"1213\":1}}],[\"重试\",{\"1\":{\"1213\":1}}],[\"重试失败后的数据如何再次处理\",{\"0\":{\"1213\":1}}],[\"重试多次失败\",{\"1\":{\"1212\":1}}],[\"重试多次后会被跳过\",{\"1\":{\"1209\":1}}],[\"重试多次后会跳过当前消息\",{\"1\":{\"1209\":1}}],[\"重试是否有时间间隔\",{\"1\":{\"1210\":1}}],[\"重试机制\",{\"0\":{\"1208\":1}}],[\"重试次数是多少\",{\"1\":{\"1210\":1}}],[\"重试次数\",{\"1\":{\"1204\":1}}],[\"重试次数可以自己定\",{\"1\":{\"316\":1}}],[\"重试任务\",{\"1\":{\"785\":1}}],[\"重置为最大值\",{\"1\":{\"570\":1}}],[\"重置为\",{\"1\":{\"570\":1,\"756\":1,\"911\":1}}],[\"重新选择其他\",{\"1\":{\"1301\":1}}],[\"重新消费\",{\"1\":{\"1213\":1}}],[\"重新实现一个\",{\"1\":{\"1211\":1}}],[\"重新计时\",{\"1\":{\"1111\":1}}],[\"重新计算tab下次扩容的阈值\",{\"1\":{\"1038\":1}}],[\"重新计算hash位置\",{\"1\":{\"1038\":1}}],[\"重新计算当前key的下标位置是不是当前槽位下标位置\",{\"1\":{\"1037\":1}}],[\"重新安排语句的执行顺序\",{\"1\":{\"969\":1}}],[\"重新进入\",{\"1\":{\"820\":1,\"1374\":1,\"1375\":1}}],[\"重新设置当前值和\",{\"1\":{\"767\":2}}],[\"重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录\",{\"1\":{\"406\":1}}],[\"重新标记\",{\"1\":{\"406\":1}}],[\"重新组装结果数据\",{\"1\":{\"286\":1}}],[\"重点了解下面列举的\",{\"1\":{\"975\":1}}],[\"重点搞清楚虚拟线程和平台线程的关系以及虚拟线程的优势即可\",{\"1\":{\"912\":1}}],[\"重点来了\",{\"1\":{\"684\":1}}],[\"重点关注\",{\"1\":{\"619\":1}}],[\"重点\",{\"0\":{\"348\":1,\"380\":1,\"489\":1},\"1\":{\"447\":1}}],[\"重要概念\",{\"0\":{\"1347\":1}}],[\"重要方法与\",{\"0\":{\"1007\":1}}],[\"重要\",{\"0\":{\"263\":1,\"264\":1,\"284\":1,\"304\":1,\"676\":1,\"935\":1,\"939\":1},\"1\":{\"272\":1,\"688\":1}}],[\"重启的时候可以再次加载进行使用\",{\"1\":{\"245\":1}}],[\"重启时\",{\"1\":{\"230\":1}}],[\"重启加载\",{\"1\":{\"230\":1}}],[\"重启节点可以做到内存碎片重新整理\",{\"1\":{\"220\":1}}],[\"重做日志记录数据被修改后的信息\",{\"1\":{\"137\":1}}],[\"重做日志缓冲\",{\"1\":{\"135\":1}}],[\"重做日志\",{\"1\":{\"89\":1,\"135\":2}}],[\"重定向跳转啥的\",{\"1\":{\"1159\":1}}],[\"重定向\",{\"1\":{\"9\":1}}],[\"重写了其中的某些方法\",{\"1\":{\"748\":1}}],[\"重写了\",{\"1\":{\"711\":1,\"712\":1}}],[\"重写了解吗\",{\"0\":{\"233\":1}}],[\"重写的一个方法\",{\"1\":{\"748\":1,\"752\":2}}],[\"重写的\",{\"1\":{\"710\":1}}],[\"重写的时候就直接把\",{\"1\":{\"235\":1}}],[\"重写removeeldestentry\",{\"1\":{\"706\":1}}],[\"重写hashcode\",{\"1\":{\"619\":1}}],[\"重写一个类加载器的\",{\"1\":{\"340\":1}}],[\"重写描述不准确\",{\"1\":{\"233\":1}}],[\"重写期间的增量数据如何处理一直是个问题\",{\"1\":{\"233\":1}}],[\"重写期间到达的所有写入命令都会写入磁盘两次\",{\"1\":{\"233\":1,\"236\":1}}],[\"重写机制得到了优化改进\",{\"1\":{\"233\":1}}],[\"重写时\",{\"1\":{\"233\":1}}],[\"重写功能\",{\"1\":{\"233\":1}}],[\"重写程序放到子进程里执行\",{\"1\":{\"233\":1}}],[\"重写会进行大量的写入操作\",{\"1\":{\"233\":1}}],[\"重写缓冲区\",{\"1\":{\"162\":1,\"233\":1}}],[\"重写阻塞问题分析\",{\"1\":{\"162\":1}}],[\"重写阻塞\",{\"0\":{\"162\":1}}],[\"重写\",{\"0\":{\"663\":1},\"1\":{\"9\":1,\"233\":5,\"359\":1,\"519\":1,\"521\":1,\"619\":1,\"712\":1,\"1212\":1}}],[\"转化而来\",{\"1\":{\"1108\":1}}],[\"转变为权益证明\",{\"1\":{\"1097\":1}}],[\"转红黑树的概率不大\",{\"1\":{\"708\":1}}],[\"转换为红黑树\",{\"1\":{\"691\":1}}],[\"转换红黑树\",{\"1\":{\"683\":1}}],[\"转换成\",{\"1\":{\"19\":1}}],[\"转换成用户友好的错误提示返回\",{\"1\":{\"2\":1}}],[\"转移maxelements个元素到集合中\",{\"1\":{\"533\":1}}],[\"转储到物理文件中\",{\"1\":{\"484\":1}}],[\"转入2000元\",{\"1\":{\"127\":1}}],[\"转账过程具体到程序里会有一系列的操作\",{\"1\":{\"124\":1}}],[\"转进制后的短网址\",{\"1\":{\"24\":1}}],[\"转进制的压缩算法在生活中有广泛的应用场景\",{\"1\":{\"24\":1}}],[\"转更高进制的方式压缩长度\",{\"1\":{\"24\":1}}],[\"转发消息的策略有所区别\",{\"1\":{\"1249\":1}}],[\"转发\",{\"1\":{\"9\":1}}],[\"熔断\",{\"1\":{\"9\":1}}],[\"熔断降级\",{\"1\":{\"2\":1}}],[\"自诞生以来\",{\"1\":{\"1236\":1}}],[\"自上而下由浅入深\",{\"1\":{\"1003\":1}}],[\"自选检查\",{\"1\":{\"752\":1}}],[\"自此将节点p移动到链表末尾\",{\"1\":{\"710\":1}}],[\"自此我们阻塞式获取元素的逻辑都已完成后\",{\"1\":{\"604\":1}}],[\"自此我们了解了\",{\"1\":{\"535\":1}}],[\"自此我们对阻塞队列的使用有了基本的印象\",{\"1\":{\"532\":1}}],[\"自平衡的排序二叉树\",{\"1\":{\"643\":1,\"645\":1}}],[\"自旋+cas\",{\"1\":{\"577\":1}}],[\"自旋达到指定次数后\",{\"1\":{\"571\":1}}],[\"自旋获取锁\",{\"1\":{\"571\":1}}],[\"自旋判断计算得到的指定位置的\",{\"1\":{\"571\":1}}],[\"自旋检查\",{\"1\":{\"571\":1}}],[\"自旋锁\",{\"1\":{\"50\":1,\"854\":1,\"996\":1}}],[\"自然是要操作对应的对象\",{\"1\":{\"826\":1}}],[\"自然after不会是null\",{\"1\":{\"710\":1}}],[\"自然受到方法区内存的限制\",{\"1\":{\"497\":1}}],[\"自然可以获得很高的单线程收集效率\",{\"1\":{\"401\":1}}],[\"自定义控制消费速率\",{\"1\":{\"1293\":1}}],[\"自定义\",{\"1\":{\"1252\":1}}],[\"自定义操作\",{\"1\":{\"1212\":1}}],[\"自定义重试失败后逻辑\",{\"1\":{\"1212\":1}}],[\"自定义重试时间间隔以及次数\",{\"1\":{\"1211\":1}}],[\"自定义的规则\",{\"1\":{\"1152\":1}}],[\"自定义的类加载器\",{\"1\":{\"432\":1}}],[\"自定义同步工具\",{\"0\":{\"1020\":1}}],[\"自定义同步器无关\",{\"1\":{\"1007\":1}}],[\"自定义同步器要么是独占方式\",{\"1\":{\"1007\":1}}],[\"自定义同步器需要实现以下方法\",{\"1\":{\"1007\":1}}],[\"自定义同步器实现的相关方法也只是为了通过修改\",{\"1\":{\"1007\":1}}],[\"自定义同步器时需要重写下面几个\",{\"1\":{\"744\":1}}],[\"自定义同步器\",{\"0\":{\"744\":1}}],[\"自定义同步器的共享方式要么是独占\",{\"1\":{\"743\":1}}],[\"自定义线程池\",{\"1\":{\"927\":1}}],[\"自定义实现\",{\"1\":{\"896\":1,\"923\":1}}],[\"自定义业务操作\",{\"1\":{\"782\":2,\"909\":2}}],[\"自定义注解\",{\"1\":{\"523\":1}}],[\"自定义加载器的话\",{\"1\":{\"359\":1}}],[\"自定义类加载器\",{\"0\":{\"354\":1}}],[\"自身提交了这个事务并且要发送给所有\",{\"1\":{\"1380\":1}}],[\"自身\",{\"1\":{\"1261\":1}}],[\"自身的类\",{\"1\":{\"359\":1}}],[\"自身的一部分之外\",{\"1\":{\"353\":1}}],[\"自身也越来越强大了\",{\"1\":{\"245\":1}}],[\"自己搞丢\",{\"1\":{\"1261\":1}}],[\"自己已经成为了大将军\",{\"1\":{\"1105\":1}}],[\"自己的倒计时还没有结束\",{\"1\":{\"1105\":1}}],[\"自己解析requestid使用即可\",{\"1\":{\"1048\":1}}],[\"自己独立思考一会\",{\"1\":{\"941\":1}}],[\"自己实现一个同步工具\",{\"1\":{\"1020\":1}}],[\"自己实现\",{\"1\":{\"894\":1,\"920\":1}}],[\"自己实现的内存分配方法\",{\"1\":{\"218\":1}}],[\"自己模拟了多线程的运行\",{\"1\":{\"808\":1}}],[\"自己不得不实现之外\",{\"1\":{\"678\":1}}],[\"自己都说从来不会使用\",{\"1\":{\"656\":1,\"724\":1}}],[\"自己动手写\",{\"1\":{\"511\":1}}],[\"自己造缓存轮子的时候需要格外考虑的东西\",{\"1\":{\"272\":1}}],[\"自带了给缓存数据设置过期时间的功能\",{\"1\":{\"270\":1}}],[\"自带了限流过滤器\",{\"1\":{\"76\":1}}],[\"自带了诸如限流\",{\"1\":{\"9\":1}}],[\"自带的序列化方式\",{\"1\":{\"1147\":1}}],[\"自带的序列化\",{\"1\":{\"1146\":1}}],[\"自带的工具\",{\"1\":{\"895\":1,\"922\":1}}],[\"自带的静态工厂方法\",{\"1\":{\"776\":1}}],[\"自带的jvisualvm分析\",{\"1\":{\"412\":1}}],[\"自带的类加载器加载的类是不会被卸载的\",{\"1\":{\"345\":1}}],[\"自带的引擎是\",{\"1\":{\"89\":1}}],[\"自带的\",{\"1\":{\"60\":1,\"164\":1,\"249\":1,\"293\":2,\"298\":1,\"345\":1,\"455\":1,\"851\":1}}],[\"自带的客户端\",{\"1\":{\"53\":1,\"1332\":1}}],[\"自动提交的话会有一个问题\",{\"1\":{\"1205\":1}}],[\"自动内存管理最核心的功能是\",{\"1\":{\"382\":1}}],[\"自动内存碎片清理机制可能会对\",{\"1\":{\"220\":1}}],[\"自动化\",{\"1\":{\"381\":1}}],[\"自动删除\",{\"1\":{\"231\":1}}],[\"自动续期机制\",{\"1\":{\"49\":3}}],[\"自动熔断\",{\"1\":{\"2\":1}}],[\"自\",{\"1\":{\"40\":1,\"1258\":1}}],[\"自增方案变为\",{\"1\":{\"1375\":1}}],[\"自增后返回\",{\"1\":{\"56\":1}}],[\"自增值\",{\"1\":{\"35\":1}}],[\"自增\",{\"1\":{\"24\":1,\"987\":1}}],[\"自增序列\",{\"1\":{\"22\":1}}],[\"高度封装的消费者类型\",{\"1\":{\"1292\":1}}],[\"高度可扩展能力\",{\"1\":{\"1122\":1}}],[\"高度可靠的状态机\",{\"1\":{\"1106\":1}}],[\"高实时\",{\"1\":{\"1276\":1}}],[\"高可靠的定时触发能力\",{\"1\":{\"1285\":1}}],[\"高可靠\",{\"1\":{\"1276\":1}}],[\"高可用的\",{\"0\":{\"1263\":1}}],[\"高可用的分布式\",{\"1\":{\"8\":1}}],[\"高可用性等方面表现不俗\",{\"1\":{\"1245\":1}}],[\"高可用性\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"高可用\",{\"1\":{\"30\":1,\"42\":1,\"61\":1,\"63\":1,\"1106\":1,\"1275\":1}}],[\"高扩展\",{\"1\":{\"1236\":1}}],[\"高吞吐量和低延迟\",{\"1\":{\"1362\":1}}],[\"高吞吐\",{\"1\":{\"1236\":1,\"1238\":1}}],[\"高级定制场景\",{\"1\":{\"1292\":1}}],[\"高级消息队列协议\",{\"1\":{\"1230\":1,\"1237\":1}}],[\"高级特性与最佳实践\",{\"1\":{\"380\":1,\"409\":1,\"489\":1,\"511\":1}}],[\"高速缓存是一种速度非常快\",{\"1\":{\"1184\":1}}],[\"高速缓存与主内存交互的时候需要遵守的原则和规范\",{\"1\":{\"968\":1}}],[\"高速缓存呢\",{\"1\":{\"968\":1}}],[\"高效的数据格式\",{\"1\":{\"1170\":1}}],[\"高效的并发队列\",{\"1\":{\"791\":1}}],[\"高效需多\",{\"1\":{\"713\":1}}],[\"高效率的利用\",{\"1\":{\"403\":1}}],[\"高层的类加载器需要加载低层的加载器才能加载的类\",{\"1\":{\"359\":1}}],[\"高版本的\",{\"1\":{\"327\":1}}],[\"高并发的场景下\",{\"1\":{\"837\":1,\"838\":1,\"986\":1,\"987\":1,\"995\":1}}],[\"高并发程序设计\",{\"1\":{\"800\":1,\"801\":1,\"876\":1,\"913\":1}}],[\"高并发\",{\"1\":{\"246\":2}}],[\"高性能可扩展\",{\"1\":{\"1285\":1}}],[\"高性能读写的原因和顺序消费的具体实现\",{\"1\":{\"1267\":1}}],[\"高性能和丰富功能的流计算引擎\",{\"1\":{\"1236\":1}}],[\"高性能队列\",{\"1\":{\"1185\":1}}],[\"高性能队列原理浅析\",{\"1\":{\"1184\":1}}],[\"高性能队列原理的详细介绍\",{\"1\":{\"1184\":1}}],[\"高性能之道\",{\"1\":{\"1185\":2}}],[\"高性能解决线程饥饿的利器\",{\"1\":{\"876\":1}}],[\"高性能\",{\"1\":{\"9\":1,\"30\":1,\"61\":1,\"63\":1,\"246\":2,\"1344\":1},\"2\":{\"1186\":1,\"1215\":1,\"1242\":1,\"1265\":1,\"1317\":1}}],[\"技术架构中有四大角色\",{\"1\":{\"1281\":1}}],[\"技术架构更贴合云原生\",{\"1\":{\"10\":1}}],[\"技术应用\",{\"1\":{\"1178\":1}}],[\"技术小黑屋\",{\"1\":{\"876\":1}}],[\"技术沙龙\",{\"1\":{\"742\":1}}],[\"技术面试题篇\",{\"1\":{\"194\":1,\"258\":1}}],[\"技术实现需要因地制宜地思考\",{\"1\":{\"19\":1}}],[\"技术和业务的深度结合\",{\"1\":{\"17\":1}}],[\"技术博客\",{\"1\":{\"8\":1}}],[\"技术栈开发\",{\"1\":{\"4\":1}}],[\"为事件监听器\",{\"1\":{\"1385\":1}}],[\"为用户程序提供数据节点监听服务\",{\"1\":{\"1362\":1}}],[\"为客户端提供读服务\",{\"1\":{\"1355\":2}}],[\"为客户端提供读和写的服务\",{\"1\":{\"1355\":1}}],[\"为一个点号\",{\"1\":{\"1252\":1}}],[\"为消息定义了线路层\",{\"1\":{\"1231\":1}}],[\"为面向消息的中间件设计\",{\"1\":{\"1230\":1}}],[\"为分区\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"为大规模微服务实践提供高性能\",{\"1\":{\"1168\":1}}],[\"为平滑加权轮询算法\",{\"1\":{\"1144\":1}}],[\"为统一接口\",{\"1\":{\"1130\":1}}],[\"为中心\",{\"1\":{\"1130\":7}}],[\"为的是使得系统稳定运行\",{\"1\":{\"1116\":1}}],[\"为的是使leader能够持续发送心跳信息\",{\"1\":{\"1116\":1}}],[\"为的是让线程\",{\"1\":{\"370\":1,\"823\":1}}],[\"为啥不可能选择\",{\"1\":{\"1068\":1}}],[\"为当前位置\",{\"1\":{\"1036\":1}}],[\"为很多其他同步工具提供了良好的解决方案\",{\"1\":{\"1019\":1}}],[\"为释放锁的次数\",{\"1\":{\"1007\":2}}],[\"为获取锁的次数\",{\"1\":{\"1007\":2}}],[\"为共享变量提供了可见性的保障\",{\"1\":{\"972\":1}}],[\"为false使用线程池最大大小\",{\"1\":{\"941\":1}}],[\"为构建锁和同步器提供了一些通用功能的实现\",{\"1\":{\"740\":1,\"903\":1}}],[\"为我们提供了高可用\",{\"1\":{\"1344\":1}}],[\"为我们提供的延迟队列\",{\"1\":{\"597\":1}}],[\"为我的知识星球\",{\"1\":{\"736\":1}}],[\"为偶数就是\",{\"1\":{\"558\":1}}],[\"为0\",{\"1\":{\"553\":1}}],[\"为每一个线程预先在\",{\"1\":{\"503\":1}}],[\"为对象分配空间的任务等同于把一块确定大小的内存从\",{\"1\":{\"503\":1}}],[\"为止\",{\"1\":{\"448\":1,\"904\":1}}],[\"为最小单位\",{\"1\":{\"442\":1}}],[\"为类的二进制名称\",{\"1\":{\"354\":1}}],[\"为null就是\",{\"1\":{\"353\":1}}],[\"为null的话\",{\"1\":{\"353\":1}}],[\"为空表示当前链表还没有节点\",{\"1\":{\"729\":1}}],[\"为空则说明当前节点\",{\"1\":{\"711\":2}}],[\"为空\",{\"1\":{\"251\":1,\"571\":2,\"958\":1}}],[\"为空时\",{\"1\":{\"251\":1}}],[\"为集合数量\",{\"1\":{\"193\":1}}],[\"为返回的元素数量\",{\"1\":{\"157\":1,\"301\":1}}],[\"为所有元素的数量\",{\"1\":{\"157\":2,\"301\":2}}],[\"为此我们定义了一个线程池和\",{\"1\":{\"909\":1}}],[\"为此\",{\"1\":{\"50\":1,\"251\":1,\"266\":1,\"971\":1}}],[\"为例子讲解第一种\",{\"1\":{\"1263\":1}}],[\"为例子来介绍\",{\"1\":{\"763\":1,\"766\":1,\"767\":1}}],[\"为例说一说\",{\"1\":{\"1069\":1}}],[\"为例说明\",{\"1\":{\"293\":1,\"298\":1,\"299\":1,\"632\":1,\"1085\":1}}],[\"为例进行介绍\",{\"1\":{\"588\":1,\"591\":1,\"686\":1}}],[\"为例分析\",{\"1\":{\"556\":1}}],[\"为例\",{\"1\":{\"117\":1,\"553\":1,\"586\":1,\"600\":1,\"727\":1,\"742\":1,\"904\":1,\"1008\":1,\"1040\":1,\"1292\":2}}],[\"为例来说明如何使用\",{\"1\":{\"49\":1}}],[\"为例介绍分布式锁的实现\",{\"1\":{\"45\":1}}],[\"为\",{\"1\":{\"34\":1,\"56\":1,\"257\":2,\"261\":1,\"357\":1,\"366\":1,\"429\":1,\"557\":4,\"558\":4,\"571\":1,\"630\":1,\"706\":1,\"709\":1,\"710\":3,\"711\":1,\"712\":1,\"717\":1,\"749\":1,\"752\":2,\"834\":1,\"840\":1,\"861\":1,\"884\":3,\"908\":1,\"909\":1,\"989\":1,\"1005\":4,\"1015\":1,\"1033\":1,\"1275\":1,\"1285\":1,\"1286\":1,\"1304\":2,\"1344\":2,\"1380\":2,\"1384\":1}}],[\"为主要开发语言的情况下\",{\"1\":{\"10\":1}}],[\"为什么快的一个很重要原因\",{\"1\":{\"1311\":1}}],[\"为什么一个主题中需要维护多个队列\",{\"1\":{\"1280\":1}}],[\"为什么既然有了\",{\"0\":{\"1160\":1}}],[\"为什么有\",{\"1\":{\"1155\":1}}],[\"为什么还要用\",{\"1\":{\"1150\":1}}],[\"为什么还要有\",{\"0\":{\"1150\":1,\"1155\":1,\"1174\":1},\"1\":{\"1174\":1}}],[\"为什么还需要\",{\"1\":{\"8\":1}}],[\"为什么这么做呢\",{\"1\":{\"1371\":1}}],[\"为什么这么快\",{\"0\":{\"243\":1,\"1184\":1}}],[\"为什么这样说呢\",{\"1\":{\"1074\":1,\"1224\":1}}],[\"为什么这样设计呢\",{\"1\":{\"825\":1}}],[\"为什么堆和方法区是线程共享的呢\",{\"1\":{\"810\":1}}],[\"为什么程序计数器\",{\"1\":{\"810\":1}}],[\"为什么线程不安全\",{\"0\":{\"686\":1}}],[\"为什么不推荐使用\",{\"0\":{\"951\":1,\"955\":1,\"959\":1}}],[\"为什么不推荐使用内置线程池\",{\"0\":{\"889\":1}}],[\"为什么不直接在\",{\"1\":{\"708\":1}}],[\"为什么不能实现\",{\"0\":{\"655\":1,\"726\":1}}],[\"为什么不支持回滚\",{\"1\":{\"281\":1}}],[\"为什么是这三个参数\",{\"1\":{\"896\":1,\"923\":1}}],[\"为什么是\",{\"1\":{\"444\":1}}],[\"为什么是重写\",{\"1\":{\"359\":1}}],[\"为什么是在执行完命令之后记录日志\",{\"0\":{\"232\":1}}],[\"为什么是在执行完命令之后记录日志呢\",{\"1\":{\"160\":1,\"232\":1}}],[\"为什么需要\",{\"0\":{\"971\":1},\"1\":{\"318\":1,\"974\":1}}],[\"为什么需要分布式锁\",{\"0\":{\"60\":1}}],[\"为什么建议部署多个\",{\"1\":{\"318\":1}}],[\"为什么会出现这种情况呢\",{\"1\":{\"835\":1}}],[\"为什么会出现误判的情况呢\",{\"1\":{\"307\":1}}],[\"为什么会有慢查询命令呢\",{\"1\":{\"301\":1}}],[\"为什么会有慢查询命令\",{\"0\":{\"301\":1}}],[\"为什么会有\",{\"0\":{\"218\":1},\"1\":{\"303\":1}}],[\"为什么呢\",{\"1\":{\"270\":1,\"658\":1,\"889\":1,\"919\":1,\"1206\":1,\"1280\":1,\"1314\":1}}],[\"为什么\",{\"0\":{\"693\":1,\"826\":1},\"1\":{\"266\":1,\"318\":1,\"353\":1,\"708\":1,\"820\":1,\"826\":1,\"1315\":1}}],[\"为什么内存占用率还是很高\",{\"1\":{\"221\":1}}],[\"为什么日志需要\",{\"1\":{\"89\":1}}],[\"为什么要设置奇数个结点\",{\"1\":{\"1380\":1}}],[\"为什么要设置对前一个节点的监听\",{\"0\":{\"55\":1}}],[\"为什么要这么做呢\",{\"1\":{\"1315\":1}}],[\"为什么要\",{\"1\":{\"1165\":1}}],[\"为什么要分布式\",{\"0\":{\"1126\":1},\"1\":{\"1123\":1}}],[\"为什么要分为新生代和老年代\",{\"1\":{\"380\":1,\"399\":1}}],[\"为什么要从后往前找第一个非\",{\"1\":{\"1014\":1}}],[\"为什么要判断的头结点的下一个节点\",{\"1\":{\"1011\":1}}],[\"为什么要遵守这些并发相关的原则和规范呢\",{\"1\":{\"971\":1}}],[\"为什么要弄一个\",{\"1\":{\"968\":1}}],[\"为什么要使用多线程\",{\"0\":{\"816\":1}}],[\"为什么要使用集合\",{\"0\":{\"647\":1}}],[\"为什么要遍历\",{\"1\":{\"571\":1}}],[\"为什么要将字符串常量池移动到堆中\",{\"1\":{\"498\":1}}],[\"为什么要将永久代\",{\"1\":{\"496\":1}}],[\"为什么要用线程池\",{\"0\":{\"887\":1}}],[\"为什么要用缓存\",{\"0\":{\"246\":1}}],[\"为什么要用\",{\"0\":{\"246\":1,\"1123\":1,\"1179\":1}}],[\"为什么要用临时顺序节点\",{\"0\":{\"54\":1}}],[\"为什么要给锁设置一个过期时间\",{\"0\":{\"48\":1}}],[\"为什么说\",{\"1\":{\"8\":1}}],[\"为了多吃点\",{\"1\":{\"1271\":1}}],[\"为了确定消息是发送成功\",{\"1\":{\"1204\":1}}],[\"为了确保目标字段独占一个\",{\"1\":{\"1184\":1}}],[\"为了确保优先级最高的任务到期后可以即刻被执行\",{\"1\":{\"601\":1}}],[\"为了利用\",{\"1\":{\"1184\":1}}],[\"为了加速数据的读取过程\",{\"1\":{\"1184\":1}}],[\"为了使得\",{\"1\":{\"1112\":1}}],[\"为了开始新的选举\",{\"1\":{\"1111\":1}}],[\"为了应对高度动态的环境\",{\"1\":{\"1104\":1}}],[\"为了减少实现该算法所需的节点数\",{\"1\":{\"1098\":1}}],[\"为了介绍\",{\"1\":{\"1096\":1}}],[\"为了帮助大家理解\",{\"1\":{\"1007\":1}}],[\"为了帮助大家更好地理解\",{\"1\":{\"1001\":1}}],[\"为了帮助理解\",{\"1\":{\"535\":1,\"539\":1}}],[\"为了对编译器和处理器的约束尽可能少\",{\"1\":{\"974\":1}}],[\"为了获取更好的运行速度\",{\"1\":{\"972\":1}}],[\"为了达到屏障的效果\",{\"1\":{\"969\":1}}],[\"为了更好地理解\",{\"1\":{\"968\":1}}],[\"为了更加完整的了解\",{\"1\":{\"535\":1}}],[\"为了更加高效地管理内存空间\",{\"1\":{\"165\":1}}],[\"为了搞懂线程池的原理\",{\"1\":{\"941\":1}}],[\"为了搞清楚这个问题\",{\"1\":{\"42\":1,\"1030\":1}}],[\"为了引出\",{\"1\":{\"800\":1}}],[\"为了方便演示\",{\"1\":{\"1038\":1}}],[\"为了方便\",{\"1\":{\"784\":1}}],[\"为了验证笔者所说的观点\",{\"1\":{\"713\":1}}],[\"为了实现访问顺序遍历\",{\"1\":{\"705\":1}}],[\"为了实现多线程之间等待和唤醒的交互效率\",{\"1\":{\"607\":1}}],[\"为了能够帮助小伙伴们理解\",{\"1\":{\"1166\":1}}],[\"为了能够对一系列的值达成共识\",{\"1\":{\"1099\":1}}],[\"为了能让\",{\"1\":{\"684\":1}}],[\"为了能更方便的查询哪个环节的服务出现了问题\",{\"1\":{\"21\":1}}],[\"为了让这些线程都能得到有效执行\",{\"1\":{\"895\":1,\"922\":1}}],[\"为了让读者可以更直观的了解阻塞式获取元素的全流程\",{\"1\":{\"604\":1}}],[\"为了让一个查询尽量少地读磁盘\",{\"1\":{\"98\":1}}],[\"为了将读操作性能发挥到极致\",{\"1\":{\"584\":1,\"793\":1}}],[\"为了印证这一点\",{\"1\":{\"533\":1}}],[\"为了后续更加深入的了解\",{\"1\":{\"531\":1}}],[\"为了线程切换后能恢复到正确的执行位置\",{\"1\":{\"492\":1}}],[\"为了解决这一个问题\",{\"1\":{\"1271\":1}}],[\"为了解决这个问题\",{\"1\":{\"6\":1,\"685\":1,\"1043\":1,\"1069\":1}}],[\"为了解决内存缓存不一致性问题可以通过制定缓存一致协议\",{\"1\":{\"968\":1}}],[\"为了解决高并发场景下多线程之间数据共享的问题\",{\"1\":{\"529\":1}}],[\"为了解决标记\",{\"1\":{\"397\":1}}],[\"为了做到这一点\",{\"1\":{\"386\":1}}],[\"为了隔离\",{\"1\":{\"359\":1}}],[\"为了降低对\",{\"1\":{\"293\":1}}],[\"为了满足不同的业务场景\",{\"1\":{\"242\":1}}],[\"为了兼顾数据和写入性能\",{\"1\":{\"231\":1}}],[\"为了在发生错误时回滚之前的操作\",{\"1\":{\"137\":1}}],[\"为了维持\",{\"1\":{\"97\":1}}],[\"为了保证一致性\",{\"1\":{\"1368\":1}}],[\"为了保证高可用\",{\"1\":{\"1354\":1,\"1362\":1}}],[\"为了保证分布式系统能够同步访问某个资源\",{\"1\":{\"1341\":1}}],[\"为了保证整个\",{\"1\":{\"1206\":1}}],[\"为了保证上述要求\",{\"1\":{\"1116\":1}}],[\"为了保证线程中的局部变量不被别的线程访问到\",{\"1\":{\"812\":1}}],[\"为了保证线程安全还用到了可重入锁\",{\"1\":{\"607\":1}}],[\"为了保证线程安全\",{\"1\":{\"541\":1}}],[\"为了保证键值对移除后双向链表中的节点也会同步被移除\",{\"1\":{\"711\":1}}],[\"为了保证\",{\"1\":{\"708\":1,\"1068\":1,\"1206\":1,\"1281\":1}}],[\"为了保证使用\",{\"1\":{\"708\":1}}],[\"为了保证框架的通用性\",{\"1\":{\"523\":1}}],[\"为了保证迁移的一致性\",{\"1\":{\"167\":1}}],[\"为了保证共享资源被安全地访问\",{\"1\":{\"60\":1}}],[\"为了保证兑换码的有效性\",{\"1\":{\"19\":1}}],[\"为了防止因死循环导致\",{\"1\":{\"1012\":1}}],[\"为了防止\",{\"1\":{\"798\":1}}],[\"为了防止超卖\",{\"1\":{\"60\":1}}],[\"为了防止误删到其他的锁\",{\"1\":{\"47\":1}}],[\"为了防止单机多进程出现\",{\"1\":{\"22\":1}}],[\"为了避免消息队列服务器宕机造成消息丢失\",{\"1\":{\"1222\":1}}],[\"为了避免大家有强烈的审丑疲劳\",{\"1\":{\"1150\":1}}],[\"为了避免数据倾斜问题\",{\"1\":{\"1143\":1}}],[\"为了避免双亲委托机制\",{\"1\":{\"359\":1}}],[\"为了避免修改\",{\"1\":{\"256\":1}}],[\"为了避免对\",{\"1\":{\"233\":1}}],[\"为了避免单点故障\",{\"1\":{\"51\":1}}],[\"为了避免单点问题\",{\"1\":{\"34\":1}}],[\"为了避免锁无法被释放\",{\"1\":{\"48\":1}}],[\"为了避免在获取新号段的情况下\",{\"1\":{\"42\":1}}],[\"为了提高应用程序的稳定性\",{\"1\":{\"482\":1}}],[\"为了提高可用性和并发\",{\"1\":{\"35\":1}}],[\"为了提升执行速度\",{\"1\":{\"969\":1,\"981\":1}}],[\"为了提升性能和减少内存消耗针对字符串\",{\"1\":{\"498\":1}}],[\"为了提升性能不会把每次的修改都实时同步到磁盘\",{\"1\":{\"136\":1}}],[\"为了提升网关的性能\",{\"1\":{\"5\":1,\"68\":1}}],[\"为了增强兑换码的可识别度\",{\"1\":{\"19\":1}}],[\"在收到\",{\"1\":{\"1380\":1}}],[\"在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给\",{\"1\":{\"1373\":1}}],[\"在很多地方进行了超时中断的处理\",{\"1\":{\"1371\":1}}],[\"在很多互联网公司得到应用\",{\"1\":{\"1171\":1}}],[\"在成功的环境下的流程图\",{\"1\":{\"1371\":1}}],[\"在两阶段提交中\",{\"1\":{\"1370\":1}}],[\"在两个日志里\",{\"1\":{\"1112\":2}}],[\"在介绍\",{\"1\":{\"1370\":1,\"1378\":1}}],[\"在介绍共识算法之前\",{\"1\":{\"1105\":1}}],[\"在科学家和程序员的不断探索中\",{\"1\":{\"1369\":1}}],[\"在为客户端创建会话之前\",{\"1\":{\"1353\":1}}],[\"在前面我们已经提到\",{\"1\":{\"1350\":1}}],[\"在立项初期\",{\"1\":{\"1343\":1}}],[\"在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调\",{\"1\":{\"1343\":1}}],[\"在当时\",{\"1\":{\"1343\":1}}],[\"在最上面的那一块就是我刚刚讲的你现在可以直接\",{\"1\":{\"1315\":1}}],[\"在最坏的情况下也只会造成可用性问题\",{\"1\":{\"1106\":1}}],[\"在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中\",{\"1\":{\"1314\":1}}],[\"在上面我们提到了消息队列一个很重要的功能\",{\"1\":{\"1305\":1}}],[\"在上面我介绍\",{\"1\":{\"1298\":1}}],[\"在上面的技术架构介绍中\",{\"1\":{\"1299\":1}}],[\"在上面结构的基础上\",{\"1\":{\"645\":1}}],[\"在上面工作都完成之后\",{\"1\":{\"506\":1}}],[\"在单主从架构中\",{\"1\":{\"1314\":1}}],[\"在单核\",{\"1\":{\"819\":1}}],[\"在单核时代多线程主要是为了提高单进程利用\",{\"1\":{\"816\":1}}],[\"在主节点还未发送完需要同步的消息的时候主节点挂掉了\",{\"1\":{\"1314\":1}}],[\"在主题上是无序的\",{\"1\":{\"1299\":1}}],[\"在主题模型中\",{\"1\":{\"1279\":1}}],[\"在同步刷盘中需要等待一个刷盘成功的\",{\"1\":{\"1313\":1}}],[\"在同一个系统中我们可以轻松地实现事务\",{\"1\":{\"1304\":1}}],[\"在同一个系统中我们一般会使用事务来进行解决\",{\"1\":{\"1275\":1}}],[\"在同一个\",{\"1\":{\"280\":1}}],[\"在如上代码中\",{\"1\":{\"1311\":1}}],[\"在rocketmq\",{\"1\":{\"1306\":1}}],[\"在resize中再赋值给\",{\"1\":{\"621\":1}}],[\"在事务提交之前\",{\"1\":{\"1304\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"125\":1}}],[\"在第一阶段是只将提案编号发送给所有的表决者\",{\"1\":{\"1373\":1}}],[\"在第一步发送的\",{\"1\":{\"1304\":1}}],[\"在第一个事务中的两次读数据之间\",{\"1\":{\"128\":1}}],[\"在其他场景中来解决重复请求或者重复调用的问题\",{\"1\":{\"1303\":1}}],[\"在其中扮演了什么角色呢\",{\"1\":{\"1069\":1}}],[\"在轮询的策略下这\",{\"1\":{\"1299\":1}}],[\"在谈\",{\"1\":{\"1277\":1}}],[\"在每年的双十一当天\",{\"1\":{\"1276\":1}}],[\"在每秒几十上百次的切换中\",{\"1\":{\"895\":1,\"922\":1}}],[\"在阿里内部\",{\"1\":{\"1276\":1}}],[\"在生产者需要向\",{\"1\":{\"1281\":1}}],[\"在生产者这边我们只需要关注\",{\"1\":{\"1272\":1}}],[\"在生产环境的实施阶段就可以考虑使用\",{\"1\":{\"341\":1}}],[\"在镜像集群模式下\",{\"1\":{\"1263\":1}}],[\"在绑定队列和交换器时指定一组键值对\",{\"1\":{\"1252\":1}}],[\"在绑定多个队列到同一个交换器的时候\",{\"1\":{\"1249\":1}}],[\"在绑定的时候一般会指定一个\",{\"1\":{\"1249\":1}}],[\"在大数据领域中以及日志采集中\",{\"1\":{\"1240\":1}}],[\"在大多数情况下只有一个服务器会率先超时\",{\"1\":{\"1111\":1}}],[\"在吞吐量方面虽然稍逊于\",{\"1\":{\"1240\":1}}],[\"在安装\",{\"1\":{\"1237\":1}}],[\"在加入\",{\"1\":{\"1224\":1}}],[\"在加载你的\",{\"1\":{\"358\":1}}],[\"在加载时调用\",{\"1\":{\"354\":1}}],[\"在电子商务一些秒杀\",{\"1\":{\"1221\":1}}],[\"在日常学习与开发过程中\",{\"1\":{\"1217\":1}}],[\"在死信队列中\",{\"1\":{\"1213\":1}}],[\"在默认配置下\",{\"1\":{\"1209\":1}}],[\"在默认情况下\",{\"1\":{\"936\":1}}],[\"在消费监听器内将消息再次分发到自定义的其他线程\",{\"1\":{\"1292\":1}}],[\"在消费过程中\",{\"1\":{\"1209\":1}}],[\"在消息进入队列之前\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"在消息队列服务器宕机后\",{\"1\":{\"1222\":1}}],[\"在消息队列领域就像是一个衣衫褴褛的孩子一样\",{\"1\":{\"1191\":1}}],[\"在消息发布的时候进行处理\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"在维护\",{\"1\":{\"1199\":1}}],[\"在计算机系统中\",{\"1\":{\"1184\":1}}],[\"在国内有很多成功的案例比如当当网\",{\"1\":{\"1172\":1}}],[\"在慢慢融合\",{\"1\":{\"1155\":1,\"1161\":1}}],[\"在连接建立之后\",{\"1\":{\"1151\":1}}],[\"在定义了\",{\"1\":{\"1151\":1}}],[\"在定时任务调度中\",{\"1\":{\"609\":1}}],[\"在集群负载均衡时\",{\"1\":{\"1140\":1}}],[\"在集群中大多数服务器响应\",{\"1\":{\"1106\":1}}],[\"在微服务中应用更加广泛\",{\"1\":{\"1123\":1}}],[\"在易用性\",{\"1\":{\"1120\":1,\"1245\":1}}],[\"在保持原有核心功能特性的同时\",{\"1\":{\"1120\":1}}],[\"在选举过程中会参与投票\",{\"1\":{\"1378\":1}}],[\"在选举开始时\",{\"1\":{\"1109\":1}}],[\"在选主期间整个集群对外是不可用的\",{\"1\":{\"1115\":1}}],[\"在失败之后\",{\"1\":{\"1112\":1}}],[\"在该位置之后的日志\",{\"1\":{\"1112\":1}}],[\"在发布\",{\"1\":{\"1194\":1}}],[\"在发起选举后\",{\"1\":{\"1111\":1}}],[\"在发生\",{\"1\":{\"388\":1}}],[\"在发生紧急情况时\",{\"1\":{\"298\":1}}],[\"在正常的情况下\",{\"1\":{\"1108\":1}}],[\"在正式讨论\",{\"1\":{\"708\":1}}],[\"在有了大将军之后\",{\"1\":{\"1105\":1}}],[\"在有的语境中也用于指代整堆收集\",{\"1\":{\"387\":1}}],[\"在少于一半的节点出现故障时\",{\"1\":{\"1098\":1}}],[\"在看了论文之后\",{\"1\":{\"1096\":1}}],[\"在实现分布式锁这方面是非常非常简单的\",{\"1\":{\"1388\":1}}],[\"在实现反熵的时候\",{\"1\":{\"1087\":1}}],[\"在实际生产中应尽量避免默认值\",{\"1\":{\"1206\":1}}],[\"在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列\",{\"1\":{\"794\":1}}],[\"在实际开发中\",{\"1\":{\"781\":1}}],[\"在实际使用过程中存在一些局限性比如不支持异步任务的编排组合\",{\"1\":{\"774\":1,\"901\":1}}],[\"在实际使用中依然会有一些小问题不太好解决比如在\",{\"1\":{\"251\":1}}],[\"在实际的面试中\",{\"1\":{\"43\":1}}],[\"在实际项目中使用的并不多\",{\"1\":{\"864\":1}}],[\"在实际项目中的运用\",{\"1\":{\"788\":1}}],[\"在实际项目中\",{\"1\":{\"38\":1}}],[\"在故障时可以自动切换\",{\"1\":{\"1085\":1}}],[\"在向consumer\",{\"1\":{\"1306\":1}}],[\"在向\",{\"1\":{\"1078\":1}}],[\"在经过一段时间的同步后\",{\"1\":{\"1078\":1}}],[\"在系统发生\",{\"1\":{\"1070\":1}}],[\"在进行分布式系统设计和开发时\",{\"1\":{\"1070\":1}}],[\"在进行回收前就要判断哪些对象还存活\",{\"1\":{\"445\":1}}],[\"在设计的时候就是优先保证\",{\"1\":{\"1069\":1}}],[\"在此基础上\",{\"1\":{\"1068\":1}}],[\"在此列表中的指定位置插入指定的元素\",{\"1\":{\"553\":1,\"561\":1}}],[\"在理论计算机科学中\",{\"1\":{\"1067\":1}}],[\"在密集\",{\"1\":{\"1062\":1}}],[\"在引入虚拟线程之前\",{\"1\":{\"1053\":1}}],[\"在init方法中拷贝父线程数据到子线程中\",{\"1\":{\"1043\":1}}],[\"在异步场景下是无法给子线程共享父线程中创建的线程副本数据的\",{\"1\":{\"1043\":1}}],[\"在threadlocalmap\",{\"1\":{\"1038\":1}}],[\"在timertask\",{\"1\":{\"962\":1}}],[\"在往后迭代的过程中碰到空的槽位\",{\"1\":{\"1037\":1}}],[\"在entry为null的桶中创建一个新的entry对象\",{\"1\":{\"1036\":1}}],[\"在找到entry为null的槽位之前\",{\"1\":{\"1035\":2}}],[\"在set过程中\",{\"1\":{\"1033\":1}}],[\"在semaphore中的资源即许可证\",{\"1\":{\"748\":1}}],[\"在散列表中对应的数组下标位置\",{\"1\":{\"1032\":1}}],[\"在自己的map里找对应的key\",{\"1\":{\"1029\":1}}],[\"在自旋时顺表获取下\",{\"1\":{\"571\":1}}],[\"在整个集群中保持数据的一致性\",{\"1\":{\"1379\":1}}],[\"在整个流程中\",{\"1\":{\"1015\":1}}],[\"在整个请求的调用链中\",{\"1\":{\"21\":1}}],[\"在产生\",{\"1\":{\"1014\":1}}],[\"在解决分布式数据一致性问题时并没有直接使用\",{\"1\":{\"1377\":1}}],[\"在解决哈希冲突时有了较大的变化\",{\"1\":{\"616\":1,\"677\":1}}],[\"在解锁的时候\",{\"1\":{\"1014\":1}}],[\"在非公平锁中\",{\"1\":{\"1008\":1}}],[\"在要出现问题之前快速解决问题\",{\"1\":{\"985\":1}}],[\"在运行时如何分区存储程序数据\",{\"1\":{\"973\":1}}],[\"在不可靠信道上试图通过消息传递的方式达到一致性是不可能的\",{\"1\":{\"1369\":1}}],[\"在不影响写性能的情况下提升集群的读性能\",{\"1\":{\"1355\":1}}],[\"在不改变单线程程序语义的前提下\",{\"1\":{\"969\":1}}],[\"在不同的虚拟机实现上\",{\"1\":{\"496\":1}}],[\"在示例代码中\",{\"1\":{\"941\":1}}],[\"在调用服务\",{\"1\":{\"1045\":1}}],[\"在调用\",{\"1\":{\"884\":1,\"924\":1}}],[\"在调度线程上更加灵活\",{\"1\":{\"544\":1,\"862\":1}}],[\"在垃圾回收器线程扫描它\",{\"1\":{\"884\":1}}],[\"在垃圾回收器线程扫描它所管辖的内存区域的过程中\",{\"1\":{\"392\":1}}],[\"在垃圾回收的时候\",{\"1\":{\"884\":1}}],[\"在获取锁的时候会返回一个\",{\"1\":{\"871\":1}}],[\"在获取号段的时候阻塞请求获取\",{\"1\":{\"41\":1}}],[\"在下面的代码中\",{\"1\":{\"860\":1}}],[\"在操作员\",{\"1\":{\"840\":1,\"989\":1}}],[\"在操作系统层面\",{\"1\":{\"820\":1}}],[\"在提交更新时\",{\"1\":{\"840\":1,\"989\":1}}],[\"在读取数据时\",{\"1\":{\"1078\":1}}],[\"在读取数据的同时也会读取\",{\"1\":{\"840\":1,\"989\":1}}],[\"在读多写少的情况下\",{\"1\":{\"866\":1}}],[\"在读多写少的场合性能非常好\",{\"1\":{\"791\":1}}],[\"在性能上往往会更胜一筹\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"在对应的\",{\"1\":{\"1182\":1}}],[\"在对这个变量进行读写操作的时候\",{\"1\":{\"834\":1}}],[\"在对象被移动时只会改变句柄中的实例数据指针\",{\"1\":{\"510\":1}}],[\"在等待\",{\"1\":{\"819\":1}}],[\"在等待期间\",{\"1\":{\"535\":1}}],[\"在任意的时间\",{\"1\":{\"1108\":1}}],[\"在任务比较多的时候会导致\",{\"1\":{\"951\":1}}],[\"在任务中的多个线程没有资源竞争的情况下\",{\"1\":{\"816\":1}}],[\"在任何时候都可能被垃圾回收\",{\"1\":{\"392\":1}}],[\"在跳表中查找元素18\",{\"1\":{\"800\":1}}],[\"在跳表中查找元素\",{\"1\":{\"800\":1}}],[\"在高并发场景下会比\",{\"1\":{\"838\":1,\"987\":1}}],[\"在高并发环境下\",{\"1\":{\"800\":1}}],[\"在高并发的情况下保证节点创建的全局唯一性\",{\"1\":{\"1387\":1,\"1388\":1}}],[\"在高并发的情况下\",{\"1\":{\"800\":1}}],[\"在并发场景下如果要保证一种可行的方式是使用\",{\"1\":{\"792\":1}}],[\"在化学反应中是不可分割的\",{\"1\":{\"762\":1}}],[\"在化学上\",{\"1\":{\"762\":1}}],[\"在构造函数中初始化的\",{\"1\":{\"753\":1}}],[\"在子类中无法被重写\",{\"1\":{\"742\":1,\"904\":1}}],[\"在指定位置插入元素\",{\"1\":{\"733\":1}}],[\"在指定元素之前插入元素\",{\"1\":{\"729\":1}}],[\"在指定列表的头部\",{\"1\":{\"181\":1}}],[\"在指定列表的尾部\",{\"1\":{\"181\":1}}],[\"在面试中这个问题在面试官问到\",{\"1\":{\"1166\":1}}],[\"在面试中被问到并发知识的时候\",{\"1\":{\"741\":1}}],[\"在面试中可能更多的会出现在手撕算法的时候\",{\"1\":{\"669\":1}}],[\"在面向对象编程中\",{\"1\":{\"356\":1}}],[\"在队列的两端均可以插入或删除元素\",{\"1\":{\"667\":1}}],[\"在索引为1的位置插入一个元素8\",{\"1\":{\"653\":1}}],[\"在平时开发中还是比较常见的\",{\"1\":{\"634\":1}}],[\"在编程中一个幂等\",{\"1\":{\"1303\":1}}],[\"在编写程序中\",{\"1\":{\"624\":1}}],[\"在编译之后都会变成\",{\"1\":{\"522\":1}}],[\"在编译器编译生成的字节码的时候会去掉\",{\"1\":{\"522\":1}}],[\"在链表指定位置插入元素\",{\"1\":{\"729\":1}}],[\"在链表尾部插入元素\",{\"1\":{\"729\":1}}],[\"在链表末端\",{\"1\":{\"711\":1}}],[\"在链表首部\",{\"1\":{\"711\":1}}],[\"在链表长度超过一定阈值\",{\"1\":{\"691\":1}}],[\"在链表中get\",{\"1\":{\"623\":1}}],[\"在链表最末插入结点\",{\"1\":{\"622\":1}}],[\"在树中get\",{\"1\":{\"623\":1}}],[\"在尾部插入新结点\",{\"1\":{\"622\":1}}],[\"在某些情况下可能读到旧的元素值\",{\"1\":{\"589\":1}}],[\"在某个数据页上做了什么修改\",{\"1\":{\"89\":1}}],[\"在写入数据\",{\"1\":{\"1078\":1}}],[\"在写入比较频繁的场景下\",{\"1\":{\"585\":1}}],[\"在写操作不频繁且内存资源充足的情况下\",{\"1\":{\"588\":1}}],[\"在写数据的过程中\",{\"1\":{\"145\":2}}],[\"在数据被缓存到内存之后\",{\"1\":{\"609\":1}}],[\"在数据量比较大的情况下\",{\"1\":{\"585\":1}}],[\"在数据文件中\",{\"1\":{\"94\":1}}],[\"在冲突小于一定数量时又退回链表\",{\"1\":{\"579\":1}}],[\"在后面我会介绍到\",{\"1\":{\"1331\":1}}],[\"在后面使用线程池的过程中你一定会用到\",{\"1\":{\"936\":1}}],[\"在后面\",{\"1\":{\"570\":1}}],[\"在添加第一个元素后扩容成\",{\"1\":{\"557\":1}}],[\"在添加大量元素前\",{\"1\":{\"549\":1}}],[\"在添加元素上并不会向\",{\"1\":{\"529\":1}}],[\"在创建时可以指定容量大小\",{\"1\":{\"671\":1}}],[\"在创建时需要指定容量大小\",{\"1\":{\"671\":1}}],[\"在创建时就会占用一定的内存空间\",{\"1\":{\"542\":1,\"672\":1}}],[\"在创建对象的时候有一个很重要的问题\",{\"1\":{\"503\":1}}],[\"在初始化容量和锁的非公平性之后\",{\"1\":{\"534\":1}}],[\"在了解完上述知识点以后\",{\"1\":{\"1018\":1}}],[\"在了解数据结构后\",{\"1\":{\"1006\":1}}],[\"在了解\",{\"1\":{\"533\":1}}],[\"在切面编程\",{\"1\":{\"523\":1}}],[\"在给线程中的对象分配内存时\",{\"1\":{\"503\":1}}],[\"在类加载检查通过后\",{\"1\":{\"503\":1}}],[\"在类加载的时候\",{\"1\":{\"352\":1,\"357\":1}}],[\"在一定时间内\",{\"1\":{\"1371\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"324\":1}}],[\"在一开始我跟你提到了一个\",{\"1\":{\"1278\":1}}],[\"在一条\",{\"1\":{\"1260\":1}}],[\"在一条消息广播之后才订阅的用户则是收不到该条消息的\",{\"1\":{\"1194\":1}}],[\"在一个任期内收到了来自集群内的多数选票\",{\"1\":{\"1111\":1}}],[\"在一个周期内没有收到心跳信息\",{\"1\":{\"1111\":1}}],[\"在一些处理器上延迟时间是零\",{\"1\":{\"844\":1,\"993\":1}}],[\"在一些文章中将直接内存等价于堆外内存\",{\"1\":{\"499\":1}}],[\"在一次新生代垃圾回收后\",{\"1\":{\"495\":1}}],[\"在本地方法栈也会创建一个栈帧\",{\"1\":{\"494\":1}}],[\"在本篇文章中\",{\"1\":{\"476\":1}}],[\"在多线程环境下\",{\"1\":{\"686\":1}}],[\"在多线程环境下扩容操作可能存在死循环问题\",{\"1\":{\"685\":1}}],[\"在多线程环境中\",{\"1\":{\"60\":1}}],[\"在多线程的情况下\",{\"1\":{\"492\":1,\"811\":1}}],[\"在虚拟机自动内存管理机制下\",{\"1\":{\"490\":1}}],[\"在虚拟机启动时创建\",{\"1\":{\"477\":1,\"495\":1}}],[\"在名称中找到一个\",{\"1\":{\"484\":1}}],[\"在遇到\",{\"1\":{\"484\":1}}],[\"在堆内存所占的比例\",{\"1\":{\"479\":1}}],[\"在堆总可用内存配置完成之后\",{\"1\":{\"479\":1}}],[\"在堆中创建字符串对象\",{\"1\":{\"498\":1}}],[\"在堆中生成一个代表这个类的\",{\"1\":{\"428\":1}}],[\"在堆中为一个新的\",{\"1\":{\"425\":1}}],[\"在论坛中有这样一句话\",{\"1\":{\"449\":1}}],[\"在相同物理内存下\",{\"1\":{\"449\":1,\"458\":1}}],[\"在注重吞吐量以及\",{\"1\":{\"405\":1}}],[\"在标记阶段\",{\"1\":{\"396\":1}}],[\"在标记完成后统一回收掉所有没有被标记的对象\",{\"1\":{\"396\":1}}],[\"在程序世界中\",{\"1\":{\"985\":1}}],[\"在程序设计中一般很少使用弱引用与虚引用\",{\"1\":{\"392\":1}}],[\"在程序执行方法时\",{\"1\":{\"343\":1}}],[\"在没有锁竞争的时候会省去唤醒操作\",{\"1\":{\"1183\":1}}],[\"在没有得到结果之前\",{\"1\":{\"815\":1}}],[\"在没有\",{\"1\":{\"366\":1}}],[\"在没有同步到其他节点时\",{\"1\":{\"51\":1}}],[\"在父类加载器没有找到所请求的类的情况下\",{\"1\":{\"357\":1}}],[\"在需要的时候自动创建的\",{\"1\":{\"340\":1,\"351\":1}}],[\"在内存中可见\",{\"1\":{\"765\":1}}],[\"在内存中生成一个代表该类的\",{\"1\":{\"340\":1,\"349\":1,\"351\":1}}],[\"在内部经过多次迭代开发\",{\"1\":{\"233\":1}}],[\"在常量池结束之后\",{\"1\":{\"329\":1}}],[\"在位数组中把对应下标的值置为\",{\"1\":{\"307\":1}}],[\"在业务代码中添加相应的逻辑对\",{\"1\":{\"298\":1}}],[\"在关闭\",{\"1\":{\"298\":1}}],[\"在线程持有写锁的情况下\",{\"1\":{\"868\":1}}],[\"在线程持有读锁的情况下\",{\"1\":{\"868\":1}}],[\"在线上执行该命令时\",{\"1\":{\"293\":1}}],[\"在线活跃用户数\",{\"1\":{\"261\":1}}],[\"在客户端\",{\"1\":{\"280\":1}}],[\"在键空间中\",{\"1\":{\"273\":2,\"298\":1}}],[\"在bio\",{\"1\":{\"268\":1}}],[\"在绝大部分情况\",{\"1\":{\"255\":1}}],[\"在服务器内存使用完之后\",{\"1\":{\"245\":2}}],[\"在服务器端看到了越来越多的用例\",{\"1\":{\"8\":1}}],[\"在启动时\",{\"1\":{\"1199\":1}}],[\"在启动时会比较计算出的校验和与文件末尾保存的校验和\",{\"1\":{\"234\":1}}],[\"在启动时对\",{\"1\":{\"234\":1}}],[\"在过去写期间的增量数据需要在内存中保留\",{\"1\":{\"233\":1}}],[\"在60秒\",{\"1\":{\"226\":1}}],[\"在300秒\",{\"1\":{\"226\":1}}],[\"在900秒\",{\"1\":{\"226\":1}}],[\"在扩缩容的时候\",{\"1\":{\"167\":1}}],[\"在应用程序释放内存时\",{\"1\":{\"165\":1}}],[\"在命令执行完之后再记录\",{\"1\":{\"160\":1,\"232\":1}}],[\"在请求量大的时候\",{\"1\":{\"1158\":1}}],[\"在请求\",{\"1\":{\"145\":1}}],[\"在请求被转发到微服务之前\",{\"1\":{\"73\":1}}],[\"在可重复读隔离级别\",{\"1\":{\"141\":1}}],[\"在这样下去\",{\"1\":{\"1343\":1}}],[\"在这篇论文中\",{\"1\":{\"974\":1,\"1096\":1}}],[\"在这种模式中\",{\"1\":{\"1354\":1}}],[\"在这种\",{\"1\":{\"1155\":1}}],[\"在这种情况下\",{\"1\":{\"1010\":1}}],[\"在这种饱和策略下\",{\"1\":{\"891\":1}}],[\"在这种架构模式下\",{\"1\":{\"42\":1}}],[\"在这期间我还可以取消任务以及获取任务的执行状态\",{\"1\":{\"773\":1,\"899\":1}}],[\"在这里\",{\"1\":{\"1087\":1}}],[\"在这里计算新的resize上限\",{\"1\":{\"624\":1}}],[\"在这里进行阈值初始化\",{\"1\":{\"624\":1}}],[\"在这个阶段\",{\"1\":{\"1356\":1}}],[\"在这个时间点\",{\"1\":{\"688\":1}}],[\"在这个位置赋值为\",{\"1\":{\"571\":1}}],[\"在这个事务还没有结束时\",{\"1\":{\"128\":1}}],[\"在这行的列值可被优化器剩余部分认为是常数\",{\"1\":{\"120\":1}}],[\"在我们实际应用场景中\",{\"1\":{\"1087\":1}}],[\"在我们这里\",{\"1\":{\"762\":1}}],[\"在我们的这个例子中\",{\"1\":{\"117\":1}}],[\"在我看来\",{\"1\":{\"42\":1,\"144\":1,\"658\":1}}],[\"在图中最左边说明了红色方块代表被写入的消息\",{\"1\":{\"1315\":1}}],[\"在图\",{\"1\":{\"117\":1}}],[\"在mysql官网\",{\"1\":{\"115\":1}}],[\"在机械硬盘时代\",{\"1\":{\"98\":1}}],[\"在avl树中任何节点的两个子树的高度最大差别为1\",{\"1\":{\"98\":1}}],[\"在之后用\",{\"1\":{\"89\":1}}],[\"在使用上官方为了降低使用门槛\",{\"1\":{\"1057\":1}}],[\"在使用线程池等会池化复用线程的执行组件情况下\",{\"1\":{\"929\":1}}],[\"在使用线程池时\",{\"1\":{\"925\":1}}],[\"在使用过程中不断的往里面存放数据\",{\"1\":{\"619\":1}}],[\"在使用notify\",{\"1\":{\"544\":1,\"862\":1}}],[\"在使用\",{\"1\":{\"72\":1,\"373\":1,\"630\":1,\"694\":1}}],[\"在执行过程中不允许被中断\",{\"1\":{\"1344\":1}}],[\"在执行引擎使用这个变量前\",{\"1\":{\"972\":1}}],[\"在执行monitorenter时\",{\"1\":{\"851\":1}}],[\"在执行\",{\"1\":{\"47\":1,\"162\":1,\"851\":1}}],[\"在分区故障恢复后\",{\"1\":{\"1074\":1}}],[\"在分配的时候\",{\"1\":{\"503\":1}}],[\"在分库分表\",{\"1\":{\"1143\":1}}],[\"在分库分表下\",{\"1\":{\"412\":1}}],[\"在分库之后\",{\"1\":{\"29\":1}}],[\"在分布式定时调度触发\",{\"1\":{\"1285\":1}}],[\"在分布式系统中\",{\"1\":{\"1083\":1}}],[\"在分布式环境中\",{\"1\":{\"974\":1}}],[\"在分布式链路跟踪中有两个重要的概念\",{\"1\":{\"21\":1}}],[\"在分布式链路跟踪\",{\"1\":{\"21\":1}}],[\"在分布式服务架构下\",{\"1\":{\"21\":1}}],[\"在跨层传递透传的同时\",{\"1\":{\"23\":1}}],[\"在\",{\"0\":{\"1199\":1},\"1\":{\"23\":1,\"41\":1,\"47\":1,\"60\":1,\"69\":2,\"70\":1,\"77\":1,\"101\":1,\"117\":3,\"120\":1,\"146\":1,\"161\":1,\"226\":1,\"231\":2,\"264\":1,\"266\":1,\"282\":1,\"286\":1,\"292\":1,\"302\":1,\"324\":1,\"333\":1,\"345\":1,\"377\":1,\"382\":1,\"393\":1,\"408\":2,\"443\":1,\"445\":1,\"446\":1,\"448\":1,\"452\":1,\"455\":1,\"494\":1,\"495\":1,\"496\":1,\"507\":1,\"537\":1,\"549\":1,\"571\":1,\"577\":1,\"578\":1,\"583\":1,\"588\":2,\"598\":4,\"658\":1,\"680\":2,\"686\":1,\"688\":1,\"742\":1,\"753\":1,\"773\":1,\"792\":1,\"793\":1,\"806\":2,\"808\":3,\"812\":1,\"833\":2,\"834\":2,\"838\":1,\"847\":2,\"851\":1,\"876\":1,\"889\":1,\"899\":1,\"904\":1,\"934\":1,\"941\":1,\"969\":1,\"972\":1,\"978\":1,\"979\":1,\"980\":1,\"1014\":1,\"1018\":1,\"1030\":1,\"1048\":1,\"1053\":2,\"1069\":1,\"1072\":1,\"1084\":1,\"1085\":1,\"1096\":2,\"1111\":1,\"1112\":1,\"1122\":1,\"1140\":1,\"1142\":1,\"1157\":1,\"1159\":1,\"1161\":1,\"1178\":1,\"1199\":3,\"1200\":2,\"1208\":1,\"1231\":1,\"1235\":2,\"1249\":1,\"1257\":1,\"1276\":1,\"1281\":1,\"1293\":1,\"1304\":3,\"1310\":1,\"1312\":1,\"1315\":2,\"1344\":2,\"1355\":1,\"1359\":1,\"1360\":1,\"1362\":1,\"1371\":1,\"1372\":1,\"1378\":1,\"1379\":2,\"1382\":1,\"1383\":1,\"1384\":1,\"1390\":1}}],[\"在活动正式开始前提供出来进行活动预热\",{\"1\":{\"19\":1}}],[\"在文库购买\",{\"1\":{\"19\":1}}],[\"在文库的应用中\",{\"1\":{\"17\":1}}],[\"在订单号的设计上需要体现几个特性\",{\"1\":{\"18\":1}}],[\"在部署的时候\",{\"1\":{\"1\":1}}],[\"提醒\",{\"1\":{\"1315\":1}}],[\"提前订阅主题\",{\"1\":{\"1279\":1}}],[\"提议者负责接受客户端的请求并发起提案\",{\"1\":{\"1098\":1}}],[\"提议者\",{\"1\":{\"1098\":1}}],[\"提案信息通常包括提案编号\",{\"1\":{\"1098\":1}}],[\"提案\",{\"1\":{\"1097\":1}}],[\"提案的含义在分布式系统中十分宽泛\",{\"1\":{\"1097\":1}}],[\"提升读取消息的效率\",{\"1\":{\"1315\":1}}],[\"提升节点间数据的相似度\",{\"1\":{\"1087\":1}}],[\"提升用户的支付体验\",{\"1\":{\"17\":1}}],[\"提到的来说一下使用线程池的好处\",{\"1\":{\"887\":1}}],[\"提到事务\",{\"1\":{\"124\":1}}],[\"提高数据的写入效率\",{\"1\":{\"1315\":1}}],[\"提高并发能力\",{\"1\":{\"1280\":1}}],[\"提高并发访问率\",{\"1\":{\"688\":1,\"792\":1}}],[\"提高程序的性能\",{\"1\":{\"1184\":1}}],[\"提高程序执行效率\",{\"1\":{\"787\":1}}],[\"提高集群利用率\",{\"1\":{\"1123\":1}}],[\"提高线程的可管理性\",{\"1\":{\"887\":1,\"933\":1}}],[\"提高响应速度\",{\"1\":{\"887\":1,\"933\":1}}],[\"提高对资源的利用率\",{\"1\":{\"887\":1,\"932\":1}}],[\"提高用户体验\",{\"1\":{\"403\":1}}],[\"提高网络\",{\"1\":{\"264\":1}}],[\"提高了\",{\"1\":{\"1313\":1}}],[\"提高了容灾能力\",{\"1\":{\"1197\":1}}],[\"提高了效率\",{\"1\":{\"819\":1}}],[\"提高了其并发操作性能\",{\"1\":{\"598\":1}}],[\"提高了其性能和可靠性\",{\"1\":{\"598\":1}}],[\"提高了可用性\",{\"1\":{\"42\":1}}],[\"提高了开发效率\",{\"1\":{\"8\":1}}],[\"提交是什么意思呢\",{\"1\":{\"1380\":1}}],[\"提交\",{\"1\":{\"1380\":1}}],[\"提交的提案最终能够被所有的\",{\"1\":{\"1380\":2}}],[\"提交的数据版本号为\",{\"1\":{\"840\":1,\"989\":1}}],[\"提交完毕之后将给协调者发送提交成功的响应\",{\"1\":{\"1370\":1}}],[\"提交操作\",{\"1\":{\"1370\":1}}],[\"提交消费结果\",{\"1\":{\"1293\":1}}],[\"提交给状态机\",{\"1\":{\"1110\":1}}],[\"提交给了\",{\"1\":{\"773\":1,\"899\":1}}],[\"提交任务到任务队列\",{\"1\":{\"958\":1}}],[\"提交到线程池的任务实现\",{\"1\":{\"897\":1}}],[\"提交版本必须等于当前版本才能执行更新\",{\"1\":{\"840\":1,\"989\":1}}],[\"提交至数据库更新\",{\"1\":{\"840\":1,\"989\":1}}],[\"提交记录可以看出\",{\"1\":{\"244\":1}}],[\"提交事务\",{\"1\":{\"127\":1,\"128\":1,\"129\":1}}],[\"提出一个方案\",{\"1\":{\"1375\":1}}],[\"提出后\",{\"1\":{\"1374\":1}}],[\"提出\",{\"1\":{\"1096\":1}}],[\"提出了逻辑时钟的概念\",{\"1\":{\"974\":1}}],[\"提出查询条件等等\",{\"1\":{\"86\":1}}],[\"提出查询的表\",{\"1\":{\"86\":1}}],[\"提出字段名\",{\"1\":{\"86\":1}}],[\"提供秒杀服务\",{\"1\":{\"1367\":1}}],[\"提供高可用支持\",{\"1\":{\"1344\":1}}],[\"提供确保整个集群只有一个\",{\"1\":{\"1344\":1}}],[\"提供消费服务\",{\"1\":{\"1281\":1}}],[\"提供帧的处理\",{\"1\":{\"1253\":1}}],[\"提供可靠性同步机制和错误处理\",{\"1\":{\"1253\":1}}],[\"提供轻量\",{\"1\":{\"1236\":1}}],[\"提供两种消息模型\",{\"1\":{\"1231\":1}}],[\"提供元数据的管理的功能\",{\"1\":{\"1199\":1}}],[\"提供远程方法的一端\",{\"1\":{\"1166\":1}}],[\"提供threadlocal值的传递功能\",{\"1\":{\"929\":1}}],[\"提供给开发者使用\",{\"1\":{\"516\":1}}],[\"提供java的开发和运行环境\",{\"1\":{\"516\":1}}],[\"提供java运行时环境\",{\"1\":{\"516\":1}}],[\"提供在\",{\"1\":{\"377\":1}}],[\"提供\",{\"1\":{\"273\":1,\"1344\":1}}],[\"提供的持久化消息存储机制保证消息传递\",{\"1\":{\"1238\":1}}],[\"提供的路由算法\",{\"1\":{\"1231\":1}}],[\"提供的功能优点类似于\",{\"1\":{\"1178\":1}}],[\"提供的负载均衡策略有哪些\",{\"0\":{\"1140\":1}}],[\"提供的协作式中断知识内容\",{\"1\":{\"1015\":1}}],[\"提供的下面这些方法\",{\"1\":{\"896\":1,\"923\":1}}],[\"提供的所有现成的\",{\"1\":{\"860\":1}}],[\"提供的线程安全的\",{\"1\":{\"794\":1}}],[\"提供的这些容器大部分在\",{\"1\":{\"791\":1}}],[\"提供的钩子方法\",{\"1\":{\"744\":1}}],[\"提供的一个集合类\",{\"1\":{\"702\":1}}],[\"提供的一种实时查看\",{\"1\":{\"298\":1}}],[\"提供的注解\",{\"1\":{\"359\":1}}],[\"提供的接口\",{\"1\":{\"359\":1}}],[\"提供的类\",{\"1\":{\"345\":1}}],[\"提供的数据结构\",{\"1\":{\"249\":1}}],[\"提供的\",{\"1\":{\"205\":1,\"212\":1,\"1222\":1,\"1344\":1}}],[\"提供的限流功能比较简易且不易使用\",{\"1\":{\"76\":1}}],[\"提供了以下几种方式\",{\"1\":{\"1351\":1}}],[\"提供了以下\",{\"1\":{\"1351\":1}}],[\"提供了许多插件\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"提供了五种消息模型\",{\"1\":{\"1231\":1}}],[\"提供了一种可以通过\",{\"1\":{\"1315\":1}}],[\"提供了一个易用的用户界面\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"提供了一个完整的流式处理类库\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"提供了一些原子性的复合操作\",{\"1\":{\"694\":1}}],[\"提供了一些参数\",{\"1\":{\"484\":1}}],[\"提供了从服务定义\",{\"1\":{\"1168\":1}}],[\"提供了六大核心能力\",{\"1\":{\"1122\":1}}],[\"提供了什么服务呢\",{\"1\":{\"1069\":1}}],[\"提供了大量用于自定义同步器实现的\",{\"1\":{\"1007\":1}}],[\"提供了很多对多线程友好的方法\",{\"1\":{\"909\":1}}],[\"提供了很多开箱即用的功能\",{\"1\":{\"49\":1}}],[\"提供了三种模式的读写控制模式\",{\"1\":{\"871\":1}}],[\"提供了atomicreference类来保证引用对象之间的原子性\",{\"1\":{\"845\":1,\"994\":1}}],[\"提供了可阻塞的插入和移除的方法\",{\"1\":{\"796\":1}}],[\"提供了按照插入顺序或访问顺序迭代元素的功能\",{\"1\":{\"719\":1}}],[\"提供了多种均衡策略\",{\"1\":{\"1140\":1}}],[\"提供了多种全局处理的方式\",{\"1\":{\"77\":1}}],[\"提供了多个静态方法可以把他们包装成线程同步的集合\",{\"1\":{\"698\":1}}],[\"提供了多个synchronizedxxx\",{\"1\":{\"698\":1}}],[\"提供了判断某个元素是否在一个\",{\"1\":{\"188\":1}}],[\"提供了两个命令来生成\",{\"1\":{\"158\":1,\"227\":1}}],[\"提供了\",{\"1\":{\"41\":1,\"538\":1,\"900\":1,\"1069\":1,\"1281\":1}}],[\"提供了插件机制来扩展其功能\",{\"1\":{\"7\":1}}],[\"提示\",{\"1\":{\"15\":1,\"1120\":1,\"1217\":1}}],[\"通知\",{\"1\":{\"1344\":1,\"1346\":1}}],[\"通知注册的重试监听器\",{\"1\":{\"1210\":1}}],[\"通知其他节点将故障节点\",{\"1\":{\"1085\":1}}],[\"通知机制\",{\"1\":{\"862\":1}}],[\"通知或中断\",{\"1\":{\"820\":1}}],[\"通知调用取元素方法而阻塞的线程来争抢这个任务\",{\"1\":{\"603\":1}}],[\"通知因为队列为空时调用\",{\"1\":{\"603\":1}}],[\"通知那些被打断的线程当前队列状态非满\",{\"1\":{\"535\":1}}],[\"通知队列非空\",{\"1\":{\"535\":2}}],[\"通知此时条件非空\",{\"1\":{\"535\":1}}],[\"通知获取锁失败的客户端\",{\"1\":{\"55\":1}}],[\"通用的开源\",{\"1\":{\"1170\":1}}],[\"通用\",{\"1\":{\"177\":2}}],[\"通用唯一标识符\",{\"1\":{\"37\":1}}],[\"通用券\",{\"1\":{\"19\":1}}],[\"通常多台机器会部署在不同机房\",{\"1\":{\"1358\":1}}],[\"通常来说\",{\"1\":{\"1219\":1}}],[\"通常来讲\",{\"1\":{\"503\":1}}],[\"通常被分为多级缓存\",{\"1\":{\"1184\":1}}],[\"通常被用于实现诸如数据发布\",{\"1\":{\"1344\":1}}],[\"通常被用于暂停执行\",{\"1\":{\"825\":1}}],[\"通常被用于线程间交互\",{\"1\":{\"825\":1}}],[\"通常分为三层\",{\"1\":{\"968\":1}}],[\"通常用于那些资源有明确访问数量限制的场景比如限流\",{\"1\":{\"747\":1,\"905\":1}}],[\"通常用于实现定时任务调度和缓存过期删除等场景\",{\"1\":{\"609\":1}}],[\"通常\",{\"1\":{\"523\":1,\"1354\":2}}],[\"通常会降低吞吐量\",{\"1\":{\"797\":1}}],[\"通常会将\",{\"1\":{\"451\":1}}],[\"通常会比\",{\"1\":{\"236\":1}}],[\"通常表示为\",{\"1\":{\"353\":1}}],[\"通常情况\",{\"1\":{\"342\":1}}],[\"通常情况下\",{\"1\":{\"45\":1,\"112\":1,\"219\":1,\"249\":1,\"881\":1,\"1132\":1}}],[\"通常由\",{\"1\":{\"286\":1}}],[\"通常不会轻易释放内存给操作系统\",{\"1\":{\"218\":1}}],[\"通常不建议这样实现分布式锁\",{\"1\":{\"178\":1}}],[\"通常都是执行命令之前记录日志\",{\"1\":{\"160\":1,\"232\":1}}],[\"通常创建辅助索引就是为了提升查询效率\",{\"1\":{\"114\":1}}],[\"通常说的主键索引就是聚簇索引\",{\"1\":{\"113\":1}}],[\"通常使用搜索引擎如\",{\"1\":{\"103\":2,\"104\":1}}],[\"通常是因为消息格式错误\",{\"1\":{\"1213\":1}}],[\"通常是因为缓存中的那份数据已经过期\",{\"1\":{\"309\":1,\"311\":1,\"315\":1}}],[\"通常是由于下面这些原因产生的\",{\"1\":{\"292\":1}}],[\"通常是组或用户\",{\"1\":{\"37\":1}}],[\"通常是\",{\"1\":{\"37\":1}}],[\"通常是个不错的选择\",{\"1\":{\"10\":1}}],[\"通常在创建\",{\"1\":{\"798\":1}}],[\"通常在\",{\"1\":{\"19\":1}}],[\"通俗易懂\",{\"1\":{\"11\":1,\"996\":1}}],[\"通信的渠道\",{\"1\":{\"1260\":1}}],[\"通信框架\",{\"1\":{\"1171\":1}}],[\"通信协议\",{\"1\":{\"1168\":1}}],[\"通信\",{\"1\":{\"8\":1,\"825\":1,\"1168\":1}}],[\"通过注册中心找到相应的服务的地址列表\",{\"1\":{\"1390\":1}}],[\"通过其\",{\"1\":{\"1379\":1}}],[\"通过本文\",{\"1\":{\"1341\":1}}],[\"通过网络请求将消息发送到\",{\"1\":{\"1301\":1}}],[\"通过消费者分组实现消费性能的水平扩展以及高可用容灾\",{\"1\":{\"1297\":1}}],[\"通过埋点组件收集前端应用的相关操作日志\",{\"1\":{\"1284\":1}}],[\"通过元数据\",{\"1\":{\"1263\":1}}],[\"通过交换器来路由消息\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"通过异步处理提高系统性能\",{\"0\":{\"1220\":1},\"1\":{\"1219\":1,\"1220\":1}}],[\"通过定时任务在业务不繁忙\",{\"1\":{\"1207\":1}}],[\"通过定时对账检测副本数据的一致性\",{\"1\":{\"1078\":1}}],[\"通过偏移量\",{\"1\":{\"1202\":1,\"1205\":1}}],[\"通过给特定\",{\"1\":{\"1197\":1,\"1199\":1}}],[\"通过订阅特定的\",{\"1\":{\"1196\":1}}],[\"通过名字我们就能看出\",{\"1\":{\"1165\":1}}],[\"通过虚拟节点可以让节点更加分散\",{\"1\":{\"1143\":1}}],[\"通过反射加载实现类\",{\"1\":{\"1131\":1}}],[\"通过反编译你会发现\",{\"1\":{\"631\":1}}],[\"通过强制\",{\"1\":{\"1112\":1}}],[\"通过可线性化\",{\"1\":{\"1069\":1}}],[\"通过多线程和虚拟线程的方式处理相同的任务\",{\"1\":{\"1062\":1}}],[\"通过hash计算后\",{\"1\":{\"1040\":1}}],[\"通过hash计算后的槽位对应的entry数据为空\",{\"1\":{\"1035\":1}}],[\"通过简单的几行代码就能实现同步功能\",{\"1\":{\"1020\":1}}],[\"通过我们自己定义的\",{\"1\":{\"1020\":1}}],[\"通过前驱节点\",{\"1\":{\"1013\":1}}],[\"通过枚举值我们知道waitstatus>0是取消状态\",{\"1\":{\"1012\":1}}],[\"通过当前的线程和锁模式新建一个节点\",{\"1\":{\"1011\":1}}],[\"通过上图可知\",{\"1\":{\"1035\":1}}],[\"通过上文我们已经了解\",{\"1\":{\"1002\":1}}],[\"通过上面记录的回滚日志\",{\"1\":{\"1371\":1}}],[\"通过上面这些内容\",{\"1\":{\"883\":1}}],[\"通过上面的一些介绍\",{\"1\":{\"1311\":1}}],[\"通过上面的流程\",{\"1\":{\"1013\":1}}],[\"通过上面的描述\",{\"1\":{\"1007\":1}}],[\"通过上面的介绍我们大概知道了虚拟机的内存情况\",{\"1\":{\"500\":1}}],[\"通过上面的计算公示找到的对应的哈希槽\",{\"1\":{\"286\":1}}],[\"通过一系列的超时机制很好的缓解了阻塞问题\",{\"1\":{\"1371\":1}}],[\"通过一系列规则来定义逻辑时钟的变化\",{\"1\":{\"974\":1}}],[\"通过一个简单例子带大家看一下基本数据类型原子类的优势\",{\"1\":{\"764\":1}}],[\"通过一个叫做过期字典\",{\"1\":{\"271\":1}}],[\"通过插入内存屏障\",{\"1\":{\"969\":1}}],[\"通过插件扩展支持\",{\"1\":{\"377\":1}}],[\"通过插件扩展功能\",{\"1\":{\"9\":1}}],[\"通过禁止特定类型的编译器重排序的方式来禁止重排序\",{\"1\":{\"969\":1}}],[\"通过重写\",{\"1\":{\"962\":1}}],[\"通过重复利用已创建的线程降低线程创建和销毁造成的消耗\",{\"1\":{\"887\":1,\"933\":1}}],[\"通过提供\",{\"1\":{\"962\":1}}],[\"通过创建唯一节点获得分布式锁\",{\"1\":{\"1346\":1}}],[\"通过创建\",{\"1\":{\"951\":1}}],[\"通过创建太多相同\",{\"1\":{\"485\":1}}],[\"通过addworker\",{\"1\":{\"941\":2}}],[\"通过asm框架序列化字节流\",{\"1\":{\"523\":1}}],[\"通过查找key值计算出散列表中slot位置\",{\"1\":{\"1040\":1}}],[\"通过查看\",{\"1\":{\"934\":1}}],[\"通过查阅\",{\"1\":{\"174\":1}}],[\"通过适配器runnableadapter来将runnable对象runnable转换成callable对象\",{\"1\":{\"900\":1}}],[\"通过构造方法实现\",{\"1\":{\"888\":1,\"937\":1}}],[\"通过threadpoolexecutor构造函数自定义参数创建\",{\"1\":{\"940\":1}}],[\"通过threadpoolexecutor构造函数来创建\",{\"1\":{\"888\":1,\"937\":1}}],[\"通过top命令获取进程对\",{\"1\":{\"169\":1}}],[\"通过同步状态值\",{\"1\":{\"874\":1}}],[\"通过该\",{\"1\":{\"852\":1}}],[\"通过原子方式用新值\",{\"1\":{\"841\":1,\"990\":1}}],[\"通过下图我们从\",{\"1\":{\"810\":1}}],[\"通过下面命令你可以输出一个\",{\"1\":{\"455\":1}}],[\"通过下面参数设置\",{\"1\":{\"109\":1}}],[\"通过并行执行多个任务的方式\",{\"1\":{\"772\":1}}],[\"通过方法名在\",{\"1\":{\"767\":2}}],[\"通过内置的\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"通过堆元素的上浮和下沉\",{\"1\":{\"669\":1}}],[\"通过getarray\",{\"1\":{\"589\":1}}],[\"通过复制底层数组的方式实现写操作\",{\"1\":{\"588\":1}}],[\"通过运行结果\",{\"1\":{\"564\":1}}],[\"通过使用在一个\",{\"1\":{\"1280\":1}}],[\"通过使用\",{\"1\":{\"544\":1,\"598\":2}}],[\"通过继承\",{\"1\":{\"518\":1,\"533\":3}}],[\"通过各种各样的搜索引擎也可以得知这些信息\",{\"1\":{\"449\":1}}],[\"通过在实际的计算机上仿真模拟各类计算机功能实现\",{\"1\":{\"417\":1}}],[\"通过观察\",{\"1\":{\"412\":1}}],[\"通过监控链路查看发现\",{\"1\":{\"412\":1}}],[\"通过以下方式运行\",{\"1\":{\"384\":1}}],[\"通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置\",{\"1\":{\"343\":1}}],[\"通过全类名获取定义此类的二进制字节流\",{\"1\":{\"340\":2,\"349\":1}}],[\"通过javap\",{\"1\":{\"329\":1}}],[\"通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中\",{\"1\":{\"307\":1}}],[\"通过阿里云的proxy\",{\"1\":{\"299\":1}}],[\"通过源码可以看出\",{\"1\":{\"256\":1}}],[\"通过info\",{\"1\":{\"169\":1}}],[\"通过分析\",{\"1\":{\"164\":1,\"293\":1,\"325\":1}}],[\"通过读写锁\",{\"1\":{\"140\":1}}],[\"通过回表查询\",{\"1\":{\"114\":1}}],[\"通过辅助索引无法直接定位行记录\",{\"1\":{\"112\":1}}],[\"通过主键索引查询通常只需要1\",{\"1\":{\"110\":1}}],[\"通过非叶子节点的二分查找和指针确定数据在哪一页\",{\"1\":{\"109\":1}}],[\"通过哈希函数算出\",{\"1\":{\"96\":1}}],[\"通过调用\",{\"1\":{\"49\":1}}],[\"通过这种通信协议\",{\"1\":{\"1084\":1,\"1091\":1}}],[\"通过这个连接\",{\"1\":{\"1353\":1}}],[\"通过这个requestid即可找到对应链路\",{\"1\":{\"1045\":1}}],[\"通过这个\",{\"1\":{\"944\":1}}],[\"通过这篇文章\",{\"1\":{\"43\":1}}],[\"通过这样的方式\",{\"1\":{\"8\":1}}],[\"通过公司\",{\"1\":{\"41\":1}}],[\"通过散列\",{\"1\":{\"37\":1}}],[\"通过层\",{\"1\":{\"23\":1}}],[\"通过\",{\"0\":{\"1008\":1},\"1\":{\"8\":1,\"30\":1,\"33\":1,\"34\":1,\"72\":1,\"181\":5,\"201\":1,\"202\":1,\"209\":1,\"210\":1,\"212\":1,\"220\":1,\"249\":3,\"251\":2,\"261\":1,\"265\":1,\"268\":3,\"283\":1,\"370\":2,\"445\":1,\"479\":2,\"544\":1,\"570\":1,\"607\":1,\"618\":1,\"682\":1,\"776\":1,\"777\":1,\"823\":1,\"851\":1,\"862\":1,\"874\":1,\"888\":1,\"891\":1,\"934\":1,\"936\":1,\"937\":1,\"941\":1,\"949\":1,\"1004\":1,\"1007\":2,\"1011\":1,\"1013\":1,\"1015\":1,\"1016\":1,\"1033\":1,\"1112\":1,\"1165\":1,\"1170\":1,\"1232\":2,\"1238\":1,\"1257\":1,\"1324\":1,\"1325\":2,\"1328\":2,\"1329\":1,\"1333\":1,\"1346\":1,\"1379\":1}}],[\"通过实现\",{\"1\":{\"6\":1}}],[\"通过协议转换整合后台基于\",{\"1\":{\"2\":1}}],[\"还拿秒杀系统的下订单和加积分两个系统来举例吧\",{\"1\":{\"1370\":1}}],[\"还挺有意思的\",{\"1\":{\"1343\":1}}],[\"还记得\",{\"1\":{\"1387\":1,\"1388\":1}}],[\"还记得临时节点的生命周期吗\",{\"1\":{\"1387\":1}}],[\"还记得上面我们的所说的临时节点吗\",{\"1\":{\"1387\":1}}],[\"还记得上面我们一开始的三个问题吗\",{\"1\":{\"1315\":1}}],[\"还记得我上面说的吗\",{\"1\":{\"359\":1}}],[\"还让不让人活了\",{\"1\":{\"1276\":1}}],[\"还怕没柴烧\",{\"1\":{\"1273\":1}}],[\"还包含了这个\",{\"1\":{\"1263\":1}}],[\"还包括其他进程开销\",{\"1\":{\"219\":1}}],[\"还违背了使用消息队列的目的\",{\"1\":{\"1193\":1}}],[\"还需要对新节点进行同步\",{\"1\":{\"1356\":1}}],[\"还需要访问其他公司的网站服务器\",{\"1\":{\"1155\":1}}],[\"还需要等待复制完成\",{\"1\":{\"585\":1}}],[\"还引入了虚拟节点的概念\",{\"1\":{\"1143\":1}}],[\"还太依赖与中心节点\",{\"1\":{\"1083\":1}}],[\"还发现了其他过期的slot数据\",{\"1\":{\"1036\":1}}],[\"还规定了下面这些同步规则来保证这些同步操作的正确执行\",{\"1\":{\"972\":1}}],[\"还允许您在需要时处理它们\",{\"1\":{\"962\":1}}],[\"还可能会有死锁问题发生\",{\"1\":{\"869\":1}}],[\"还可以避免频繁的内存分配和垃圾回收\",{\"1\":{\"1184\":1}}],[\"还可以被用作流式处理平台\",{\"1\":{\"1180\":1}}],[\"还可以放各种东西\",{\"1\":{\"1152\":1}}],[\"还可以多找一些书籍和博客看\",{\"1\":{\"788\":1}}],[\"还可以对其进行进一步的处理\",{\"1\":{\"779\":1}}],[\"还可以看一下这个试验\",{\"1\":{\"480\":1}}],[\"还可以细化到\",{\"1\":{\"375\":1}}],[\"还可以查看类的基本信息\",{\"1\":{\"325\":1}}],[\"还可以留意其提供的开箱即用的解决方案\",{\"1\":{\"299\":1}}],[\"还可以将快照留在原地以便重启服务器的时候使用\",{\"1\":{\"226\":1}}],[\"还可以通过\",{\"1\":{\"192\":1,\"195\":1}}],[\"还可以再次获取锁\",{\"1\":{\"61\":1}}],[\"还可以基于\",{\"1\":{\"7\":1}}],[\"还未解决\",{\"1\":{\"1315\":1}}],[\"还未解决线程安全问题\",{\"1\":{\"598\":1}}],[\"还未对其进行修改\",{\"1\":{\"835\":1}}],[\"还未被初始化\",{\"1\":{\"834\":1}}],[\"还实现了runnable\",{\"1\":{\"900\":1}}],[\"还实现了\",{\"1\":{\"729\":1}}],[\"还重写了\",{\"1\":{\"712\":1}}],[\"还得确定链表是否为空\",{\"1\":{\"712\":1}}],[\"还提供一个更高级的构造函数\",{\"1\":{\"757\":1}}],[\"还提供有\",{\"1\":{\"667\":1}}],[\"还提供了丰富的扩展功能比如支持批量操作\",{\"1\":{\"1179\":1}}],[\"还提供了一些其他开箱即用的功能比如智能负载均衡\",{\"1\":{\"1122\":1}}],[\"还提供了线程工厂\",{\"1\":{\"934\":1}}],[\"还提供了函数式编程的能力\",{\"1\":{\"774\":1}}],[\"还提供了函数式编程\",{\"1\":{\"774\":1,\"901\":1}}],[\"还提供了很多其他方面的功能\",{\"1\":{\"377\":1}}],[\"还提供了\",{\"1\":{\"251\":1,\"1212\":1}}],[\"还提供了其他的概率数据结构\",{\"1\":{\"205\":1}}],[\"还用什么\",{\"1\":{\"1155\":1}}],[\"还用到了\",{\"1\":{\"607\":1}}],[\"还用上面那两张表\",{\"1\":{\"137\":1}}],[\"还继承了\",{\"1\":{\"533\":1}}],[\"还在试验阶段\",{\"1\":{\"408\":1}}],[\"还具备高吞吐量性能特征\",{\"1\":{\"407\":1}}],[\"还有两种模式的定义\",{\"1\":{\"1378\":1}}],[\"还有需要注意的是\",{\"1\":{\"1371\":1}}],[\"还有点对点订阅模式\",{\"1\":{\"1222\":1}}],[\"还有\",{\"1\":{\"1033\":1}}],[\"还有垃圾回收\",{\"1\":{\"1030\":1}}],[\"还有关键的一点\",{\"1\":{\"934\":1}}],[\"还有可以私有化构造器\",{\"1\":{\"521\":1}}],[\"还有用于存放编译期生成的各种字面量\",{\"1\":{\"497\":1}}],[\"还有一点我觉得比较重要的是\",{\"1\":{\"1197\":1}}],[\"还有一点原因\",{\"1\":{\"1014\":1}}],[\"还有一种情况是这两个线程同时\",{\"1\":{\"686\":1}}],[\"还有一个重要的作用就是防止\",{\"1\":{\"834\":1}}],[\"还有一个传入\",{\"1\":{\"602\":1}}],[\"还有一个不怎么常用的构造方法\",{\"1\":{\"534\":1}}],[\"还有一个很大的优点\",{\"1\":{\"377\":1}}],[\"还有一些小细节不同会在后面提到\",{\"1\":{\"1298\":1}}],[\"还有一些其他的组合\",{\"1\":{\"781\":1}}],[\"还有一些其他的比如\",{\"1\":{\"253\":1}}],[\"还有一些时间复杂度可能在\",{\"1\":{\"157\":1,\"301\":1}}],[\"还有什么其他用么\",{\"1\":{\"270\":1}}],[\"还能建立可预测的停顿时间模型\",{\"1\":{\"407\":1}}],[\"还能做什么\",{\"0\":{\"249\":1}}],[\"还能通过下面两种方式开发来避开\",{\"1\":{\"8\":1}}],[\"还会根据之前访问的内存地址预取相邻的内存数据\",{\"1\":{\"1184\":1}}],[\"还会记录下这些\",{\"1\":{\"1142\":1}}],[\"还会检测每个服务提供者的权重是否相同\",{\"1\":{\"1141\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"887\":1,\"933\":1}}],[\"还会造成阻塞问题\",{\"1\":{\"292\":1}}],[\"还会对性能造成比较大的影响\",{\"1\":{\"292\":1}}],[\"还会维护一个\",{\"1\":{\"233\":1}}],[\"还会优雅的放慢自己的速度以便适应硬盘的最大写入速度\",{\"1\":{\"231\":1}}],[\"还会多分配\",{\"1\":{\"218\":1}}],[\"还要能够自己画出来并且能够给别人讲出来\",{\"1\":{\"1166\":1}}],[\"还要支持手机端和\",{\"1\":{\"1155\":1}}],[\"还要有\",{\"0\":{\"1160\":1},\"1\":{\"1155\":1}}],[\"还要关注系统的扩展性\",{\"1\":{\"1070\":1}}],[\"还要看加载此类的类加载器是否一样\",{\"1\":{\"357\":1}}],[\"还要写到磁盘上\",{\"1\":{\"98\":1}}],[\"还要求生成的效率高\",{\"1\":{\"22\":1}}],[\"还没提交\",{\"1\":{\"1205\":1}}],[\"还没有把自己当作候选人\",{\"1\":{\"1105\":1}}],[\"还没有写完的时候\",{\"1\":{\"89\":1}}],[\"还没执行\",{\"1\":{\"1014\":1}}],[\"还没初始化\",{\"1\":{\"1014\":1}}],[\"还没看够\",{\"1\":{\"896\":1}}],[\"还没来得及执行上面图中红色的操作\",{\"1\":{\"136\":1}}],[\"还没做减法之前\",{\"1\":{\"124\":1}}],[\"还没写\",{\"1\":{\"89\":1}}],[\"还是前面三个\",{\"1\":{\"1380\":1}}],[\"还是直接上图吧\",{\"1\":{\"1222\":1}}],[\"还是推荐\",{\"1\":{\"1169\":1}}],[\"还是有别的策略来解决这一问题\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"还是有很多欠缺的地方\",{\"1\":{\"251\":1}}],[\"还是有很多欠缺的地方比如消息丢失和堆积问题不好解决\",{\"1\":{\"182\":1}}],[\"还是需要一直等待吗\",{\"1\":{\"1002\":1}}],[\"还是局部变量\",{\"1\":{\"972\":1}}],[\"还是可以在实际项目中使用的\",{\"1\":{\"847\":1}}],[\"还是可以节省不少网络传输次数\",{\"1\":{\"286\":1}}],[\"还是因为找不到对应的键而返回的\",{\"1\":{\"693\":1}}],[\"还是根本没有这个键\",{\"1\":{\"693\":1}}],[\"还是会存在数据覆盖的问题\",{\"1\":{\"685\":1}}],[\"还是会在\",{\"1\":{\"384\":1}}],[\"还是优先执行的\",{\"1\":{\"599\":1}}],[\"还是从旧的\",{\"1\":{\"589\":1}}],[\"还是通过可达性分析法判断对象的引用链是否可达\",{\"1\":{\"392\":1}}],[\"还是要看业务的具体需求\",{\"1\":{\"57\":1}}],[\"还是\",{\"0\":{\"255\":1,\"257\":1},\"1\":{\"57\":1,\"196\":1,\"503\":1,\"603\":1,\"968\":1,\"1068\":1,\"1070\":1,\"1074\":1,\"1152\":1,\"1155\":1,\"1165\":1}}],[\"还是比较推荐直接基于\",{\"1\":{\"49\":1}}],[\"还是差一些\",{\"1\":{\"10\":1}}],[\"还支持这三种锁在一定条件下进行相互转换\",{\"1\":{\"871\":1}}],[\"还支持如果队列已满\",{\"1\":{\"670\":1}}],[\"还支持动态添加和移除任务\",{\"1\":{\"611\":1}}],[\"还支持事务\",{\"1\":{\"242\":1}}],[\"还支持\",{\"1\":{\"49\":1,\"199\":1,\"251\":1,\"298\":1,\"1237\":1,\"1246\":1,\"1253\":1}}],[\"还解决了雪花\",{\"1\":{\"41\":1}}],[\"还应保证\",{\"1\":{\"30\":1}}],[\"功能特性\",{\"0\":{\"1282\":1}}],[\"功能支持\",{\"1\":{\"1240\":1}}],[\"功能不完备并且有一些小问题比如丢失消息\",{\"1\":{\"1191\":1}}],[\"功能更加纯粹\",{\"1\":{\"1169\":1}}],[\"功能更丰富\",{\"1\":{\"10\":2}}],[\"功能接口作为参数\",{\"1\":{\"882\":1}}],[\"功能非常强大\",{\"1\":{\"772\":1}}],[\"功能比较鸡肋\",{\"1\":{\"279\":1}}],[\"功能\",{\"1\":{\"8\":1,\"10\":1,\"251\":2,\"280\":1,\"1131\":1,\"1344\":1}}],[\"贝壳\",{\"1\":{\"8\":1}}],[\"腾讯官方曾经发过一篇文章\",{\"1\":{\"244\":1}}],[\"腾讯也开源了一款类似于\",{\"1\":{\"244\":1}}],[\"腾讯\",{\"1\":{\"8\":1}}],[\"k8s\",{\"1\":{\"1236\":1}}],[\"kraft\",{\"1\":{\"1200\":4,\"1235\":3,\"1241\":2,\"1344\":1}}],[\"kriszhang\",{\"1\":{\"1169\":1}}],[\"kryo\",{\"1\":{\"1146\":1,\"1147\":2}}],[\"knowledge\",{\"1\":{\"1117\":1}}],[\"k>\",{\"1\":{\"630\":1}}],[\"keep\",{\"1\":{\"940\":2,\"1158\":1}}],[\"keepalivetime才会被回收销毁\",{\"1\":{\"890\":1,\"936\":1}}],[\"keepalivetime\",{\"1\":{\"530\":1,\"890\":6,\"894\":1,\"920\":1,\"936\":6,\"940\":1,\"951\":1,\"958\":2}}],[\"key=null\",{\"1\":{\"1040\":1}}],[\"key和要查找的key不一致\",{\"1\":{\"1040\":1}}],[\"key和查找的key一致\",{\"1\":{\"1040\":1}}],[\"key过期的数据会被清理掉\",{\"1\":{\"1037\":1}}],[\"key的数据\",{\"1\":{\"1036\":1}}],[\"key则会接着往下走\",{\"1\":{\"1036\":1}}],[\"key值与当前threadlocal通过hash计算获取的key值一致\",{\"1\":{\"1035\":1}}],[\"key值相同\",{\"1\":{\"578\":1}}],[\"key就会被回收\",{\"1\":{\"1030\":1}}],[\"key是否是null\",{\"1\":{\"1030\":1}}],[\"key是查询语句\",{\"1\":{\"85\":1}}],[\"keyword\",{\"1\":{\"876\":1}}],[\"keymapper\",{\"1\":{\"630\":2}}],[\"key+\",{\"1\":{\"625\":1}}],[\"key2\",{\"1\":{\"177\":4,\"189\":6,\"193\":3,\"202\":1,\"206\":1,\"262\":1}}],[\"key1\",{\"1\":{\"177\":4,\"189\":6,\"193\":3,\"202\":1,\"206\":1,\"262\":1}}],[\"keys2\",{\"1\":{\"625\":2}}],[\"keyset\",{\"1\":{\"625\":2,\"663\":1,\"687\":2}}],[\"keyspace\",{\"1\":{\"293\":2,\"298\":1}}],[\"keys\",{\"1\":{\"47\":2,\"49\":2,\"120\":1,\"157\":1,\"218\":1,\"293\":8,\"298\":1,\"301\":1,\"302\":1,\"319\":1,\"625\":2,\"663\":2}}],[\"key\",{\"0\":{\"163\":1,\"164\":1,\"165\":1,\"289\":1,\"290\":1,\"295\":1,\"693\":1,\"1030\":1,\"1037\":1,\"1042\":1},\"1\":{\"8\":1,\"33\":2,\"34\":1,\"47\":5,\"48\":3,\"96\":4,\"111\":1,\"120\":4,\"157\":1,\"163\":7,\"164\":3,\"165\":1,\"167\":2,\"177\":33,\"178\":1,\"181\":7,\"185\":12,\"189\":6,\"193\":6,\"201\":1,\"202\":3,\"206\":1,\"210\":5,\"212\":1,\"254\":1,\"257\":2,\"260\":3,\"261\":2,\"262\":1,\"266\":2,\"270\":3,\"271\":2,\"272\":9,\"273\":2,\"280\":5,\"286\":7,\"287\":2,\"288\":1,\"289\":6,\"291\":2,\"292\":7,\"293\":10,\"294\":3,\"296\":6,\"298\":6,\"299\":1,\"301\":1,\"306\":2,\"307\":12,\"309\":1,\"311\":2,\"316\":2,\"318\":1,\"319\":1,\"498\":1,\"571\":26,\"572\":1,\"573\":9,\"577\":14,\"578\":11,\"609\":3,\"616\":1,\"618\":6,\"619\":10,\"621\":3,\"622\":28,\"623\":13,\"625\":6,\"630\":4,\"640\":4,\"658\":3,\"663\":3,\"677\":2,\"678\":1,\"679\":1,\"680\":1,\"682\":6,\"683\":5,\"686\":9,\"693\":8,\"694\":17,\"697\":1,\"708\":2,\"710\":4,\"711\":2,\"712\":9,\"883\":2,\"884\":4,\"1026\":3,\"1030\":3,\"1032\":2,\"1033\":2,\"1035\":2,\"1036\":14,\"1037\":1,\"1041\":6,\"1042\":1,\"1046\":1,\"1202\":4,\"1248\":1,\"1303\":1,\"1315\":1}}],[\"kit\",{\"1\":{\"516\":1}}],[\"kill\",{\"1\":{\"368\":1}}],[\"kb\",{\"1\":{\"478\":1,\"485\":1}}],[\"kou\",{\"1\":{\"679\":1,\"940\":1}}],[\"kotlincompiledaemon\",{\"1\":{\"370\":1}}],[\"kotlin\",{\"1\":{\"324\":1}}],[\"konghq\",{\"1\":{\"7\":2}}],[\"kong\",{\"0\":{\"7\":1},\"1\":{\"7\":16,\"8\":3,\"10\":8,\"11\":2}}],[\"kafkaconsumer\",{\"1\":{\"1209\":1}}],[\"kafkaconst\",{\"1\":{\"1209\":2,\"1213\":1}}],[\"kafkalistenercontainerfactory\",{\"1\":{\"1211\":3}}],[\"kafkalistener\",{\"1\":{\"1209\":1,\"1213\":2}}],[\"kafkatemplate\",{\"1\":{\"1204\":2,\"1209\":1}}],[\"kafka3\",{\"1\":{\"1200\":1}}],[\"kafka常见问题总结\",{\"0\":{\"1188\":1}}],[\"kafka\",{\"0\":{\"1180\":1,\"1189\":1,\"1190\":1,\"1191\":1,\"1192\":1,\"1194\":1,\"1195\":1,\"1197\":1,\"1198\":1,\"1199\":1,\"1200\":1,\"1201\":1,\"1202\":1,\"1203\":1,\"1206\":1,\"1207\":1,\"1208\":1,\"1235\":1},\"1\":{\"249\":1,\"251\":1,\"1178\":1,\"1180\":1,\"1190\":5,\"1191\":8,\"1194\":3,\"1196\":6,\"1197\":3,\"1199\":9,\"1200\":8,\"1202\":6,\"1204\":3,\"1205\":2,\"1206\":4,\"1207\":3,\"1208\":4,\"1209\":4,\"1210\":1,\"1212\":1,\"1213\":2,\"1214\":3,\"1217\":1,\"1223\":1,\"1235\":17,\"1236\":1,\"1240\":8,\"1241\":1,\"1250\":2,\"1277\":1,\"1280\":1,\"1298\":1,\"1304\":1,\"1315\":2,\"1341\":2,\"1344\":4}}],[\"k\",{\"1\":{\"245\":2,\"384\":1,\"478\":1,\"571\":10,\"572\":7,\"573\":4,\"577\":3,\"578\":1,\"619\":4,\"621\":4,\"622\":12,\"623\":6,\"630\":2,\"669\":1,\"680\":1,\"683\":2,\"686\":4,\"694\":2,\"708\":1,\"710\":5,\"712\":3,\"713\":9,\"884\":2,\"1029\":1,\"1036\":12,\"1037\":6,\"1038\":3,\"1041\":3,\"1122\":1,\"1142\":2,\"1209\":1}}],[\"kv\",{\"1\":{\"242\":1,\"244\":1}}],[\"km\",{\"1\":{\"210\":7}}],[\"kleppmann\",{\"1\":{\"51\":3}}],[\"写请求只监听比自己小的最后一个节点\",{\"1\":{\"1388\":1}}],[\"写个临时程序\",{\"1\":{\"1264\":1}}],[\"写数据库等操作中可能失败\",{\"1\":{\"1220\":1}}],[\"写时修复\",{\"1\":{\"1078\":2}}],[\"写时复制机制并不是银弹\",{\"1\":{\"585\":1}}],[\"写时复制机制非常适合读多写少的并发场景\",{\"1\":{\"585\":1}}],[\"写时复制\",{\"1\":{\"584\":1,\"588\":1,\"793\":1}}],[\"写缓冲区\",{\"1\":{\"972\":1}}],[\"写共享变量的副本\",{\"1\":{\"972\":1}}],[\"写线程有机会获取写锁\",{\"1\":{\"872\":1}}],[\"写占比非常多的情况\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"写操作开销\",{\"1\":{\"585\":1}}],[\"写操作比较频繁的话导致\",{\"1\":{\"145\":1}}],[\"写写互斥\",{\"1\":{\"584\":1,\"793\":1,\"865\":2}}],[\"写写并行\",{\"1\":{\"140\":1}}],[\"写的\",{\"1\":{\"1120\":1}}],[\"写的很不错\",{\"1\":{\"868\":1}}],[\"写的痛点\",{\"1\":{\"233\":1}}],[\"写的比较详细\",{\"1\":{\"7\":1}}],[\"写会额外消耗内存和磁盘\",{\"1\":{\"233\":1}}],[\"写结束后再把这部分增量数据写入新的\",{\"1\":{\"233\":1}}],[\"写入节点\",{\"1\":{\"1390\":1}}],[\"写入下一个文件\",{\"1\":{\"1315\":1}}],[\"写入时复制\",{\"1\":{\"585\":1}}],[\"写入操作也不会阻塞读取操作\",{\"1\":{\"584\":1,\"793\":1}}],[\"写入系统内核缓冲区之后直接返回\",{\"1\":{\"230\":1}}],[\"写入到\",{\"1\":{\"146\":1}}],[\"写入\",{\"1\":{\"145\":1,\"265\":1,\"267\":1,\"972\":1,\"1069\":1,\"1303\":1}}],[\"写入磁盘\",{\"1\":{\"89\":1}}],[\"写\",{\"1\":{\"145\":1,\"146\":1,\"265\":1,\"1344\":3,\"1362\":3}}],[\"写锁和乐观读\",{\"1\":{\"871\":1}}],[\"写锁可以降级为读锁\",{\"1\":{\"869\":1}}],[\"写锁是独占锁\",{\"1\":{\"865\":1}}],[\"写锁会排斥其他所有获取锁的请求\",{\"1\":{\"140\":1}}],[\"写锁\",{\"1\":{\"140\":1,\"865\":1,\"871\":2}}],[\"写完之后\",{\"1\":{\"89\":2}}],[\"写完\",{\"1\":{\"89\":2}}],[\"写了一个相对简洁易懂的版本\",{\"1\":{\"59\":1}}],[\"写一个自己自定义的\",{\"1\":{\"7\":1}}],[\"lmax\",{\"1\":{\"1178\":7,\"1182\":2}}],[\"lynch\",{\"1\":{\"1066\":1}}],[\"l4\",{\"1\":{\"968\":1}}],[\"l3\",{\"1\":{\"634\":1,\"968\":1,\"1184\":1}}],[\"l2\",{\"1\":{\"634\":1,\"968\":1,\"1184\":1}}],[\"l1\",{\"1\":{\"634\":1,\"968\":1,\"1184\":1}}],[\"lcok\",{\"1\":{\"604\":1}}],[\"lf\",{\"1\":{\"571\":3}}],[\"lfu\",{\"1\":{\"273\":2,\"298\":10}}],[\"lwp\",{\"1\":{\"485\":1,\"1052\":1}}],[\"l\",{\"1\":{\"365\":2,\"634\":3,\"729\":6,\"730\":3,\"731\":3,\"779\":3,\"851\":1}}],[\"lvmid\",{\"1\":{\"365\":1}}],[\"lrucache\",{\"1\":{\"706\":3}}],[\"lrucache<k\",{\"1\":{\"706\":1}}],[\"lru\",{\"0\":{\"706\":1,\"718\":1},\"1\":{\"273\":2,\"298\":1,\"702\":1,\"706\":1,\"718\":1,\"720\":1}}],[\"lrange\",{\"1\":{\"157\":1,\"181\":7,\"182\":1,\"301\":1,\"319\":1}}],[\"ls2\",{\"0\":{\"1330\":1},\"1\":{\"1330\":3}}],[\"ls\",{\"0\":{\"1328\":1},\"1\":{\"1328\":6,\"1330\":1}}],[\"lsb\",{\"1\":{\"256\":5}}],[\"lset\",{\"1\":{\"181\":1}}],[\"llc\",{\"1\":{\"205\":1}}],[\"llen等命令返回其长度或成员数量\",{\"1\":{\"293\":1}}],[\"llen\",{\"1\":{\"181\":3,\"293\":1}}],[\"lpop\",{\"1\":{\"181\":5,\"251\":4}}],[\"lpush\",{\"1\":{\"181\":3,\"182\":1,\"251\":2}}],[\"leemain\",{\"1\":{\"1020\":1}}],[\"leelock\",{\"1\":{\"1020\":6}}],[\"leetcode\",{\"1\":{\"720\":1}}],[\"leslie\",{\"1\":{\"974\":2,\"1096\":1}}],[\"left\",{\"1\":{\"619\":1}}],[\"letter\",{\"1\":{\"1213\":1,\"1256\":1}}],[\"let\",{\"1\":{\"553\":3}}],[\"level\",{\"1\":{\"370\":1,\"570\":2,\"969\":1,\"1231\":1}}],[\"len=8来举例\",{\"1\":{\"1038\":1}}],[\"len的默认配置如下\",{\"1\":{\"302\":1}}],[\"length==hash\",{\"1\":{\"684\":1}}],[\"length属性是针对数组说的\",{\"1\":{\"558\":1}}],[\"length\",{\"1\":{\"201\":1,\"256\":1,\"293\":1,\"302\":1,\"535\":3,\"536\":1,\"537\":1,\"538\":1,\"553\":8,\"555\":1,\"557\":6,\"558\":4,\"561\":3,\"562\":3,\"571\":3,\"572\":1,\"573\":1,\"576\":2,\"577\":1,\"578\":1,\"587\":2,\"588\":1,\"590\":1,\"591\":1,\"592\":2,\"622\":3,\"623\":1,\"624\":1,\"629\":1,\"634\":1,\"649\":2,\"683\":1,\"684\":2,\"713\":1,\"766\":1,\"1036\":3,\"1037\":1,\"1038\":2,\"1041\":2,\"1042\":1,\"1062\":1,\"1141\":5,\"1142\":4}}],[\"len\",{\"1\":{\"120\":1,\"256\":11,\"293\":1,\"302\":4,\"588\":3,\"591\":4,\"592\":2,\"1032\":1,\"1036\":21,\"1037\":8,\"1038\":3,\"1041\":2,\"1042\":3,\"1311\":1}}],[\"leading\",{\"1\":{\"1356\":1}}],[\"leader\",{\"0\":{\"1356\":1},\"1\":{\"318\":1,\"601\":6,\"603\":2,\"604\":10,\"1069\":2,\"1097\":1,\"1108\":5,\"1109\":5,\"1110\":5,\"1111\":11,\"1112\":18,\"1114\":3,\"1115\":2,\"1197\":9,\"1206\":18,\"1355\":9,\"1356\":14,\"1358\":6,\"1361\":8,\"1378\":3,\"1379\":11,\"1380\":28,\"1391\":1}}],[\"learn\",{\"1\":{\"1241\":1}}],[\"learner学习者\",{\"1\":{\"1372\":1}}],[\"learner\",{\"1\":{\"1098\":1,\"1374\":1}}],[\"learning\",{\"1\":{\"876\":1}}],[\"lea\",{\"1\":{\"530\":1,\"693\":1,\"1022\":1}}],[\"leastindex\",{\"1\":{\"1142\":3}}],[\"leastindexes\",{\"1\":{\"1142\":6}}],[\"leastcount++\",{\"1\":{\"1142\":1}}],[\"leastcount\",{\"1\":{\"1142\":5}}],[\"leastactive\",{\"1\":{\"1142\":6}}],[\"leastactiveloadbalance\",{\"0\":{\"1142\":1},\"1\":{\"1142\":2}}],[\"least\",{\"1\":{\"273\":4,\"298\":2,\"706\":1}}],[\"leaves\",{\"1\":{\"41\":1}}],[\"leaf\",{\"0\":{\"41\":1},\"1\":{\"38\":1,\"41\":6}}],[\"live\",{\"1\":{\"1257\":1}}],[\"litetimeoutblockingwaitstrategy\",{\"1\":{\"1183\":1}}],[\"liteblockingwaitstrategy\",{\"1\":{\"1183\":2}}],[\"literal\",{\"1\":{\"497\":1}}],[\"lightweight\",{\"1\":{\"1052\":1}}],[\"life\",{\"1\":{\"820\":1}}],[\"library\",{\"1\":{\"516\":1}}],[\"lib\",{\"1\":{\"353\":1}}],[\"lib目录下的\",{\"1\":{\"353\":1}}],[\"libc\",{\"1\":{\"218\":1}}],[\"lisi\",{\"1\":{\"663\":1}}],[\"lisp\",{\"1\":{\"324\":1}}],[\"listenablefuture<sendresult<string\",{\"1\":{\"1204\":1}}],[\"listener\",{\"1\":{\"807\":1,\"1209\":2}}],[\"listed\",{\"1\":{\"370\":1}}],[\"list的前distance个元素整体移到后面\",{\"1\":{\"696\":1}}],[\"list的最右边的元素取出\",{\"1\":{\"181\":1}}],[\"listitr\",{\"1\":{\"553\":2,\"732\":2}}],[\"listiterator\",{\"1\":{\"553\":2,\"634\":1}}],[\"listiterator<e>\",{\"1\":{\"553\":2,\"634\":1,\"732\":1}}],[\"listofstrings\",{\"1\":{\"551\":4,\"652\":4}}],[\"list<messagequeue>\",{\"1\":{\"1299\":1}}],[\"list<messageview>\",{\"1\":{\"1293\":1}}],[\"list<consumerrecord<\",{\"1\":{\"1212\":1}}],[\"list<completablefuture<string>>\",{\"1\":{\"909\":1}}],[\"list<invoker<t>>\",{\"1\":{\"1131\":1,\"1140\":2,\"1141\":1,\"1142\":1}}],[\"list<integer>\",{\"1\":{\"531\":1,\"631\":1,\"634\":1,\"1062\":1}}],[\"list<\",{\"1\":{\"658\":1}}],[\"list<string>\",{\"1\":{\"633\":1,\"634\":8,\"909\":1,\"1028\":3,\"1338\":1}}],[\"list<t>\",{\"1\":{\"632\":4,\"634\":3,\"698\":1}}],[\"list<person>\",{\"1\":{\"630\":1}}],[\"list<e>\",{\"1\":{\"549\":1,\"553\":1,\"586\":1,\"727\":1}}],[\"lists\",{\"1\":{\"293\":1,\"634\":3,\"1028\":1,\"1384\":1}}],[\"listpack\",{\"1\":{\"174\":1}}],[\"list\",{\"0\":{\"179\":1,\"640\":1,\"642\":1,\"648\":1},\"1\":{\"157\":1,\"174\":4,\"180\":2,\"181\":2,\"182\":1,\"188\":1,\"195\":2,\"245\":1,\"249\":1,\"251\":6,\"253\":1,\"291\":1,\"293\":5,\"301\":1,\"412\":1,\"522\":2,\"531\":8,\"549\":3,\"550\":2,\"552\":1,\"557\":1,\"564\":5,\"572\":1,\"583\":2,\"584\":1,\"586\":2,\"593\":18,\"631\":4,\"632\":2,\"633\":2,\"634\":14,\"639\":1,\"640\":1,\"646\":1,\"650\":2,\"656\":1,\"658\":6,\"662\":4,\"696\":12,\"697\":11,\"698\":2,\"727\":1,\"729\":2,\"732\":11,\"733\":17,\"791\":1,\"793\":3,\"924\":1,\"945\":1,\"1062\":6,\"1333\":1}}],[\"limit\",{\"1\":{\"302\":1,\"495\":1}}],[\"link\",{\"1\":{\"798\":1}}],[\"linkbefore\",{\"1\":{\"729\":3}}],[\"linklast\",{\"1\":{\"729\":4}}],[\"linkedin\",{\"1\":{\"1191\":1,\"1235\":1}}],[\"linkedtransferqueue\",{\"1\":{\"1179\":1}}],[\"linkedentryiterator\",{\"1\":{\"713\":1}}],[\"linkedhashiterator\",{\"1\":{\"713\":1}}],[\"linkedhashset\",{\"0\":{\"665\":1},\"1\":{\"643\":2,\"665\":4}}],[\"linkedhashmapyuan\",{\"1\":{\"720\":1}}],[\"linkedhashmap<k\",{\"1\":{\"706\":1}}],[\"linkedhashmap<>\",{\"1\":{\"705\":1,\"713\":1}}],[\"linkedhashmap<integer\",{\"1\":{\"705\":1}}],[\"linkedhashmap\",{\"0\":{\"701\":1,\"702\":1,\"703\":1,\"707\":1,\"713\":1,\"714\":1,\"715\":1,\"716\":1,\"717\":1,\"718\":1,\"719\":1},\"1\":{\"619\":1,\"643\":1,\"645\":4,\"702\":3,\"704\":3,\"705\":3,\"706\":3,\"708\":14,\"709\":6,\"710\":7,\"711\":5,\"712\":7,\"713\":12,\"715\":1,\"716\":2,\"717\":1,\"718\":1,\"719\":4,\"720\":3}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"784\":1,\"889\":2,\"937\":2,\"949\":2,\"953\":2}}],[\"linkedblockingqueue中的锁是分离的\",{\"1\":{\"542\":1,\"672\":1}}],[\"linkedblockingqueue\",{\"0\":{\"542\":1,\"672\":1,\"798\":1},\"1\":{\"529\":4,\"542\":4,\"671\":1,\"672\":4,\"796\":1,\"798\":7,\"799\":1,\"889\":3,\"892\":1,\"917\":1,\"937\":3,\"938\":1,\"949\":1,\"950\":2,\"951\":1,\"954\":1,\"955\":1,\"1179\":1}}],[\"linkedlist<>\",{\"1\":{\"732\":2,\"733\":1}}],[\"linkedlist<string>\",{\"1\":{\"732\":2,\"733\":1}}],[\"linkedlist<e>\",{\"1\":{\"727\":1}}],[\"linkedlist删除元素相关的方法一共有\",{\"1\":{\"731\":1}}],[\"linkedlist获取元素相关的方法一共有\",{\"1\":{\"730\":1}}],[\"linkedlist\",{\"0\":{\"552\":1,\"654\":1,\"655\":1,\"656\":1,\"668\":1,\"723\":1,\"724\":1,\"725\":1,\"726\":1,\"727\":1,\"733\":1},\"1\":{\"174\":4,\"180\":1,\"552\":5,\"642\":2,\"646\":1,\"654\":1,\"655\":1,\"656\":11,\"658\":2,\"668\":5,\"698\":1,\"724\":8,\"726\":1,\"727\":7,\"728\":3,\"729\":2,\"731\":1,\"732\":3,\"733\":1,\"791\":1}}],[\"linking\",{\"1\":{\"338\":1,\"345\":1}}],[\"linux\",{\"1\":{\"161\":1,\"168\":1,\"230\":3,\"231\":1,\"242\":2,\"368\":1,\"412\":1,\"417\":1,\"808\":1,\"895\":1,\"922\":1,\"968\":1,\"1053\":1,\"1328\":1}}],[\"linearizable\",{\"1\":{\"1069\":1}}],[\"line\",{\"1\":{\"86\":1,\"1184\":4}}],[\"like\",{\"1\":{\"117\":1,\"201\":1}}],[\"lb\",{\"1\":{\"75\":2}}],[\"loss\",{\"1\":{\"1383\":1}}],[\"lost\",{\"1\":{\"56\":1,\"576\":1}}],[\"lorin\",{\"1\":{\"1051\":1}}],[\"looking\",{\"1\":{\"1042\":1,\"1356\":1,\"1380\":5}}],[\"loop\",{\"1\":{\"756\":1,\"911\":1,\"941\":1,\"1182\":1}}],[\"lotail\",{\"1\":{\"624\":6}}],[\"lohead\",{\"1\":{\"624\":3}}],[\"lo\",{\"1\":{\"377\":1}}],[\"locating\",{\"1\":{\"571\":1}}],[\"locate\",{\"1\":{\"351\":1}}],[\"localfunc\",{\"1\":{\"1154\":1}}],[\"localhost\",{\"1\":{\"369\":1}}],[\"local\",{\"1\":{\"365\":1,\"929\":1}}],[\"lock或\",{\"1\":{\"871\":1,\"874\":1}}],[\"lock或者atomicinteger都可以\",{\"1\":{\"835\":1}}],[\"lockinterruptibly\",{\"1\":{\"535\":2,\"537\":2,\"604\":1,\"862\":1}}],[\"locking\",{\"1\":{\"51\":1}}],[\"locked\",{\"1\":{\"370\":2}}],[\"lockcount\",{\"1\":{\"56\":4}}],[\"lockdata是\",{\"1\":{\"56\":1}}],[\"lockdata为\",{\"1\":{\"56\":1}}],[\"lockdata\",{\"1\":{\"56\":15}}],[\"lockdata>\",{\"1\":{\"56\":2}}],[\"lockpath\",{\"1\":{\"56\":7}}],[\"lockpath2\",{\"1\":{\"53\":1}}],[\"lockpath1\",{\"1\":{\"53\":1}}],[\"lock2\",{\"1\":{\"53\":4}}],[\"lock0上注册一个事件监听器\",{\"1\":{\"53\":1}}],[\"lock1\",{\"1\":{\"53\":4}}],[\"lock1是最小的子节点\",{\"1\":{\"53\":1}}],[\"lock1是否是\",{\"1\":{\"53\":1}}],[\"lock1节点\",{\"1\":{\"53\":1}}],[\"lock\",{\"1\":{\"49\":8,\"50\":3,\"53\":3,\"56\":1,\"140\":2,\"370\":4,\"534\":8,\"535\":8,\"536\":15,\"537\":8,\"538\":5,\"544\":1,\"571\":2,\"577\":1,\"588\":5,\"591\":5,\"601\":3,\"603\":7,\"604\":11,\"605\":5,\"688\":3,\"742\":1,\"756\":5,\"835\":5,\"837\":5,\"847\":1,\"857\":2,\"860\":1,\"861\":1,\"862\":2,\"865\":2,\"871\":1,\"876\":1,\"904\":1,\"911\":5,\"941\":1,\"971\":1,\"972\":6,\"978\":2,\"979\":1,\"985\":1,\"986\":5,\"1001\":6,\"1002\":3,\"1007\":5,\"1008\":1,\"1016\":1,\"1018\":2,\"1020\":3}}],[\"lockwatchdogtimeout\",{\"1\":{\"49\":5}}],[\"locksupport\",{\"1\":{\"1012\":1,\"1014\":1,\"1015\":1}}],[\"lockstate\",{\"1\":{\"688\":2}}],[\"locks\",{\"1\":{\"49\":1,\"53\":4,\"740\":1,\"742\":1,\"903\":1,\"1002\":2,\"1006\":1,\"1008\":3,\"1011\":5,\"1012\":5,\"1013\":2,\"1014\":6,\"1015\":3,\"1018\":3}}],[\"lockkey\",{\"1\":{\"47\":3,\"48\":3}}],[\"loadservice\",{\"1\":{\"1293\":1}}],[\"loadbalance文件中即可\",{\"1\":{\"1131\":1}}],[\"loadbalance\",{\"1\":{\"1131\":5,\"1140\":3,\"1143\":1}}],[\"loadbalancerclientfilter\",{\"1\":{\"75\":1}}],[\"loadfence\",{\"1\":{\"834\":1}}],[\"loadfactor\",{\"1\":{\"570\":4,\"571\":2,\"572\":1,\"619\":8,\"621\":12,\"624\":1,\"677\":6,\"709\":4}}],[\"loaders\",{\"1\":{\"351\":1,\"360\":1}}],[\"loader\",{\"1\":{\"351\":5,\"353\":1,\"356\":5}}],[\"loadclass\",{\"1\":{\"340\":1,\"354\":2,\"357\":4,\"359\":5}}],[\"loading\",{\"1\":{\"338\":1,\"339\":1,\"345\":1,\"351\":1}}],[\"load\",{\"1\":{\"230\":1,\"570\":3,\"618\":1,\"619\":1,\"621\":4,\"624\":1,\"677\":2,\"682\":1,\"972\":5,\"1245\":1}}],[\"lower\",{\"1\":{\"220\":1}}],[\"logger\",{\"1\":{\"1204\":3,\"1293\":2}}],[\"logging\",{\"1\":{\"302\":1}}],[\"log4j2\",{\"1\":{\"1181\":2}}],[\"loginterceptor\",{\"1\":{\"1046\":1}}],[\"loglog\",{\"1\":{\"205\":1}}],[\"log是用来回滚数据的用于保障\",{\"1\":{\"138\":1}}],[\"log是用来恢复数据的\",{\"1\":{\"136\":1}}],[\"log的信息来进行回滚到没被修改前的状态\",{\"1\":{\"138\":1}}],[\"log主要记录的是数据的逻辑变化\",{\"1\":{\"137\":1}}],[\"log恢复最新数据\",{\"1\":{\"136\":1}}],[\"log持久化到磁盘\",{\"1\":{\"136\":1}}],[\"log来记录已成功提交事务的修改信息\",{\"1\":{\"136\":1}}],[\"log作用是什么\",{\"0\":{\"136\":1}}],[\"log叫做重做日志\",{\"1\":{\"135\":1}}],[\"log介绍\",{\"0\":{\"134\":1}}],[\"logn\",{\"1\":{\"98\":1,\"669\":1,\"800\":1}}],[\"log2\",{\"1\":{\"97\":1}}],[\"log\",{\"0\":{\"134\":1,\"135\":1,\"137\":1,\"138\":1},\"1\":{\"49\":1,\"89\":17,\"90\":2,\"97\":1,\"133\":2,\"135\":2,\"137\":2,\"138\":1,\"157\":2,\"301\":2,\"302\":8,\"483\":1,\"691\":1,\"918\":6,\"1110\":4,\"1209\":1,\"1212\":1,\"1213\":1}}],[\"long类型的\",{\"1\":{\"841\":1,\"990\":1}}],[\"longadder以空间换时间的方式就解决了这个问题\",{\"1\":{\"838\":1,\"987\":1}}],[\"longadder\",{\"1\":{\"838\":4,\"987\":7}}],[\"longitude\",{\"1\":{\"210\":1}}],[\"longitude1\",{\"1\":{\"210\":1}}],[\"longcodec\",{\"1\":{\"49\":1}}],[\"long\",{\"1\":{\"49\":4,\"56\":1,\"268\":4,\"271\":2,\"328\":1,\"357\":2,\"493\":1,\"530\":1,\"533\":2,\"537\":6,\"539\":2,\"553\":1,\"564\":4,\"571\":1,\"573\":2,\"597\":1,\"599\":4,\"604\":1,\"619\":1,\"629\":4,\"713\":2,\"752\":1,\"756\":1,\"765\":1,\"773\":1,\"774\":1,\"820\":2,\"825\":1,\"841\":5,\"871\":13,\"890\":1,\"899\":1,\"911\":1,\"936\":1,\"940\":1,\"944\":2,\"990\":5,\"1043\":1,\"1062\":1,\"1210\":4,\"1379\":1}}],[\"layer\",{\"1\":{\"1253\":2}}],[\"layout\",{\"1\":{\"256\":1}}],[\"label\",{\"1\":{\"1248\":1,\"1254\":1}}],[\"lamport\",{\"1\":{\"974\":2,\"1096\":1}}],[\"lambda\",{\"1\":{\"679\":1,\"687\":2,\"749\":1}}],[\"lambda$main$0\",{\"1\":{\"370\":1}}],[\"lambda$main$1\",{\"1\":{\"370\":1}}],[\"lao\",{\"1\":{\"625\":1}}],[\"larger\",{\"1\":{\"553\":1,\"564\":1}}],[\"largepagesizeinbytes\",{\"1\":{\"485\":1}}],[\"largestpoolsize\",{\"1\":{\"941\":3}}],[\"largest\",{\"1\":{\"386\":1}}],[\"launcher\",{\"1\":{\"365\":2,\"370\":2}}],[\"launcher$extclassloader\",{\"1\":{\"353\":1}}],[\"launcher$appclassloader\",{\"1\":{\"353\":1}}],[\"landin\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"landis\",{\"1\":{\"98\":1}}],[\"lang包\",{\"1\":{\"661\":1}}],[\"lang\",{\"1\":{\"330\":2,\"341\":3,\"344\":1,\"353\":1,\"354\":1,\"357\":1,\"358\":1,\"359\":1,\"360\":1,\"370\":8,\"394\":1,\"428\":1,\"433\":3,\"446\":1,\"480\":1,\"495\":2,\"496\":2,\"851\":1,\"876\":1,\"1030\":3,\"1036\":2,\"1041\":1,\"1053\":1}}],[\"lazyset\",{\"1\":{\"763\":2,\"766\":2}}],[\"lazy\",{\"1\":{\"268\":2,\"289\":3,\"294\":2,\"633\":1}}],[\"latency\",{\"1\":{\"1179\":1}}],[\"later\",{\"1\":{\"449\":1}}],[\"latest\",{\"1\":{\"7\":1,\"293\":1,\"298\":1}}],[\"latitude\",{\"1\":{\"210\":1}}],[\"latitude1\",{\"1\":{\"210\":1}}],[\"lastnext\",{\"1\":{\"732\":2}}],[\"lastreturned\",{\"1\":{\"732\":12}}],[\"lastrun\",{\"1\":{\"572\":6}}],[\"lastidx\",{\"1\":{\"572\":4}}],[\"lastindexofsublist\",{\"1\":{\"697\":1}}],[\"lastindexof\",{\"1\":{\"553\":1}}],[\"last\",{\"1\":{\"33\":1,\"572\":6,\"710\":7,\"729\":4,\"730\":2,\"731\":3,\"732\":1,\"798\":1}}],[\"luanlouis\",{\"1\":{\"334\":1}}],[\"luajit\",{\"1\":{\"6\":3}}],[\"lua\",{\"0\":{\"288\":1},\"1\":{\"6\":12,\"7\":5,\"8\":2,\"47\":3,\"49\":2,\"76\":1,\"242\":1,\"245\":1,\"249\":1,\"283\":8,\"287\":3,\"288\":9,\"319\":2}}],[\"最典型集群模式\",{\"1\":{\"1354\":1}}],[\"最上层是根节点以\",{\"1\":{\"1348\":1}}],[\"最主要的就是\",{\"1\":{\"1315\":1}}],[\"最主要的是对会话失效的情况处理不一样\",{\"1\":{\"54\":1}}],[\"最快速解决消息堆积问题的方法还是增加消费者实例\",{\"1\":{\"1305\":1}}],[\"最底层\",{\"1\":{\"1253\":1}}],[\"最被大家诟病的就是其重度依赖于\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"最早起源于雅虎研究院的一个研究小组\",{\"1\":{\"1343\":1}}],[\"最早开发\",{\"1\":{\"1191\":1}}],[\"最早是在\",{\"1\":{\"598\":1}}],[\"最早是\",{\"1\":{\"256\":1}}],[\"最高可以每秒处理千万级别的消息\",{\"1\":{\"1191\":1}}],[\"最具影响力的\",{\"1\":{\"1178\":1}}],[\"最明显的\",{\"1\":{\"1159\":1}}],[\"最关键的是这篇论文的摘要就一句话\",{\"1\":{\"1096\":1}}],[\"最关键的点是\",{\"1\":{\"814\":1}}],[\"最佳线程数\",{\"1\":{\"895\":1,\"922\":1}}],[\"最低层的链表维护了跳表内所有的元素\",{\"1\":{\"800\":1}}],[\"最低的隔离级别\",{\"1\":{\"132\":1}}],[\"最近接收的事务提议\",{\"1\":{\"1356\":1}}],[\"最近访问的元素移动到链表尾部\",{\"1\":{\"709\":1}}],[\"最近最少使用\",{\"1\":{\"706\":1}}],[\"最简便的方法\",{\"1\":{\"634\":1}}],[\"最接近的\",{\"1\":{\"621\":1}}],[\"最多等待5分钟\",{\"1\":{\"924\":1}}],[\"最多分割几个文件\",{\"1\":{\"483\":1}}],[\"最多丢失\",{\"1\":{\"236\":1}}],[\"最小投递延迟算法\",{\"1\":{\"1299\":1}}],[\"最小化响应时间\",{\"1\":{\"1139\":1}}],[\"最小\",{\"1\":{\"479\":1}}],[\"最大的问题就在于它太长了\",{\"1\":{\"1389\":1}}],[\"最大重试次数\",{\"1\":{\"1333\":1}}],[\"最大化复用原则\",{\"1\":{\"1289\":1}}],[\"最大化吞吐量\",{\"1\":{\"1139\":1}}],[\"最大间隔\",{\"1\":{\"1213\":1}}],[\"最大线程数\",{\"1\":{\"928\":1,\"940\":1}}],[\"最大线程数是\",{\"1\":{\"889\":1,\"937\":1}}],[\"最大扩容可达\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"最大可以同时运行的线程数量\",{\"1\":{\"890\":1,\"936\":1}}],[\"最大并发度是\",{\"1\":{\"692\":2}}],[\"最大容量\",{\"1\":{\"619\":1}}],[\"最大堆内存可通过\",{\"1\":{\"495\":1}}],[\"最大堆大小\",{\"1\":{\"449\":1}}],[\"最大大小\",{\"1\":{\"480\":1,\"496\":1}}],[\"最大大小为无限制\",{\"1\":{\"479\":1}}],[\"最大限度降低新对象直接进入老年代的情况\",{\"1\":{\"479\":1}}],[\"最大\",{\"1\":{\"479\":1}}],[\"最大暂停时间\",{\"1\":{\"449\":1}}],[\"最大区别是\",{\"1\":{\"443\":1}}],[\"最大事务id为300\",{\"1\":{\"141\":1}}],[\"最终需要被抛弃掉\",{\"1\":{\"1380\":1}}],[\"最终协调者收到响应后便给事务发起者返回处理失败的结果\",{\"1\":{\"1370\":1}}],[\"最终将会严格地按照顺序被应用到\",{\"1\":{\"1345\":1}}],[\"最终我们从大妈手中接过饭菜然后去寻找座位了\",{\"1\":{\"1271\":1}}],[\"最终能够达到一个一致的状态\",{\"1\":{\"1078\":1}}],[\"最终一致性的本质是需要系统保证最终数据能够达到一致\",{\"1\":{\"1078\":1}}],[\"最终一致性强调的是系统中所有的数据副本\",{\"1\":{\"1078\":1}}],[\"最终一致性\",{\"0\":{\"1078\":1},\"1\":{\"1073\":1,\"1078\":1}}],[\"最终虚拟线程诞生\",{\"1\":{\"1062\":1}}],[\"最终又回到了同步编程\",{\"1\":{\"1062\":1}}],[\"最终才变成操作系统可执行的指令序列\",{\"1\":{\"969\":1}}],[\"最终实现的可动态修改线程池参数效果如下\",{\"1\":{\"896\":1,\"923\":1}}],[\"最终的变量是放在了当前线程的\",{\"1\":{\"883\":1}}],[\"最终\",{\"1\":{\"766\":1,\"1112\":1}}],[\"最终设置为newvalue\",{\"1\":{\"763\":1}}],[\"最终代码的输出结果如下\",{\"1\":{\"531\":1}}],[\"最终都会委托到\",{\"1\":{\"433\":1}}],[\"最终值会为静态代码块中的赋值\",{\"1\":{\"430\":1}}],[\"最终标记\",{\"1\":{\"407\":1}}],[\"最重要的是你还能找到非常多的\",{\"1\":{\"1172\":1}}],[\"最重要的参数\",{\"1\":{\"896\":1,\"923\":1}}],[\"最重要的jvm参数总结\",{\"0\":{\"475\":1}}],[\"最重要的\",{\"1\":{\"412\":1}}],[\"最下面一层属于永久代\",{\"1\":{\"382\":1,\"495\":1}}],[\"最下面有一个\",{\"1\":{\"376\":1}}],[\"最顶层的加载类\",{\"1\":{\"353\":1}}],[\"最初由\",{\"1\":{\"1238\":1}}],[\"最初只是为了满足\",{\"1\":{\"351\":1}}],[\"最初是为浏览器构建的\",{\"1\":{\"8\":1}}],[\"最基本的就是首先做好参数校验\",{\"1\":{\"307\":1}}],[\"最基本的一种灰度发布\",{\"1\":{\"2\":1}}],[\"最友好\",{\"1\":{\"272\":1}}],[\"最要命的是没有广播机制\",{\"1\":{\"251\":1}}],[\"最新版本默认支持的是\",{\"1\":{\"1253\":1}}],[\"最新动态\",{\"1\":{\"182\":1}}],[\"最新文章\",{\"1\":{\"182\":1}}],[\"最右边\",{\"1\":{\"181\":1}}],[\"最左边\",{\"1\":{\"181\":1}}],[\"最左匹配顾名思义\",{\"1\":{\"116\":1}}],[\"最左匹配原则\",{\"0\":{\"116\":1},\"1\":{\"118\":1}}],[\"最好是以集群形态来部署\",{\"1\":{\"1354\":1,\"1362\":1}}],[\"最好是支撑较少的\",{\"1\":{\"1240\":1}}],[\"最好能满足以下的时间条件\",{\"1\":{\"1116\":1}}],[\"最好能达到ref\",{\"1\":{\"120\":1}}],[\"最好不要用下面这些方法\",{\"1\":{\"698\":1}}],[\"最好在向\",{\"1\":{\"564\":1}}],[\"最好选择在从节点上执行该命令\",{\"1\":{\"164\":1}}],[\"最经典的例子就是转账\",{\"1\":{\"124\":1}}],[\"最常见的例子无非是我们的线程池\",{\"1\":{\"530\":1}}],[\"最常见的就是在\",{\"1\":{\"38\":1}}],[\"最常用的也就\",{\"1\":{\"206\":1}}],[\"最常用的是\",{\"1\":{\"10\":1}}],[\"最后如果参与者顺利执行了事务则给协调者返回成功的响应\",{\"1\":{\"1371\":1}}],[\"最后拷贝到网卡\",{\"1\":{\"1311\":1}}],[\"最后在kibana中进行展示和检索\",{\"1\":{\"1045\":1}}],[\"最后在做一个总结\",{\"1\":{\"133\":1}}],[\"最后判断除了staleslot以外\",{\"1\":{\"1036\":1}}],[\"最后调用cleansomeslots\",{\"1\":{\"1036\":1}}],[\"最后抢到锁返回了\",{\"1\":{\"1015\":1}}],[\"最后我们将\",{\"1\":{\"710\":1}}],[\"最后一次被更新时\",{\"1\":{\"1382\":1}}],[\"最后一个节点的\",{\"1\":{\"657\":1}}],[\"最后一行的\",{\"1\":{\"571\":1}}],[\"最后表示全部包含或者制定集合为空集合\",{\"1\":{\"592\":1}}],[\"最后返回新数组\",{\"1\":{\"588\":1}}],[\"最后返回给客户端\",{\"1\":{\"69\":1}}],[\"最后将新数组赋值给底层数组的引用\",{\"1\":{\"588\":1}}],[\"最后size加1\",{\"1\":{\"553\":1,\"561\":1}}],[\"最后更新列表记录\",{\"1\":{\"503\":1}}],[\"最后再汇总数据统一返回\",{\"1\":{\"772\":1}}],[\"最后再来分享一段周志明老师在\",{\"1\":{\"498\":1}}],[\"最后再根据持久化方式\",{\"1\":{\"229\":1}}],[\"最后\",{\"1\":{\"37\":1,\"162\":1,\"233\":1,\"607\":1,\"693\":1,\"934\":1,\"1166\":1,\"1210\":1,\"1380\":1}}],[\"最后的\",{\"1\":{\"22\":1}}],[\"最后引用即可\",{\"1\":{\"7\":1}}],[\"中创建一个临时节点并且将自己的\",{\"1\":{\"1390\":1}}],[\"中定义了\",{\"1\":{\"1384\":1}}],[\"中生成后需要\",{\"1\":{\"1379\":1}}],[\"中更新了\",{\"1\":{\"1379\":1}}],[\"中更小的一个值\",{\"1\":{\"386\":1,\"495\":1}}],[\"中三个主要的角色\",{\"1\":{\"1378\":1}}],[\"中主要有三个角色\",{\"1\":{\"1372\":1}}],[\"中做出权衡\",{\"1\":{\"1368\":1}}],[\"中记录了这个\",{\"1\":{\"1350\":1}}],[\"中记录数16k\",{\"1\":{\"110\":1}}],[\"中去\",{\"1\":{\"1345\":1}}],[\"中去并设置过期时间\",{\"1\":{\"307\":1}}],[\"中介绍到\",{\"1\":{\"1335\":1}}],[\"中介层\",{\"1\":{\"1218\":1}}],[\"中管你是哪门子消息\",{\"1\":{\"1315\":1}}],[\"中又使用了\",{\"1\":{\"1315\":1}}],[\"中又包含了\",{\"1\":{\"1196\":1}}],[\"中采用了\",{\"1\":{\"1314\":1}}],[\"中通常是直接抛出一个异常让用户来自行解决\",{\"1\":{\"1304\":1}}],[\"中通过查看任务管理器的方式\",{\"1\":{\"806\":1}}],[\"中通过\",{\"1\":{\"37\":1,\"1249\":1}}],[\"中拉取消息进行消费\",{\"1\":{\"1304\":1}}],[\"中配置多个队列并且每个队列维护每个消费者组的消费位置\",{\"1\":{\"1280\":1}}],[\"中积压超过一定的时间就会被\",{\"1\":{\"1264\":1}}],[\"中消费数据的整个流程\",{\"1\":{\"1251\":1}}],[\"中消息只能存储在\",{\"1\":{\"1250\":1}}],[\"中消息消费的顺序\",{\"1\":{\"1202\":1}}],[\"中华石杉老师\",{\"1\":{\"1240\":1}}],[\"中发送\",{\"1\":{\"1202\":1}}],[\"中如果有和\",{\"1\":{\"1197\":1}}],[\"中选举出一个\",{\"1\":{\"1197\":1}}],[\"中插入新的事件对象时\",{\"1\":{\"1184\":1}}],[\"中插入新元素\",{\"1\":{\"712\":2}}],[\"中常见的线程安全的队列如下\",{\"1\":{\"1179\":1}}],[\"中常用的阻塞队列实现类有以下几种\",{\"1\":{\"671\":1}}],[\"中专门介绍过这个\",{\"1\":{\"1178\":1}}],[\"中央处理单元或磁盘驱动\",{\"1\":{\"1139\":1}}],[\"中国开源项目\",{\"1\":{\"1122\":1}}],[\"中冲突的日志条目都被移除了\",{\"1\":{\"1112\":1}}],[\"中是使用\",{\"1\":{\"1382\":1}}],[\"中是通过\",{\"1\":{\"1281\":1}}],[\"中是这样介绍\",{\"1\":{\"1078\":1}}],[\"中是没有与之对应的类的\",{\"1\":{\"353\":1}}],[\"中一致性\",{\"1\":{\"1073\":1}}],[\"中文\",{\"1\":{\"1071\":1}}],[\"中文文档\",{\"1\":{\"377\":1,\"1169\":1}}],[\"中还定义了一个\",{\"1\":{\"1379\":1}}],[\"中还有一个inheritablethreadlocal类\",{\"1\":{\"1043\":1}}],[\"中还能看到\",{\"1\":{\"688\":1,\"792\":1}}],[\"中取消节点是怎么生成的呢\",{\"1\":{\"1012\":1}}],[\"中公平锁和非公平锁在底层是相同的\",{\"1\":{\"1008\":1}}],[\"中会维护队列\",{\"1\":{\"1380\":1}}],[\"中会为每个\",{\"1\":{\"1315\":1}}],[\"中会创建这些文件夹\",{\"1\":{\"1199\":1}}],[\"中会先进行一轮探测式清理\",{\"1\":{\"1036\":1}}],[\"中会调用\",{\"1\":{\"1007\":1}}],[\"中会首先判断当前数组长度\",{\"1\":{\"577\":1}}],[\"中维护了一个名为\",{\"1\":{\"1006\":1}}],[\"中最基本的数据结构\",{\"1\":{\"1005\":1}}],[\"中最简单同时也是最常用的一个数据类型\",{\"1\":{\"176\":1,\"254\":1}}],[\"中独占锁的逻辑和\",{\"1\":{\"999\":1}}],[\"中抛出的运行时异常会杀死一个线程\",{\"1\":{\"962\":1}}],[\"中线程处理任务的速度时\",{\"1\":{\"957\":1}}],[\"中保存的线程池当前的一些状态信息\",{\"1\":{\"941\":1}}],[\"中强制线程池不允许使用\",{\"1\":{\"889\":1}}],[\"中就是使用的上述的事务反查来解决的\",{\"1\":{\"1304\":1}}],[\"中就是这种方式创建的\",{\"1\":{\"777\":1}}],[\"中就涉及一些\",{\"1\":{\"1177\":1}}],[\"中就说过这三个参数是\",{\"1\":{\"923\":1}}],[\"中就会出现\",{\"1\":{\"884\":1}}],[\"中扩展\",{\"1\":{\"882\":1}}],[\"中自带的threadlocal类正是为了解决这样的问题\",{\"1\":{\"881\":1}}],[\"中实现的\",{\"1\":{\"857\":1}}],[\"中实现这一数据结构的类是\",{\"1\":{\"800\":1}}],[\"中断事务\",{\"1\":{\"1371\":1}}],[\"中断恢复后的执行流程\",{\"0\":{\"1015\":1}}],[\"中断如何处理\",{\"1\":{\"1014\":1}}],[\"中断\",{\"1\":{\"857\":1,\"1012\":1}}],[\"中java\",{\"1\":{\"838\":1,\"987\":1}}],[\"中synchronized和reentrantlock等独占锁就是悲观锁思想的实现\",{\"1\":{\"837\":1,\"986\":1}}],[\"中重写的一个方法\",{\"1\":{\"748\":1}}],[\"中移除\",{\"1\":{\"712\":2}}],[\"中看到\",{\"1\":{\"712\":1}}],[\"中使用的是\",{\"1\":{\"1304\":1}}],[\"中使用的\",{\"1\":{\"884\":1}}],[\"中使用\",{\"1\":{\"693\":1,\"1030\":1}}],[\"中treebin通过waiter属性维护当前使用这棵红黑树的线程\",{\"1\":{\"688\":1}}],[\"中都存在\",{\"1\":{\"686\":1}}],[\"中带有初始容量的构造函数\",{\"1\":{\"677\":1}}],[\"中被处理\",{\"1\":{\"1182\":1}}],[\"中被提出的\",{\"1\":{\"1084\":1}}],[\"中被引入的\",{\"1\":{\"669\":1}}],[\"中被称为\",{\"1\":{\"54\":1,\"1348\":1,\"1349\":1}}],[\"中用于排序的接口\",{\"1\":{\"661\":1}}],[\"中用于运行用户代码的时间与\",{\"1\":{\"403\":1}}],[\"中只能存储对象\",{\"1\":{\"649\":1}}],[\"中只存\",{\"1\":{\"273\":1}}],[\"中没有文件系统中目录与文件的概念\",{\"1\":{\"1382\":1}}],[\"中没有选择传统的\",{\"1\":{\"1355\":1}}],[\"中没有队列这个概念\",{\"1\":{\"1194\":1}}],[\"中没有权重的概念\",{\"1\":{\"1143\":1}}],[\"中没有空闲线程时\",{\"1\":{\"958\":1}}],[\"中没有包含\",{\"1\":{\"680\":1}}],[\"中没有\",{\"1\":{\"621\":1}}],[\"中唯一一个可以等待并获取元素的线程引用\",{\"1\":{\"604\":1}}],[\"中获取路由表然后照着路由表的信息和对应的\",{\"1\":{\"1281\":1}}],[\"中获取任务来执行\",{\"1\":{\"950\":1,\"954\":1}}],[\"中获取元素的方式分为阻塞式和非阻塞式\",{\"1\":{\"604\":1}}],[\"中获取当前线程对应的\",{\"1\":{\"56\":1}}],[\"中相对于\",{\"1\":{\"578\":1}}],[\"中大量调用了这两个方法\",{\"1\":{\"560\":1}}],[\"中添加元素\",{\"1\":{\"678\":2}}],[\"中添加\",{\"1\":{\"551\":1,\"652\":1}}],[\"中可以存在两种特殊字符串\",{\"1\":{\"1252\":1}}],[\"中可以存储任何类型的对象\",{\"1\":{\"551\":1,\"652\":1}}],[\"中可以通过\",{\"1\":{\"120\":1}}],[\"中另一个重要的继承接口\",{\"1\":{\"533\":1}}],[\"中并没有链表结构\",{\"1\":{\"1033\":1}}],[\"中并没有类似于\",{\"1\":{\"588\":1}}],[\"中并没有对\",{\"1\":{\"533\":1}}],[\"中并执行的能力\",{\"1\":{\"351\":1}}],[\"中则\",{\"1\":{\"531\":1}}],[\"中新加入的\",{\"1\":{\"499\":1}}],[\"中说过的话\",{\"1\":{\"498\":1}}],[\"中接口和类的关系\",{\"1\":{\"496\":1}}],[\"中花费的\",{\"1\":{\"484\":1}}],[\"中提到的\",{\"1\":{\"480\":1}}],[\"中显示的\",{\"1\":{\"449\":1}}],[\"中测试\",{\"1\":{\"448\":1}}],[\"中已经逐步替换掉它\",{\"1\":{\"446\":1}}],[\"中已经被标记为\",{\"1\":{\"446\":1}}],[\"中已经移除永久代\",{\"1\":{\"443\":1}}],[\"中要求的\",{\"1\":{\"444\":1}}],[\"中其实就是方法\",{\"1\":{\"441\":1}}],[\"中叫栈帧\",{\"1\":{\"441\":1}}],[\"中出现\",{\"1\":{\"408\":1}}],[\"中开辟了一块区域存放运行时常量池\",{\"1\":{\"393\":1}}],[\"中引入\",{\"1\":{\"943\":1}}],[\"中引入的\",{\"1\":{\"598\":1}}],[\"中引入了一个概念叫\",{\"1\":{\"251\":1}}],[\"中引用的定义很传统\",{\"1\":{\"392\":1}}],[\"中引用的对象\",{\"1\":{\"391\":2,\"445\":1}}],[\"中每熬过一次\",{\"1\":{\"386\":1}}],[\"中间层\",{\"1\":{\"1253\":1}}],[\"中间还必须经过\",{\"1\":{\"1249\":1}}],[\"中间件协议\",{\"1\":{\"1246\":1}}],[\"中间件同产品\",{\"1\":{\"1230\":1}}],[\"中间件就是一类为应用软件服务的软件\",{\"1\":{\"1218\":1}}],[\"中间件位于客户机服务器的操作系统之上\",{\"1\":{\"1218\":1}}],[\"中间件\",{\"1\":{\"1218\":2}}],[\"中间有一个分界指针\",{\"1\":{\"503\":1}}],[\"中间的\",{\"1\":{\"412\":1}}],[\"中间一层属于老年代\",{\"1\":{\"382\":1,\"495\":1}}],[\"中间只是一个横线\",{\"1\":{\"99\":1}}],[\"中除了少数几个关键模块\",{\"1\":{\"353\":1}}],[\"中除了字符串类型有自己独有设置过期时间的命令\",{\"1\":{\"270\":1}}],[\"中内置了三个重要的\",{\"1\":{\"353\":1}}],[\"中进行分配\",{\"1\":{\"342\":1}}],[\"中遇到写请求是这样的\",{\"1\":{\"316\":1}}],[\"中缓存大量无效的\",{\"1\":{\"307\":1}}],[\"中任意选择数据淘汰\",{\"1\":{\"273\":2}}],[\"中挑选最不经常使用的数据淘汰\",{\"1\":{\"273\":1,\"298\":1}}],[\"中挑选最近最少使用的数据淘汰\",{\"1\":{\"273\":1}}],[\"中挑选将要过期的数据淘汰\",{\"1\":{\"273\":1}}],[\"中有闲线程正在执行\",{\"1\":{\"958\":1}}],[\"中有四个构造方法\",{\"1\":{\"621\":1}}],[\"中有两种\",{\"1\":{\"298\":1}}],[\"中有一个无参构造函数和一个有参构造函数\",{\"1\":{\"728\":1}}],[\"中有一个无参构造函数和两个有参构造函数\",{\"1\":{\"587\":1}}],[\"中有一个叫做\",{\"1\":{\"258\":1}}],[\"中有一些原生支持批量操作的命令\",{\"1\":{\"286\":1}}],[\"中有新数据后在返回或者是等待最多一个超时时间后返回空\",{\"1\":{\"251\":1}}],[\"中对应的\",{\"1\":{\"257\":1}}],[\"中比较常见的数据类型有下面这些\",{\"1\":{\"253\":1}}],[\"中增加的\",{\"1\":{\"249\":1}}],[\"中存放的元素必须实现\",{\"1\":{\"597\":1}}],[\"中存放了太多不经常被访问的数据\",{\"1\":{\"319\":1}}],[\"中存储的数据量较小的进一步原因\",{\"1\":{\"1362\":1}}],[\"中存储的是稳定的句柄地址\",{\"1\":{\"510\":1}}],[\"中存储的直接就是对象的地址\",{\"1\":{\"510\":1}}],[\"中存储的就是对象的句柄地址\",{\"1\":{\"509\":1}}],[\"中存储的地理位置信息的经纬度数据通过\",{\"1\":{\"210\":1}}],[\"中存在多个队列\",{\"1\":{\"1281\":1}}],[\"中存在\",{\"1\":{\"146\":1,\"292\":1,\"1098\":1}}],[\"中储存的数字值减一\",{\"1\":{\"177\":2}}],[\"中储存的数字值增一\",{\"1\":{\"177\":2}}],[\"中指定排名范围\",{\"1\":{\"157\":1,\"301\":1}}],[\"中指定排名范围内的所有元素\",{\"1\":{\"157\":1,\"301\":1}}],[\"中指定范围内的元素\",{\"1\":{\"157\":1,\"301\":1}}],[\"中所有的键值对\",{\"1\":{\"157\":1,\"301\":1}}],[\"中不需要向\",{\"1\":{\"1388\":1}}],[\"中不为空的元素\",{\"1\":{\"713\":1}}],[\"中不存在什么\",{\"1\":{\"1069\":1}}],[\"中不存在对应的数据\",{\"1\":{\"146\":1}}],[\"中不存在\",{\"1\":{\"146\":1,\"694\":2}}],[\"中不包含敏感信息\",{\"1\":{\"30\":1}}],[\"中服务端把\",{\"1\":{\"146\":1}}],[\"中服务端需要同时维系\",{\"1\":{\"145\":1}}],[\"中读取的\",{\"1\":{\"968\":1}}],[\"中读取不到的话\",{\"1\":{\"145\":1}}],[\"中读取数据返回\",{\"1\":{\"145\":1}}],[\"中读取数据\",{\"1\":{\"145\":2,\"146\":1,\"968\":1}}],[\"中包含\",{\"1\":{\"70\":1}}],[\"中数据的最小单元\",{\"1\":{\"54\":1,\"1348\":1,\"1349\":1}}],[\"中加入业务类型信息\",{\"1\":{\"38\":1}}],[\"中关于线程状态的三处错误\",{\"1\":{\"820\":1}}],[\"中关于\",{\"1\":{\"37\":1}}],[\"中的最小数据单元\",{\"1\":{\"1382\":1}}],[\"中的最新数据\",{\"1\":{\"1087\":4}}],[\"中的三个角色\",{\"0\":{\"1378\":1}}],[\"中的队列\",{\"1\":{\"1315\":1}}],[\"中的队列是\",{\"1\":{\"1004\":1}}],[\"中的起始物理偏移量\",{\"1\":{\"1315\":1}}],[\"中的技术架构肯定不止前面那么简单\",{\"1\":{\"1281\":1}}],[\"中的消息队列进行发送\",{\"1\":{\"1301\":1}}],[\"中的消息模型就是按照\",{\"1\":{\"1280\":1}}],[\"中的消息模型\",{\"0\":{\"1280\":1}}],[\"中的消息有序\",{\"1\":{\"1202\":1}}],[\"中的交换器\",{\"1\":{\"1253\":1}}],[\"中的交换器看作一个简单的实体\",{\"1\":{\"1249\":1}}],[\"中的作用\",{\"1\":{\"1199\":1}}],[\"中的作用是什么\",{\"0\":{\"1199\":1}}],[\"中的多个副本之间会有一个叫做\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"中的节点\",{\"1\":{\"1085\":1}}],[\"中的节点都会定时地向其他节点发送\",{\"1\":{\"1085\":1}}],[\"中的节点是怎么进行通信的\",{\"1\":{\"318\":1}}],[\"中的某个方法的话就可以通过\",{\"1\":{\"1165\":1}}],[\"中的某个\",{\"1\":{\"1085\":1}}],[\"中的某个数据删除时\",{\"1\":{\"218\":1}}],[\"中的各个节点基于\",{\"1\":{\"1085\":1}}],[\"中的几种同步工具\",{\"1\":{\"1019\":1}}],[\"中的应用场景\",{\"0\":{\"1019\":1}}],[\"中的核心方法\",{\"1\":{\"1002\":1}}],[\"中的核心方法进行详细介绍\",{\"1\":{\"732\":1}}],[\"中的大部分同步类\",{\"1\":{\"999\":1}}],[\"中的大部分命令都是\",{\"1\":{\"157\":1,\"301\":1}}],[\"中的线程模型是用户级的么\",{\"1\":{\"808\":1,\"1053\":1}}],[\"中的任意一个完成时触发执行任务\",{\"1\":{\"781\":1}}],[\"中的任意一个任务执行完后就执行\",{\"1\":{\"781\":1}}],[\"中的默认实现呢\",{\"1\":{\"1131\":1}}],[\"中的默认实现\",{\"0\":{\"1131\":1},\"1\":{\"748\":2,\"752\":2}}],[\"中的共享资源\",{\"1\":{\"747\":1,\"905\":1}}],[\"中的await\",{\"1\":{\"742\":1}}],[\"中的方法\",{\"1\":{\"678\":1}}],[\"中的tablesizefor\",{\"1\":{\"677\":1}}],[\"中的读取操作是完全无需加锁的\",{\"1\":{\"584\":1,\"793\":1}}],[\"中的类似于\",{\"1\":{\"570\":2}}],[\"中的数组相比\",{\"1\":{\"549\":1}}],[\"中的数据都是热点数据\",{\"1\":{\"273\":1}}],[\"中的数据也会产生内存碎片\",{\"1\":{\"218\":1}}],[\"中的数据的命令\",{\"1\":{\"161\":1,\"229\":1}}],[\"中的数据会被频繁被删除\",{\"1\":{\"145\":1}}],[\"中的数据\",{\"1\":{\"145\":1}}],[\"中的剩余内存或\",{\"1\":{\"503\":1}}],[\"中的垃圾回收器\",{\"1\":{\"448\":1}}],[\"中的java\",{\"1\":{\"433\":1}}],[\"中的第一条语句为\",{\"1\":{\"425\":1}}],[\"中的永久代\",{\"1\":{\"393\":1}}],[\"中的getcontextclassloader\",{\"1\":{\"359\":1}}],[\"中的示例\",{\"1\":{\"298\":1}}],[\"中的所有\",{\"1\":{\"293\":1}}],[\"中的所有元素\",{\"1\":{\"157\":1,\"301\":1}}],[\"中的原子操作时\",{\"1\":{\"287\":1}}],[\"中的事务理解为\",{\"1\":{\"279\":1}}],[\"中的文件事件处理器\",{\"1\":{\"265\":1}}],[\"中的元素是通过\",{\"1\":{\"727\":1}}],[\"中的元素已经是按照\",{\"1\":{\"679\":1}}],[\"中的元素数\",{\"1\":{\"531\":1}}],[\"中的元素\",{\"1\":{\"210\":1,\"531\":1,\"649\":2,\"732\":1}}],[\"中的实现\",{\"1\":{\"1310\":1}}],[\"中的实现可以看这篇文章\",{\"1\":{\"205\":1}}],[\"中的实际数据类型\",{\"1\":{\"201\":1}}],[\"中的虚拟内存\",{\"1\":{\"168\":1}}],[\"中的主键索引就属于聚簇索引\",{\"1\":{\"105\":1}}],[\"中的一些基本概念\",{\"1\":{\"1391\":1}}],[\"中的一些关于\",{\"1\":{\"1251\":1}}],[\"中的一种即可\",{\"1\":{\"1007\":1}}],[\"中的一个注解\",{\"1\":{\"1213\":1}}],[\"中的一个\",{\"1\":{\"1142\":1}}],[\"中的一个关键字\",{\"1\":{\"847\":1}}],[\"中的一个性能瓶颈\",{\"1\":{\"267\":1}}],[\"中的一个很重要的特性\",{\"1\":{\"55\":1,\"1352\":1}}],[\"中的一段\",{\"1\":{\"22\":1}}],[\"中的分布式锁自带自动续期机制\",{\"1\":{\"49\":1}}],[\"中的号段在用到一定程度的时候\",{\"1\":{\"42\":1}}],[\"中的\",{\"0\":{\"1129\":1},\"1\":{\"22\":1,\"47\":1,\"50\":1,\"55\":1,\"74\":1,\"145\":2,\"168\":1,\"180\":2,\"184\":1,\"188\":2,\"195\":1,\"259\":1,\"265\":1,\"408\":1,\"443\":1,\"558\":3,\"570\":1,\"579\":2,\"691\":1,\"693\":1,\"712\":1,\"742\":1,\"876\":1,\"918\":1,\"1007\":2,\"1015\":1,\"1033\":1,\"1110\":1,\"1144\":1,\"1196\":1,\"1249\":1,\"1280\":4,\"1281\":1,\"1298\":1,\"1310\":1,\"1312\":1,\"1314\":1,\"1315\":1,\"1328\":1,\"1380\":2}}],[\"中运行\",{\"1\":{\"8\":1}}],[\"中\",{\"0\":{\"610\":1,\"826\":1,\"830\":1},\"1\":{\"7\":1,\"8\":1,\"13\":1,\"23\":1,\"47\":1,\"56\":2,\"60\":1,\"65\":1,\"70\":1,\"101\":1,\"117\":1,\"141\":1,\"145\":2,\"150\":1,\"153\":1,\"161\":1,\"189\":3,\"192\":1,\"193\":1,\"195\":1,\"206\":2,\"210\":1,\"229\":1,\"231\":1,\"259\":1,\"262\":2,\"302\":1,\"320\":1,\"324\":1,\"351\":1,\"352\":1,\"357\":2,\"359\":1,\"386\":1,\"407\":1,\"412\":1,\"419\":1,\"445\":1,\"486\":1,\"511\":2,\"523\":1,\"530\":1,\"531\":1,\"549\":1,\"569\":1,\"570\":1,\"579\":1,\"588\":1,\"598\":4,\"602\":1,\"609\":2,\"610\":1,\"632\":1,\"649\":1,\"680\":2,\"686\":2,\"691\":1,\"693\":1,\"694\":1,\"712\":1,\"736\":1,\"742\":1,\"773\":1,\"806\":1,\"826\":1,\"833\":1,\"834\":2,\"848\":1,\"851\":1,\"883\":1,\"899\":1,\"968\":3,\"972\":1,\"978\":1,\"979\":1,\"980\":1,\"1002\":1,\"1011\":1,\"1033\":1,\"1074\":1,\"1140\":1,\"1157\":1,\"1196\":1,\"1199\":1,\"1202\":1,\"1238\":1,\"1249\":2,\"1250\":1,\"1252\":5,\"1281\":1,\"1305\":1,\"1306\":1,\"1360\":1,\"1383\":1}}],[\"嵌入\",{\"1\":{\"7\":1}}],[\"v3\",{\"1\":{\"1258\":1}}],[\"v>>\",{\"1\":{\"619\":1}}],[\"v>\",{\"1\":{\"570\":5,\"571\":25,\"572\":11,\"573\":5,\"576\":4,\"577\":8,\"578\":2,\"619\":18,\"621\":3,\"622\":6,\"623\":5,\"624\":9,\"630\":1,\"683\":4,\"688\":4,\"690\":1,\"698\":1,\"706\":3,\"708\":6,\"711\":6,\"712\":1}}],[\"voter\",{\"1\":{\"1098\":1}}],[\"volatoleatomicitydemo\",{\"1\":{\"835\":5}}],[\"volatile或者final关键字\",{\"1\":{\"978\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"855\":1}}],[\"volatile性能肯定比synchronized关键字要好\",{\"1\":{\"855\":1}}],[\"volatile\",{\"0\":{\"832\":1,\"835\":1,\"855\":1},\"1\":{\"273\":4,\"298\":3,\"331\":1,\"589\":1,\"688\":3,\"742\":2,\"764\":1,\"765\":3,\"768\":2,\"833\":5,\"834\":5,\"835\":5,\"855\":4,\"876\":2,\"904\":2,\"971\":1,\"975\":4,\"979\":2,\"980\":1,\"1004\":1,\"1006\":2,\"1018\":2}}],[\"void\",{\"1\":{\"49\":2,\"56\":1,\"218\":2,\"268\":8,\"352\":1,\"353\":1,\"370\":1,\"384\":2,\"390\":1,\"433\":1,\"438\":1,\"480\":1,\"531\":3,\"533\":1,\"535\":2,\"539\":1,\"553\":11,\"557\":2,\"558\":1,\"561\":3,\"562\":1,\"564\":3,\"572\":1,\"591\":1,\"599\":1,\"621\":1,\"625\":1,\"634\":6,\"662\":2,\"663\":3,\"679\":1,\"683\":1,\"696\":6,\"697\":1,\"710\":1,\"711\":2,\"712\":1,\"729\":3,\"731\":1,\"732\":1,\"742\":1,\"748\":5,\"749\":2,\"752\":3,\"753\":2,\"757\":4,\"763\":2,\"764\":2,\"766\":2,\"767\":5,\"768\":3,\"778\":1,\"779\":2,\"807\":1,\"823\":1,\"834\":3,\"835\":5,\"837\":1,\"848\":2,\"851\":1,\"852\":1,\"860\":2,\"882\":2,\"883\":1,\"891\":1,\"904\":1,\"906\":3,\"909\":1,\"918\":1,\"940\":3,\"941\":1,\"943\":1,\"986\":1,\"1001\":2,\"1002\":2,\"1006\":1,\"1008\":2,\"1012\":2,\"1013\":1,\"1014\":2,\"1015\":1,\"1020\":4,\"1028\":2,\"1030\":2,\"1031\":2,\"1036\":2,\"1038\":3,\"1043\":3,\"1046\":3,\"1047\":2,\"1058\":2,\"1059\":2,\"1060\":2,\"1061\":2,\"1062\":2,\"1209\":1,\"1212\":1,\"1213\":1}}],[\"v\",{\"1\":{\"245\":2,\"327\":1,\"328\":2,\"329\":1,\"365\":1,\"553\":4,\"571\":6,\"572\":3,\"573\":1,\"577\":5,\"578\":1,\"619\":7,\"621\":1,\"622\":8,\"623\":1,\"630\":6,\"680\":2,\"686\":8,\"708\":1,\"710\":6,\"711\":2,\"712\":4,\"713\":13,\"773\":3,\"841\":5,\"843\":3,\"851\":1,\"884\":2,\"899\":3,\"900\":1,\"943\":1,\"990\":5,\"992\":3}}],[\"vscode\",{\"1\":{\"1132\":1}}],[\"vs\",{\"0\":{\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"1231\":1},\"1\":{\"244\":1,\"274\":2,\"693\":1,\"820\":1}}],[\"vps\",{\"1\":{\"168\":1}}],[\"via\",{\"1\":{\"571\":1,\"693\":1}}],[\"virt\",{\"1\":{\"412\":1}}],[\"virtualthreadtest\",{\"1\":{\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1}}],[\"virtual\",{\"1\":{\"334\":1,\"339\":1,\"345\":1,\"356\":1,\"365\":1,\"377\":1,\"417\":1,\"511\":1,\"1052\":1,\"1053\":1,\"1062\":2}}],[\"visualvm\",{\"1\":{\"377\":13,\"455\":2,\"895\":1,\"922\":1}}],[\"visual\",{\"0\":{\"377\":1},\"1\":{\"368\":1,\"377\":2}}],[\"view都会按照数据库当前状态重新生成read\",{\"1\":{\"141\":1}}],[\"view都是使用第一次查询时生成的read\",{\"1\":{\"141\":1}}],[\"view和可见性算法其实就是记录了sql查询那个时刻数据库里提交和未提交所有事务的状态\",{\"1\":{\"141\":1}}],[\"view是不变动的\",{\"1\":{\"141\":1}}],[\"view为\",{\"1\":{\"141\":1}}],[\"view做比对从而得到最终的快照结果\",{\"1\":{\"141\":1}}],[\"view\",{\"1\":{\"141\":8}}],[\"vip+qq\",{\"1\":{\"19\":1}}],[\"very\",{\"1\":{\"1096\":1}}],[\"verification\",{\"1\":{\"338\":1}}],[\"version=1\",{\"1\":{\"840\":5,\"989\":5}}],[\"version=version+1\",{\"1\":{\"34\":1}}],[\"version\",{\"0\":{\"327\":1,\"1350\":1},\"1\":{\"34\":4,\"37\":6,\"86\":1,\"141\":1,\"325\":2,\"327\":2,\"400\":1,\"403\":2,\"840\":7,\"989\":7,\"1382\":1}}],[\"version>\",{\"1\":{\"4\":1,\"1332\":2}}],[\"vector<>\",{\"1\":{\"352\":1}}],[\"vector<class<\",{\"1\":{\"352\":1}}],[\"vector\",{\"0\":{\"550\":1,\"650\":1,\"651\":1},\"1\":{\"201\":1,\"550\":1,\"583\":4,\"642\":1,\"650\":1,\"651\":4,\"791\":1,\"793\":4}}],[\"velsky和e\",{\"1\":{\"98\":1}}],[\"vmid\",{\"1\":{\"366\":10,\"367\":3}}],[\"vm\",{\"0\":{\"377\":1},\"1\":{\"41\":1,\"168\":1,\"368\":1,\"377\":2,\"387\":1,\"403\":1,\"443\":1,\"448\":1,\"449\":1,\"451\":1,\"480\":1,\"484\":1,\"485\":1,\"808\":1,\"1053\":1}}],[\"val\",{\"1\":{\"577\":4,\"578\":3,\"619\":2}}],[\"valueof\",{\"1\":{\"1209\":1}}],[\"valueoffset\",{\"1\":{\"765\":2}}],[\"valuefield\",{\"1\":{\"1030\":3}}],[\"value为代码中放入的值\",{\"1\":{\"1029\":1}}],[\"valuemapper\",{\"1\":{\"630\":2}}],[\"value+\",{\"1\":{\"625\":1}}],[\"value作为新数组的大小\",{\"1\":{\"559\":1}}],[\"value`\",{\"1\":{\"558\":1,\"889\":1,\"937\":1}}],[\"value=111\",{\"1\":{\"342\":2}}],[\"value中指定的字段是否存在\",{\"1\":{\"185\":1}}],[\"value3\",{\"1\":{\"181\":7,\"189\":3,\"193\":3}}],[\"value2\",{\"1\":{\"177\":3,\"181\":9,\"185\":1,\"189\":7,\"193\":9}}],[\"value1\",{\"1\":{\"177\":3,\"181\":8,\"185\":1,\"189\":7,\"193\":8}}],[\"value是查询的结果\",{\"1\":{\"85\":1}}],[\"value对的形式存储之前做过的查询\",{\"1\":{\"85\":1}}],[\"values\",{\"1\":{\"33\":1,\"34\":1,\"125\":2,\"625\":3,\"629\":1,\"688\":1,\"713\":2}}],[\"value\",{\"0\":{\"693\":1},\"1\":{\"8\":1,\"47\":2,\"96\":3,\"120\":2,\"163\":4,\"177\":6,\"178\":1,\"181\":2,\"184\":1,\"185\":3,\"195\":1,\"202\":1,\"254\":1,\"257\":3,\"270\":1,\"286\":1,\"291\":4,\"302\":1,\"307\":1,\"342\":3,\"386\":2,\"480\":1,\"498\":1,\"529\":1,\"542\":1,\"553\":4,\"558\":2,\"559\":4,\"571\":21,\"572\":1,\"573\":3,\"577\":10,\"578\":2,\"616\":1,\"619\":10,\"621\":2,\"622\":16,\"623\":1,\"624\":2,\"625\":2,\"629\":3,\"630\":6,\"640\":3,\"671\":1,\"672\":1,\"677\":2,\"680\":2,\"683\":1,\"686\":7,\"688\":1,\"693\":2,\"694\":8,\"708\":2,\"710\":1,\"711\":5,\"712\":4,\"765\":3,\"777\":3,\"798\":3,\"883\":5,\"884\":6,\"889\":5,\"892\":3,\"917\":3,\"937\":5,\"938\":3,\"949\":1,\"951\":1,\"955\":1,\"957\":3,\"959\":1,\"961\":2,\"1030\":3,\"1031\":3,\"1036\":14,\"1037\":3,\"1038\":1,\"1097\":1,\"1098\":1,\"1204\":1,\"1303\":1}}],[\"var\",{\"1\":{\"841\":1,\"990\":1}}],[\"various\",{\"1\":{\"756\":1,\"911\":1}}],[\"variables\",{\"1\":{\"342\":1}}],[\"variant\",{\"1\":{\"37\":2}}],[\"varargs\",{\"1\":{\"634\":2}}],[\"varhandle\",{\"1\":{\"344\":1}}],[\"varchar\",{\"1\":{\"18\":1,\"103\":1,\"104\":1}}],[\"v2\",{\"1\":{\"7\":1,\"1140\":1,\"1143\":1}}],[\"emmm\",{\"1\":{\"1303\":1,\"1315\":1}}],[\"empty\",{\"1\":{\"553\":10,\"555\":5,\"557\":1,\"564\":2,\"570\":1,\"577\":1,\"622\":1,\"941\":1}}],[\"employee\",{\"1\":{\"329\":2}}],[\"epoch\",{\"1\":{\"1379\":3}}],[\"epidemic\",{\"1\":{\"1084\":3}}],[\"ephemeralowner=0\",{\"1\":{\"1349\":1}}],[\"ephemeralowner\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":2,\"1382\":1}}],[\"ephemeral\",{\"1\":{\"54\":3,\"1335\":5,\"1337\":1,\"1349\":3}}],[\"ebay\",{\"1\":{\"1072\":1}}],[\"erlang\",{\"1\":{\"1237\":1,\"1240\":4,\"1245\":1,\"1253\":1,\"1257\":1}}],[\"eric\",{\"1\":{\"1066\":1}}],[\"err\",{\"1\":{\"298\":1,\"924\":1}}],[\"errorwebexceptionhandler\",{\"1\":{\"77\":1}}],[\"error\",{\"1\":{\"49\":1,\"86\":3,\"298\":1,\"524\":2,\"687\":2,\"748\":1,\"756\":1,\"765\":1,\"780\":2,\"911\":1,\"1007\":1,\"1011\":1,\"1018\":2,\"1204\":1,\"1293\":2}}],[\"edu\",{\"1\":{\"982\":1}}],[\"eden=2\",{\"1\":{\"453\":1}}],[\"eden+2\",{\"1\":{\"452\":1}}],[\"eden+\",{\"1\":{\"449\":1}}],[\"eden\",{\"0\":{\"384\":1,\"444\":1,\"453\":1,\"470\":1},\"1\":{\"375\":1,\"382\":1,\"384\":7,\"386\":3,\"443\":1,\"444\":5,\"449\":3,\"453\":1,\"454\":1,\"485\":2,\"495\":4,\"503\":1}}],[\"e=1\",{\"1\":{\"841\":1,\"990\":1}}],[\"efg\",{\"1\":{\"782\":2}}],[\"eh\",{\"1\":{\"578\":3}}],[\"ek\",{\"1\":{\"577\":4,\"578\":7}}],[\"e>\",{\"1\":{\"533\":2,\"534\":1,\"553\":3,\"555\":1,\"587\":1,\"602\":1,\"634\":2,\"728\":1}}],[\"eaf70fc620cb\",{\"1\":{\"1322\":1}}],[\"each\",{\"1\":{\"356\":1,\"618\":1,\"682\":1,\"732\":2}}],[\"early\",{\"1\":{\"480\":1}}],[\"ear\",{\"1\":{\"340\":1}}],[\"eazcettjtuemxfuubvhjew\",{\"1\":{\"171\":1}}],[\"evict\",{\"1\":{\"621\":2,\"622\":2,\"680\":1,\"686\":3,\"712\":4}}],[\"eviction\",{\"1\":{\"273\":1}}],[\"even\",{\"1\":{\"756\":1,\"911\":1}}],[\"eventprocessor\",{\"1\":{\"1182\":2}}],[\"eventhandler\",{\"1\":{\"1182\":1}}],[\"eventfactory\",{\"1\":{\"1182\":1}}],[\"eventually\",{\"1\":{\"1073\":1}}],[\"events\",{\"1\":{\"974\":1}}],[\"event\",{\"1\":{\"265\":5,\"1182\":4}}],[\"every\",{\"1\":{\"302\":1,\"351\":1,\"612\":1}}],[\"everysec\",{\"1\":{\"161\":1,\"231\":2,\"236\":1,\"282\":2}}],[\"eval\",{\"1\":{\"49\":1}}],[\"evalwriteasync\",{\"1\":{\"49\":1}}],[\"equal\",{\"1\":{\"571\":1}}],[\"equals\",{\"1\":{\"538\":1,\"553\":4,\"571\":2,\"573\":1,\"577\":1,\"578\":2,\"619\":4,\"622\":3,\"623\":2,\"632\":1,\"664\":2,\"683\":1,\"711\":1,\"731\":1}}],[\"equivalent\",{\"1\":{\"302\":1}}],[\"eqrub12qh6ebbhxa\",{\"1\":{\"156\":1}}],[\"eq\",{\"1\":{\"120\":2}}],[\"eldest\",{\"1\":{\"706\":1,\"712\":3}}],[\"eliminating\",{\"1\":{\"369\":1}}],[\"elements\",{\"1\":{\"587\":8,\"588\":3,\"591\":6,\"592\":6,\"634\":2}}],[\"elementdata数组中区分出来\",{\"1\":{\"553\":1}}],[\"elementdata\",{\"1\":{\"553\":65,\"555\":14,\"557\":11,\"558\":3,\"561\":5,\"562\":2,\"564\":2,\"632\":2}}],[\"elementdequeued\",{\"1\":{\"535\":1}}],[\"element\",{\"1\":{\"351\":2,\"531\":2,\"552\":2,\"553\":5,\"560\":1,\"561\":2,\"564\":1,\"588\":1,\"630\":3,\"634\":2,\"656\":2,\"667\":1,\"680\":1,\"727\":2,\"729\":4,\"731\":2}}],[\"element2\",{\"1\":{\"206\":1,\"262\":1}}],[\"element1\",{\"1\":{\"206\":1,\"262\":1}}],[\"election\",{\"1\":{\"1206\":3,\"1356\":1}}],[\"electiontimeout也要比mtbf小几个数量级\",{\"1\":{\"1116\":1}}],[\"electiontimeout\",{\"1\":{\"1115\":1,\"1116\":3}}],[\"electionelapsed\",{\"1\":{\"1111\":1}}],[\"elect\",{\"1\":{\"86\":2}}],[\"elasticsearch\",{\"1\":{\"103\":2,\"104\":1}}],[\"else其实\",{\"1\":{\"710\":1}}],[\"else\",{\"1\":{\"47\":1,\"49\":1,\"218\":1,\"353\":1,\"357\":1,\"533\":2,\"536\":3,\"553\":6,\"555\":3,\"571\":7,\"572\":1,\"576\":1,\"577\":4,\"578\":1,\"587\":1,\"591\":1,\"604\":3,\"621\":1,\"622\":3,\"624\":8,\"630\":1,\"632\":1,\"658\":1,\"683\":2,\"686\":1,\"710\":3,\"711\":4,\"729\":3,\"730\":1,\"731\":3,\"732\":1,\"756\":2,\"883\":1,\"911\":2,\"941\":3,\"1002\":1,\"1007\":1,\"1008\":1,\"1011\":2,\"1012\":1,\"1013\":2,\"1018\":2,\"1031\":1,\"1037\":1,\"1038\":1,\"1041\":2,\"1062\":1,\"1142\":1,\"1210\":2}}],[\"ee\",{\"1\":{\"49\":1}}],[\"example\",{\"1\":{\"964\":3}}],[\"exit\",{\"1\":{\"824\":1}}],[\"existing\",{\"1\":{\"712\":1}}],[\"exist\",{\"1\":{\"480\":1}}],[\"exists\",{\"1\":{\"47\":1,\"177\":2}}],[\"exe\",{\"1\":{\"806\":1}}],[\"exe然后双击启动\",{\"1\":{\"372\":1}}],[\"executor框架以及\",{\"1\":{\"939\":1}}],[\"executor\",{\"0\":{\"934\":1},\"1\":{\"778\":4,\"779\":12,\"780\":3,\"781\":3,\"784\":2,\"888\":1,\"890\":1,\"924\":2,\"927\":2,\"928\":2,\"934\":10,\"935\":1,\"936\":1,\"937\":1,\"940\":4,\"941\":1,\"1061\":2,\"1062\":4}}],[\"executors提供的两种快捷的线程池的原因还有\",{\"1\":{\"917\":1}}],[\"executors\",{\"0\":{\"1061\":1},\"1\":{\"749\":1,\"753\":1,\"757\":2,\"835\":1,\"888\":2,\"889\":2,\"894\":1,\"900\":1,\"909\":1,\"917\":1,\"920\":1,\"937\":4,\"943\":3,\"944\":2,\"949\":1,\"1061\":1,\"1062\":3}}],[\"executorservice\",{\"1\":{\"749\":1,\"753\":1,\"757\":2,\"835\":1,\"889\":3,\"894\":1,\"900\":1,\"909\":1,\"920\":1,\"934\":11,\"937\":3,\"944\":8,\"949\":2,\"953\":2,\"957\":2,\"1061\":1,\"1062\":2}}],[\"execute方法\",{\"1\":{\"941\":1}}],[\"execute\",{\"0\":{\"944\":1},\"1\":{\"599\":2,\"749\":1,\"753\":1,\"757\":2,\"835\":1,\"909\":1,\"927\":1,\"934\":2,\"940\":1,\"941\":3,\"944\":1,\"950\":1,\"958\":3,\"1047\":2}}],[\"executetime\",{\"1\":{\"599\":5}}],[\"executionexception\",{\"1\":{\"773\":2,\"780\":1,\"785\":1,\"899\":2}}],[\"execution\",{\"1\":{\"426\":1,\"756\":1,\"911\":1}}],[\"exec\",{\"1\":{\"280\":9,\"1322\":1}}],[\"extends\",{\"1\":{\"533\":2,\"534\":1,\"549\":1,\"553\":4,\"555\":1,\"586\":1,\"587\":1,\"597\":1,\"600\":2,\"602\":1,\"619\":2,\"621\":6,\"630\":4,\"634\":1,\"658\":1,\"670\":1,\"688\":1,\"690\":1,\"706\":1,\"708\":2,\"713\":2,\"727\":1,\"728\":1,\"740\":1,\"748\":3,\"752\":1,\"779\":3,\"780\":3,\"781\":5,\"797\":1,\"884\":1,\"903\":1,\"934\":2,\"961\":1,\"1002\":2,\"1008\":1,\"1020\":1,\"1030\":1,\"1046\":1,\"1047\":1,\"1141\":1,\"1142\":1,\"1212\":1}}],[\"extension\",{\"1\":{\"432\":1}}],[\"extensionclassloader\",{\"1\":{\"353\":1}}],[\"ext\",{\"1\":{\"353\":2}}],[\"extclassloader的父classloader是bootstrap\",{\"1\":{\"353\":1}}],[\"extclassloader\",{\"1\":{\"345\":1,\"358\":2}}],[\"extra\",{\"1\":{\"120\":1,\"218\":1}}],[\"exponentialbackoffretry\",{\"1\":{\"1333\":1}}],[\"exported\",{\"1\":{\"268\":1}}],[\"expungestaleentries\",{\"1\":{\"1038\":2}}],[\"expungestaleentry\",{\"1\":{\"1035\":1,\"1036\":5,\"1037\":1,\"1038\":1,\"1041\":1,\"1042\":2}}],[\"explicitly\",{\"1\":{\"693\":1}}],[\"explain输出内容如下\",{\"1\":{\"120\":1}}],[\"explain\",{\"1\":{\"120\":2}}],[\"expectedstamp\",{\"1\":{\"843\":2,\"992\":2}}],[\"expectedreference\",{\"1\":{\"843\":2,\"992\":2}}],[\"expected\",{\"1\":{\"841\":5,\"990\":5}}],[\"expectedmodcount++\",{\"1\":{\"732\":1}}],[\"expectedmodcount\",{\"1\":{\"713\":2,\"732\":1}}],[\"expect\",{\"1\":{\"369\":1,\"742\":2,\"763\":1,\"766\":1,\"904\":2,\"1006\":1,\"1011\":4}}],[\"expired\",{\"1\":{\"1383\":1}}],[\"expires\",{\"1\":{\"271\":1,\"273\":4,\"298\":1}}],[\"expire\",{\"1\":{\"177\":2,\"270\":2,\"307\":1}}],[\"expiration\",{\"1\":{\"49\":2}}],[\"expressed\",{\"1\":{\"302\":1}}],[\"expr\",{\"1\":{\"120\":2}}],[\"exceeded\",{\"1\":{\"495\":1,\"748\":1,\"1007\":1,\"1018\":2}}],[\"exceptionally\",{\"1\":{\"780\":2,\"786\":1}}],[\"exceptionhandler就可以了\",{\"1\":{\"77\":1}}],[\"exception\",{\"1\":{\"49\":1,\"56\":2,\"524\":2,\"757\":1,\"765\":1,\"782\":1,\"909\":1,\"943\":1,\"944\":1,\"1001\":1,\"1011\":1,\"1020\":1,\"1030\":1,\"1046\":2,\"1210\":7,\"1212\":1}}],[\"excluding\",{\"1\":{\"256\":4}}],[\"exclusive\",{\"1\":{\"140\":1,\"743\":1,\"1005\":1,\"1008\":1,\"1011\":1,\"1012\":1}}],[\"exchange\",{\"0\":{\"1249\":1,\"1252\":1,\"1255\":1},\"1\":{\"77\":1,\"1130\":1,\"1178\":2,\"1231\":5,\"1249\":10,\"1251\":1,\"1252\":5,\"1253\":1,\"1255\":1,\"1256\":1,\"1257\":2,\"1280\":1}}],[\"ex\",{\"1\":{\"48\":4,\"77\":1,\"270\":1,\"307\":1,\"534\":1,\"765\":2,\"779\":3,\"780\":4,\"782\":1,\"909\":1,\"1011\":2,\"1204\":2}}],[\"english\",{\"1\":{\"1096\":1}}],[\"engine\",{\"1\":{\"426\":1}}],[\"engine=innodb\",{\"1\":{\"33\":1,\"34\":1}}],[\"enq\",{\"1\":{\"1011\":6,\"1014\":3}}],[\"enqueue\",{\"1\":{\"535\":6,\"536\":1,\"537\":1}}],[\"enable\",{\"1\":{\"1206\":3,\"1207\":1}}],[\"enableasync\",{\"1\":{\"928\":1}}],[\"enables\",{\"1\":{\"218\":1}}],[\"enough\",{\"1\":{\"708\":1}}],[\"ensures\",{\"1\":{\"618\":1,\"682\":1}}],[\"ensuresegment\",{\"1\":{\"571\":3}}],[\"ensureexplicitcapacity\",{\"1\":{\"553\":3,\"557\":4,\"564\":1}}],[\"ensurecapacitytest\",{\"1\":{\"564\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"553\":6,\"557\":6,\"561\":2}}],[\"ensurecapacity\",{\"0\":{\"564\":1},\"1\":{\"553\":1,\"564\":4}}],[\"en\",{\"1\":{\"511\":1}}],[\"environment\",{\"1\":{\"403\":1,\"516\":1}}],[\"encouraged\",{\"1\":{\"354\":1}}],[\"entropy\",{\"0\":{\"1087\":1},\"1\":{\"1086\":1,\"1089\":1}}],[\"entry=2\",{\"1\":{\"1033\":1}}],[\"entryclass\",{\"1\":{\"1030\":3}}],[\"entryiterator\",{\"1\":{\"713\":1}}],[\"entrys\",{\"1\":{\"625\":2}}],[\"entryset\",{\"1\":{\"619\":1,\"621\":1,\"625\":1,\"679\":1,\"687\":2,\"704\":1,\"705\":1}}],[\"entry这个静态内部类对象中\",{\"1\":{\"625\":1}}],[\"entry<integer\",{\"1\":{\"705\":1}}],[\"entry<string\",{\"1\":{\"625\":2}}],[\"entry<\",{\"1\":{\"619\":2,\"621\":1}}],[\"entry<k\",{\"1\":{\"619\":4,\"622\":1,\"706\":1,\"708\":3,\"711\":2,\"712\":1}}],[\"entry\",{\"1\":{\"571\":1,\"619\":3,\"625\":3,\"704\":4,\"705\":3,\"708\":8,\"710\":3,\"712\":1,\"713\":6,\"884\":3,\"1032\":2,\"1033\":4,\"1035\":2,\"1036\":8,\"1037\":2,\"1038\":6,\"1041\":5,\"1042\":2,\"1110\":8,\"1112\":12,\"1114\":2,\"1115\":1}}],[\"entryforhash\",{\"1\":{\"571\":2}}],[\"entryat\",{\"1\":{\"571\":1}}],[\"entries\",{\"1\":{\"293\":1,\"1042\":1}}],[\"entire\",{\"1\":{\"293\":1,\"298\":1}}],[\"enterprise\",{\"1\":{\"196\":1,\"213\":1}}],[\"endtime1\",{\"1\":{\"564\":2}}],[\"endtime\",{\"1\":{\"564\":2}}],[\"endif\",{\"1\":{\"218\":1,\"268\":1}}],[\"end\",{\"1\":{\"47\":1,\"49\":1,\"181\":2,\"193\":4,\"202\":2,\"713\":9,\"940\":11}}],[\"endpoint=http\",{\"1\":{\"7\":1}}],[\"e\",{\"1\":{\"23\":2,\"49\":3,\"357\":1,\"370\":4,\"531\":4,\"533\":16,\"534\":4,\"535\":13,\"536\":22,\"537\":9,\"539\":12,\"541\":2,\"552\":10,\"553\":14,\"557\":3,\"560\":1,\"561\":1,\"571\":14,\"572\":7,\"573\":7,\"577\":8,\"578\":11,\"587\":1,\"588\":10,\"589\":3,\"591\":2,\"592\":2,\"603\":4,\"604\":4,\"605\":1,\"619\":3,\"621\":3,\"622\":20,\"623\":10,\"624\":16,\"634\":8,\"656\":10,\"667\":12,\"680\":3,\"683\":9,\"704\":2,\"710\":7,\"711\":3,\"712\":4,\"713\":9,\"727\":2,\"729\":13,\"730\":3,\"731\":7,\"732\":2,\"749\":2,\"753\":2,\"757\":9,\"781\":6,\"782\":4,\"785\":4,\"823\":4,\"824\":2,\"841\":2,\"882\":2,\"891\":2,\"909\":2,\"924\":1,\"940\":2,\"944\":4,\"990\":2,\"1020\":2,\"1030\":2,\"1036\":16,\"1037\":8,\"1038\":8,\"1041\":10,\"1042\":3,\"1293\":4}}],[\"etcd\",{\"1\":{\"8\":2,\"10\":1,\"62\":1,\"63\":1,\"896\":1,\"923\":1,\"1097\":1,\"1157\":1}}],[\"eureka\",{\"1\":{\"4\":1,\"1068\":1,\"1069\":6,\"1281\":2,\"1368\":1,\"1390\":1}}],[\"$home\",{\"1\":{\"1315\":1}}],[\"$20\",{\"1\":{\"840\":2,\"989\":2}}],[\"$50\",{\"1\":{\"840\":2,\"989\":2}}],[\"$100\",{\"1\":{\"840\":3,\"989\":3}}],[\"$\",{\"1\":{\"7\":1,\"74\":1,\"75\":1,\"408\":1}}],[\"zxid\",{\"1\":{\"1349\":2,\"1379\":2,\"1380\":8,\"1382\":2}}],[\"zk数据模型\",{\"1\":{\"1382\":1}}],[\"zkserver\",{\"1\":{\"1378\":1,\"1379\":1}}],[\"zk\",{\"1\":{\"1325\":2,\"1326\":1,\"1327\":1,\"1328\":2,\"1329\":1,\"1330\":1,\"1331\":1,\"1349\":1,\"1383\":1,\"1385\":1,\"1388\":2}}],[\"zkclient\",{\"1\":{\"1331\":1,\"1333\":2,\"1335\":8,\"1336\":2,\"1337\":3,\"1338\":1}}],[\"zkcli\",{\"1\":{\"1322\":1}}],[\"zkutils\",{\"1\":{\"53\":1}}],[\"zgc\",{\"0\":{\"408\":1},\"1\":{\"408\":8}}],[\"zero\",{\"1\":{\"302\":1,\"798\":1}}],[\"zmalloc\",{\"1\":{\"218\":8}}],[\"zab\",{\"0\":{\"1359\":1,\"1360\":1,\"1361\":1,\"1376\":1,\"1378\":1},\"1\":{\"1097\":2,\"1354\":1,\"1359\":2,\"1360\":2,\"1361\":6,\"1367\":1,\"1377\":1,\"1378\":3,\"1379\":3,\"1380\":3,\"1381\":1,\"1391\":1}}],[\"zap\",{\"1\":{\"206\":4}}],[\"zadd\",{\"1\":{\"193\":3}}],[\"zdiff\",{\"1\":{\"193\":1}}],[\"zdiffstore\",{\"1\":{\"193\":1}}],[\"zunionstore\",{\"1\":{\"193\":2}}],[\"zuul2\",{\"1\":{\"4\":1}}],[\"zuul<\",{\"1\":{\"4\":1}}],[\"zuul\",{\"0\":{\"4\":1},\"1\":{\"4\":12,\"5\":5,\"68\":5}}],[\"zinterstore\",{\"1\":{\"193\":4}}],[\"zip\",{\"1\":{\"340\":1}}],[\"ziplist\",{\"1\":{\"174\":7}}],[\"zipkin\",{\"1\":{\"7\":2,\"8\":1}}],[\"zcard\",{\"1\":{\"193\":2,\"293\":1}}],[\"zscore\",{\"1\":{\"193\":2,\"210\":1}}],[\"zscan\",{\"1\":{\"157\":1,\"301\":1,\"319\":1}}],[\"zsets\",{\"1\":{\"293\":1}}],[\"zset\",{\"1\":{\"174\":2,\"195\":1,\"245\":1,\"253\":1}}],[\"zrem\",{\"1\":{\"210\":1}}],[\"zremrangebyscore\",{\"1\":{\"157\":1,\"301\":1}}],[\"zremrangebyrank\",{\"1\":{\"157\":1,\"301\":1}}],[\"zrevrank\",{\"1\":{\"193\":3,\"194\":2,\"258\":1}}],[\"zrevrange\",{\"1\":{\"157\":1,\"193\":2,\"194\":2,\"258\":1,\"301\":1}}],[\"zrange\",{\"1\":{\"157\":1,\"193\":4,\"194\":2,\"210\":1,\"258\":1,\"301\":1}}],[\"znode\",{\"0\":{\"1349\":1},\"1\":{\"54\":2,\"1335\":2,\"1348\":3,\"1349\":5,\"1350\":5,\"1351\":1,\"1362\":4,\"1382\":4}}],[\"zookeeper架构\",{\"1\":{\"1377\":1}}],[\"zookeeper3\",{\"1\":{\"1355\":1}}],[\"zookeeper相关概念总结\",{\"0\":{\"1341\":1,\"1366\":1}}],[\"zookeeper\",{\"0\":{\"52\":1,\"53\":1,\"1198\":1,\"1199\":1,\"1200\":1,\"1319\":1,\"1320\":1,\"1321\":1,\"1322\":1,\"1323\":1,\"1332\":1,\"1333\":1,\"1342\":1,\"1343\":1,\"1344\":1,\"1345\":1,\"1346\":1,\"1347\":1,\"1354\":1,\"1355\":1,\"1356\":1,\"1357\":1,\"1358\":1,\"1367\":1,\"1377\":1,\"1381\":1,\"1386\":1,\"1398\":1},\"1\":{\"41\":1,\"43\":1,\"45\":1,\"51\":1,\"52\":1,\"53\":5,\"54\":4,\"55\":4,\"57\":2,\"62\":2,\"63\":1,\"896\":1,\"923\":1,\"1068\":1,\"1069\":11,\"1097\":1,\"1157\":1,\"1199\":11,\"1200\":2,\"1235\":2,\"1241\":1,\"1281\":1,\"1298\":1,\"1319\":2,\"1321\":5,\"1322\":6,\"1324\":1,\"1327\":1,\"1328\":2,\"1329\":1,\"1331\":1,\"1332\":4,\"1335\":3,\"1341\":19,\"1343\":7,\"1344\":9,\"1345\":2,\"1346\":7,\"1348\":7,\"1349\":6,\"1350\":1,\"1351\":2,\"1352\":6,\"1353\":3,\"1354\":9,\"1355\":3,\"1356\":2,\"1357\":8,\"1358\":1,\"1359\":4,\"1360\":4,\"1361\":1,\"1362\":9,\"1363\":1,\"1367\":4,\"1368\":1,\"1377\":2,\"1380\":3,\"1381\":4,\"1382\":4,\"1383\":1,\"1384\":1,\"1387\":1,\"1388\":3,\"1389\":2,\"1390\":3,\"1391\":4},\"2\":{\"1340\":1,\"1365\":1,\"1393\":1}}],[\"z\",{\"1\":{\"19\":2}}],[\"zhdocsv27devsourceloadbalance\",{\"1\":{\"1140\":1}}],[\"zhangsan\",{\"1\":{\"135\":1,\"663\":1}}],[\"zhihu\",{\"1\":{\"78\":1,\"360\":1,\"511\":2,\"545\":2,\"913\":1,\"996\":2,\"1218\":1}}],[\"zhuanlan\",{\"1\":{\"78\":1,\"360\":1,\"545\":2,\"913\":1,\"996\":2}}],[\"zh\",{\"1\":{\"8\":1,\"11\":1,\"293\":1,\"298\":1,\"1100\":1,\"1117\":2,\"1140\":1,\"1143\":1,\"1168\":1,\"1169\":1}}],[\"当集群中有机器挂了\",{\"1\":{\"1380\":1}}],[\"当集群中已经有过半的\",{\"1\":{\"1361\":1}}],[\"当系统出现崩溃影响最大应该是\",{\"1\":{\"1380\":1}}],[\"当参与者收到\",{\"1\":{\"1370\":1}}],[\"当要执行一个分布式事务的时候\",{\"1\":{\"1370\":1}}],[\"当在消息的传播\",{\"1\":{\"1368\":1}}],[\"当创建临时节点的客户端会话一直保持活动\",{\"1\":{\"1362\":1}}],[\"当一台同样遵守\",{\"1\":{\"1361\":1}}],[\"当一个提案被\",{\"1\":{\"1374\":1}}],[\"当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区\",{\"1\":{\"1371\":1}}],[\"当一个\",{\"1\":{\"1005\":1,\"1112\":1,\"1379\":1}}],[\"当一个线程获取锁时\",{\"1\":{\"1019\":1}}],[\"当一个线程获取写锁后\",{\"1\":{\"871\":1}}],[\"当一个线程对共享变量进行了修改\",{\"1\":{\"979\":1}}],[\"当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用\",{\"1\":{\"895\":1,\"922\":1}}],[\"当一个线程占用锁访问其中一个段数据时\",{\"1\":{\"690\":1}}],[\"当一个线程访问同步方法时\",{\"1\":{\"688\":1}}],[\"当一个方法要调用其他方法\",{\"1\":{\"493\":1}}],[\"当一个类收到了加载请求时\",{\"1\":{\"433\":1}}],[\"当一个对象被创建时\",{\"1\":{\"396\":1}}],[\"当一个对象到\",{\"1\":{\"391\":1}}],[\"当一个接口中定义了\",{\"1\":{\"344\":1}}],[\"当一个元素加入布隆过滤器中的时候\",{\"1\":{\"307\":1}}],[\"当一个锁服务出现问题\",{\"1\":{\"61\":1}}],[\"当选举产生了新的\",{\"1\":{\"1361\":1}}],[\"当选择了执行方案后\",{\"1\":{\"88\":1}}],[\"当整个服务框架在启动过程中\",{\"1\":{\"1361\":1}}],[\"当网络恢复的时候会发现有\",{\"1\":{\"1358\":1}}],[\"当由于服务器压力太大\",{\"1\":{\"1353\":1}}],[\"当获得锁的一方执行完相关代码或者是挂掉之后就释放锁\",{\"1\":{\"1346\":1}}],[\"当获取失败时\",{\"1\":{\"748\":1}}],[\"当文件满了\",{\"1\":{\"1315\":1}}],[\"当第一个文件写满了\",{\"1\":{\"1315\":1}}],[\"当主节点挂掉之后\",{\"1\":{\"1314\":1}}],[\"当主线程调用\",{\"1\":{\"753\":1}}],[\"当用户发起\",{\"1\":{\"1310\":1}}],[\"当用户请求过来\",{\"1\":{\"307\":1}}],[\"当用户请求获取的是一些静态的或更新不频繁的数据时\",{\"1\":{\"2\":1}}],[\"当流量到峰值的时候是因为生产者生产太快\",{\"1\":{\"1305\":1}}],[\"当路由不到时\",{\"1\":{\"1255\":1}}],[\"当发送消息到交换器时\",{\"1\":{\"1252\":1}}],[\"当发生网络分区的时候\",{\"1\":{\"1068\":1}}],[\"当消息在一个队列中变成死信\",{\"1\":{\"1256\":1}}],[\"当消息进入队列后\",{\"1\":{\"1213\":1}}],[\"当消费速度大于生产速度且\",{\"1\":{\"1258\":1}}],[\"当消费异常会进行重试\",{\"1\":{\"1209\":1}}],[\"当消费者调用服务时\",{\"1\":{\"1390\":1}}],[\"当消费者刚拿到这个消息准备进行真正消费的时候\",{\"1\":{\"1205\":1}}],[\"当消费者拉取到了分区的某个消息之后\",{\"1\":{\"1205\":1}}],[\"当消费者从队列中\",{\"1\":{\"535\":1}}],[\"当消费者从队列中消费一个元素之后\",{\"1\":{\"530\":1}}],[\"当消费者将\",{\"1\":{\"531\":1}}],[\"当代码修复后\",{\"1\":{\"1213\":1}}],[\"当达到最大重试次数后\",{\"1\":{\"1213\":2}}],[\"当出现网络问题之后能够自动重试消息发送\",{\"1\":{\"1204\":1}}],[\"当出现如下情况的时候\",{\"1\":{\"821\":1}}],[\"当向数组中添加新元素时\",{\"1\":{\"1184\":1}}],[\"当没有锁竞争的时候会省去唤醒操作\",{\"1\":{\"1183\":1}}],[\"当没有线程获取到锁时\",{\"1\":{\"1011\":1}}],[\"当客户端发起请求的时候\",{\"1\":{\"1139\":1}}],[\"当客户端发送命令请求的时候\",{\"1\":{\"286\":1}}],[\"当应用访问压力越来越大后\",{\"1\":{\"1123\":1}}],[\"当服务提供者的某台服务器宕机或下线时\",{\"1\":{\"1390\":1}}],[\"当服务端符合了\",{\"1\":{\"1385\":1}}],[\"当服务越来越多之后\",{\"1\":{\"1123\":1}}],[\"当服务器之间进行通信时会交换当前的\",{\"1\":{\"1109\":1}}],[\"当leader崩溃时\",{\"1\":{\"1116\":1}}],[\"当今的数据中心和应用程序在高度动态的环境中运行\",{\"1\":{\"1104\":1}}],[\"当设计读写操作时\",{\"1\":{\"1067\":1}}],[\"当设置\",{\"1\":{\"267\":1}}],[\"当虚拟线程被阻塞或等待时\",{\"1\":{\"1053\":1}}],[\"当虚拟机启动时\",{\"1\":{\"344\":1}}],[\"当虚拟机要使用一个类时\",{\"1\":{\"341\":1,\"496\":1}}],[\"当中断线程被唤醒时\",{\"1\":{\"1015\":1}}],[\"当自定义同步器进行加锁或者解锁操作时\",{\"1\":{\"1003\":1}}],[\"当自旋次数大于指定次数时\",{\"1\":{\"571\":1}}],[\"当运算完成后\",{\"1\":{\"968\":1}}],[\"当另一个线程对这个共享变量执行写操作后\",{\"1\":{\"967\":1}}],[\"当初始\",{\"1\":{\"958\":1}}],[\"当初始的资源个数为\",{\"1\":{\"747\":1,\"905\":1}}],[\"当最大池被填满时\",{\"1\":{\"936\":1}}],[\"当任务过多的时候\",{\"1\":{\"909\":1}}],[\"当任务到达时\",{\"1\":{\"887\":1,\"933\":1}}],[\"当可用许可证数减当前获取的许可证数结果小于0\",{\"1\":{\"906\":1}}],[\"当可重入计数器大于\",{\"1\":{\"50\":1}}],[\"当插入的元素数量超过指定值就返回\",{\"1\":{\"897\":1}}],[\"当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数\",{\"1\":{\"896\":1,\"923\":1}}],[\"当提交的任务过多而不能及时处理时\",{\"1\":{\"890\":1,\"936\":1}}],[\"当其中一个消息消费异常时\",{\"1\":{\"1209\":1}}],[\"当其再次想要获取这个对象的锁的时候还是可以获取的\",{\"1\":{\"860\":1}}],[\"当其他进程过度消耗\",{\"1\":{\"169\":1}}],[\"当执行出错会进入\",{\"1\":{\"1210\":1}}],[\"当执行\",{\"1\":{\"851\":1,\"1010\":1}}],[\"当执行任务的线程数量超出\",{\"1\":{\"749\":1}}],[\"当操作涉及跨多个共享变量时\",{\"1\":{\"845\":1,\"994\":1}}],[\"当多个线程同时使用\",{\"1\":{\"841\":1,\"990\":1}}],[\"当且仅当调用\",{\"1\":{\"940\":1}}],[\"当且仅当\",{\"1\":{\"841\":1,\"990\":1}}],[\"当分配到时间片后就可以开始运行了\",{\"1\":{\"827\":1}}],[\"当超时时间结束后\",{\"1\":{\"820\":1}}],[\"当使用多线程的时候\",{\"1\":{\"816\":1}}],[\"当使用迭代器迭代元素时\",{\"1\":{\"716\":1}}],[\"当做\",{\"1\":{\"777\":1}}],[\"当拦住的线程数量达到\",{\"1\":{\"756\":1,\"911\":1}}],[\"当拦截的线程数量达到这个值的时候就打开栅栏\",{\"1\":{\"756\":1,\"911\":1}}],[\"当这个请求处理完之后\",{\"1\":{\"1142\":1}}],[\"当这\",{\"1\":{\"753\":1}}],[\"当这一块的内存使用完后\",{\"1\":{\"397\":1}}],[\"当计数器的值变为\",{\"1\":{\"753\":1}}],[\"当所有的子线程都执行完毕后\",{\"1\":{\"742\":1}}],[\"当线程池中的线程数达到\",{\"1\":{\"951\":1}}],[\"当线程池不再需要使用时\",{\"1\":{\"924\":1}}],[\"当线程使用\",{\"1\":{\"908\":1}}],[\"当线程进入\",{\"1\":{\"820\":1}}],[\"当线程执行\",{\"1\":{\"820\":1}}],[\"当线程数大于核心线程数时\",{\"1\":{\"890\":1,\"936\":1}}],[\"当线程数达到之后\",{\"1\":{\"757\":3}}],[\"当线程数量或者请求数量达到\",{\"1\":{\"756\":1,\"911\":1}}],[\"当线程调用\",{\"1\":{\"752\":1}}],[\"当线程\",{\"1\":{\"742\":1,\"840\":1,\"989\":1}}],[\"当链表\",{\"1\":{\"712\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"619\":1,\"645\":1,\"677\":1,\"683\":1}}],[\"当链表长度大于等于阈值\",{\"1\":{\"616\":1}}],[\"当distance为负数时\",{\"1\":{\"696\":1}}],[\"当distance为正数时\",{\"1\":{\"696\":1}}],[\"当对\",{\"1\":{\"690\":1}}],[\"当对象实例数据部分没有对齐时\",{\"1\":{\"507\":1}}],[\"当对象大于\",{\"1\":{\"503\":1}}],[\"当对象没有覆盖\",{\"1\":{\"391\":1}}],[\"当遍历不存在阻塞时\",{\"1\":{\"687\":1}}],[\"当删除的元素位于列表末尾时\",{\"1\":{\"653\":1}}],[\"当容量已达到极限并且需要扩容时\",{\"1\":{\"653\":1}}],[\"当传入一个原生数据类型数组时\",{\"1\":{\"634\":1}}],[\"当我用无修饰的英文来描述时\",{\"1\":{\"1096\":1}}],[\"当我调用put\",{\"1\":{\"625\":1}}],[\"当我们拿到数据之后\",{\"1\":{\"1308\":1}}],[\"当我们在学生时代需要在食堂排队的时候\",{\"1\":{\"1271\":1}}],[\"当我们在使用\",{\"1\":{\"164\":1}}],[\"当我们配置了\",{\"1\":{\"1206\":1}}],[\"当我们配置\",{\"1\":{\"1206\":1}}],[\"当我们把\",{\"1\":{\"934\":1}}],[\"当我们不指定\",{\"1\":{\"891\":1,\"936\":1}}],[\"当我们请求\",{\"1\":{\"816\":1}}],[\"当我们启动\",{\"1\":{\"806\":1}}],[\"当我们获取到异步计算的结果之后\",{\"1\":{\"779\":1}}],[\"当我们执行某一耗时的任务时\",{\"1\":{\"773\":1,\"899\":1}}],[\"当我们需要使用消息的时候\",{\"1\":{\"1218\":1}}],[\"当我们需要对某一个集合实现两种排序方式\",{\"1\":{\"661\":1}}],[\"当我们需要存储一组类型相同的数据时\",{\"1\":{\"647\":1}}],[\"当我们需要判断一个元素是否存在于布隆过滤器的时候\",{\"1\":{\"307\":1}}],[\"当我们要\",{\"1\":{\"557\":1}}],[\"当我们\",{\"1\":{\"444\":1}}],[\"当我们想要加载一个类的时候\",{\"1\":{\"340\":1,\"356\":1}}],[\"当我们提到\",{\"1\":{\"287\":1}}],[\"当我们调用\",{\"1\":{\"56\":1}}],[\"当数据被修改时\",{\"1\":{\"840\":1,\"989\":1}}],[\"当数据过期时\",{\"1\":{\"609\":1}}],[\"当数量超过了\",{\"1\":{\"619\":1}}],[\"当实际大小超过阈值时\",{\"1\":{\"619\":1}}],[\"当桶\",{\"1\":{\"619\":2}}],[\"当冲突链表达到一定长度时\",{\"1\":{\"575\":1,\"688\":1}}],[\"当真正对数组进行添加元素操作时\",{\"1\":{\"555\":1}}],[\"当添加第一个元素的时候数组容量才变成10\",{\"1\":{\"553\":1}}],[\"当有线程持有该锁时\",{\"1\":{\"1018\":1}}],[\"当有自定义同步器接入时\",{\"1\":{\"1003\":1}}],[\"当有新任务提交时\",{\"1\":{\"888\":1}}],[\"当有新的元素被添加时\",{\"1\":{\"544\":1}}],[\"当有一个新的任务提交时\",{\"1\":{\"888\":1,\"937\":1}}],[\"当有任务要处理时\",{\"1\":{\"886\":1}}],[\"当有多个请求来读取表中的数据时可以不采取任何操作\",{\"1\":{\"140\":1}}],[\"当生产者产生消息后也会尽量投递到不同\",{\"1\":{\"1199\":1}}],[\"当生产者不断往\",{\"1\":{\"1184\":1}}],[\"当生产者将元素存到队列中后\",{\"1\":{\"535\":1}}],[\"当生产者往队列里填充数据后\",{\"1\":{\"530\":1}}],[\"当队列中存放的任务达到队列容量的时候\",{\"1\":{\"896\":1,\"923\":1}}],[\"当队列中有元素被取出时\",{\"1\":{\"544\":1}}],[\"当队列容量满时\",{\"1\":{\"797\":1}}],[\"当队列容器为空时\",{\"1\":{\"796\":1}}],[\"当队列容器已满\",{\"1\":{\"796\":1}}],[\"当队列已满时\",{\"1\":{\"544\":1}}],[\"当队列为空时返回\",{\"1\":{\"536\":1}}],[\"当队列为空时\",{\"1\":{\"531\":1,\"544\":1}}],[\"当队列元素达到我们设置的上限\",{\"1\":{\"531\":1}}],[\"当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时\",{\"1\":{\"530\":1}}],[\"当阻塞队列数据为空时\",{\"1\":{\"530\":1}}],[\"当时就很懵\",{\"1\":{\"1150\":1}}],[\"当时\",{\"1\":{\"529\":1}}],[\"当常量池无法再申请到内存时会抛出\",{\"1\":{\"497\":1}}],[\"当元空间溢出时会得到如下错误\",{\"1\":{\"496\":1}}],[\"当方法执行位置超过了某个变量\",{\"1\":{\"442\":1}}],[\"当无法申请足够内存时就会报错\",{\"1\":{\"439\":1}}],[\"当它发现队列中没有数据\",{\"1\":{\"535\":1}}],[\"当它存储的信息过大时\",{\"1\":{\"436\":1}}],[\"当它的年龄增加到一定程度\",{\"1\":{\"386\":1,\"495\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"392\":1}}],[\"当垃圾收集成为系统达到更高并发的瓶颈时\",{\"1\":{\"381\":1}}],[\"当内存空间不足\",{\"1\":{\"392\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"273\":2,\"298\":1}}],[\"当引用失效\",{\"1\":{\"390\":1}}],[\"当累积的某个年龄大小超过了\",{\"1\":{\"386\":1,\"495\":1}}],[\"当需要修改\",{\"1\":{\"585\":1,\"793\":1}}],[\"当需要排查各种内存溢出问题\",{\"1\":{\"381\":1}}],[\"当需要调用一个类的方法的时候\",{\"1\":{\"343\":1}}],[\"当父类加载器无法加载时\",{\"1\":{\"357\":1}}],[\"当父类的加载器为空\",{\"1\":{\"357\":1}}],[\"当父类的加载器不为空\",{\"1\":{\"357\":1}}],[\"当遇到\",{\"1\":{\"344\":1}}],[\"当类试图访问一个指定的方法\",{\"1\":{\"341\":1}}],[\"当类试图访问或修改一个指定的对象字段\",{\"1\":{\"341\":1}}],[\"当类试图访问或修改它没有权限访问的字段\",{\"1\":{\"341\":1}}],[\"当慢查询日志超过设定的最大记录条数之后\",{\"1\":{\"302\":1}}],[\"当调用\",{\"1\":{\"280\":1,\"752\":1,\"756\":1,\"908\":1,\"911\":1,\"946\":2}}],[\"当调用了\",{\"1\":{\"280\":1}}],[\"当被监听的套接字准备好执行连接应答\",{\"1\":{\"265\":1}}],[\"当子进程完成创建新\",{\"1\":{\"233\":1}}],[\"当子线程完成创建新\",{\"1\":{\"162\":1}}],[\"当硬盘忙于执行写入操作的时候\",{\"1\":{\"231\":1}}],[\"当程序申请的内存最接近某个固定值时\",{\"1\":{\"218\":1}}],[\"当磁盘压力太大的时候\",{\"1\":{\"161\":1}}],[\"当后台线程\",{\"1\":{\"161\":1}}],[\"当你是读请求\",{\"1\":{\"1388\":1}}],[\"当你将数据发布到\",{\"1\":{\"1346\":1}}],[\"当你将一个包裹送到邮局\",{\"1\":{\"1247\":1}}],[\"当你需要异步操作且关心返回结果的时候\",{\"1\":{\"778\":1}}],[\"当你需要异步操作且不关心返回结果的时候可以使用\",{\"1\":{\"778\":1}}],[\"当你需要存储一个列表数据\",{\"1\":{\"188\":1}}],[\"当你把对象加入hashset时\",{\"1\":{\"680\":1}}],[\"当你这样回答之后\",{\"1\":{\"145\":1}}],[\"当你添加\",{\"1\":{\"72\":1}}],[\"当\",{\"1\":{\"141\":1,\"157\":2,\"218\":1,\"230\":1,\"233\":1,\"236\":1,\"251\":1,\"256\":2,\"301\":2,\"302\":1,\"344\":4,\"359\":1,\"384\":2,\"444\":2,\"495\":1,\"557\":1,\"558\":2,\"619\":1,\"653\":1,\"680\":1,\"712\":1,\"717\":1,\"751\":1,\"752\":1,\"756\":1,\"797\":1,\"907\":1,\"911\":1,\"968\":1,\"1011\":1,\"1015\":1,\"1197\":1,\"1199\":1,\"1206\":1,\"1249\":1,\"1356\":1,\"1374\":1,\"1380\":1,\"1390\":1}}],[\"当事务开启后\",{\"1\":{\"141\":1}}],[\"当事务提交之后会把所有修改信息都会存到该日志中\",{\"1\":{\"135\":1}}],[\"当编辑人员第二次读取文档时\",{\"1\":{\"128\":1}}],[\"当二叉搜索树失去平衡时\",{\"1\":{\"97\":1}}],[\"当二叉搜索树保持平衡时\",{\"1\":{\"97\":1}}],[\"当匹配到这个路由后\",{\"1\":{\"75\":1}}],[\"当请求\",{\"1\":{\"70\":1}}],[\"当该锁被释放之后\",{\"1\":{\"54\":1}}],[\"当机器时间不对的情况下\",{\"1\":{\"35\":1,\"37\":1,\"38\":1}}],[\"当前客户端都无法获取到写锁\",{\"1\":{\"1388\":1}}],[\"当前消费到的\",{\"1\":{\"1205\":1}}],[\"当前最常用的一些共识算法比如\",{\"1\":{\"1097\":1}}],[\"当前最大id\",{\"1\":{\"34\":1}}],[\"当前端发送请求到服务\",{\"1\":{\"1045\":1}}],[\"当前节点的子节点个数\",{\"1\":{\"1349\":1}}],[\"当前节点的子节点每次变化时值增加\",{\"1\":{\"1349\":1}}],[\"当前节点的\",{\"1\":{\"1330\":1}}],[\"当前节点的前置节点可能已经从队列中出去了\",{\"1\":{\"1013\":1}}],[\"当前节点之前的节点都不会出现变化\",{\"1\":{\"1013\":1}}],[\"当前节点不是\",{\"1\":{\"1013\":2}}],[\"当前节点是\",{\"1\":{\"1013\":2}}],[\"当前节点是尾节点\",{\"1\":{\"1013\":2}}],[\"当前节点在队列中的状态\",{\"1\":{\"742\":1,\"904\":1,\"1005\":1}}],[\"当前运行的线程数等于\",{\"1\":{\"950\":1}}],[\"当前运行的进程\",{\"1\":{\"806\":1}}],[\"当前的流程\",{\"1\":{\"1013\":1}}],[\"当前的\",{\"1\":{\"941\":1}}],[\"当前任务在执行完\",{\"1\":{\"895\":1,\"922\":1}}],[\"当前可以同时运行的线程数量变为最大线程数\",{\"1\":{\"890\":1,\"896\":1,\"923\":1,\"936\":1}}],[\"当前可用许可证大于0时才可能获取成功\",{\"1\":{\"748\":1}}],[\"当前可用许可证数量小于等于0时\",{\"1\":{\"748\":1}}],[\"当前可用许可证数量\",{\"1\":{\"748\":1}}],[\"当前可用的总空间\",{\"1\":{\"451\":3}}],[\"当前对象实例的锁\",{\"1\":{\"848\":1}}],[\"当前值为\",{\"1\":{\"840\":1,\"989\":1}}],[\"当前时间\",{\"1\":{\"781\":10}}],[\"当前线程不是持有锁的线程\",{\"1\":{\"1014\":1}}],[\"当前线程必须加入进等待队列\",{\"1\":{\"1011\":1}}],[\"当前线程必须加入到等待队列中\",{\"1\":{\"1011\":1}}],[\"当前线程处在\",{\"1\":{\"1005\":1}}],[\"当前线程池中有一个运行的线程后\",{\"1\":{\"954\":1}}],[\"当前线程持有了锁再次获取锁还是会返回一个新的数据戳\",{\"1\":{\"871\":1}}],[\"当前线程放弃更新\",{\"1\":{\"841\":1,\"990\":1}}],[\"当前线程\",{\"1\":{\"686\":1}}],[\"当前线程将被挂起放到aqs队列中\",{\"1\":{\"535\":1}}],[\"当前线程获取过一次锁之后\",{\"1\":{\"56\":1}}],[\"当前虚拟机的垃圾收集都采用分代收集算法\",{\"1\":{\"399\":1}}],[\"当前使用的是哪种收集器等\",{\"1\":{\"368\":1}}],[\"当前类\",{\"0\":{\"330\":1},\"1\":{\"325\":1,\"330\":1}}],[\"当前\",{\"1\":{\"233\":1,\"848\":1,\"1350\":3}}],[\"当前持有锁的线程\",{\"1\":{\"56\":1}}],[\"当前一个节点对应的客户端释放锁之后\",{\"1\":{\"55\":1}}],[\"当前进程号\",{\"1\":{\"22\":1}}],[\"当前采用\",{\"1\":{\"19\":2}}],[\"当前兑换码的数据组成如下所示\",{\"1\":{\"19\":1}}],[\"当然这么说有点虚\",{\"1\":{\"1379\":1}}],[\"当然这个东西其实也可以通过一个\",{\"1\":{\"443\":1}}],[\"当然加机器这种说法也无可厚非\",{\"1\":{\"1367\":1}}],[\"当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增\",{\"1\":{\"1305\":1}}],[\"当然你可以让消费者进行节点监听\",{\"1\":{\"1390\":1}}],[\"当然你可以让\",{\"1\":{\"1278\":1}}],[\"当然还有优化的地方\",{\"1\":{\"1388\":1}}],[\"当然还有使用\",{\"1\":{\"1303\":1}}],[\"当然还有很多种情况\",{\"1\":{\"1303\":1}}],[\"当然不仅仅只有上面两种方法\",{\"1\":{\"1202\":1}}],[\"当然上面说的\",{\"1\":{\"1159\":1}}],[\"当然迭代过程中还有其他的情况\",{\"1\":{\"1033\":1}}],[\"当然也可以消费者个数小于队列个数\",{\"1\":{\"1280\":1}}],[\"当然也可以编写自\",{\"1\":{\"1246\":1}}],[\"当然也可以编写自己的插件\",{\"1\":{\"1237\":1}}],[\"当然也可以是\",{\"1\":{\"940\":1}}],[\"当然也允许失败的线程放弃操作\",{\"1\":{\"841\":1,\"990\":1}}],[\"当然了\",{\"1\":{\"929\":1}}],[\"当然一次也可以一次拿取和释放多个许可\",{\"1\":{\"749\":1}}],[\"当然如果需要复用\",{\"1\":{\"442\":1}}],[\"当然有\",{\"1\":{\"401\":1}}],[\"当然缺点也是有的\",{\"1\":{\"235\":1}}],[\"当然实现的就是每次都能查到已提交的最新数据效果了\",{\"1\":{\"141\":1}}],[\"当然可以实现每次查询的可重复读的效果了\",{\"1\":{\"141\":1}}],[\"当然在可重复读隔离级别下\",{\"1\":{\"132\":1}}],[\"当然是判断其他条件是否满足\",{\"1\":{\"117\":1}}],[\"当然我们也可以自定义过滤器\",{\"1\":{\"74\":1}}],[\"当然\",{\"1\":{\"7\":1,\"117\":1,\"819\":1,\"904\":1,\"1043\":1,\"1191\":1,\"1253\":1,\"1271\":1,\"1281\":1,\"1305\":1}}],[\"pzxid\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":3,\"1382\":1}}],[\"pc\",{\"1\":{\"1155\":1,\"1371\":1}}],[\"p=1970\",{\"1\":{\"1100\":1}}],[\"png\",{\"1\":{\"1106\":1,\"1200\":1}}],[\"pn>\",{\"1\":{\"824\":1}}],[\"pn\",{\"1\":{\"824\":1}}],[\"p3\",{\"1\":{\"824\":2}}],[\"p2p\",{\"0\":{\"1228\":1}}],[\"p2\",{\"1\":{\"824\":2,\"1375\":1}}],[\"p1\",{\"1\":{\"824\":1,\"1375\":3}}],[\"pdf\",{\"1\":{\"1117\":1}}],[\"pdata\",{\"1\":{\"663\":6}}],[\"pdk\",{\"1\":{\"7\":1}}],[\"phase\",{\"1\":{\"1371\":1}}],[\"phasedbackoffwaitstrategy\",{\"1\":{\"1183\":1}}],[\"phantomreference\",{\"1\":{\"392\":1,\"1030\":1}}],[\"phonenumber\",{\"1\":{\"630\":1}}],[\"php\",{\"1\":{\"593\":3,\"1171\":1,\"1237\":1,\"1245\":1,\"1246\":1}}],[\"p92\",{\"1\":{\"387\":1}}],[\"plug\",{\"1\":{\"1132\":1}}],[\"plugin\",{\"1\":{\"8\":1,\"1132\":1}}],[\"plugins\",{\"1\":{\"7\":2,\"377\":1}}],[\"plain\",{\"1\":{\"708\":1,\"1096\":1}}],[\"placed\",{\"1\":{\"624\":1}}],[\"platform\",{\"1\":{\"353\":1,\"480\":1,\"876\":1,\"1053\":1,\"1062\":19}}],[\"please\",{\"1\":{\"298\":1}}],[\"pig\",{\"1\":{\"1343\":1}}],[\"pid<pid>\",{\"1\":{\"484\":1}}],[\"ping\",{\"1\":{\"298\":2,\"1085\":2}}],[\"pipelining\",{\"1\":{\"285\":1}}],[\"pipeline\",{\"0\":{\"287\":1},\"1\":{\"285\":1,\"287\":12,\"288\":2,\"319\":1,\"320\":2}}],[\"pire\",{\"1\":{\"270\":1}}],[\"pitr\",{\"1\":{\"233\":1}}],[\"ptr+prefix\",{\"1\":{\"218\":1}}],[\"ptr\",{\"1\":{\"218\":5}}],[\"pfail\",{\"1\":{\"1085\":3}}],[\"pfadd\",{\"1\":{\"206\":5,\"207\":1,\"262\":2}}],[\"pfmerge\",{\"1\":{\"206\":2}}],[\"pfcount\",{\"1\":{\"206\":4,\"207\":1,\"262\":2}}],[\"pp成功插入\",{\"1\":{\"125\":1}}],[\"pp\",{\"1\":{\"125\":3}}],[\"psyounggen\",{\"1\":{\"451\":1}}],[\"ps\",{\"1\":{\"99\":1,\"106\":1,\"364\":1,\"365\":1,\"1245\":1,\"1322\":1}}],[\"p\",{\"1\":{\"78\":1,\"84\":1,\"168\":1,\"219\":1,\"293\":2,\"298\":1,\"360\":1,\"545\":2,\"572\":7,\"577\":4,\"578\":3,\"619\":3,\"622\":13,\"683\":8,\"686\":1,\"688\":1,\"710\":20,\"711\":13,\"720\":1,\"758\":1,\"913\":3,\"996\":2,\"1012\":4,\"1013\":2,\"1015\":4,\"1068\":4,\"1070\":1,\"1074\":1,\"1171\":1,\"1199\":1,\"1290\":3,\"1321\":1}}],[\"pow\",{\"1\":{\"1097\":2}}],[\"power\",{\"1\":{\"570\":1,\"677\":1}}],[\"pong\",{\"1\":{\"1085\":1}}],[\"podc\",{\"1\":{\"1066\":1}}],[\"poisson\",{\"1\":{\"708\":1}}],[\"pointsoftware\",{\"1\":{\"511\":1}}],[\"pointer把这些undo日志串联起来形成一个历史记录版本链\",{\"1\":{\"141\":1}}],[\"pop\",{\"1\":{\"667\":1}}],[\"polarismesh\",{\"1\":{\"1170\":1}}],[\"polllast\",{\"1\":{\"667\":1}}],[\"pollfirst\",{\"1\":{\"667\":1}}],[\"poll\",{\"1\":{\"530\":1,\"531\":7,\"533\":1,\"535\":2,\"536\":6,\"537\":4,\"539\":2,\"541\":1,\"604\":5,\"667\":1,\"958\":3}}],[\"policies\",{\"1\":{\"298\":1,\"756\":1,\"911\":1}}],[\"policy\",{\"1\":{\"298\":4}}],[\"pool\",{\"0\":{\"328\":1},\"1\":{\"136\":1,\"147\":1,\"325\":3,\"328\":4,\"497\":1,\"894\":1,\"918\":1,\"920\":1,\"940\":24,\"964\":1,\"1158\":1}}],[\"pos\",{\"1\":{\"1097\":2}}],[\"possibly\",{\"1\":{\"712\":1}}],[\"possible\",{\"1\":{\"120\":1,\"218\":1}}],[\"position\",{\"1\":{\"618\":1,\"682\":1,\"1311\":1}}],[\"positional\",{\"1\":{\"553\":1}}],[\"posthandle\",{\"1\":{\"1046\":1}}],[\"posts\",{\"1\":{\"237\":1}}],[\"post\",{\"1\":{\"7\":1,\"69\":2,\"73\":1,\"237\":1,\"415\":1,\"545\":1,\"801\":2,\"913\":1,\"1025\":1,\"1150\":1,\"1178\":1}}],[\"postgresql\",{\"1\":{\"7\":2,\"10\":1}}],[\"port=60001\",{\"1\":{\"373\":1}}],[\"port\",{\"1\":{\"75\":1,\"369\":1,\"1085\":1,\"1390\":1}}],[\"password\",{\"1\":{\"1351\":1}}],[\"passjava\",{\"1\":{\"75\":4}}],[\"payload\",{\"1\":{\"1248\":1,\"1254\":1}}],[\"paxos第二阶段2\",{\"1\":{\"1374\":1}}],[\"paxos第二阶段1\",{\"1\":{\"1374\":1}}],[\"paxos第一阶段\",{\"1\":{\"1373\":1}}],[\"paxos\",{\"0\":{\"1095\":1,\"1098\":1,\"1099\":1,\"1359\":1,\"1372\":1,\"1375\":1},\"1\":{\"1096\":12,\"1097\":21,\"1098\":2,\"1099\":12,\"1100\":1,\"1343\":1,\"1349\":1,\"1359\":3,\"1361\":2,\"1363\":1,\"1367\":1,\"1369\":1,\"1371\":1,\"1372\":3,\"1375\":1,\"1377\":1,\"1378\":1,\"1379\":1,\"1391\":1}}],[\"pause\",{\"1\":{\"844\":2,\"993\":2}}],[\"pair\",{\"1\":{\"843\":2,\"992\":2}}],[\"pair<v>\",{\"1\":{\"843\":1,\"992\":1}}],[\"parseint\",{\"1\":{\"1209\":1,\"1213\":1}}],[\"parliament\",{\"1\":{\"1096\":2}}],[\"parkandcheckinterrupt\",{\"1\":{\"1012\":3,\"1015\":3}}],[\"park\",{\"1\":{\"749\":1,\"1012\":1,\"1015\":1}}],[\"param\",{\"1\":{\"553\":1,\"561\":5,\"564\":1,\"571\":3,\"599\":2,\"798\":1,\"841\":4,\"918\":1,\"941\":2,\"990\":4}}],[\"parameters\",{\"1\":{\"475\":1}}],[\"parallelism\",{\"1\":{\"969\":1}}],[\"parallelstream\",{\"1\":{\"687\":7}}],[\"parallelgcthreads\",{\"1\":{\"449\":1}}],[\"parallel\",{\"0\":{\"403\":1,\"405\":1},\"1\":{\"385\":1,\"386\":1,\"400\":2,\"402\":1,\"403\":9,\"404\":1,\"405\":4,\"448\":3,\"449\":1,\"772\":1}}],[\"parnew\",{\"0\":{\"402\":1},\"1\":{\"402\":2,\"403\":1,\"408\":1,\"503\":1}}],[\"parents\",{\"1\":{\"356\":1}}],[\"parent\",{\"1\":{\"352\":1,\"353\":1,\"356\":7,\"357\":2,\"619\":2,\"1043\":2}}],[\"partition\",{\"0\":{\"1196\":1},\"1\":{\"1067\":4,\"1068\":1,\"1194\":1,\"1196\":6,\"1197\":6,\"1199\":6,\"1202\":13,\"1204\":2,\"1205\":2,\"1206\":3,\"1209\":1,\"1210\":1,\"1344\":1,\"1368\":1}}],[\"partitions\",{\"1\":{\"120\":1,\"1199\":2}}],[\"parties\",{\"1\":{\"756\":13,\"757\":1,\"911\":13}}],[\"partial\",{\"1\":{\"387\":1}}],[\"part\",{\"1\":{\"231\":5,\"233\":1,\"1096\":2}}],[\"package\",{\"1\":{\"329\":1,\"433\":1,\"625\":1,\"1131\":1}}],[\"packed\",{\"1\":{\"256\":5}}],[\"paths\",{\"1\":{\"1311\":1}}],[\"path\",{\"1\":{\"483\":1,\"1011\":1,\"1014\":1,\"1328\":1}}],[\"path=\",{\"1\":{\"75\":1}}],[\"pattern\",{\"0\":{\"145\":1,\"146\":1,\"147\":1},\"1\":{\"145\":3,\"146\":7,\"147\":3,\"316\":2,\"882\":1}}],[\"page默认大小为16k\",{\"1\":{\"109\":1}}],[\"page\",{\"1\":{\"94\":1,\"262\":2}}],[\"pullconsumer\",{\"0\":{\"1294\":1}}],[\"pull\",{\"1\":{\"1281\":2,\"1292\":1,\"1321\":1}}],[\"pulsar\",{\"0\":{\"1238\":1},\"1\":{\"1223\":1,\"1238\":12,\"1240\":4}}],[\"pushconsumer\",{\"0\":{\"1292\":1},\"1\":{\"1292\":5}}],[\"push\",{\"1\":{\"667\":1,\"1281\":1,\"1292\":1}}],[\"pushdown\",{\"1\":{\"117\":1}}],[\"publish\",{\"1\":{\"251\":1}}],[\"publisher\",{\"1\":{\"251\":1,\"1279\":1}}],[\"public\",{\"1\":{\"49\":3,\"56\":1,\"77\":2,\"307\":1,\"329\":2,\"331\":1,\"351\":1,\"352\":1,\"353\":4,\"356\":1,\"370\":2,\"384\":4,\"390\":2,\"433\":2,\"438\":2,\"530\":1,\"531\":6,\"533\":5,\"534\":3,\"535\":2,\"536\":6,\"537\":2,\"538\":1,\"549\":1,\"553\":28,\"555\":3,\"557\":1,\"561\":4,\"562\":4,\"564\":5,\"570\":2,\"571\":1,\"573\":1,\"577\":1,\"578\":1,\"586\":1,\"587\":3,\"588\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":2,\"597\":1,\"599\":5,\"600\":1,\"602\":2,\"603\":1,\"604\":2,\"605\":1,\"619\":7,\"621\":4,\"622\":2,\"623\":1,\"625\":2,\"629\":2,\"630\":2,\"632\":5,\"634\":12,\"658\":2,\"662\":1,\"663\":8,\"670\":1,\"677\":2,\"679\":5,\"680\":1,\"686\":2,\"693\":1,\"706\":2,\"709\":4,\"710\":1,\"713\":2,\"727\":1,\"728\":2,\"729\":2,\"730\":3,\"731\":4,\"732\":5,\"740\":1,\"747\":2,\"748\":6,\"749\":3,\"752\":6,\"753\":3,\"756\":3,\"757\":6,\"763\":8,\"764\":4,\"766\":8,\"767\":11,\"768\":9,\"773\":1,\"774\":1,\"777\":2,\"778\":3,\"779\":14,\"780\":3,\"781\":5,\"797\":1,\"798\":2,\"807\":2,\"823\":2,\"834\":5,\"835\":8,\"837\":1,\"841\":3,\"843\":1,\"851\":2,\"852\":2,\"857\":2,\"860\":3,\"865\":3,\"871\":4,\"882\":3,\"883\":2,\"889\":5,\"890\":1,\"891\":3,\"894\":3,\"899\":1,\"900\":2,\"901\":1,\"903\":1,\"905\":2,\"906\":4,\"909\":2,\"911\":3,\"918\":1,\"920\":3,\"927\":1,\"928\":2,\"934\":2,\"936\":1,\"937\":5,\"940\":6,\"941\":1,\"943\":3,\"949\":2,\"953\":2,\"957\":2,\"961\":3,\"986\":1,\"990\":3,\"992\":1,\"1001\":2,\"1008\":1,\"1011\":1,\"1012\":1,\"1014\":3,\"1020\":6,\"1028\":5,\"1030\":2,\"1031\":1,\"1032\":1,\"1043\":3,\"1046\":6,\"1047\":2,\"1058\":3,\"1059\":3,\"1060\":3,\"1061\":3,\"1062\":2,\"1131\":2,\"1140\":2,\"1141\":2,\"1142\":5,\"1210\":6,\"1211\":1,\"1212\":3,\"1299\":1}}],[\"pub\",{\"0\":{\"1229\":1},\"1\":{\"251\":6,\"1194\":1,\"1218\":1,\"1229\":2,\"1231\":1,\"1259\":1}}],[\"putfornullkey\",{\"1\":{\"622\":1}}],[\"putmapentries\",{\"1\":{\"621\":3}}],[\"puttreeval\",{\"1\":{\"577\":1,\"622\":2}}],[\"putifabsent\",{\"1\":{\"577\":1,\"694\":3}}],[\"putindex\",{\"1\":{\"534\":1,\"535\":6,\"538\":3}}],[\"putval中会调用resize初始化或扩容\",{\"1\":{\"621\":1}}],[\"putval\",{\"1\":{\"577\":2,\"621\":1,\"622\":4,\"680\":1,\"683\":1,\"686\":4,\"712\":2,\"713\":4}}],[\"putorderedobject\",{\"1\":{\"570\":1}}],[\"put方法内部调用了\",{\"1\":{\"535\":1}}],[\"putstatic\",{\"1\":{\"344\":2}}],[\"put\",{\"0\":{\"571\":1,\"577\":1,\"622\":1,\"712\":1},\"1\":{\"56\":1,\"530\":1,\"531\":4,\"533\":1,\"535\":5,\"536\":1,\"539\":1,\"570\":1,\"571\":12,\"577\":3,\"603\":1,\"622\":6,\"625\":6,\"630\":1,\"663\":4,\"678\":1,\"679\":4,\"680\":1,\"686\":6,\"688\":2,\"694\":2,\"704\":4,\"705\":5,\"706\":4,\"713\":2,\"799\":1,\"1046\":1}}],[\"peer\",{\"1\":{\"1231\":1}}],[\"peeklast\",{\"1\":{\"667\":1}}],[\"peekfirst\",{\"1\":{\"667\":1}}],[\"peek\",{\"1\":{\"536\":3,\"539\":1,\"603\":2,\"604\":3,\"605\":5,\"667\":1}}],[\"pessimisticlock\",{\"1\":{\"985\":1}}],[\"pessimistic\",{\"1\":{\"985\":1}}],[\"pear\",{\"1\":{\"732\":1,\"733\":1}}],[\"performance\",{\"1\":{\"1200\":1}}],[\"performsynchronisedtask\",{\"1\":{\"837\":1,\"986\":1}}],[\"perfcounter\",{\"1\":{\"357\":3}}],[\"permit\",{\"1\":{\"748\":1}}],[\"permits\",{\"1\":{\"747\":5,\"748\":8,\"749\":3,\"905\":5,\"906\":2}}],[\"perm\",{\"1\":{\"449\":1}}],[\"permsize=n\",{\"1\":{\"480\":1,\"496\":1}}],[\"permsize\",{\"1\":{\"449\":1,\"456\":2}}],[\"permgen\",{\"1\":{\"382\":1,\"480\":1,\"485\":1,\"495\":1,\"496\":2,\"511\":2}}],[\"permanent\",{\"1\":{\"382\":1,\"495\":1}}],[\"per\",{\"1\":{\"246\":1,\"293\":2,\"298\":2}}],[\"percentage\",{\"1\":{\"233\":1}}],[\"personstringentry\",{\"1\":{\"679\":2}}],[\"person4\",{\"1\":{\"679\":2}}],[\"person3\",{\"1\":{\"679\":2}}],[\"person2\",{\"1\":{\"679\":6}}],[\"person1\",{\"1\":{\"679\":6}}],[\"person对象没有实现comparable接口\",{\"1\":{\"663\":1}}],[\"person\",{\"1\":{\"433\":2,\"438\":1,\"630\":5,\"663\":8,\"679\":9,\"767\":14}}],[\"personlocation\",{\"1\":{\"210\":12}}],[\"persist\",{\"1\":{\"270\":1}}],[\"persistence\",{\"1\":{\"224\":1,\"235\":1,\"236\":1,\"237\":3}}],[\"persistent\",{\"1\":{\"54\":3,\"1335\":5,\"1349\":3}}],[\"pexpire\",{\"1\":{\"49\":1}}],[\"px\",{\"1\":{\"48\":1}}],[\"pr\",{\"1\":{\"1143\":1}}],[\"precommit\",{\"1\":{\"1371\":5}}],[\"precheck\",{\"1\":{\"941\":1}}],[\"prehandle\",{\"1\":{\"1046\":1}}],[\"preemptive\",{\"1\":{\"820\":1}}],[\"previndex\",{\"1\":{\"1036\":6}}],[\"previous\",{\"1\":{\"571\":1,\"680\":1,\"732\":2}}],[\"prev\",{\"1\":{\"619\":1,\"657\":2,\"683\":1,\"727\":4,\"729\":4,\"730\":1,\"731\":13,\"732\":1,\"742\":1,\"904\":1,\"1005\":1,\"1011\":4,\"1012\":3,\"1013\":12,\"1014\":4}}],[\"prednext\",{\"1\":{\"1013\":3}}],[\"predecessor\",{\"1\":{\"1005\":1,\"1012\":1,\"1013\":1,\"1015\":1}}],[\"pred\",{\"1\":{\"577\":2,\"729\":4,\"1011\":9,\"1012\":7,\"1013\":16,\"1014\":8}}],[\"predicates\",{\"1\":{\"70\":1,\"75\":1}}],[\"predicate\",{\"1\":{\"69\":1,\"70\":1,\"71\":2}}],[\"presented\",{\"1\":{\"1096\":1}}],[\"present\",{\"1\":{\"571\":1,\"680\":1}}],[\"pretenuresizethreshold\",{\"1\":{\"449\":1,\"469\":1}}],[\"preparation\",{\"1\":{\"338\":1}}],[\"prepare\",{\"0\":{\"1373\":1},\"1\":{\"89\":1,\"90\":1,\"1370\":3,\"1372\":1,\"1373\":1,\"1374\":1,\"1375\":4}}],[\"prefix\",{\"1\":{\"218\":1}}],[\"pre\",{\"1\":{\"69\":2,\"73\":1,\"621\":1}}],[\"preamble\",{\"1\":{\"35\":1,\"235\":1}}],[\"pritchett\",{\"1\":{\"1072\":1}}],[\"priority参数来实现优先级队列\",{\"1\":{\"1258\":1}}],[\"priority\",{\"1\":{\"928\":1,\"1248\":1}}],[\"priorityblockingqueue\",{\"0\":{\"799\":1},\"1\":{\"671\":1,\"796\":1,\"799\":3,\"897\":5}}],[\"priorityqueue<e>\",{\"1\":{\"601\":2}}],[\"priorityqueue\",{\"0\":{\"669\":1,\"736\":1},\"1\":{\"597\":2,\"601\":1,\"607\":2,\"644\":3,\"669\":6,\"736\":2,\"799\":1,\"897\":2}}],[\"printf\",{\"1\":{\"1062\":1}}],[\"printthreadpoolstatus\",{\"1\":{\"918\":2}}],[\"print\",{\"1\":{\"561\":1,\"625\":3,\"918\":1}}],[\"printsafepointstatisticscount=1\",{\"1\":{\"483\":1}}],[\"printstacktrace\",{\"1\":{\"370\":2,\"531\":2,\"749\":1,\"753\":1,\"757\":4,\"781\":3,\"782\":2,\"785\":2,\"823\":2,\"824\":1,\"882\":1,\"909\":1,\"940\":1,\"944\":2,\"1020\":1,\"1030\":1}}],[\"printgc\",{\"1\":{\"367\":5}}],[\"printgcdetails\",{\"1\":{\"367\":1}}],[\"printclassloadertree\",{\"1\":{\"353\":3}}],[\"println\",{\"1\":{\"53\":6,\"353\":1,\"370\":6,\"433\":1,\"451\":14,\"498\":1,\"531\":11,\"551\":1,\"562\":1,\"564\":2,\"593\":10,\"599\":3,\"625\":17,\"631\":1,\"634\":6,\"649\":5,\"652\":1,\"662\":8,\"663\":1,\"679\":1,\"704\":1,\"705\":1,\"706\":1,\"713\":5,\"732\":2,\"733\":8,\"749\":2,\"753\":3,\"757\":6,\"763\":3,\"766\":4,\"767\":14,\"768\":2,\"778\":1,\"779\":3,\"780\":1,\"781\":6,\"782\":5,\"785\":1,\"807\":1,\"823\":6,\"824\":3,\"835\":1,\"851\":1,\"852\":1,\"860\":2,\"882\":2,\"909\":2,\"924\":1,\"940\":3,\"944\":2,\"1020\":1,\"1028\":2,\"1030\":2,\"1043\":2,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1,\"1213\":1,\"1293\":1}}],[\"primitive\",{\"1\":{\"351\":1}}],[\"primary\",{\"1\":{\"33\":1,\"34\":1,\"111\":1,\"120\":1}}],[\"private\",{\"1\":{\"49\":2,\"56\":4,\"77\":1,\"331\":1,\"351\":1,\"352\":2,\"353\":1,\"356\":1,\"370\":2,\"521\":1,\"535\":2,\"553\":17,\"555\":2,\"557\":3,\"558\":2,\"559\":1,\"571\":2,\"572\":1,\"576\":1,\"585\":2,\"589\":2,\"599\":2,\"601\":4,\"619\":1,\"630\":2,\"632\":1,\"634\":1,\"663\":2,\"679\":1,\"706\":1,\"727\":1,\"732\":5,\"742\":1,\"748\":1,\"749\":1,\"752\":1,\"753\":1,\"756\":4,\"757\":4,\"764\":2,\"765\":3,\"767\":2,\"768\":1,\"784\":1,\"797\":1,\"823\":2,\"834\":2,\"837\":1,\"882\":2,\"894\":3,\"904\":1,\"909\":1,\"911\":4,\"920\":3,\"940\":6,\"941\":9,\"986\":1,\"1006\":1,\"1011\":3,\"1012\":3,\"1013\":1,\"1014\":2,\"1015\":1,\"1018\":1,\"1020\":2,\"1028\":1,\"1030\":1,\"1032\":4,\"1036\":4,\"1037\":1,\"1038\":3,\"1041\":2,\"1042\":1,\"1043\":1,\"1047\":1,\"1062\":1,\"1142\":1,\"1209\":1,\"1213\":1,\"1333\":2}}],[\"production\",{\"1\":{\"1200\":1}}],[\"producergroup\",{\"1\":{\"1296\":1}}],[\"producerbuilder\",{\"1\":{\"1290\":1}}],[\"producertype\",{\"1\":{\"1182\":1}}],[\"producer\",{\"0\":{\"1196\":1,\"1248\":1,\"1254\":1},\"1\":{\"531\":4,\"1182\":1,\"1196\":2,\"1204\":3,\"1206\":1,\"1248\":1,\"1249\":1,\"1278\":1,\"1280\":3,\"1281\":3,\"1290\":1,\"1299\":3,\"1301\":1,\"1315\":1,\"1316\":1}}],[\"producerconsumerexample\",{\"1\":{\"531\":1}}],[\"proof\",{\"1\":{\"1097\":2}}],[\"proposer提案者\",{\"1\":{\"1372\":1,\"1373\":1}}],[\"proposer\",{\"1\":{\"1098\":1,\"1373\":1,\"1374\":8}}],[\"proposal\",{\"1\":{\"1097\":1,\"1098\":1,\"1373\":1,\"1374\":1,\"1379\":1}}],[\"propagation\",{\"1\":{\"1084\":1}}],[\"propagate\",{\"1\":{\"1005\":1}}],[\"programming\",{\"1\":{\"1022\":1}}],[\"provider\",{\"1\":{\"1128\":1,\"1131\":1,\"1293\":2}}],[\"provide\",{\"1\":{\"767\":2}}],[\"problems\",{\"1\":{\"720\":1}}],[\"probabilistic\",{\"1\":{\"205\":1}}],[\"protobuf\",{\"1\":{\"1146\":1,\"1147\":1,\"1159\":2,\"1170\":4}}],[\"protostuff\",{\"1\":{\"1146\":1,\"1147\":1}}],[\"protocol\",{\"0\":{\"1395\":1},\"1\":{\"1130\":1,\"1154\":1,\"1159\":1,\"1170\":1,\"1230\":1,\"1231\":1,\"1237\":1,\"1245\":1}}],[\"prototype\",{\"1\":{\"571\":1}}],[\"proto\",{\"1\":{\"571\":3}}],[\"protected修饰符\",{\"1\":{\"331\":1}}],[\"protected\",{\"1\":{\"49\":1,\"354\":2,\"356\":1,\"357\":1,\"553\":1,\"634\":1,\"706\":1,\"712\":1,\"742\":4,\"744\":6,\"748\":2,\"752\":2,\"882\":1,\"904\":4,\"1006\":3,\"1007\":6,\"1008\":1,\"1014\":1,\"1020\":3,\"1140\":1,\"1141\":1,\"1142\":1}}],[\"promotion\",{\"1\":{\"388\":1}}],[\"prometheus\",{\"1\":{\"8\":1}}],[\"profiling\",{\"1\":{\"377\":2}}],[\"proxy\",{\"1\":{\"299\":1,\"1130\":1}}],[\"project\",{\"1\":{\"280\":20}}],[\"projects\",{\"1\":{\"5\":1,\"68\":1}}],[\"procedure\",{\"1\":{\"1154\":1,\"1165\":1}}],[\"processcommand\",{\"1\":{\"940\":2}}],[\"processnum\",{\"1\":{\"928\":3}}],[\"process\",{\"0\":{\"1399\":1},\"1\":{\"168\":2,\"364\":1,\"365\":1,\"824\":1,\"1052\":1}}],[\"proc\",{\"1\":{\"168\":2}}],[\"python\",{\"1\":{\"7\":1,\"8\":1,\"164\":1,\"293\":1,\"593\":1,\"1171\":1,\"1237\":1,\"1238\":1,\"1245\":1,\"1246\":1}}],[\"用它来干这些事会带来什么好处\",{\"1\":{\"1268\":1}}],[\"用它来处理结果\",{\"1\":{\"779\":1}}],[\"用到\",{\"1\":{\"1181\":1}}],[\"用到了循环队列的思想\",{\"1\":{\"535\":1}}],[\"用到了\",{\"1\":{\"359\":1}}],[\"用到了全局过滤器\",{\"1\":{\"75\":1}}],[\"用完放回去\",{\"1\":{\"1158\":1}}],[\"用完后再把资源转让给其它线程\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"用起来更方便\",{\"1\":{\"1154\":1}}],[\"用connect\",{\"1\":{\"1151\":1}}],[\"用线程池实现\",{\"1\":{\"934\":1}}],[\"用过\",{\"0\":{\"909\":1}}],[\"用过的内存全部整合到一边\",{\"1\":{\"503\":1}}],[\"用给定的初始参数创建一个新的threadpoolexecutor\",{\"1\":{\"890\":1,\"936\":1}}],[\"用基于\",{\"1\":{\"840\":1,\"989\":1}}],[\"用了这个方法\",{\"1\":{\"753\":1}}],[\"用了一个\",{\"1\":{\"412\":1}}],[\"用新元素替换旧元素\",{\"1\":{\"697\":1}}],[\"用新值替换旧值\",{\"1\":{\"622\":1}}],[\"用指定的元素代替指定list中的所有元素\",{\"1\":{\"697\":1}}],[\"用指定的元素替换此列表中指定位置的元素\",{\"1\":{\"553\":1}}],[\"用之前还要先做对数组的长度取模运算\",{\"1\":{\"684\":1}}],[\"用\",{\"1\":{\"640\":1,\"744\":1,\"1240\":1}}],[\"用空数组代替\",{\"1\":{\"553\":1}}],[\"用法详解\",{\"1\":{\"545\":1}}],[\"用reentrantlock类结合condition实例可以实现\",{\"1\":{\"544\":1,\"862\":1}}],[\"用的是非公平锁\",{\"1\":{\"534\":1}}],[\"用的要更多一点\",{\"1\":{\"45\":1}}],[\"用lock锁创建两个条件控制队列生产和消费\",{\"1\":{\"534\":1}}],[\"用此类加载器记录每个已加载类\",{\"1\":{\"352\":1}}],[\"用一个闭包结构去记录可达对象\",{\"1\":{\"406\":1}}],[\"用一个哈希函数把\",{\"1\":{\"96\":1}}],[\"用一个日志模块不行吗\",{\"1\":{\"89\":1}}],[\"用于完成一定功能的一个过程\",{\"1\":{\"1344\":1}}],[\"用于匹配多个单词\",{\"1\":{\"1252\":1}}],[\"用于匹配一个单词\",{\"1\":{\"1252\":1}}],[\"用于做模糊匹配\",{\"1\":{\"1252\":1}}],[\"用于处理海量的日志有很大关系\",{\"1\":{\"1191\":1}}],[\"用于区分\",{\"1\":{\"1152\":1}}],[\"用于度量一个热力学系统的混乱程度\",{\"1\":{\"1087\":1}}],[\"用于将其添加进\",{\"1\":{\"1085\":1}}],[\"用于检测是否重复获取\",{\"1\":{\"1019\":1}}],[\"用于方法\",{\"1\":{\"1001\":1}}],[\"用于方便地搭建能够处理超高并发\",{\"1\":{\"6\":1}}],[\"用于对象\",{\"1\":{\"1001\":1}}],[\"用于代码块\",{\"1\":{\"1001\":1}}],[\"用于展示当前临界资源的获锁情况\",{\"1\":{\"742\":1,\"904\":1,\"1006\":1}}],[\"用于和\",{\"1\":{\"732\":1}}],[\"用于在分布式系统中存储转发消息\",{\"1\":{\"1237\":1,\"1245\":1}}],[\"用于在线程到达屏障时\",{\"1\":{\"757\":1}}],[\"用于在指定位置插入元素\",{\"1\":{\"729\":1}}],[\"用于在指定的超时时间内阻塞式地添加和获取元素\",{\"1\":{\"537\":1}}],[\"用于在\",{\"1\":{\"729\":1}}],[\"用于记录元素的插入顺序或访问顺序\",{\"1\":{\"719\":1}}],[\"用于记录元素的插入顺序\",{\"1\":{\"716\":1}}],[\"用于记录数据被修改前的信息\",{\"1\":{\"137\":1}}],[\"用于支持对元素自定义排序规则的场景\",{\"1\":{\"665\":1}}],[\"用于支持基于时间的任务调度和缓存过期删除等场景\",{\"1\":{\"598\":1}}],[\"用于保存事件\",{\"1\":{\"1182\":1}}],[\"用于保证一定的可见性和有序性\",{\"1\":{\"1018\":1}}],[\"用于保证元素的插入和取出顺序满足\",{\"1\":{\"665\":1}}],[\"用于保障\",{\"1\":{\"136\":1}}],[\"用于不需要保证元素插入和取出顺序的场景\",{\"1\":{\"665\":1}}],[\"用于遍历桶中的链表\",{\"1\":{\"622\":1}}],[\"用于添加元素\",{\"1\":{\"622\":1}}],[\"用于实现乐观锁\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"用于实现延时任务比如订单下单\",{\"1\":{\"597\":1}}],[\"用于实现类加载过程中的加载这一步\",{\"1\":{\"351\":1}}],[\"用于默认大小空实例的共享空数组实例\",{\"1\":{\"553\":1}}],[\"用于空实例\",{\"1\":{\"553\":1}}],[\"用于存储消息\",{\"1\":{\"1255\":1}}],[\"用于存储键值对数据\",{\"1\":{\"690\":1}}],[\"用于存储从队列中取出的元素\",{\"1\":{\"531\":1}}],[\"用于存放该本地方法的局部变量表\",{\"1\":{\"494\":1}}],[\"用于存放方法执行过程中产生的中间计算结果\",{\"1\":{\"493\":1}}],[\"用于发出紧急命令\",{\"1\":{\"484\":1}}],[\"用于分析\",{\"1\":{\"364\":1,\"369\":1}}],[\"用于收集\",{\"1\":{\"364\":1}}],[\"用于查看所有\",{\"1\":{\"364\":1}}],[\"用于加载\",{\"1\":{\"359\":1}}],[\"用于统计类加载器相关的信息\",{\"1\":{\"357\":1}}],[\"用于描述接口或类中声明的变量\",{\"1\":{\"331\":1}}],[\"用于生成自己的内部调用视图\",{\"1\":{\"21\":1}}],[\"用户程序提交的数据\",{\"1\":{\"1362\":1}}],[\"用户程序在继续运行\",{\"1\":{\"402\":1}}],[\"用户名\",{\"1\":{\"1351\":1}}],[\"用户在发起\",{\"1\":{\"1311\":1}}],[\"用户在真正扫码后\",{\"1\":{\"17\":1}}],[\"用户调用\",{\"1\":{\"1308\":1}}],[\"用户购票完成之后是不是需要增加账户积分\",{\"1\":{\"1275\":1}}],[\"用户购买完还需要给他加积分\",{\"1\":{\"1272\":1}}],[\"用户账号等等\",{\"1\":{\"1272\":1}}],[\"用户都睡觉了\",{\"1\":{\"1264\":1}}],[\"用户不会接触或者使用到中间件\",{\"1\":{\"1218\":1}}],[\"用户数量越来越多\",{\"1\":{\"1123\":1}}],[\"用户线程创建和切换成本低\",{\"1\":{\"808\":1}}],[\"用户线程\",{\"1\":{\"808\":2}}],[\"用户请求获取订单信息\",{\"1\":{\"772\":1}}],[\"用户自己指定容量\",{\"1\":{\"555\":1}}],[\"用户可以在创建arraylist对象时自己指定集合的初始大小\",{\"1\":{\"553\":1}}],[\"用户可以使用系统的全部功能\",{\"1\":{\"1076\":1}}],[\"用户可以使用\",{\"1\":{\"8\":1}}],[\"用户可通过覆写该方法\",{\"1\":{\"357\":1}}],[\"用户还可以加入自定义的类加载器来进行拓展\",{\"1\":{\"353\":1}}],[\"用户需要定义一个要执行的主类\",{\"1\":{\"344\":1}}],[\"用户登录的\",{\"1\":{\"270\":1}}],[\"用户添加商品就是往\",{\"1\":{\"257\":1}}],[\"用户\",{\"1\":{\"257\":1}}],[\"用户访问的数据属于高频数据并且不会经常改变的话\",{\"1\":{\"246\":1}}],[\"用户最多只会丢失一秒之内产生的数据\",{\"1\":{\"231\":1}}],[\"用户行为统计\",{\"1\":{\"203\":1}}],[\"用户签到情况\",{\"1\":{\"203\":1}}],[\"用户信息\",{\"1\":{\"186\":1}}],[\"用户单位时间的请求数\",{\"1\":{\"178\":1}}],[\"用户体验差\",{\"1\":{\"132\":1}}],[\"用户下订单之前需要检查库存\",{\"1\":{\"60\":1}}],[\"用户订单遇到问题\",{\"1\":{\"18\":1}}],[\"用户代理\",{\"1\":{\"17\":1}}],[\"用户使用支付宝微信直接扫一个码付钱\",{\"1\":{\"17\":1}}],[\"用户群体庞大\",{\"1\":{\"10\":1}}],[\"用户案例\",{\"1\":{\"8\":1}}],[\"用来保证集群中存在过半的机器能够和\",{\"1\":{\"1361\":1}}],[\"用来保存消息直到发送给消费者\",{\"1\":{\"1250\":1}}],[\"用来读写文件\",{\"1\":{\"1311\":1}}],[\"用来存储消息的数据结构\",{\"1\":{\"1253\":1}}],[\"用来存储操作数据\",{\"1\":{\"7\":1}}],[\"用来指定这个消息的路由规则\",{\"1\":{\"1249\":1}}],[\"用来做出所有的决定\",{\"1\":{\"1105\":1}}],[\"用来禁止处理器指令发生重排序\",{\"1\":{\"969\":1}}],[\"用来在给定的延迟后运行任务或者定期执行任务\",{\"1\":{\"961\":1}}],[\"用来创建线程\",{\"1\":{\"890\":1,\"936\":1}}],[\"用来储存等待执行任务的队列\",{\"1\":{\"890\":1,\"936\":1}}],[\"用来表明实现该接口的类支持随机访问\",{\"1\":{\"655\":1,\"726\":1}}],[\"用来表示锁的占用状态\",{\"1\":{\"742\":1}}],[\"用来表示序列号\",{\"1\":{\"38\":1}}],[\"用来表示时间戳\",{\"1\":{\"38\":1}}],[\"用来对数据库数据进行并发访问\",{\"1\":{\"141\":1}}],[\"用来接收生产者发送的消息并将这些消息路由给服务器中的队列中\",{\"1\":{\"1249\":1}}],[\"用来接收\",{\"1\":{\"7\":1}}],[\"3pc流程\",{\"1\":{\"1371\":1}}],[\"3pc\",{\"0\":{\"1371\":1},\"1\":{\"1369\":1,\"1371\":5,\"1391\":1}}],[\"37\",{\"1\":{\"940\":5,\"1328\":1}}],[\"376c55d8\",{\"1\":{\"237\":1}}],[\"3is\",{\"1\":{\"757\":4}}],[\"3s到期的任务\",{\"1\":{\"599\":1}}],[\"3s\",{\"1\":{\"599\":1}}],[\"362498820763181265l\",{\"1\":{\"619\":1}}],[\"368\",{\"1\":{\"511\":1}}],[\"36\",{\"1\":{\"444\":1}}],[\"365\",{\"1\":{\"19\":1}}],[\"310621485\",{\"1\":{\"913\":1}}],[\"31\",{\"1\":{\"369\":1,\"370\":1,\"1026\":1}}],[\"31736\",{\"1\":{\"366\":2}}],[\"3g\",{\"1\":{\"219\":1}}],[\"350ms\",{\"1\":{\"1271\":1}}],[\"35\",{\"1\":{\"210\":1,\"679\":1}}],[\"34\",{\"1\":{\"210\":1,\"343\":1,\"444\":1,\"497\":1,\"1122\":1,\"1325\":1,\"1349\":2}}],[\"347028665\",{\"1\":{\"78\":1}}],[\"39960815\",{\"1\":{\"334\":1}}],[\"39\",{\"1\":{\"210\":7}}],[\"33+33\",{\"1\":{\"558\":1}}],[\"339662987\",{\"1\":{\"545\":1}}],[\"33\",{\"1\":{\"210\":4,\"342\":1,\"1096\":1}}],[\"3种常用的缓存读写策略详解\",{\"0\":{\"144\":1}}],[\"3次io操作即可查找到数据\",{\"1\":{\"110\":1}}],[\"3层\",{\"1\":{\"110\":1}}],[\"3210435\",{\"1\":{\"687\":1}}],[\"32000\",{\"1\":{\"384\":1}}],[\"327234\",{\"1\":{\"298\":1}}],[\"32768\",{\"1\":{\"19\":1}}],[\"3299986720085144\",{\"1\":{\"210\":1}}],[\"32\",{\"1\":{\"37\":3,\"217\":1,\"218\":2,\"256\":2,\"442\":1,\"570\":2,\"1209\":3,\"1379\":3}}],[\"3~6\",{\"1\":{\"35\":1}}],[\"30w\",{\"1\":{\"1315\":1}}],[\"30w+\",{\"1\":{\"246\":1}}],[\"302\",{\"1\":{\"1159\":1}}],[\"309\",{\"1\":{\"1022\":1}}],[\"30900\",{\"1\":{\"384\":1}}],[\"3000\",{\"1\":{\"599\":1}}],[\"3000~5000\",{\"1\":{\"449\":1,\"458\":1}}],[\"300秒\",{\"1\":{\"307\":1}}],[\"300做对比\",{\"1\":{\"141\":1}}],[\"300\",{\"1\":{\"141\":2,\"226\":1,\"749\":1,\"753\":1,\"928\":1}}],[\"30s\",{\"1\":{\"49\":1,\"230\":1}}],[\"30秒\",{\"1\":{\"49\":1}}],[\"30\",{\"1\":{\"19\":1,\"49\":4,\"161\":1,\"231\":1,\"369\":1,\"444\":1,\"619\":1,\"663\":2,\"1281\":1,\"1293\":1}}],[\"3\",{\"0\":{\"19\":1,\"23\":1,\"129\":1,\"199\":1,\"430\":1,\"433\":1,\"435\":1,\"436\":1,\"437\":2,\"438\":2,\"439\":2,\"440\":3,\"441\":2,\"442\":2,\"443\":2,\"444\":2,\"445\":2,\"446\":2,\"447\":1,\"448\":1,\"449\":1,\"453\":1,\"463\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"571\":1,\"577\":1,\"579\":1,\"919\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":2,\"1013\":1,\"1014\":2,\"1015\":1,\"1016\":1,\"1020\":1,\"1068\":1,\"1110\":1,\"1111\":1,\"1116\":1},\"1\":{\"7\":1,\"18\":1,\"19\":1,\"23\":2,\"34\":1,\"35\":1,\"37\":1,\"48\":3,\"49\":5,\"60\":3,\"99\":2,\"101\":1,\"106\":1,\"117\":4,\"125\":4,\"127\":1,\"128\":1,\"129\":1,\"132\":1,\"141\":2,\"144\":2,\"174\":2,\"181\":5,\"185\":1,\"189\":1,\"193\":4,\"199\":1,\"206\":3,\"210\":2,\"224\":1,\"231\":1,\"243\":1,\"247\":1,\"251\":2,\"252\":2,\"253\":1,\"256\":7,\"266\":1,\"268\":1,\"280\":1,\"281\":1,\"282\":1,\"293\":3,\"298\":2,\"302\":1,\"328\":1,\"339\":1,\"340\":2,\"342\":2,\"345\":1,\"349\":1,\"366\":1,\"368\":1,\"392\":1,\"394\":2,\"412\":1,\"429\":1,\"430\":1,\"445\":1,\"449\":3,\"450\":1,\"455\":1,\"496\":2,\"498\":1,\"507\":1,\"515\":1,\"523\":1,\"531\":10,\"534\":1,\"557\":1,\"561\":5,\"562\":1,\"593\":1,\"599\":3,\"604\":4,\"625\":1,\"631\":1,\"634\":9,\"653\":6,\"662\":10,\"679\":1,\"704\":2,\"705\":3,\"706\":2,\"710\":1,\"730\":1,\"733\":1,\"763\":3,\"766\":1,\"781\":2,\"796\":1,\"807\":1,\"834\":1,\"848\":2,\"882\":2,\"890\":1,\"895\":1,\"922\":1,\"934\":1,\"936\":1,\"940\":4,\"941\":2,\"944\":3,\"974\":5,\"1001\":2,\"1002\":1,\"1005\":1,\"1011\":1,\"1013\":1,\"1016\":4,\"1022\":1,\"1036\":3,\"1037\":1,\"1038\":2,\"1076\":1,\"1078\":1,\"1085\":1,\"1090\":2,\"1098\":1,\"1105\":1,\"1109\":2,\"1141\":1,\"1144\":2,\"1170\":1,\"1200\":3,\"1204\":2,\"1206\":3,\"1208\":1,\"1235\":2,\"1252\":1,\"1257\":1,\"1296\":1,\"1297\":1,\"1308\":2,\"1310\":2,\"1311\":1,\"1321\":2,\"1322\":1,\"1331\":1,\"1332\":1,\"1333\":2,\"1346\":1,\"1354\":1,\"1355\":1,\"1357\":1,\"1358\":3,\"1380\":2}}],[\"可是有一次\",{\"1\":{\"1303\":1}}],[\"可是仔细一想你就感觉有点问题\",{\"1\":{\"1271\":1}}],[\"可复用的企业消息系统\",{\"1\":{\"1245\":1}}],[\"可无缝扩展到超过一百万个\",{\"1\":{\"1238\":1}}],[\"可跨机房在集群间无缝地完成消息复制\",{\"1\":{\"1238\":1}}],[\"可观测性等解决方案\",{\"1\":{\"1168\":1}}],[\"可想而知\",{\"1\":{\"1155\":1}}],[\"可靠的定时事件触发\",{\"1\":{\"1285\":1}}],[\"可靠\",{\"1\":{\"1151\":1,\"1152\":1}}],[\"可靠性和高可用性等方面的卓著表现是分不开的\",{\"1\":{\"1237\":1}}],[\"可靠性\",{\"1\":{\"515\":1,\"1237\":1,\"1246\":1,\"1345\":1}}],[\"可作为第三方插件下载的\",{\"1\":{\"1132\":1}}],[\"可见\",{\"1\":{\"1011\":1}}],[\"可见性\",{\"0\":{\"979\":1},\"1\":{\"331\":1}}],[\"可参考\",{\"1\":{\"1002\":1}}],[\"可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范\",{\"1\":{\"971\":1,\"973\":1,\"981\":1}}],[\"可传入\",{\"1\":{\"900\":1}}],[\"可通过\",{\"1\":{\"896\":1,\"923\":1}}],[\"可中断锁\",{\"1\":{\"863\":1}}],[\"可中断锁和不可中断锁有什么区别\",{\"0\":{\"863\":1}}],[\"可实现选择性通知\",{\"1\":{\"862\":1}}],[\"可实现公平锁\",{\"1\":{\"862\":1}}],[\"可运行状态的线程获得了\",{\"1\":{\"820\":1}}],[\"可运行\",{\"1\":{\"820\":1}}],[\"可采用如下代码\",{\"1\":{\"797\":1}}],[\"可扩容动态双向数组\",{\"1\":{\"644\":1}}],[\"可扩展的网关系统\",{\"1\":{\"8\":1}}],[\"可扩展\",{\"1\":{\"7\":1,\"1285\":1}}],[\"可自行查看源码\",{\"1\":{\"639\":1}}],[\"可配置\",{\"1\":{\"523\":1}}],[\"可选\",{\"1\":{\"483\":1}}],[\"可它的实现需要耗费大量资源和时间\",{\"1\":{\"445\":1}}],[\"可预测的停顿\",{\"1\":{\"407\":1}}],[\"可达性分析计算\",{\"1\":{\"445\":1}}],[\"可达性分析法中不可达的对象被第一次标记并且进行一次筛选\",{\"1\":{\"391\":1}}],[\"可达性分析算法\",{\"0\":{\"391\":1},\"1\":{\"391\":1}}],[\"可视化的服务治理与运维\",{\"1\":{\"1122\":1}}],[\"可视化分析工具\",{\"0\":{\"371\":1}}],[\"可视化工具查看\",{\"1\":{\"210\":1}}],[\"可变性\",{\"1\":{\"331\":1}}],[\"可否被序列化\",{\"1\":{\"331\":1}}],[\"可读性较差\",{\"1\":{\"235\":1}}],[\"可用性降低\",{\"1\":{\"1275\":1}}],[\"可用性等等\",{\"1\":{\"1070\":1}}],[\"可用性\",{\"1\":{\"1067\":2,\"1068\":1,\"1069\":1,\"1240\":1,\"1314\":1,\"1368\":1}}],[\"可用于通讯协议\",{\"1\":{\"1170\":1}}],[\"可用于代码块\",{\"1\":{\"1001\":1}}],[\"可用于解决原子的更新数据和数据的版本号\",{\"1\":{\"762\":1,\"767\":1}}],[\"可用于模拟栈\",{\"1\":{\"667\":1}}],[\"可用许可证+1\",{\"1\":{\"748\":1}}],[\"可用内存缩小为原来的一半\",{\"1\":{\"397\":1}}],[\"可用内存变小\",{\"1\":{\"397\":1}}],[\"可用运算符有\",{\"1\":{\"202\":1}}],[\"可用字符如下所示\",{\"1\":{\"19\":1}}],[\"可重复的\",{\"1\":{\"640\":3}}],[\"可重复读\",{\"1\":{\"125\":1,\"132\":2}}],[\"可重入锁\",{\"1\":{\"601\":1,\"860\":1,\"996\":1}}],[\"可重入\",{\"1\":{\"61\":1,\"63\":1,\"1001\":1}}],[\"可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁\",{\"1\":{\"50\":1}}],[\"可能我们会有这样的需求\",{\"1\":{\"1390\":1}}],[\"可能获取锁的客户端宕机了\",{\"1\":{\"1388\":1}}],[\"可能不是\",{\"1\":{\"1380\":1}}],[\"可能你还有一个问题\",{\"1\":{\"1280\":1}}],[\"可能你是熟练使用消息队列的老手\",{\"1\":{\"1217\":1}}],[\"可能存在的情况是\",{\"1\":{\"1192\":1}}],[\"可能也会用到\",{\"1\":{\"978\":1}}],[\"可能还有\",{\"1\":{\"968\":1}}],[\"可能是历史原因\",{\"1\":{\"1277\":1}}],[\"可能是借鉴了\",{\"1\":{\"1169\":1}}],[\"可能是当前线程在等待中被中断\",{\"1\":{\"1015\":1}}],[\"可能是非公平锁被抢占了\",{\"1\":{\"1012\":1}}],[\"可能是操作系统中时间消耗最大的操作\",{\"1\":{\"895\":1,\"922\":1}}],[\"可能是一个空元素\",{\"1\":{\"571\":1}}],[\"可能是一个元素\",{\"1\":{\"571\":1}}],[\"可能是一个指向对象起始地址的引用指针\",{\"1\":{\"493\":1}}],[\"可能堆积大量的请求\",{\"1\":{\"889\":2,\"897\":1,\"917\":2,\"937\":2}}],[\"可能需要调用用户信息\",{\"1\":{\"772\":1}}],[\"可能相同\",{\"1\":{\"678\":1}}],[\"可能直接就被这么多请求弄宕机了\",{\"1\":{\"306\":1,\"309\":1,\"313\":1}}],[\"可能只在\",{\"1\":{\"270\":1}}],[\"可能只是简单了写一些\",{\"1\":{\"144\":1}}],[\"可能\",{\"1\":{\"132\":6}}],[\"可能会出现消息冗余的问题\",{\"1\":{\"1090\":1}}],[\"可能会创建大量线程\",{\"1\":{\"892\":1,\"917\":1,\"937\":1,\"938\":1,\"959\":1}}],[\"可能会创建大量的线程\",{\"1\":{\"889\":1}}],[\"可能会被其他任务占用\",{\"1\":{\"784\":1}}],[\"可能会进入阻塞或轮询状态\",{\"1\":{\"688\":1}}],[\"可能会抛出concurrentmodificationexception\",{\"1\":{\"631\":1}}],[\"可能会崩溃\",{\"1\":{\"485\":1}}],[\"可能会交替执行\",{\"1\":{\"402\":1}}],[\"可能会影响\",{\"1\":{\"297\":1}}],[\"可能会使用大量内存\",{\"1\":{\"233\":1,\"236\":1}}],[\"可能会有新的数据结构出现\",{\"1\":{\"174\":1}}],[\"可能会有很多客户端同时获取锁\",{\"1\":{\"55\":1}}],[\"可能会阻塞后续其他命令的执行\",{\"1\":{\"160\":1,\"232\":1}}],[\"可能会导致无法遍历所有的节点\",{\"1\":{\"1014\":1}}],[\"可能会导致线程从threadlocal获取到的是旧值\",{\"1\":{\"929\":1}}],[\"可能会导致线程池中的线程被长时间占用\",{\"1\":{\"925\":1}}],[\"可能会导致饥饿问题\",{\"1\":{\"897\":1}}],[\"可能会导致大量的请求\",{\"1\":{\"895\":1,\"922\":1}}],[\"可能会导致内存资源不足\",{\"1\":{\"585\":1}}],[\"可能会导致内存占用过高的问题\",{\"1\":{\"302\":1}}],[\"可能会导致数据库崩溃\",{\"1\":{\"297\":1}}],[\"可能会导致出现脏数据或者系统问题\",{\"1\":{\"60\":1}}],[\"可能会导致锁无法被释放\",{\"1\":{\"47\":1}}],[\"可能导致会产生重复\",{\"1\":{\"35\":1,\"37\":1,\"38\":1}}],[\"可能无法正确打开\",{\"1\":{\"24\":2}}],[\"可表示范围\",{\"1\":{\"19\":1}}],[\"可编程的能力\",{\"1\":{\"7\":1}}],[\"可以保存数据的功能\",{\"1\":{\"1346\":1}}],[\"可以保证父节点不存在的时候自动创建父节点\",{\"1\":{\"1335\":1}}],[\"可以保证消息在分区内的顺序性\",{\"1\":{\"1205\":1}}],[\"可以保证任一时刻只有一个线程访问该代码块\",{\"1\":{\"978\":1}}],[\"可以保证任何时刻任何线程总能拿到该变量的最新值\",{\"1\":{\"765\":1}}],[\"可以保证每次出队的任务都是当前队列中执行时间最靠前的\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行\",{\"1\":{\"847\":1}}],[\"可以保证变量的可见性嘛\",{\"1\":{\"835\":1}}],[\"可以保证原子性么\",{\"0\":{\"835\":1}}],[\"可以保证多线程环境下的安全性和可靠性\",{\"1\":{\"608\":1}}],[\"可以保证数据的安全性\",{\"1\":{\"589\":1}}],[\"可以保证锁能被释放\",{\"1\":{\"588\":1}}],[\"可以保证唯一性\",{\"1\":{\"37\":1}}],[\"可以很方便地实现数据发布\",{\"1\":{\"1346\":1}}],[\"可以很方便的监视本地及远程服务器的\",{\"1\":{\"372\":1}}],[\"可以像数组一样随机访问每一个条目\",{\"1\":{\"1315\":1}}],[\"可以减少\",{\"1\":{\"1311\":1}}],[\"可以满足\",{\"1\":{\"1311\":1}}],[\"可以按照时间维度来回退消费进度\",{\"1\":{\"1306\":1}}],[\"可以手动设置\",{\"1\":{\"1301\":1}}],[\"可以顺序消费\",{\"1\":{\"1286\":1}}],[\"可以轻松实现任意精度事件触发\",{\"1\":{\"1285\":1}}],[\"可以以两种模式启动\",{\"1\":{\"1281\":1}}],[\"可以以原子性的方式执行\",{\"1\":{\"47\":1}}],[\"可以配置多个\",{\"1\":{\"1281\":1}}],[\"可以配置任意数量的线程\",{\"1\":{\"962\":1}}],[\"可以找到\",{\"1\":{\"1263\":1}}],[\"可以是零个\",{\"1\":{\"1252\":1}}],[\"可以是可以\",{\"1\":{\"251\":1}}],[\"可以把消息传递的过程想象成\",{\"1\":{\"1247\":1}}],[\"可以把多个服务的响应整合起来\",{\"1\":{\"2\":1}}],[\"可以直观看到项目是否还在维护\",{\"1\":{\"1235\":1,\"1236\":1,\"1237\":1,\"1238\":1}}],[\"可以直接调用\",{\"0\":{\"827\":1}}],[\"可以直接存储基本类型数据\",{\"1\":{\"649\":1}}],[\"可以直接跳过了\",{\"0\":{\"460\":1}}],[\"可以部署在在本地和云环境中的裸机硬件\",{\"1\":{\"1235\":1}}],[\"可以进一步分析\",{\"1\":{\"1213\":1}}],[\"可以进行消息广播\",{\"1\":{\"1356\":1}}],[\"可以进行编排\",{\"1\":{\"772\":1}}],[\"可以进行深拷贝或浅拷贝操作\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"可以确保不止一个\",{\"1\":{\"1206\":1}}],[\"可以确保是安全的\",{\"1\":{\"388\":1}}],[\"可以指定\",{\"1\":{\"1202\":1}}],[\"可以指定对应的\",{\"1\":{\"1197\":1}}],[\"可以根据msg特点选择\",{\"1\":{\"1299\":1}}],[\"可以根据当前的\",{\"1\":{\"1199\":1}}],[\"可以根据业务情况来预估一些\",{\"1\":{\"298\":1}}],[\"可以横跨多个\",{\"1\":{\"1196\":1}}],[\"可以分布在不同的\",{\"1\":{\"1196\":1,\"1197\":1,\"1199\":1}}],[\"可以分为阻塞队列和非阻塞队列\",{\"1\":{\"794\":1}}],[\"可以分为两类方法\",{\"1\":{\"667\":1}}],[\"可以帮助我们调用远程计算机上某个服务的方法\",{\"1\":{\"1165\":1,\"1232\":1}}],[\"可以帮助我们来做多个任务的编排\",{\"1\":{\"772\":1}}],[\"可以采用为其添加回调函数的形式\",{\"1\":{\"1204\":1}}],[\"可以采用体积更小的\",{\"1\":{\"1159\":1}}],[\"可以采用异步操作的方式来处理\",{\"1\":{\"925\":1}}],[\"可以多花点时间研究一下\",{\"1\":{\"1143\":1}}],[\"可以为我们解决服务之间互相是如何调用的\",{\"1\":{\"1123\":1}}],[\"可以设置为\",{\"1\":{\"1116\":1}}],[\"可以生成\",{\"1\":{\"1112\":1}}],[\"可以创建\",{\"1\":{\"1110\":1}}],[\"可以查看这篇文章\",{\"1\":{\"1085\":1,\"1184\":1}}],[\"可以向指定的\",{\"1\":{\"1085\":1}}],[\"可以详细看下\",{\"1\":{\"1016\":1}}],[\"可以借助synchronized\",{\"1\":{\"978\":1,\"979\":1}}],[\"可以借助现成的开源项目\",{\"1\":{\"896\":1,\"923\":1}}],[\"可以实现异步分发\",{\"1\":{\"1293\":1}}],[\"可以实现将\",{\"1\":{\"943\":1}}],[\"可以实现多个任务按照时间先后顺序执行\",{\"1\":{\"611\":1}}],[\"可以再加载这个任务的状态\",{\"1\":{\"895\":1,\"922\":1}}],[\"可以访问到该线程的threadlocalmap对象\",{\"1\":{\"883\":1}}],[\"可以作为参考\",{\"1\":{\"921\":1}}],[\"可以作为\",{\"1\":{\"873\":1}}],[\"可以延迟流水线执行指令\",{\"1\":{\"844\":1,\"993\":1}}],[\"可以获取到\",{\"1\":{\"824\":1}}],[\"可以获取部分字段的信息\",{\"1\":{\"255\":1}}],[\"可以主动释放它占有的资源\",{\"1\":{\"824\":1}}],[\"可以从顶级链表开始找\",{\"1\":{\"800\":1}}],[\"可以从注册中心获取服务的元数据\",{\"1\":{\"72\":1}}],[\"可以当做无界队列也可以当做有界队列来使用\",{\"1\":{\"798\":1}}],[\"可以互相独立地运行\",{\"1\":{\"782\":1}}],[\"可以链接两个\",{\"1\":{\"781\":1}}],[\"可以接收\",{\"1\":{\"779\":1}}],[\"可以同时被多个线程持有\",{\"1\":{\"865\":1}}],[\"可以同时调用获取物流信息\",{\"1\":{\"772\":1}}],[\"可以同时以交错方式执行\",{\"1\":{\"287\":1}}],[\"可以解决使用\",{\"1\":{\"762\":1,\"767\":1}}],[\"可以更好地适应现代软件开发中多样化的数据需求\",{\"1\":{\"647\":1}}],[\"可以快速对一个集合进行去重操作\",{\"1\":{\"632\":1}}],[\"可以遍历链表\",{\"1\":{\"622\":1}}],[\"可以存储\",{\"1\":{\"616\":1,\"677\":1,\"693\":1}}],[\"可以存放\",{\"1\":{\"442\":1}}],[\"可以发现\",{\"1\":{\"575\":1}}],[\"可以添加\",{\"0\":{\"551\":1,\"652\":1}}],[\"可以动态地增加容量\",{\"1\":{\"543\":1}}],[\"可以动态的修改\",{\"1\":{\"367\":1}}],[\"可以继续存放元素\",{\"1\":{\"535\":1}}],[\"可以继续扩展\",{\"1\":{\"456\":1}}],[\"可以修饰属性\",{\"1\":{\"521\":1}}],[\"可以简单地看作一个\",{\"1\":{\"1251\":1}}],[\"可以简单地将它的key视作threadlocal\",{\"1\":{\"1029\":1}}],[\"可以简单理解为一个固定大小的hashtable\",{\"1\":{\"498\":1}}],[\"可以简单参考一下\",{\"1\":{\"244\":1}}],[\"可以给出任何文件名\",{\"1\":{\"484\":1}}],[\"可以参考下图理解\",{\"1\":{\"731\":1}}],[\"可以参考\",{\"1\":{\"480\":1}}],[\"可以举个例子\",{\"1\":{\"444\":1}}],[\"可以被用作注册中心\",{\"1\":{\"1341\":1}}],[\"可以被设置为\",{\"1\":{\"841\":1,\"990\":1}}],[\"可以被访问时\",{\"1\":{\"797\":1}}],[\"可以被其它变量复用\",{\"1\":{\"442\":1}}],[\"可以被所有\",{\"1\":{\"359\":1}}],[\"可以算是粗调吧\",{\"1\":{\"412\":1}}],[\"可以跟着作者思路一步一步来\",{\"1\":{\"412\":1}}],[\"可以不需要其他收集器配合就能独立管理整个\",{\"1\":{\"407\":1}}],[\"可以\",{\"1\":{\"394\":1,\"772\":1}}],[\"可以维护系统的运行安全\",{\"1\":{\"392\":1}}],[\"可以执行如下代码验证\",{\"1\":{\"384\":1}}],[\"可以回过头看看\",{\"1\":{\"382\":1}}],[\"可以显示当前内存的详细信息\",{\"1\":{\"375\":1}}],[\"可以有多个\",{\"1\":{\"1196\":1}}],[\"可以有效防止恶意代码的执行\",{\"1\":{\"341\":1}}],[\"可以有局部规律\",{\"1\":{\"18\":1}}],[\"可以理解的代码就叫做字节码\",{\"1\":{\"324\":1}}],[\"可以理解为线程数是可以无限扩展的\",{\"1\":{\"892\":1,\"938\":1}}],[\"可以理解为只是threadlocalmap的封装\",{\"1\":{\"883\":1}}],[\"可以理解为类的扩展\",{\"1\":{\"518\":1}}],[\"可以理解为类的复用\",{\"1\":{\"518\":1}}],[\"可以理解为类的隔离\",{\"1\":{\"518\":1}}],[\"可以理解为\",{\"1\":{\"69\":2}}],[\"可以防止脑裂吗\",{\"1\":{\"318\":1}}],[\"可以适当增加位数组大小或者调整我们的哈希函数来降低概率\",{\"1\":{\"307\":1}}],[\"可以自行修改\",{\"1\":{\"302\":1}}],[\"可以用接口实现多继承\",{\"1\":{\"517\":2}}],[\"可以用\",{\"1\":{\"299\":1}}],[\"可以用于临时监控\",{\"1\":{\"298\":1}}],[\"可以用来判断\",{\"1\":{\"1387\":1}}],[\"可以用来控制同时访问特定资源的线程数量\",{\"1\":{\"747\":1,\"905\":1}}],[\"可以用来做消息队列\",{\"1\":{\"182\":1}}],[\"可以用来存储任何类型的数据比如字符串\",{\"1\":{\"176\":1,\"195\":1,\"254\":1}}],[\"可以利用多核\",{\"1\":{\"808\":1}}],[\"可以利用\",{\"1\":{\"293\":1,\"632\":1}}],[\"可以打包不同的命令\",{\"1\":{\"287\":1}}],[\"可以避免在退出循环的时候因内存顺序冲而引起\",{\"1\":{\"844\":1,\"993\":1}}],[\"可以避免类的重复加载\",{\"1\":{\"358\":1}}],[\"可以避免缓冲区溢出\",{\"1\":{\"256\":1}}],[\"可以避免内存碎片率过大的问题\",{\"1\":{\"220\":1}}],[\"可以做消息队列么\",{\"0\":{\"251\":1}}],[\"可以做到\",{\"1\":{\"377\":1}}],[\"可以做到读读可以并行\",{\"1\":{\"140\":1}}],[\"可以做到全局唯一性\",{\"1\":{\"37\":1}}],[\"可以选择使用\",{\"1\":{\"236\":1}}],[\"可以提供多样化的路由方式来传递消息到消息队列\",{\"1\":{\"1231\":1}}],[\"可以提供两种资源维度的限流\",{\"1\":{\"76\":1}}],[\"可以提升系统的性能表现\",{\"1\":{\"588\":1}}],[\"可以提高并发度和灵活性\",{\"1\":{\"784\":1}}],[\"可以提高效率\",{\"1\":{\"464\":1}}],[\"可以提高\",{\"1\":{\"234\":1}}],[\"可以调用回调函数重新获得锁\",{\"1\":{\"1388\":1}}],[\"可以调用\",{\"1\":{\"233\":1}}],[\"可以考虑使用\",{\"1\":{\"1172\":1}}],[\"可以考虑通过循环来添加任务\",{\"1\":{\"909\":1}}],[\"可以考虑\",{\"1\":{\"231\":1}}],[\"可以加载\",{\"1\":{\"230\":1}}],[\"可以将多个交换器绑定在一起\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"可以将多个异步任务串联起来\",{\"1\":{\"774\":1,\"901\":1}}],[\"可以将线程数设置为\",{\"1\":{\"895\":1,\"922\":1}}],[\"可以将threadlocal类形象的比喻成存放数据的盒子\",{\"1\":{\"881\":1}}],[\"可以将这个耗时任务交给一个子线程去异步执行\",{\"1\":{\"773\":1,\"899\":1}}],[\"可以将\",{\"1\":{\"762\":1}}],[\"可以将快照发送开发者处进行\",{\"1\":{\"377\":1}}],[\"可以将快照复制到其他服务器从而创建具有相同数据的服务器副本\",{\"1\":{\"226\":1}}],[\"可以将不用的数据放到磁盘上\",{\"1\":{\"245\":1}}],[\"可以将内存中的数据保持在磁盘中\",{\"1\":{\"245\":1}}],[\"可以将热点数据可以提前放入\",{\"1\":{\"145\":1}}],[\"可以组成一个\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"可以组成一棵完整的链路树\",{\"1\":{\"23\":1}}],[\"可以非常方便的实现如共同关注\",{\"1\":{\"188\":1}}],[\"可以通过x\",{\"1\":{\"1258\":1}}],[\"可以通过制定缓存一致协议\",{\"1\":{\"981\":1}}],[\"可以通过构造器来显示的指定\",{\"1\":{\"865\":1}}],[\"可以通过构造函数中的\",{\"1\":{\"717\":1}}],[\"可以通过调试定位并发现错误的原因\",{\"1\":{\"524\":1}}],[\"可以通过反射添加其它类型元素\",{\"1\":{\"522\":1}}],[\"可以通过发送邮件或者重启程序等来解决\",{\"1\":{\"455\":1}}],[\"可以通过设置不同参数来测试不同的情况\",{\"1\":{\"454\":1}}],[\"可以通过参数\",{\"1\":{\"386\":1,\"495\":1}}],[\"可以通过getparent\",{\"1\":{\"353\":1}}],[\"可以通过\",{\"1\":{\"229\":1,\"280\":1,\"368\":1,\"386\":1,\"458\":1,\"498\":1,\"742\":1,\"862\":1,\"904\":1,\"1346\":1}}],[\"可以通过创建快照来获得存储在内存里面的数据在\",{\"1\":{\"226\":1}}],[\"可以通过reids\",{\"1\":{\"169\":1}}],[\"可以通过配置项\",{\"1\":{\"35\":1,\"235\":1}}],[\"可以短暂地允许数据库和缓存数据不一致的场景\",{\"1\":{\"145\":1}}],[\"可以先删除\",{\"1\":{\"145\":1}}],[\"可以阻止脏读\",{\"1\":{\"132\":1}}],[\"可以阻止\",{\"1\":{\"132\":2}}],[\"可以替换in子查询\",{\"1\":{\"120\":1}}],[\"可以完全替换子查询\",{\"1\":{\"120\":1}}],[\"可以使得树更矮\",{\"1\":{\"101\":1}}],[\"可以使用callerrunspolicy\",{\"1\":{\"891\":1}}],[\"可以使用静态方法\",{\"1\":{\"777\":1}}],[\"可以使用一个特殊的静态空对象来代替\",{\"1\":{\"693\":1}}],[\"可以使用类名直接调用\",{\"1\":{\"521\":2}}],[\"可以使用以下参数声明这些实现\",{\"1\":{\"482\":1}}],[\"可以使用日期\",{\"1\":{\"261\":1}}],[\"可以使用多种内存分配器来分配内存\",{\"1\":{\"218\":1}}],[\"可以使用数据库集群解决\",{\"1\":{\"33\":1,\"34\":1}}],[\"可以使用\",{\"1\":{\"19\":1,\"294\":1,\"319\":1,\"368\":1,\"403\":1,\"631\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":1,\"909\":1,\"1036\":1}}],[\"可以说分布式的产生是消息队列的基础\",{\"1\":{\"1269\":1}}],[\"可以说非常环保\",{\"1\":{\"1158\":1}}],[\"可以说是非常厉害了\",{\"1\":{\"249\":1}}],[\"可以说\",{\"1\":{\"87\":1,\"324\":1}}],[\"可以结合这张图理解\",{\"1\":{\"710\":1,\"711\":1}}],[\"可以结合\",{\"1\":{\"76\":1}}],[\"可以基于\",{\"1\":{\"51\":1}}],[\"可以在消费时自定义消息的预估处理时长\",{\"1\":{\"1293\":1}}],[\"可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换\",{\"1\":{\"1055\":1}}],[\"可以在指定的时间后自行返回而不是像\",{\"1\":{\"820\":1}}],[\"可以在远程\",{\"1\":{\"373\":1}}],[\"可以在不重启虚拟机的情况下\",{\"1\":{\"367\":1}}],[\"可以在索引遍历过程中\",{\"1\":{\"117\":1}}],[\"可以在\",{\"1\":{\"49\":1}}],[\"可以在网关层在返回给用户之前做转换处理\",{\"1\":{\"2\":1}}],[\"可以看做一个\",{\"1\":{\"1255\":1}}],[\"可以看做一个线程安全的\",{\"1\":{\"791\":1}}],[\"可以看做\",{\"1\":{\"1255\":1}}],[\"可以看这篇文章\",{\"1\":{\"962\":1,\"1178\":1}}],[\"可以看我下面的介绍\",{\"1\":{\"895\":1,\"922\":1}}],[\"可以看我写的这篇文章\",{\"1\":{\"247\":1,\"249\":1,\"250\":1,\"583\":1}}],[\"可以看到这里面的内容非常多的冗余\",{\"1\":{\"1159\":1}}],[\"可以看到在密集\",{\"1\":{\"1062\":1}}],[\"可以看到产生的哈希码分布很均匀\",{\"1\":{\"1032\":1}}],[\"可以看到我们上面的代码指定了\",{\"1\":{\"940\":1}}],[\"可以看到当线程数量也就是请求数量达到我们定义的\",{\"1\":{\"757\":1}}],[\"可以看到其内部调用了\",{\"1\":{\"630\":1}}],[\"可以看到因为队列的大小为\",{\"1\":{\"531\":1}}],[\"可以看到只有生产者往队列中投放元素之后消费者才能消费\",{\"1\":{\"531\":1}}],[\"可以看到\",{\"1\":{\"370\":1,\"536\":1,\"537\":1,\"708\":1,\"713\":1,\"748\":1,\"774\":1,\"901\":1,\"1014\":1}}],[\"可以看作是一个独立的\",{\"1\":{\"1196\":1}}],[\"可以看作是线程安全的\",{\"1\":{\"897\":1}}],[\"可以看作是当前线程所执行的字节码的行号指示器\",{\"1\":{\"492\":1}}],[\"可以看作是轻量级的反射调用机制\",{\"1\":{\"344\":1}}],[\"可以看作是\",{\"1\":{\"266\":1,\"271\":1,\"288\":1,\"1353\":1}}],[\"可以看出我们通过\",{\"1\":{\"1327\":1}}],[\"可以看出当\",{\"1\":{\"1209\":1}}],[\"可以看出这一块两者也没太大区别\",{\"1\":{\"1158\":1}}],[\"可以看出服务发现这一块\",{\"1\":{\"1157\":1}}],[\"可以看出来\",{\"1\":{\"233\":1}}],[\"可以看出\",{\"1\":{\"40\":1,\"49\":1,\"54\":1,\"231\":1,\"585\":1,\"679\":1,\"704\":1,\"705\":1,\"1008\":1}}],[\"可以看看我的分析\",{\"1\":{\"941\":1}}],[\"可以看看耗子叔的这篇文章\",{\"1\":{\"685\":1}}],[\"可以看看其是否提供了\",{\"1\":{\"293\":1,\"298\":1}}],[\"可以看看\",{\"1\":{\"35\":1,\"40\":1}}],[\"可以对这两个操作进行重排序\",{\"1\":{\"975\":1}}],[\"可以对项目中类似的场景进行优化\",{\"1\":{\"788\":1}}],[\"可以对快照进行备份\",{\"1\":{\"226\":1}}],[\"可以对\",{\"1\":{\"38\":1}}],[\"可以支撑\",{\"1\":{\"38\":1}}],[\"可以表示范围\",{\"1\":{\"19\":1}}],[\"可以去看我介绍\",{\"1\":{\"1281\":1}}],[\"可以去\",{\"1\":{\"19\":1}}],[\"可以让程序等future1\",{\"1\":{\"782\":1}}],[\"可以让虚拟机在\",{\"1\":{\"368\":1}}],[\"可以让定位问题以及开发更透明化\",{\"1\":{\"30\":1}}],[\"可以让买家得到实惠\",{\"1\":{\"19\":1}}],[\"可以让后端工程师通过本地\",{\"1\":{\"8\":1}}],[\"可以和\",{\"1\":{\"4\":1}}],[\"它能干的事情还很多呢\",{\"1\":{\"1390\":1}}],[\"它能被重新被发送到另一个交换器中\",{\"1\":{\"1256\":1}}],[\"它怎么能这么能干\",{\"1\":{\"1390\":1}}],[\"它必定是唯一的\",{\"1\":{\"1389\":1}}],[\"它有点类似于订阅的方式\",{\"1\":{\"1385\":1}}],[\"它有一个\",{\"1\":{\"661\":1}}],[\"它首先也会将投票选给自己\",{\"1\":{\"1380\":1}}],[\"它首先不会自己去尝试加载这个类\",{\"1\":{\"357\":1,\"359\":1}}],[\"它为每个其他的\",{\"1\":{\"1379\":1}}],[\"它又不能批准\",{\"1\":{\"1375\":1}}],[\"它意指\",{\"1\":{\"1369\":1}}],[\"它保证了\",{\"1\":{\"1368\":2}}],[\"它保存着线程的引用\",{\"1\":{\"742\":1,\"904\":1}}],[\"它提供实时消息订阅机制\",{\"1\":{\"1281\":1}}],[\"它其实也是一个\",{\"1\":{\"1281\":1}}],[\"它仅仅是\",{\"1\":{\"1381\":1}}],[\"它仅仅是为每个消费者组维护一个\",{\"1\":{\"1280\":1}}],[\"它仅仅是一个辅助功能增强用户体验感而已\",{\"1\":{\"1271\":1}}],[\"它约定\",{\"1\":{\"1252\":1}}],[\"它依赖于交换器类型\",{\"1\":{\"1249\":1}}],[\"它同时实现了一个\",{\"1\":{\"1245\":1}}],[\"它同样可以组合两个\",{\"1\":{\"781\":1}}],[\"它同样是一个单线程收集器\",{\"1\":{\"404\":1}}],[\"它最初起源于金融系统\",{\"1\":{\"1237\":1}}],[\"它最原始的意义就是禁用\",{\"1\":{\"833\":1}}],[\"它使分布式通信耦合度更低\",{\"1\":{\"1226\":1}}],[\"它使用\",{\"1\":{\"1159\":1}}],[\"它使用的是本地内存\",{\"1\":{\"443\":1}}],[\"它使用的回收算法\",{\"1\":{\"406\":1}}],[\"它用于配置某个\",{\"1\":{\"1213\":1}}],[\"它主要用于处理无法被消费者正确处理的消息\",{\"1\":{\"1213\":1}}],[\"它主要有两大用途\",{\"1\":{\"404\":1}}],[\"它成功和我本地的\",{\"1\":{\"1199\":1}}],[\"它在无锁的情况下还能保证队列有界\",{\"1\":{\"1179\":1}}],[\"它本身并不是一个具体的协议\",{\"1\":{\"1154\":1}}],[\"它表示\",{\"1\":{\"1112\":1}}],[\"它可能收到其他节点声明自己是\",{\"1\":{\"1111\":1}}],[\"它可以用于大型软件系统各个模块之间的高效通信\",{\"1\":{\"1245\":1}}],[\"它可以帮助我们动态寻找服务\",{\"1\":{\"1131\":1}}],[\"它可以将异步代码编写得更像同步代码\",{\"1\":{\"1055\":1}}],[\"它可以将内存分为大小相同的两块\",{\"1\":{\"397\":1}}],[\"它可以接收\",{\"1\":{\"779\":1}}],[\"它可以是空方法\",{\"1\":{\"744\":1}}],[\"它可以扩容\",{\"1\":{\"579\":1}}],[\"它可以做到以下几点\",{\"1\":{\"530\":1}}],[\"它可以直接使用\",{\"1\":{\"499\":1}}],[\"它可以显示本地或者远程\",{\"1\":{\"366\":1}}],[\"它可以显著提高\",{\"1\":{\"6\":1}}],[\"它可以进一步压缩网址长度\",{\"1\":{\"24\":1}}],[\"它与\",{\"1\":{\"1252\":1}}],[\"它与其他服务器上的共识模块通信\",{\"1\":{\"1106\":1}}],[\"它与具体使用的垃圾回收器和相关参数有关\",{\"1\":{\"385\":1}}],[\"它大大降低了我们对系统的要求\",{\"1\":{\"1073\":1}}],[\"它更想表达的意义是前一个操作的结果对于后一个操作是可见的\",{\"1\":{\"974\":1}}],[\"它把\",{\"1\":{\"972\":1}}],[\"它把工作内存中一个变量的值传送到主内存中\",{\"1\":{\"972\":1}}],[\"它把一个从执行引擎接收到的值赋给工作内存的变量\",{\"1\":{\"972\":1}}],[\"它把一个变量的值从主内存传输到线程的工作内存中\",{\"1\":{\"972\":1}}],[\"它涵盖了缓存\",{\"1\":{\"972\":1}}],[\"它只有在队列层面才是保证有序\",{\"1\":{\"1299\":1}}],[\"它只有两个构造方法\",{\"1\":{\"602\":1}}],[\"它只是异步的通知线程池进行关闭处理\",{\"1\":{\"924\":1}}],[\"它设置线程名称\",{\"1\":{\"894\":1,\"920\":1}}],[\"它既不会抛弃任务\",{\"1\":{\"891\":1}}],[\"它等于下面这段代码\",{\"1\":{\"882\":1}}],[\"它之所有能有很好的性能\",{\"1\":{\"794\":1}}],[\"它要做的事情是\",{\"1\":{\"755\":1,\"910\":1}}],[\"它要判断传入的\",{\"1\":{\"658\":1}}],[\"它默认构造\",{\"1\":{\"748\":1,\"749\":1,\"752\":1,\"906\":1,\"908\":1}}],[\"它继承了\",{\"1\":{\"715\":1}}],[\"它继承自\",{\"1\":{\"702\":1}}],[\"它做了这样两件事\",{\"1\":{\"712\":1}}],[\"它做的变更才会被其他事务看到\",{\"1\":{\"132\":1}}],[\"它做的变更就能被别的事务看到\",{\"1\":{\"132\":1}}],[\"它还支持公平和非公平两种方式的锁访问机制\",{\"1\":{\"541\":1}}],[\"它还提供了一个\",{\"1\":{\"534\":1}}],[\"它还定义了自己所需要实现的方法\",{\"1\":{\"533\":1}}],[\"它还可以查询\",{\"1\":{\"368\":1}}],[\"它实现了\",{\"1\":{\"533\":1}}],[\"它通过\",{\"1\":{\"533\":1,\"608\":1}}],[\"它需要自己提供一套内存模型以屏蔽系统差异\",{\"1\":{\"971\":1}}],[\"它需要相当可观的处理器时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"它需要利用反射机制\",{\"1\":{\"523\":1}}],[\"它需要读取并解析\",{\"1\":{\"341\":1,\"496\":1}}],[\"它节省了一次指针定位的时间开销\",{\"1\":{\"510\":1}}],[\"它尽可能优化字符串串联操作\",{\"1\":{\"485\":1}}],[\"它采用\",{\"1\":{\"485\":1}}],[\"它限制在抛出\",{\"1\":{\"484\":1}}],[\"它也完成了\",{\"1\":{\"1375\":1}}],[\"它也会中断事务\",{\"1\":{\"1371\":1}}],[\"它也会使处理器写入\",{\"1\":{\"969\":1}}],[\"它也可以实现线程间的技术等待\",{\"1\":{\"755\":1,\"910\":1}}],[\"它也将元素放入桶位中\",{\"1\":{\"686\":1}}],[\"它也支持公平和非公平的锁访问机制\",{\"1\":{\"671\":1}}],[\"它也是存放在栈中的\",{\"1\":{\"441\":1}}],[\"它也是内存区域中唯一一个不会出现\",{\"1\":{\"435\":1}}],[\"它也要把字符串\",{\"1\":{\"86\":1}}],[\"它指向了我们程序中下一句需要执行的指令\",{\"1\":{\"435\":1}}],[\"它俩底层是使用\",{\"1\":{\"422\":1}}],[\"它和方法区都同属于\",{\"1\":{\"421\":1}}],[\"它就可以当选准\",{\"1\":{\"1356\":1}}],[\"它就开始接受客户端的请求\",{\"1\":{\"1112\":1}}],[\"它就是\",{\"1\":{\"799\":1}}],[\"它就会将自己的投票信息更改为\",{\"1\":{\"1380\":1}}],[\"它就会去处理消息然后给用户增加积分\",{\"1\":{\"1370\":1}}],[\"它就会在该任期内担任\",{\"1\":{\"1109\":1}}],[\"它就会成为链表中的最后一个元素\",{\"1\":{\"717\":1}}],[\"它就会抛出一个\",{\"1\":{\"631\":1}}],[\"它就像一个搬运工一样\",{\"1\":{\"419\":1}}],[\"它就能满足千万级的数据存储\",{\"1\":{\"110\":1}}],[\"它直接和操作系统进行交互\",{\"1\":{\"417\":1}}],[\"它具有很好的灵活性\",{\"1\":{\"544\":1,\"862\":1}}],[\"它具有以下特点\",{\"1\":{\"97\":1}}],[\"它具备以下特点\",{\"1\":{\"407\":1}}],[\"它第一次实现了让垃圾收集线程与用户线程\",{\"1\":{\"406\":1}}],[\"它非常符合在注重用户体验的应用上使用\",{\"1\":{\"406\":1}}],[\"它看上去几乎和\",{\"1\":{\"403\":1}}],[\"它简单而高效\",{\"1\":{\"401\":1}}],[\"它里面的\",{\"1\":{\"387\":1}}],[\"它将是运行期间定位虚拟机性能问题的首选工具\",{\"1\":{\"366\":1}}],[\"它将在查询开始时被读取\",{\"1\":{\"120\":1}}],[\"它不能再次被使用\",{\"1\":{\"751\":1,\"907\":1}}],[\"它不同于对象本身\",{\"1\":{\"493\":1}}],[\"它不是用自己的类加载器\",{\"1\":{\"359\":1}}],[\"它不面向任何特定的处理器\",{\"1\":{\"324\":1}}],[\"它对数据库中数据的改变是持久的\",{\"1\":{\"281\":1}}],[\"它会直接以\",{\"1\":{\"1380\":1}}],[\"它会首先\",{\"1\":{\"1380\":1}}],[\"它会向所有参与者发送中断请求\",{\"1\":{\"1371\":1}}],[\"它会把消息路由到那些\",{\"1\":{\"1252\":1}}],[\"它会把所有发送到该\",{\"1\":{\"1252\":1}}],[\"它会在一定时间内进行事务的提交\",{\"1\":{\"1371\":1}}],[\"它会在其他服务器超时之前赢得选举\",{\"1\":{\"1111\":1}}],[\"它会在元素查询完成之后\",{\"1\":{\"710\":1}}],[\"它会创建一个新的线程来处理该任务\",{\"1\":{\"888\":1}}],[\"它会将\",{\"1\":{\"1112\":1}}],[\"它会将节点从\",{\"1\":{\"712\":1}}],[\"它会将调用\",{\"1\":{\"602\":1}}],[\"它会将感兴趣的事件及类型\",{\"1\":{\"265\":1}}],[\"它会建立一个\",{\"1\":{\"364\":1,\"369\":1}}],[\"它会先将请求转发给父类加载器\",{\"1\":{\"357\":1}}],[\"它会清空事务队列中保存的所有命令\",{\"1\":{\"280\":1}}],[\"它会等待\",{\"1\":{\"251\":1}}],[\"它比较类似于\",{\"1\":{\"249\":1}}],[\"它由\",{\"1\":{\"231\":1}}],[\"它一般会在\",{\"1\":{\"231\":1}}],[\"它一般由子进程通过重写产生\",{\"1\":{\"231\":1}}],[\"它们会给持久化带来什么样的影响呢\",{\"1\":{\"1312\":1}}],[\"它们一般消费相同的消息\",{\"1\":{\"1280\":1}}],[\"它们一般生产相同的消息\",{\"1\":{\"1280\":1}}],[\"它们定义在生产者和消费者之间快速\",{\"1\":{\"1182\":1}}],[\"它们可以使用自家造的\",{\"1\":{\"1155\":1}}],[\"它们不仅要能访问自家公司的服务器\",{\"1\":{\"1155\":1}}],[\"它们不一定非得使用\",{\"1\":{\"1154\":1}}],[\"它们不会发送任何请求\",{\"1\":{\"1108\":1}}],[\"它们稍后可能会从稳定存储上的状态中恢复并重新加入集群\",{\"1\":{\"1106\":1}}],[\"它们就被称为已提交\",{\"1\":{\"1106\":1}}],[\"它们就会把票投给将军\",{\"1\":{\"1105\":1}}],[\"它们必须对变故做出反应并在几秒钟内自动适应\",{\"1\":{\"1104\":1}}],[\"它们通过额外的服务器进行横向扩展\",{\"1\":{\"1104\":1}}],[\"它们也只需实现\",{\"1\":{\"1007\":1}}],[\"它们基本决定了线程池对于任务的处理策略\",{\"1\":{\"896\":1,\"923\":1}}],[\"它们中的一个或者全部都在等待某个资源被释放\",{\"1\":{\"823\":1}}],[\"它们都作为客户端\",{\"1\":{\"1155\":1}}],[\"它们都只是定义了不同消息格式的\",{\"1\":{\"1154\":1}}],[\"它们都有特定的内存模型\",{\"1\":{\"968\":1}}],[\"它们都是\",{\"1\":{\"883\":1}}],[\"它们都是线程安全的\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"它们都可以对元素进行快速的查找\",{\"1\":{\"800\":1}}],[\"它们之间并没有先后依赖顺序\",{\"1\":{\"781\":1}}],[\"它们之间存在着先后顺序\",{\"1\":{\"781\":1}}],[\"它们的存在只是为了保证消息存储的安全性\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"它们的最大区别在于迭代元素的顺序\",{\"1\":{\"719\":1}}],[\"它们的作用是加速查询和排序操作\",{\"1\":{\"111\":1}}],[\"它们在实现类对象之间比较大小\",{\"1\":{\"661\":1}}],[\"它们在文件开头会有特定的文件标示\",{\"1\":{\"426\":1}}],[\"它们分别为\",{\"1\":{\"1384\":1}}],[\"它们分别如下\",{\"1\":{\"621\":1}}],[\"它们分别是\",{\"1\":{\"161\":1,\"231\":1,\"282\":1}}],[\"它们是多对多的关系\",{\"1\":{\"1281\":1}}],[\"它们是实现了\",{\"1\":{\"1161\":1}}],[\"它们是实现生产者和消费者有序工作的关键所在\",{\"1\":{\"534\":1}}],[\"它们是带有生产者\",{\"1\":{\"529\":1}}],[\"它们是由应用程序类加载器或者自定义类加载器来加载的\",{\"1\":{\"359\":1}}],[\"它们适合用于设置最多\",{\"1\":{\"201\":1}}],[\"它基于\",{\"1\":{\"1181\":4}}],[\"它基于哈希表的\",{\"1\":{\"616\":1}}],[\"它基于倒排索引实现\",{\"1\":{\"103\":1,\"104\":1}}],[\"它基于r树实现\",{\"1\":{\"103\":1}}],[\"它支持多种客户端如\",{\"1\":{\"1245\":1}}],[\"它支持通过代理查询缓存功能\",{\"1\":{\"299\":1}}],[\"它支持\",{\"1\":{\"293\":1,\"298\":1}}],[\"它支持等值查询\",{\"1\":{\"103\":1}}],[\"它支持双号段\",{\"1\":{\"41\":1}}],[\"它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来\",{\"1\":{\"1344\":1}}],[\"它的意思是\",{\"1\":{\"1304\":1}}],[\"它的源码也是非常值得学习和阅读的\",{\"1\":{\"1168\":1}}],[\"它的key是threadlocal<\",{\"1\":{\"1029\":1}}],[\"它的插入操作\",{\"1\":{\"799\":1}}],[\"它的作用是将前一个任务的返回结果作为下一个任务的输入参数\",{\"1\":{\"781\":1}}],[\"它的作用是将数据按照主键值排序\",{\"1\":{\"111\":1}}],[\"它的内部维护了一个\",{\"1\":{\"742\":1}}],[\"它的步骤就\",{\"1\":{\"605\":1}}],[\"它的冲突再达到一定大小时会转化成红黑树\",{\"1\":{\"579\":1}}],[\"它的冲突会转化为链表\",{\"1\":{\"579\":1}}],[\"它的值决定着当前的初始化状态\",{\"1\":{\"576\":1}}],[\"它的使用频率也是很高\",{\"1\":{\"567\":1}}],[\"它的容量能动态增长\",{\"1\":{\"549\":1}}],[\"它的容量是以\",{\"1\":{\"442\":1}}],[\"它的特点是什么\",{\"0\":{\"541\":1}}],[\"它的生命周期和线程相同\",{\"1\":{\"493\":1}}],[\"它的生命周期随着线程的创建而创建\",{\"1\":{\"492\":1}}],[\"它的分析过程引用关系不能发生变化\",{\"1\":{\"445\":1}}],[\"它的运作过程相比于前面几种垃圾收集器来说更加复杂一些\",{\"1\":{\"406\":1}}],[\"它的运行速度接近于\",{\"1\":{\"6\":1}}],[\"它的\",{\"1\":{\"401\":1,\"634\":1,\"1298\":1}}],[\"它的搜索范围中没有找到所需的类\",{\"1\":{\"357\":1}}],[\"它的整个生命周期可以简单概括为\",{\"1\":{\"338\":1}}],[\"它的唯一作用是确定这个文件是否为一个能被虚拟机接收的\",{\"1\":{\"326\":1}}],[\"它的功能和事务非常类似\",{\"1\":{\"283\":1}}],[\"它的性能比扫一遍索引树低\",{\"1\":{\"112\":1}}],[\"它的查找\",{\"1\":{\"98\":1}}],[\"它从\",{\"1\":{\"83\":1}}],[\"它是不是会回滚事务\",{\"1\":{\"1370\":1}}],[\"它是不会先自己去尝试加载的\",{\"1\":{\"433\":1}}],[\"它是如何保证高可用的\",{\"1\":{\"1298\":1}}],[\"它是消息的容器\",{\"1\":{\"1250\":1}}],[\"它是用来判断当前过期槽位staleslot之前是否还有过期元素\",{\"1\":{\"1035\":1}}],[\"它是斐波那契数\",{\"1\":{\"1032\":1}}],[\"它是在\",{\"1\":{\"702\":1}}],[\"它是一个\",{\"1\":{\"1379\":1}}],[\"它是一个采用\",{\"1\":{\"1276\":1}}],[\"它是一个先进后出\",{\"1\":{\"441\":1}}],[\"它是一个关于方法和运行期数据的数据集\",{\"1\":{\"441\":1}}],[\"它是一个虚构出来的计算机\",{\"1\":{\"417\":1}}],[\"它是一种权限控制\",{\"1\":{\"1384\":1}}],[\"它是一种特别为\",{\"1\":{\"1359\":1}}],[\"它是一种二进制安全的数据类型\",{\"1\":{\"254\":1}}],[\"它是一种编程术语\",{\"1\":{\"70\":1}}],[\"它是许多运行在\",{\"1\":{\"402\":1}}],[\"它是最基础的收集算法\",{\"1\":{\"396\":1}}],[\"它是\",{\"1\":{\"54\":1,\"438\":1,\"597\":1,\"1348\":1,\"1349\":1}}],[\"使的它变的非常重量级\",{\"1\":{\"1245\":1}}],[\"使代码更易于理解和维护\",{\"1\":{\"1055\":1}}],[\"使rehash后的entry数据距离正确的桶的位置更近一些\",{\"1\":{\"1037\":1}}],[\"使\",{\"1\":{\"844\":1,\"908\":1,\"993\":1}}],[\"使每个线程都可顺利完成\",{\"1\":{\"824\":1}}],[\"使之拥有顺序插入和访问有序的特性\",{\"1\":{\"715\":1}}],[\"使其进入安全状态\",{\"1\":{\"824\":1}}],[\"使其和前驱\",{\"1\":{\"711\":1}}],[\"使其和后继节点\",{\"1\":{\"710\":1}}],[\"使其和后继节点断开联系\",{\"1\":{\"710\":1}}],[\"使其更加适用于基于时间的调度和缓存过期删除等场景\",{\"1\":{\"598\":1}}],[\"使其达到最合理的状态\",{\"1\":{\"412\":1}}],[\"使程序异常终止\",{\"1\":{\"392\":1}}],[\"使得在部分节点出现问题的情况下队\",{\"1\":{\"1246\":1}}],[\"使得在部分节点出现问题的情况下队列仍然可用\",{\"1\":{\"1237\":1}}],[\"使得数据更易移入\",{\"1\":{\"1238\":1}}],[\"使得用户可以监控和管理消息\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"使得系统内的所有节点数据一致\",{\"1\":{\"1084\":1}}],[\"使得每次访问一个元素时\",{\"1\":{\"718\":1}}],[\"使得每个方法执行的时候都要去获得锁\",{\"1\":{\"583\":1,\"793\":1}}],[\"使得原本散列在不同\",{\"1\":{\"702\":1}}],[\"使得具备如下特性\",{\"1\":{\"702\":1}}],[\"使得插入的节点永远都是放在链表的末尾\",{\"1\":{\"685\":1}}],[\"使得上面的结构可以保持键值对的插入顺序\",{\"1\":{\"645\":1}}],[\"使得使用\",{\"1\":{\"598\":1}}],[\"使得他可以直接应用在生产环境中\",{\"1\":{\"377\":1}}],[\"使得集合中的元素能够按\",{\"1\":{\"192\":1,\"195\":1}}],[\"使得新的\",{\"1\":{\"162\":1,\"233\":1}}],[\"使得可以通过简单的\",{\"1\":{\"6\":1}}],[\"使用信道的方式来传输数据\",{\"1\":{\"1260\":1}}],[\"使用一些机制来保证可靠性\",{\"1\":{\"1246\":1}}],[\"使用一些机制来保证消息的可靠性\",{\"1\":{\"1237\":1}}],[\"使用一个\",{\"1\":{\"1004\":1}}],[\"使用一个新的方法withinitial\",{\"1\":{\"882\":1}}],[\"使用一个索引来选择行\",{\"1\":{\"120\":1}}],[\"使用消息队列会带来哪些问题\",{\"0\":{\"1224\":1}}],[\"使用消息队列还可以降低系统耦合性\",{\"1\":{\"1222\":1}}],[\"使用消息队列进行异步处理之后\",{\"1\":{\"1220\":1}}],[\"使用消息队列能为我们的系统带来下面三点好处\",{\"1\":{\"1219\":1}}],[\"使用消息队列可以降低系统耦合性\",{\"1\":{\"1218\":1}}],[\"使用主题\",{\"1\":{\"1194\":1,\"1229\":1}}],[\"使用主键\",{\"1\":{\"108\":1}}],[\"使用队列\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"使用不当会造成\",{\"1\":{\"1183\":1}}],[\"使用不当容易导致\",{\"1\":{\"873\":1}}],[\"使用率最低和最稳定的选项生产环境推荐使用\",{\"1\":{\"1183\":1}}],[\"使用纯裸\",{\"0\":{\"1152\":1}}],[\"使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性\",{\"1\":{\"1139\":1}}],[\"使用心跳机制来触发\",{\"1\":{\"1111\":1}}],[\"使用平台线程\",{\"1\":{\"1062\":1}}],[\"使用无界队列作为线程池的工作队列会对线程池带来的影响与\",{\"1\":{\"955\":1}}],[\"使用无界队列时\",{\"1\":{\"951\":1}}],[\"使用无界队列\",{\"1\":{\"951\":1}}],[\"使用阿里巴巴推荐的创建线程池的方式\",{\"1\":{\"940\":1}}],[\"使用频率还是非常高的\",{\"1\":{\"934\":1}}],[\"使用有界队列\",{\"1\":{\"917\":1}}],[\"使用它可以很方便地为我们编写多线程程序\",{\"1\":{\"909\":1}}],[\"使用调用者的线程来执行任务\",{\"1\":{\"891\":1}}],[\"使用线程池处理读取任务\",{\"1\":{\"909\":1}}],[\"使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销\",{\"1\":{\"889\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"887\":1,\"933\":1}}],[\"使用完\",{\"1\":{\"884\":1}}],[\"使用完毕后\",{\"1\":{\"751\":1,\"907\":1}}],[\"使用跳表实现\",{\"1\":{\"800\":1}}],[\"使用跳表来实现一个\",{\"1\":{\"800\":1}}],[\"使用跳表的数据结构进行快速查找\",{\"1\":{\"791\":1}}],[\"使用链表实现\",{\"1\":{\"791\":1}}],[\"使用建议\",{\"0\":{\"783\":1}}],[\"使用默认的\",{\"1\":{\"779\":1}}],[\"使用自定义线程池\",{\"0\":{\"784\":1},\"1\":{\"778\":2,\"779\":2}}],[\"使用atomicinteger之后\",{\"1\":{\"764\":1}}],[\"使用原子的方式更新数组里的某个元素\",{\"1\":{\"762\":1,\"766\":1}}],[\"使用原子的方式更新基本类型\",{\"1\":{\"762\":1,\"763\":1}}],[\"使用者继承\",{\"1\":{\"744\":1}}],[\"使用volatile修饰保证线程可见性\",{\"1\":{\"742\":1,\"904\":1}}],[\"使用示例如下\",{\"1\":{\"779\":2}}],[\"使用示例\",{\"0\":{\"703\":1}}],[\"使用成员对象来计算\",{\"1\":{\"678\":1}}],[\"使用键\",{\"1\":{\"678\":1}}],[\"使用键值对\",{\"1\":{\"640\":1}}],[\"使用单向链表实现的可选有界阻塞队列\",{\"1\":{\"671\":1}}],[\"使用单线程的多路\",{\"1\":{\"245\":1}}],[\"使用数组实现的有界阻塞队列\",{\"1\":{\"671\":1}}],[\"使用数组存储对象存在一些不足之处\",{\"1\":{\"647\":1}}],[\"使用集合的修改方法\",{\"1\":{\"634\":1}}],[\"使用集合转数组的方法\",{\"1\":{\"633\":1}}],[\"使用工具类\",{\"1\":{\"634\":1}}],[\"使用普通的\",{\"1\":{\"631\":1}}],[\"使用就很简单了\",{\"1\":{\"599\":1}}],[\"使用权\",{\"1\":{\"576\":1}}],[\"使用创建的\",{\"1\":{\"571\":1}}],[\"使用cas\",{\"1\":{\"571\":1}}],[\"使用ensurecapacity方法后\",{\"1\":{\"564\":2}}],[\"使用ensurecapacity方法前\",{\"1\":{\"564\":2}}],[\"使用初始容量10构造一个空列表\",{\"1\":{\"555\":1}}],[\"使用场景\",{\"0\":{\"1045\":1},\"1\":{\"523\":1}}],[\"使用泛型的时候加上类型参数\",{\"1\":{\"522\":1}}],[\"使用直接指针访问方式最大的好处就是速度快\",{\"1\":{\"510\":1}}],[\"使用句柄来访问的最大好处是\",{\"1\":{\"510\":1}}],[\"使用句柄\",{\"1\":{\"508\":1,\"509\":1}}],[\"使用该分配方式的\",{\"1\":{\"503\":2}}],[\"使用该方案的前提条件是\",{\"1\":{\"298\":1}}],[\"使用过程中触发\",{\"1\":{\"480\":1}}],[\"使用多线程可能带来什么问题\",{\"0\":{\"817\":1}}],[\"使用多线程和\",{\"1\":{\"405\":1}}],[\"使用多个\",{\"1\":{\"407\":1}}],[\"使用软引用的情况较多\",{\"1\":{\"392\":1}}],[\"使用软引用能带来的好处\",{\"1\":{\"380\":1}}],[\"使用于监视虚拟机各种运行状态信息的命令行工具\",{\"1\":{\"366\":1}}],[\"使用永久代来实现方法区的时候\",{\"1\":{\"342\":1}}],[\"使用连接池\",{\"1\":{\"319\":1}}],[\"使用规范\",{\"0\":{\"319\":1}}],[\"使用布隆过滤器中的哈希函数对元素值进行计算\",{\"1\":{\"307\":1}}],[\"使用monitor\",{\"1\":{\"298\":1}}],[\"使用这些原生批量操作命令可能会存在一些小问题需要解决\",{\"1\":{\"286\":1}}],[\"使用这些命令就会使用主线程之外的其他线程来\",{\"1\":{\"266\":1}}],[\"使用批量操作可以减少网络传输次数\",{\"1\":{\"285\":1}}],[\"使用批量操作减少网络传输\",{\"0\":{\"285\":1},\"1\":{\"319\":1}}],[\"使用起来更加灵活\",{\"1\":{\"649\":1}}],[\"使用起来相对要麻烦一些\",{\"1\":{\"251\":1}}],[\"使用起来非常简单\",{\"1\":{\"49\":1}}],[\"使用了随机的选举超时时间来避免上述情况\",{\"1\":{\"1111\":1}}],[\"使用了线程池的话可让多个不相关联的任务同时执行\",{\"1\":{\"933\":1}}],[\"使用了模板方法模式\",{\"1\":{\"744\":1}}],[\"使用了\",{\"1\":{\"231\":1,\"1341\":1,\"1382\":1}}],[\"使用了双号段缓存\",{\"1\":{\"34\":1}}],[\"使用缓存的时候\",{\"1\":{\"224\":1}}],[\"使用情况\",{\"1\":{\"169\":1}}],[\"使用表级锁\",{\"1\":{\"130\":1}}],[\"使用行级锁\",{\"1\":{\"130\":1}}],[\"使用or\",{\"1\":{\"118\":1}}],[\"使用聚簇索引就可以保证不管这个主键b+树的\",{\"1\":{\"108\":1}}],[\"使用的服务器最好是奇数台\",{\"1\":{\"1341\":1}}],[\"使用的缓存一致性协议通常也会有所不同\",{\"1\":{\"968\":1}}],[\"使用的delayedworkqueue\",{\"1\":{\"961\":1}}],[\"使用的都是容量为\",{\"1\":{\"955\":1}}],[\"使用的都是非聚簇索引\",{\"1\":{\"105\":1}}],[\"使用的任务队列\",{\"1\":{\"917\":1}}],[\"使用的无界的延迟阻塞队列delayedworkqueue\",{\"1\":{\"889\":1,\"917\":1,\"937\":1}}],[\"使用的是容量为\",{\"1\":{\"949\":1}}],[\"使用的是linkedblockingqueue\",{\"1\":{\"897\":1}}],[\"使用的是同步队列\",{\"1\":{\"889\":1,\"917\":1,\"937\":1,\"959\":1}}],[\"使用的是无界的\",{\"1\":{\"889\":1,\"917\":1,\"937\":1}}],[\"使用的是单机\",{\"1\":{\"29\":1}}],[\"使用的\",{\"1\":{\"579\":1}}],[\"使用的分段锁\",{\"1\":{\"579\":1}}],[\"使用的内存\",{\"1\":{\"289\":1,\"294\":1}}],[\"使用的时候需要注意\",{\"1\":{\"287\":1}}],[\"使用的公司也比较少\",{\"1\":{\"244\":1}}],[\"使用的部分内存换出硬盘\",{\"1\":{\"168\":1}}],[\"使用组合索引时遵循最左前缀集合\",{\"1\":{\"104\":1}}],[\"使用另外一套日志系统\",{\"1\":{\"89\":1}}],[\"使用本地锁就没办法实现资源的互斥访问了\",{\"1\":{\"60\":1,\"63\":1}}],[\"使用顺序节点之后\",{\"1\":{\"54\":1}}],[\"使用随机性或伪随机性生成\",{\"1\":{\"37\":1}}],[\"使用方便\",{\"1\":{\"30\":1}}],[\"使用到了动态二维码\",{\"1\":{\"17\":1}}],[\"使用到的优惠券码\",{\"1\":{\"16\":1}}],[\"使用熟悉的编程语言开发\",{\"1\":{\"8\":1}}],[\"使用\",{\"0\":{\"258\":1,\"260\":1,\"261\":1,\"262\":1,\"1048\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1200\":1,\"1321\":1},\"1\":{\"5\":1,\"8\":3,\"19\":1,\"54\":1,\"68\":1,\"156\":1,\"210\":2,\"218\":1,\"219\":1,\"236\":1,\"251\":1,\"256\":1,\"262\":1,\"293\":2,\"294\":1,\"298\":2,\"299\":1,\"319\":1,\"325\":1,\"338\":1,\"344\":1,\"359\":1,\"367\":1,\"400\":1,\"403\":4,\"412\":4,\"427\":1,\"571\":3,\"577\":1,\"593\":7,\"618\":1,\"629\":1,\"631\":1,\"634\":4,\"682\":1,\"688\":1,\"740\":1,\"742\":1,\"763\":1,\"766\":1,\"786\":5,\"835\":3,\"866\":1,\"903\":1,\"904\":1,\"906\":1,\"928\":1,\"944\":2,\"972\":1,\"1006\":1,\"1019\":4,\"1030\":2,\"1057\":3,\"1062\":1,\"1204\":1,\"1285\":1,\"1292\":1,\"1293\":1,\"1314\":1,\"1321\":1}}],[\"脚本代替\",{\"1\":{\"319\":1}}],[\"脚本的原子操作也无法保证了\",{\"1\":{\"288\":1}}],[\"脚本的方式来实现限流\",{\"1\":{\"249\":1}}],[\"脚本依然存在下面这些缺陷\",{\"1\":{\"288\":1}}],[\"脚本中进行处理\",{\"1\":{\"288\":1}}],[\"脚本中支持一些简单的逻辑处理比如使用命令读取值并在\",{\"1\":{\"288\":1}}],[\"脚本中的命令全部执行\",{\"1\":{\"283\":1}}],[\"脚本同样支持批量操作多条命令\",{\"1\":{\"288\":1}}],[\"脚本来批量执行\",{\"1\":{\"283\":1}}],[\"脚本来批量执行多条\",{\"1\":{\"283\":1}}],[\"脚本运行时出错并中途结束\",{\"1\":{\"283\":1,\"288\":1}}],[\"脚本执行过程中不会有其他脚本或\",{\"1\":{\"283\":1,\"288\":1}}],[\"脚本可以视作一条命令执行\",{\"1\":{\"283\":1,\"288\":1}}],[\"脚本实现的续期\",{\"1\":{\"49\":1}}],[\"脚本时\",{\"1\":{\"47\":1}}],[\"脚本是为了保证解锁操作的原子性\",{\"1\":{\"47\":1}}],[\"脚本通过\",{\"1\":{\"47\":1}}],[\"脚本\",{\"0\":{\"288\":1},\"1\":{\"6\":1,\"7\":1,\"49\":1,\"242\":1,\"245\":1,\"283\":1,\"287\":3,\"288\":1,\"319\":1}}],[\"把白天丢的数据给他补回来\",{\"1\":{\"1264\":1}}],[\"把整个系统拆分成不同的服务\",{\"1\":{\"1126\":1}}],[\"把当前节点的前驱节点的后继指针指向当前节点的后继节点\",{\"1\":{\"1013\":1}}],[\"把当前node的状态设置为cancelled\",{\"1\":{\"1013\":1}}],[\"把取消节点从队列中剔除\",{\"1\":{\"1012\":1}}],[\"把工作内存中的一个变量的值传给执行引擎\",{\"1\":{\"972\":1}}],[\"把本地内存中修改过的共享变量副本的值同步到主内存中去\",{\"1\":{\"972\":1}}],[\"把创建完成的实现\",{\"1\":{\"934\":1}}],[\"把每一个\",{\"1\":{\"909\":1}}],[\"把每个bucket都移动到新的buckets中\",{\"1\":{\"624\":1}}],[\"把两个任务的结果合并\",{\"1\":{\"781\":1}}],[\"把entry对象再添加到数组中\",{\"1\":{\"625\":1}}],[\"把数据从线程的工作内存同步回主内存中\",{\"1\":{\"972\":1}}],[\"把数据全部存在内存之中\",{\"1\":{\"245\":1}}],[\"把数组转换成集合时\",{\"1\":{\"634\":1}}],[\"把数组中所有的元素的值设为null\",{\"1\":{\"553\":1}}],[\"把⽅法锁定\",{\"1\":{\"521\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"506\":1}}],[\"把能被该集合引用到的对象加入到集合中\",{\"1\":{\"445\":1}}],[\"把内存化整为零\",{\"1\":{\"407\":1}}],[\"把内存管理优化交给虚拟机去完成也是一个不错的选择\",{\"1\":{\"403\":1}}],[\"把新生代的对象提前转移到老年代中去\",{\"1\":{\"384\":1}}],[\"把所有可能存在的请求的值都存放在布隆过滤器中\",{\"1\":{\"307\":1}}],[\"把一部分硬盘空间虚拟成内存使用\",{\"1\":{\"168\":1}}],[\"把这个虚引用加入到与之关联的引用队列中\",{\"1\":{\"392\":1}}],[\"把这个当作缓存来用\",{\"1\":{\"136\":1}}],[\"把这个值加上\",{\"1\":{\"89\":1}}],[\"把值放在数组里\",{\"1\":{\"96\":1}}],[\"把字符串\",{\"1\":{\"86\":1}}],[\"把\",{\"1\":{\"6\":1,\"89\":1,\"425\":1,\"972\":1,\"1315\":1}}],[\"并缓存到本地\",{\"1\":{\"1390\":1}}],[\"并监控其父节点\",{\"1\":{\"1390\":1}}],[\"并向协调者反馈回滚状况\",{\"1\":{\"1371\":1}}],[\"并向服务端提交消费结果\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"并与其进行数据同步\",{\"1\":{\"1361\":1}}],[\"并以一系列简单易用的接口提供给用户使用\",{\"1\":{\"1344\":1}}],[\"并以链表或红黑树的形式存储\",{\"1\":{\"686\":1}}],[\"并处理\",{\"1\":{\"1293\":1}}],[\"并按照消费者本地的业务逻辑进行处理的过程\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"并转发到\",{\"1\":{\"1284\":1}}],[\"并订阅到队列上\",{\"1\":{\"1254\":1}}],[\"并采取适当的措施\",{\"1\":{\"1213\":1}}],[\"并提供用于调用事件处理实现的事件循环\",{\"1\":{\"1182\":1}}],[\"并获得了\",{\"1\":{\"1178\":1}}],[\"并累加它们的权重\",{\"1\":{\"1142\":1}}],[\"并封装了一些公共的逻辑\",{\"1\":{\"1140\":1}}],[\"并避免任何单个资源的过载\",{\"1\":{\"1139\":1}}],[\"并桥接注册中心\",{\"1\":{\"1130\":1}}],[\"并立刻开始下一次选举\",{\"1\":{\"1109\":1}}],[\"并就该提议作出运算\",{\"1\":{\"1098\":1}}],[\"并修复\",{\"1\":{\"1078\":1}}],[\"并认为该中间状态的存在不会影响系统的整体可用性\",{\"1\":{\"1077\":1}}],[\"并记录下来\",{\"1\":{\"1015\":1}}],[\"并记录下直接与\",{\"1\":{\"406\":1}}],[\"并清除\",{\"1\":{\"1015\":1}}],[\"并更新state\",{\"1\":{\"1014\":1}}],[\"并通过\",{\"1\":{\"999\":1}}],[\"并停止处理排队的任务并返回正在等待执行的\",{\"1\":{\"945\":1}}],[\"并尝试判断线程是否全部执行完毕\",{\"1\":{\"941\":1}}],[\"并实现了\",{\"1\":{\"934\":1}}],[\"并成功更新\",{\"1\":{\"841\":1,\"990\":1}}],[\"并从其帐户余额中扣除\",{\"1\":{\"840\":2,\"989\":2}}],[\"并加载下一个将要占用\",{\"1\":{\"821\":1}}],[\"并加上预期的值\",{\"1\":{\"763\":1,\"766\":1}}],[\"并统一处理所有任务的异常\",{\"1\":{\"786\":1}}],[\"并正确地处理异常\",{\"1\":{\"786\":1}}],[\"并非\",{\"1\":{\"773\":1,\"899\":1}}],[\"并非绝对\",{\"1\":{\"375\":1}}],[\"并自减\",{\"1\":{\"763\":1}}],[\"并自增\",{\"1\":{\"763\":1}}],[\"并自旋判断\",{\"1\":{\"749\":1}}],[\"并设置新的值\",{\"1\":{\"763\":1}}],[\"并设置为独占锁\",{\"1\":{\"604\":1}}],[\"并调用其模板方法\",{\"1\":{\"744\":1}}],[\"并让该位置的元素自减\",{\"1\":{\"766\":1}}],[\"并让该位置的元素自增\",{\"1\":{\"766\":1}}],[\"并让\",{\"1\":{\"742\":1}}],[\"并让首节点指针指向下一节点\",{\"1\":{\"712\":1}}],[\"并指明前驱和后继节点\",{\"1\":{\"729\":1}}],[\"并指定节点前驱为链表尾节点\",{\"1\":{\"729\":1}}],[\"并重写一下\",{\"1\":{\"897\":1}}],[\"并重写指定的方法\",{\"1\":{\"744\":1}}],[\"并重写\",{\"1\":{\"718\":1,\"897\":1}}],[\"并重新编译\",{\"1\":{\"6\":1}}],[\"并会从\",{\"1\":{\"713\":1}}],[\"并增加存储前驱后继节点的引用\",{\"1\":{\"708\":1}}],[\"并在一定时间内\",{\"1\":{\"1084\":1}}],[\"并在\",{\"1\":{\"702\":1}}],[\"并在启动\",{\"1\":{\"359\":2}}],[\"并支持公平和非公平两种方式的锁访问机制\",{\"1\":{\"671\":1}}],[\"并支持高质量的代码编写\",{\"1\":{\"647\":1}}],[\"并进入有限期等待\",{\"1\":{\"604\":2}}],[\"并添加任务\",{\"1\":{\"599\":1}}],[\"并添加到\",{\"1\":{\"531\":1}}],[\"并返回一个新的结果\",{\"1\":{\"786\":1}}],[\"并返回该元素的值\",{\"1\":{\"731\":1}}],[\"并返回该数组\",{\"1\":{\"563\":1}}],[\"并返回新的数组\",{\"1\":{\"562\":1}}],[\"并复用父类的属性与功能\",{\"1\":{\"518\":1}}],[\"并对外提供服务\",{\"1\":{\"1358\":1}}],[\"并对其对象的属性私有化\",{\"1\":{\"518\":1}}],[\"并对文章进行了大量的完善补充\",{\"1\":{\"475\":1}}],[\"并有两个参数\",{\"1\":{\"443\":1}}],[\"并将投票信息广播出去\",{\"1\":{\"1380\":1}}],[\"并将消息发送到服务提供端\",{\"1\":{\"1166\":1}}],[\"并将输出返回给客户端\",{\"1\":{\"1106\":1}}],[\"并将当前线程的中断标识设置为\",{\"1\":{\"1015\":1}}],[\"并将当前节点\",{\"1\":{\"710\":1}}],[\"并将任务\",{\"1\":{\"941\":2}}],[\"并将前一个任务的返回结果作为下一个任务的参数\",{\"1\":{\"781\":1}}],[\"并将其设置为新值\",{\"1\":{\"766\":1}}],[\"并将其添加到\",{\"1\":{\"609\":2}}],[\"并将\",{\"1\":{\"686\":2,\"705\":1,\"1370\":1,\"1371\":1}}],[\"并将元素插入到该桶位中\",{\"1\":{\"686\":1}}],[\"并将底层aqs的state设置为0\",{\"1\":{\"604\":1}}],[\"并将原来数组的元素复制给新数组\",{\"1\":{\"588\":1}}],[\"并将这些内容转换成方法区中的运行时数据结构\",{\"1\":{\"426\":1}}],[\"并将对象年龄设为\",{\"1\":{\"386\":1}}],[\"并行或者等待所有线程执行完任务什么的都非常方便\",{\"1\":{\"909\":1}}],[\"并行运行多个\",{\"0\":{\"782\":1}}],[\"并行执行\",{\"1\":{\"772\":1}}],[\"并行垃圾收集器\",{\"1\":{\"482\":1}}],[\"并行收集器的线程数\",{\"1\":{\"449\":1}}],[\"并行与并发\",{\"1\":{\"407\":1}}],[\"并行\",{\"1\":{\"402\":1,\"814\":1}}],[\"并行和并发概念补充\",{\"1\":{\"402\":1}}],[\"并使用预取机制提前加载相邻内存的数据以利用局部性原理\",{\"1\":{\"1184\":1}}],[\"并使用\",{\"1\":{\"302\":1,\"484\":1,\"748\":1,\"906\":1}}],[\"并发量太大单机系统承受不住\",{\"1\":{\"1367\":1}}],[\"并发操作必备\",{\"1\":{\"941\":1}}],[\"并发处理\",{\"1\":{\"889\":1}}],[\"并发与并行的区别\",{\"0\":{\"814\":1}}],[\"并发队列专题\",{\"1\":{\"913\":1}}],[\"并发队列\",{\"1\":{\"799\":1}}],[\"并发控制采用的是可重入锁\",{\"1\":{\"799\":1,\"897\":1}}],[\"并发控制使用\",{\"1\":{\"688\":1,\"792\":1}}],[\"并发包基石\",{\"1\":{\"913\":1}}],[\"并发包\",{\"1\":{\"762\":1}}],[\"并发包中常用的两种队列实现\",{\"1\":{\"543\":1}}],[\"并发包中常用的两种阻塞队列实现\",{\"1\":{\"542\":1,\"672\":1}}],[\"并发之\",{\"1\":{\"758\":1,\"904\":1,\"913\":1}}],[\"并发度一下子就小了很多\",{\"1\":{\"1280\":1}}],[\"并发度更大\",{\"1\":{\"692\":1}}],[\"并发度\",{\"1\":{\"692\":1}}],[\"并发环境下\",{\"1\":{\"685\":1}}],[\"并发编程实战\",{\"1\":{\"1022\":1,\"1185\":1}}],[\"并发编程核心\",{\"1\":{\"996\":1}}],[\"并发编程之美\",{\"1\":{\"823\":1}}],[\"并发编程的目的就是为了能提高程序的执行效率提高程序运行速度\",{\"1\":{\"817\":1}}],[\"并发编程的艺术\",{\"1\":{\"769\":1,\"820\":1,\"887\":1,\"933\":1,\"950\":1,\"954\":1,\"958\":1,\"964\":1,\"974\":1,\"976\":1,\"982\":1}}],[\"并发编程的发展\",{\"1\":{\"651\":1}}],[\"并发编程大扫盲\",{\"1\":{\"545\":1}}],[\"并发容器\",{\"1\":{\"529\":1}}],[\"并发收集\",{\"1\":{\"406\":1}}],[\"并发清除\",{\"1\":{\"406\":1}}],[\"并发标记\",{\"1\":{\"406\":1,\"407\":1}}],[\"并发\",{\"1\":{\"402\":1,\"814\":1}}],[\"并发访问数据库时\",{\"1\":{\"281\":1}}],[\"并发事务会带来哪些问题\",{\"0\":{\"126\":1}}],[\"并根据套接字目前执行的任务来为套接字关联不同的事件处理器\",{\"1\":{\"265\":1}}],[\"并未用到\",{\"1\":{\"256\":1}}],[\"并经过了大量的修改完善以适合高性能操作\",{\"1\":{\"256\":1}}],[\"并集和差集的场景\",{\"1\":{\"190\":1,\"259\":1}}],[\"并集\",{\"1\":{\"157\":1,\"188\":1,\"190\":2,\"301\":1}}],[\"并没有收到它的\",{\"1\":{\"1380\":1}}],[\"并没有收到全部的参与者的响应\",{\"1\":{\"1371\":1}}],[\"并没有完全采用\",{\"1\":{\"1359\":1}}],[\"并没有文件的读写操作\",{\"1\":{\"1311\":1}}],[\"并没有详细定义\",{\"1\":{\"1067\":1}}],[\"并没有直接暴露给我们\",{\"1\":{\"861\":1}}],[\"并没有实现插入方法\",{\"1\":{\"712\":1}}],[\"并没有对\",{\"1\":{\"711\":1}}],[\"并没有列举所有关系\",{\"1\":{\"639\":1}}],[\"并没有发生实际的修改\",{\"1\":{\"589\":1}}],[\"并没有一个固定的阈值\",{\"1\":{\"385\":1}}],[\"并没有指明具体从哪里获取\",{\"1\":{\"340\":1}}],[\"并没有使用一致性哈希\",{\"1\":{\"286\":1}}],[\"并没有使用\",{\"1\":{\"176\":1}}],[\"并没有提供给用户使用\",{\"1\":{\"622\":1}}],[\"并没有提供\",{\"1\":{\"146\":1}}],[\"并没有去关注缓存的读写策略\",{\"1\":{\"144\":1}}],[\"并把\",{\"1\":{\"89\":1}}],[\"并不递归\",{\"1\":{\"1328\":1}}],[\"并不想让消费者立刻拿到消息\",{\"1\":{\"1257\":1}}],[\"并不受客户端\",{\"1\":{\"1230\":1}}],[\"并不需要知道该消息从何而来\",{\"1\":{\"1222\":1}}],[\"并不为\",{\"1\":{\"1030\":1}}],[\"并不响应中断\",{\"1\":{\"1015\":1}}],[\"并不知道被唤醒的原因\",{\"1\":{\"1015\":1}}],[\"并不区分公平锁和非公平锁\",{\"1\":{\"1014\":1}}],[\"并不区分是否为公平锁\",{\"1\":{\"1007\":1}}],[\"并不满足我们实际的需求\",{\"1\":{\"1002\":1}}],[\"并不意味着\",{\"1\":{\"974\":1}}],[\"并不真实存在\",{\"1\":{\"972\":1}}],[\"并不常见\",{\"1\":{\"968\":1}}],[\"并不代表线程池已经完成关闭操作\",{\"1\":{\"924\":1}}],[\"并不像arraylist那样会预留一定的空间\",{\"1\":{\"590\":1}}],[\"并不在\",{\"1\":{\"499\":1}}],[\"并不提倡在程序中调用\",{\"1\":{\"446\":1}}],[\"并不能完全保证这个操作中的所有写命令要么都执行要么都不执行\",{\"1\":{\"287\":1}}],[\"并不是真正的广播\",{\"1\":{\"1272\":1}}],[\"并不是在所有的情况下都生效\",{\"1\":{\"1249\":1}}],[\"并不是一个合格的消息队列\",{\"1\":{\"1191\":1}}],[\"并不是全部\",{\"1\":{\"1007\":1}}],[\"并不是人多就能把事情做好\",{\"1\":{\"895\":1,\"922\":1}}],[\"并不是存在\",{\"1\":{\"883\":1}}],[\"并不是直接实现\",{\"1\":{\"871\":1}}],[\"并不是说\",{\"1\":{\"658\":1}}],[\"并不是说真的有一个\",{\"1\":{\"356\":1}}],[\"并不是\",{\"1\":{\"205\":1}}],[\"并不是通过\",{\"1\":{\"51\":1}}],[\"并不会在某个线程中执行它\",{\"1\":{\"827\":1}}],[\"并不会直接转换成红黑树\",{\"1\":{\"683\":1}}],[\"并不会阻塞获取元素的线程\",{\"1\":{\"536\":1}}],[\"并不会一次性加载所有的类\",{\"1\":{\"352\":1}}],[\"并不会去看\",{\"1\":{\"117\":1}}],[\"并不会覆盖以前的日志\",{\"1\":{\"89\":1}}],[\"并不会不停地循环去尝试加锁\",{\"1\":{\"53\":1}}],[\"并和linkedhashmap的双向链表断开\",{\"1\":{\"712\":1}}],[\"并和\",{\"1\":{\"21\":1,\"712\":1}}],[\"并且自己的\",{\"1\":{\"1380\":1}}],[\"并且每台服务器之间都互相保持着通信\",{\"1\":{\"1354\":1}}],[\"并且每个消费者都能接收到完整的消息内容\",{\"1\":{\"1193\":1}}],[\"并且它是⽀持通过选举来动态切换主节点的\",{\"1\":{\"1314\":1}}],[\"并且重新消费一般是按照时间维度\",{\"1\":{\"1306\":1}}],[\"并且思考一下\",{\"1\":{\"1273\":1}}],[\"并且我们可以给特定\",{\"1\":{\"1202\":1}}],[\"并且同一\",{\"1\":{\"1196\":1}}],[\"并且集成了\",{\"1\":{\"1173\":1}}],[\"并且你在纠结选择哪一种\",{\"1\":{\"1172\":1}}],[\"并且支持众多开发语言\",{\"1\":{\"1170\":1}}],[\"并且存在单点故障的风险\",{\"1\":{\"1123\":1}}],[\"并且添加所缺少的上了\",{\"1\":{\"1112\":1}}],[\"并且向客户端返回执行结果\",{\"1\":{\"1112\":1}}],[\"并且开始进行一次选举以选出一个新的\",{\"1\":{\"1111\":1}}],[\"并且刷新自己的\",{\"1\":{\"1111\":1}}],[\"并且可以相互通信\",{\"1\":{\"1106\":1}}],[\"并且可以通过\",{\"1\":{\"944\":1}}],[\"并且可以通过下标进行访问\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"并且顺序也相同\",{\"1\":{\"1106\":1}}],[\"并且没有把选举票投给其他人\",{\"1\":{\"1105\":1}}],[\"并且没有父级\",{\"1\":{\"353\":1}}],[\"并且根据需求进行扩展和收缩\",{\"1\":{\"1104\":1}}],[\"并且根据特定的算法分配多余的内存\",{\"1\":{\"256\":1}}],[\"并且能够用自己的理解给别人讲出来\",{\"1\":{\"1065\":1}}],[\"并且能被\",{\"1\":{\"386\":1}}],[\"并且第一个操作的执行顺序排在第二个操作之前\",{\"1\":{\"974\":1}}],[\"并且线程的状态是存活的话\",{\"1\":{\"941\":1}}],[\"并且所有提交的任务完成后返回为\",{\"1\":{\"940\":1,\"946\":1}}],[\"并且容量为\",{\"1\":{\"940\":1}}],[\"并且使用的是基于原生\",{\"1\":{\"929\":1}}],[\"并且当前标志是否等于预期标志\",{\"1\":{\"843\":1,\"992\":1}}],[\"并且允许再次尝试\",{\"1\":{\"841\":1,\"990\":1}}],[\"并且链表是分层的\",{\"1\":{\"800\":1}}],[\"并且需要设置想要更新的类和属性\",{\"1\":{\"768\":1}}],[\"并且需要重写\",{\"1\":{\"597\":1}}],[\"并且发生了哈希冲突\",{\"1\":{\"686\":1}}],[\"并且判断了一下返回值以确保是否有重复元素\",{\"1\":{\"680\":1}}],[\"并且都不是线程安全的\",{\"1\":{\"665\":1}}],[\"并且都能够调用它的任意一个方法\",{\"1\":{\"523\":1}}],[\"并且提供了丰富的\",{\"1\":{\"649\":1}}],[\"并且其内部是通过\",{\"1\":{\"643\":1}}],[\"并且时间复杂度为\",{\"1\":{\"629\":1}}],[\"并且m元素个数大于阈值\",{\"1\":{\"621\":1}}],[\"并且java有jvm⾃动内存管理机制\",{\"1\":{\"517\":1}}],[\"并且有指针的概念\",{\"1\":{\"517\":1}}],[\"并且检查这个符号引用代表的类是否已被加载过\",{\"1\":{\"502\":1}}],[\"并且要掌握每一步在做什么\",{\"1\":{\"501\":1}}],[\"并且出现这种错误之后的表现形式还会有几种\",{\"1\":{\"495\":1}}],[\"并且对象的年龄还会加\",{\"1\":{\"495\":1}}],[\"并且对数据进行了修改\",{\"1\":{\"127\":1}}],[\"并且设置了\",{\"1\":{\"449\":1,\"452\":1}}],[\"并且将共享资源设置为锁定状态\",{\"1\":{\"742\":1,\"904\":1}}],[\"并且将其更新到\",{\"1\":{\"694\":1}}],[\"并且将\",{\"1\":{\"444\":1}}],[\"并且全都继承自\",{\"1\":{\"353\":1}}],[\"并且略微更改了上述的类加载器\",{\"1\":{\"353\":1}}],[\"并且这种阻塞很难被发现\",{\"1\":{\"344\":1}}],[\"并且这些开源实现对原有的\",{\"1\":{\"38\":1}}],[\"并且只要不与已有的属性名重复\",{\"1\":{\"333\":1}}],[\"并且被\",{\"1\":{\"280\":1}}],[\"并且还是线程安全的\",{\"1\":{\"1179\":1}}],[\"并且还支持一个超时参数\",{\"1\":{\"251\":1}}],[\"并且还能够使用类似\",{\"1\":{\"2\":1}}],[\"并且在每隔\",{\"1\":{\"1281\":1}}],[\"并且在下线报告的有效期限内集群中半数以上的节点将\",{\"1\":{\"1085\":1}}],[\"并且在准备赋值的时候检查到它仍然是\",{\"1\":{\"843\":1,\"992\":1}}],[\"并且在那段时间里有很多这样的请求\",{\"1\":{\"412\":1}}],[\"并且在\",{\"1\":{\"236\":1,\"715\":1}}],[\"并且在一些特定事件触发的时候\",{\"1\":{\"55\":1,\"1352\":1}}],[\"并且获取字符串长度复杂度为\",{\"1\":{\"176\":1}}],[\"并且数据\",{\"1\":{\"145\":1}}],[\"并且数据库自动将字符串转换为数字类型\",{\"1\":{\"118\":1}}],[\"并且也有一条id为1余额为0的基础数据\",{\"1\":{\"141\":1}}],[\"并且用两个隐藏字段trx\",{\"1\":{\"141\":1}}],[\"并且会遍历\",{\"1\":{\"624\":1}}],[\"并且会把redo\",{\"1\":{\"136\":1}}],[\"并且会带来高可用的问题\",{\"1\":{\"7\":1}}],[\"并且范围查询也有优化\",{\"1\":{\"101\":1}}],[\"并且不能插入\",{\"1\":{\"671\":1}}],[\"并且不能有明显的整体规律\",{\"1\":{\"18\":1}}],[\"并且不会被中途打断\",{\"1\":{\"279\":1}}],[\"并且不应该对整个系统的性能造成过大影响\",{\"1\":{\"61\":1}}],[\"并且不需要额外的存储空间保存这些信息\",{\"1\":{\"19\":1}}],[\"并且实现了毫秒级别的热更新响应\",{\"1\":{\"10\":1}}],[\"并且插件也是可扩展和热插拔的\",{\"1\":{\"9\":1}}],[\"并且非常接近本机性能\",{\"1\":{\"8\":1}}],[\"并且是以\",{\"1\":{\"145\":1}}],[\"并且是最快毕业的国产开源项目\",{\"1\":{\"8\":1}}],[\"并且是在\",{\"1\":{\"7\":1}}],[\"并且基于\",{\"1\":{\"5\":1,\"68\":1}}],[\"并且\",{\"1\":{\"4\":1,\"8\":1,\"10\":1,\"30\":1,\"33\":1,\"35\":1,\"40\":1,\"41\":1,\"42\":1,\"49\":1,\"54\":1,\"61\":1,\"188\":1,\"205\":1,\"242\":2,\"245\":1,\"251\":1,\"255\":1,\"272\":1,\"281\":1,\"283\":1,\"288\":1,\"293\":1,\"426\":1,\"496\":1,\"541\":1,\"588\":1,\"616\":1,\"656\":1,\"684\":1,\"712\":1,\"724\":1,\"742\":1,\"748\":1,\"773\":1,\"837\":1,\"897\":1,\"899\":1,\"904\":1,\"986\":1,\"995\":1,\"1002\":1,\"1098\":1,\"1165\":2,\"1202\":1,\"1240\":1,\"1281\":1,\"1335\":1,\"1348\":2,\"1349\":1,\"1356\":1}}],[\"就变了\",{\"1\":{\"1379\":1}}],[\"就允许一个能提案\",{\"1\":{\"1375\":1}}],[\"就这样无休无止的永远提案下去\",{\"1\":{\"1375\":1}}],[\"就这么简单\",{\"1\":{\"451\":1}}],[\"就必定要求我们需要在系统可用性\",{\"1\":{\"1368\":1}}],[\"就必须实现\",{\"1\":{\"610\":1}}],[\"就必须先使用\",{\"1\":{\"344\":1}}],[\"就必须让查询过程访问尽量少的数据块\",{\"1\":{\"98\":1}}],[\"就必须全部扫描一遍了\",{\"1\":{\"96\":1}}],[\"就两个字\",{\"1\":{\"1303\":1}}],[\"就相当于\",{\"1\":{\"1298\":1}}],[\"就提前返回消费成功结果\",{\"1\":{\"1292\":1}}],[\"就提供了现成的生成\",{\"1\":{\"37\":1}}],[\"就存放了很多\",{\"1\":{\"1281\":1}}],[\"就拿我们上面所讲的分布式系统来说\",{\"1\":{\"1275\":1}}],[\"就拿我们生活中非常常见的一例子来说\",{\"1\":{\"895\":1,\"922\":1}}],[\"就行了\",{\"1\":{\"1272\":1,\"1375\":1}}],[\"就好比由邮局\",{\"1\":{\"1247\":1}}],[\"就自带管理界面\",{\"1\":{\"1237\":1}}],[\"就自定义了类加载器\",{\"1\":{\"359\":1}}],[\"就去这些中间服务去获得\",{\"1\":{\"1157\":1}}],[\"就有些区别\",{\"1\":{\"1157\":1}}],[\"就有一篇文章详细介绍如何使用\",{\"1\":{\"194\":1,\"258\":1}}],[\"就开始退居幕后\",{\"1\":{\"1155\":1}}],[\"就开始执行rehash\",{\"1\":{\"1038\":1}}],[\"就像上图中\",{\"1\":{\"1280\":1}}],[\"就像我们理解队列一样\",{\"1\":{\"1278\":1}}],[\"就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的\",{\"1\":{\"1271\":1}}],[\"就像调用本地方法一样简单的框架\",{\"1\":{\"1167\":1}}],[\"就像下面这样\",{\"1\":{\"1154\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"125\":1}}],[\"就衍生了非常多的协议\",{\"1\":{\"1152\":1}}],[\"就对了\",{\"1\":{\"1151\":1}}],[\"就对应着一个栈帧在\",{\"1\":{\"812\":1}}],[\"就认为谁的活跃数越少\",{\"1\":{\"1142\":1}}],[\"就叫做选举超时\",{\"1\":{\"1111\":1}}],[\"就一系列值达成共识\",{\"1\":{\"1097\":1}}],[\"就要开启清理数据的逻辑\",{\"1\":{\"1036\":1}}],[\"就再中断一次\",{\"1\":{\"1015\":1}}],[\"就把当前节点unpark\",{\"1\":{\"1014\":1}}],[\"就找到队列最开始的非cancelled的节点\",{\"1\":{\"1014\":1}}],[\"就尝试获取锁\",{\"1\":{\"1012\":1}}],[\"就尝试执行我们构造方法中输入的任务\",{\"1\":{\"756\":1,\"911\":1}}],[\"就等资源释放了\",{\"1\":{\"1005\":1}}],[\"就创建新的线程来执行任务\",{\"1\":{\"950\":1}}],[\"就使用到了线程池\",{\"1\":{\"929\":1}}],[\"就新建一个线程来执行任务\",{\"1\":{\"893\":1,\"941\":1}}],[\"就马上获取失败\",{\"1\":{\"868\":1}}],[\"就属于是不可中断锁\",{\"1\":{\"863\":1}}],[\"就属于是可中断锁\",{\"1\":{\"863\":1}}],[\"就属于非聚簇索引\",{\"1\":{\"105\":1}}],[\"就获取到节点\",{\"1\":{\"1087\":1}}],[\"就获取到了锁\",{\"1\":{\"742\":1}}],[\"就获取不到了\",{\"1\":{\"824\":1}}],[\"就代表了有拦截的线程的数量\",{\"1\":{\"756\":1,\"911\":1}}],[\"就代表一定会被回收吗\",{\"1\":{\"391\":1}}],[\"就将数据缓存下来\",{\"1\":{\"1078\":1}}],[\"就将计数器减\",{\"1\":{\"753\":1}}],[\"就将还存活的对象复制到另一块去\",{\"1\":{\"397\":1}}],[\"就唤醒等待队列中的一个或多个线程\",{\"1\":{\"748\":1,\"752\":1}}],[\"就调用一次\",{\"1\":{\"742\":1}}],[\"就调用此方法来查看\",{\"1\":{\"558\":1}}],[\"就返回\",{\"1\":{\"712\":1}}],[\"就算转为红黑树变为树节点\",{\"1\":{\"708\":1}}],[\"就执行\",{\"1\":{\"683\":1}}],[\"就表明了他具有快速随机访问功能\",{\"1\":{\"658\":1}}],[\"就连\",{\"1\":{\"656\":1,\"724\":1}}],[\"就选择实现collection\",{\"1\":{\"646\":1}}],[\"就扩充为原来的2倍\",{\"1\":{\"624\":1}}],[\"就只能等到拿到锁以后才能进行其他的逻辑处理\",{\"1\":{\"863\":1}}],[\"就只好随你碰撞去吧\",{\"1\":{\"624\":1}}],[\"就只需要回表\",{\"1\":{\"117\":1}}],[\"就判断\",{\"1\":{\"622\":1}}],[\"就判断该元素与要存入的元素的\",{\"1\":{\"618\":1,\"682\":1}}],[\"就直接插入\",{\"1\":{\"622\":2}}],[\"就直接返回给执行器\",{\"1\":{\"89\":1}}],[\"就拥有了阻塞队列那些常见的操作行为\",{\"1\":{\"533\":1}}],[\"就需要依赖其他组件比如腾讯的\",{\"1\":{\"1170\":1}}],[\"就需要补充一次中断\",{\"1\":{\"1015\":1}}],[\"就需要看一下\",{\"1\":{\"1011\":1}}],[\"就需要加入到等待队列中\",{\"1\":{\"1008\":1}}],[\"就需要一定的阻塞等待唤醒机制来保证锁分配\",{\"1\":{\"1004\":1}}],[\"就需要将当前\",{\"1\":{\"619\":1}}],[\"就需要反射技术来实现了\",{\"1\":{\"523\":1}}],[\"就需要通过对齐填充来补全\",{\"1\":{\"507\":1}}],[\"就需要编写\",{\"1\":{\"6\":1}}],[\"就抛出\",{\"1\":{\"493\":2}}],[\"就已经开始了\",{\"1\":{\"480\":1,\"496\":1}}],[\"就不一样了\",{\"1\":{\"1179\":1}}],[\"就不需要每次都真的把\",{\"1\":{\"1159\":1}}],[\"就不用往后执行了\",{\"1\":{\"1008\":1}}],[\"就不用再重新获取了\",{\"1\":{\"50\":1}}],[\"就不太建议使用\",{\"1\":{\"873\":1}}],[\"就不能被打断\",{\"1\":{\"841\":1,\"990\":1}}],[\"就不能被执行\",{\"1\":{\"781\":1}}],[\"就不会被其他线程干扰\",{\"1\":{\"762\":1}}],[\"就不会影响其他\",{\"1\":{\"691\":1}}],[\"就不会产生并发\",{\"1\":{\"691\":1}}],[\"就不会存在锁竞争\",{\"1\":{\"688\":1,\"792\":1}}],[\"就不会让加入操作成功\",{\"1\":{\"680\":1}}],[\"就不会有副本\",{\"1\":{\"585\":1}}],[\"就不会说把所有都扯个遍了\",{\"1\":{\"460\":1}}],[\"就又缩水了\",{\"1\":{\"451\":1}}],[\"就知道如何正确将消息路由到队列了\",{\"1\":{\"1249\":1}}],[\"就知道\",{\"1\":{\"417\":1}}],[\"就说明常量\",{\"1\":{\"393\":1}}],[\"就称这块内存代表一个引用\",{\"1\":{\"392\":1}}],[\"就重写\",{\"1\":{\"354\":1,\"359\":1}}],[\"就出现了很多的一致性协议和算法\",{\"1\":{\"1369\":1}}],[\"就出现了\",{\"1\":{\"351\":1}}],[\"就没有用武之地了\",{\"1\":{\"1280\":1}}],[\"就没有问题了么\",{\"1\":{\"145\":1}}],[\"就没办法从前往后找了\",{\"1\":{\"1014\":1}}],[\"就没办法满足你的需求了\",{\"1\":{\"287\":1}}],[\"就非常适合\",{\"1\":{\"255\":2}}],[\"就单机\",{\"1\":{\"246\":1}}],[\"就宕机会导致对应的修改丢失\",{\"1\":{\"160\":1,\"232\":1}}],[\"就很有可能产生数据不一致性的问题\",{\"1\":{\"145\":1}}],[\"就从尾部节点开始找\",{\"1\":{\"1014\":1}}],[\"就从链表头开始遍历\",{\"1\":{\"730\":1}}],[\"就从\",{\"1\":{\"145\":1}}],[\"就准备开始执行了\",{\"1\":{\"86\":1,\"88\":1}}],[\"就匹配到了第一个路由\",{\"1\":{\"70\":1}}],[\"就能正常服务\",{\"1\":{\"1362\":1}}],[\"就能转发到指定的服务上进行处理\",{\"1\":{\"70\":1}}],[\"就能映射到具体的服务\",{\"1\":{\"69\":1}}],[\"就能确定是哪个业务\",{\"1\":{\"30\":1}}],[\"就诞生了\",{\"1\":{\"60\":1,\"1083\":1}}],[\"就可能会导致同样一套代码换了一个操作系统就无法执行了\",{\"1\":{\"971\":1}}],[\"就可能包括空字符\",{\"1\":{\"256\":1}}],[\"就可能出现以下情况\",{\"1\":{\"60\":1}}],[\"就可以调用\",{\"1\":{\"1308\":1}}],[\"就可以实现更多的自定义操作\",{\"1\":{\"1212\":1}}],[\"就可以直接从高速缓存中读取\",{\"1\":{\"1184\":1}}],[\"就可以通过\",{\"1\":{\"1157\":1}}],[\"就可以做到收发数据了\",{\"1\":{\"1151\":1}}],[\"就可以收到新的请求\",{\"1\":{\"1115\":1}}],[\"就可以成为\",{\"1\":{\"1111\":1}}],[\"就可以知道没有响应的线程到底在后台做些什么事情\",{\"1\":{\"370\":1}}],[\"就可以被称为内存碎片\",{\"1\":{\"217\":1}}],[\"就可以看作是\",{\"1\":{\"163\":1,\"291\":1,\"296\":2}}],[\"就可以找到其对应的值即\",{\"1\":{\"96\":1}}],[\"就可以了\",{\"1\":{\"56\":1}}],[\"就加锁成功了\",{\"1\":{\"53\":1}}],[\"就完全够了\",{\"1\":{\"51\":1}}],[\"就锁的过期时间设置为\",{\"1\":{\"49\":1}}],[\"就会发送提案的内容和提案编号\",{\"1\":{\"1374\":1}}],[\"就会发生此错误\",{\"1\":{\"495\":1}}],[\"就会发生\",{\"1\":{\"480\":1}}],[\"就会自动将数据同步到其他的节点上去了\",{\"1\":{\"1263\":1}}],[\"就会变为活跃节点\",{\"1\":{\"1088\":1}}],[\"就会向集群广播一条\",{\"1\":{\"1085\":1}}],[\"就会多次+1\",{\"1\":{\"1018\":1}}],[\"就会执行真正的扩容逻辑\",{\"1\":{\"1036\":1}}],[\"就会执行\",{\"1\":{\"1015\":1}}],[\"就会把当前\",{\"1\":{\"1015\":1}}],[\"就会调用\",{\"1\":{\"1010\":1}}],[\"就会抛出\",{\"1\":{\"944\":1}}],[\"就会处于空闲状态\",{\"1\":{\"895\":1,\"922\":1}}],[\"就会出现\",{\"1\":{\"1014\":1,\"1304\":1}}],[\"就会出现生产问题\",{\"1\":{\"873\":1}}],[\"就会出现锁提前过期的问题\",{\"1\":{\"48\":1}}],[\"就会造成消息丢失\",{\"1\":{\"1206\":1}}],[\"就会造成死锁\",{\"1\":{\"860\":1}}],[\"就会造成缓冲区溢出\",{\"1\":{\"256\":1}}],[\"就会转入下一层链表继续找\",{\"1\":{\"800\":1}}],[\"就会一直阻塞\",{\"1\":{\"752\":1}}],[\"就会返回\",{\"1\":{\"693\":1}}],[\"就会返回错误信息\",{\"1\":{\"88\":1}}],[\"就会释放所有等待的线程\",{\"1\":{\"752\":1}}],[\"就会释放\",{\"1\":{\"604\":1}}],[\"就会通知队列非满\",{\"1\":{\"535\":1}}],[\"就会引发此错误\",{\"1\":{\"495\":1}}],[\"就会导致栈中被压入太多栈帧而占用太多空间\",{\"1\":{\"493\":1}}],[\"就会动态申请内存空间不过会小于\",{\"1\":{\"451\":1}}],[\"就会增大堆直到\",{\"1\":{\"449\":1,\"451\":1}}],[\"就会产生死锁\",{\"1\":{\"869\":1}}],[\"就会产生\",{\"1\":{\"444\":1}}],[\"就会触发探测式清理操作\",{\"1\":{\"1037\":1}}],[\"就会触发通知队列非空\",{\"1\":{\"535\":1}}],[\"就会触发\",{\"1\":{\"444\":1}}],[\"就会将自己的\",{\"1\":{\"1199\":1}}],[\"就会将工作线程添加到工作线程集合中\",{\"1\":{\"941\":1}}],[\"就会将链表首元素移除\",{\"1\":{\"718\":1}}],[\"就会将其放入等待队列中\",{\"1\":{\"601\":1}}],[\"就会将存活对象移动到\",{\"1\":{\"444\":1}}],[\"就会将该命令记录在慢查询日志\",{\"1\":{\"302\":1}}],[\"就会将该命令写入到\",{\"1\":{\"161\":1,\"229\":1}}],[\"就会对应产生一个栈帧\",{\"1\":{\"441\":1}}],[\"就会报\",{\"1\":{\"439\":1}}],[\"就会先委派\",{\"1\":{\"433\":1}}],[\"就会在回收对象的内存之前\",{\"1\":{\"392\":1}}],[\"就会回收这些对象的内存\",{\"1\":{\"392\":1}}],[\"就会进入\",{\"1\":{\"1356\":1}}],[\"就会进入第二步\",{\"1\":{\"86\":1}}],[\"就会进行\",{\"1\":{\"388\":1}}],[\"就会被回收\",{\"1\":{\"1030\":1}}],[\"就会被加入到一个等待队列\",{\"1\":{\"742\":1}}],[\"就会被阻塞存到\",{\"1\":{\"604\":1}}],[\"就会被系统清理出常量池了\",{\"1\":{\"393\":1}}],[\"就会被晋升到老年代中\",{\"1\":{\"386\":1,\"495\":1}}],[\"就会被记录\",{\"1\":{\"302\":1}}],[\"就会直接宕机\",{\"1\":{\"297\":1}}],[\"就会直接报异常\",{\"1\":{\"245\":1}}],[\"就会拒绝启动并提供相应的错误信息\",{\"1\":{\"234\":1}}],[\"就会阻塞主线程\",{\"1\":{\"158\":1}}],[\"就会防止出现上述的问题\",{\"1\":{\"89\":1}}],[\"就会去拿新的任务执行\",{\"1\":{\"941\":1}}],[\"就会去调用引擎的接口\",{\"1\":{\"88\":1}}],[\"就会去异步加载下一个号段\",{\"1\":{\"42\":1}}],[\"就会收到\",{\"1\":{\"86\":1}}],[\"就比如我们进行消息写入的节点越多就更能保证消息的可靠性\",{\"1\":{\"1314\":1}}],[\"就比如我们刚刚画的那张图\",{\"1\":{\"1272\":1}}],[\"就比如\",{\"1\":{\"1280\":1}}],[\"就比如现在业界使用比较多的\",{\"1\":{\"1271\":1}}],[\"就比如下面我要说的负载均衡这块的源码中就有大量\",{\"1\":{\"1129\":1}}],[\"就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明\",{\"1\":{\"1097\":1}}],[\"就比如说堆主要用于存放对象实例\",{\"1\":{\"973\":1}}],[\"就比如说线程之间的共享变量必须存储在主内存中\",{\"1\":{\"972\":1}}],[\"就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题\",{\"1\":{\"971\":1}}],[\"就比如说调用获取商品详情的时候\",{\"1\":{\"772\":1}}],[\"就比如说\",{\"1\":{\"286\":1,\"287\":1,\"353\":1}}],[\"就比如说程序需要申请\",{\"1\":{\"218\":1}}],[\"就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉\",{\"1\":{\"47\":1}}],[\"就比如限流可以直接用国外朋友写的\",{\"1\":{\"4\":1}}],[\"就基本没有再维护了\",{\"1\":{\"40\":1}}],[\"就是没有选举权和被选举权的\",{\"1\":{\"1378\":1}}],[\"就是安全可靠的消息通道\",{\"1\":{\"1369\":1}}],[\"就是天然支持幂等的\",{\"1\":{\"1303\":1}}],[\"就是大量积压的时候\",{\"1\":{\"1264\":1}}],[\"就是批量重导\",{\"1\":{\"1264\":1}}],[\"就是在后台新增一个策略\",{\"1\":{\"1263\":1}}],[\"就是多一些\",{\"1\":{\"1262\":1}}],[\"就是多执行几次\",{\"1\":{\"1099\":1}}],[\"就是说让集群中多个节点来服务某个\",{\"1\":{\"1263\":1}}],[\"就是说\",{\"1\":{\"1260\":1,\"1263\":1}}],[\"就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题\",{\"1\":{\"423\":1}}],[\"就是投递消息的一方\",{\"1\":{\"1254\":1}}],[\"就是仅仅提供较少的核心功能\",{\"1\":{\"1240\":1}}],[\"就是把你调用方法\",{\"1\":{\"1166\":1}}],[\"就是这么干的\",{\"1\":{\"1158\":1}}],[\"就是这样来实现反熵的\",{\"1\":{\"1087\":1}}],[\"就是那个时代用于统一\",{\"1\":{\"1155\":1}}],[\"就是拉取对方的所有副本数据\",{\"1\":{\"1087\":1}}],[\"就是将自己的所有副本数据\",{\"1\":{\"1087\":1}}],[\"就是将原来的单个\",{\"1\":{\"231\":1}}],[\"就是可能会导致\",{\"1\":{\"955\":1}}],[\"就是新增加一个用于执行子任务的线程池专门为其服务\",{\"1\":{\"919\":1}}],[\"就是继承priorityblockingqueue\",{\"1\":{\"897\":1}}],[\"就是用来避免这两个线程竞争的\",{\"1\":{\"881\":1}}],[\"就是用一个预期值和要更新的变量值进行比较\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"就是使用了乐观锁的一种实现方式\",{\"1\":{\"838\":1,\"987\":1}}],[\"就是链表首节点\",{\"1\":{\"710\":1}}],[\"就是起一个模板的作用\",{\"1\":{\"633\":1}}],[\"就是只是对数组扩容\",{\"1\":{\"622\":1}}],[\"就是只是执行\",{\"1\":{\"619\":1}}],[\"就是基于\",{\"1\":{\"601\":1,\"1085\":1,\"1226\":1,\"1230\":1}}],[\"就是基于这种方式来做的\",{\"1\":{\"34\":1}}],[\"就是一个标准\",{\"1\":{\"1280\":1}}],[\"就是一个适用于各个系统之间同步通信的\",{\"1\":{\"1271\":1}}],[\"就是一个在双端链表添加尾节点的操作\",{\"1\":{\"1011\":1}}],[\"就是一个抽象类\",{\"1\":{\"740\":1,\"903\":1}}],[\"就是一个发生在年轻代的\",{\"1\":{\"444\":1}}],[\"就是一份字节码\",{\"1\":{\"523\":1}}],[\"就是方法调用动态分派的过程\",{\"1\":{\"519\":1}}],[\"就是方法区\",{\"1\":{\"443\":1}}],[\"就是线程安全\",{\"1\":{\"503\":1}}],[\"就是年龄\",{\"1\":{\"444\":1}}],[\"就是让\",{\"1\":{\"425\":1}}],[\"就是废弃常量\",{\"1\":{\"393\":1}}],[\"就是形同虚设\",{\"1\":{\"392\":1}}],[\"就是\",{\"1\":{\"256\":1,\"386\":1,\"618\":1,\"682\":1,\"690\":1,\"883\":2,\"1068\":2,\"1129\":1,\"1253\":1}}],[\"就是通过使用一种叫做\",{\"1\":{\"234\":1}}],[\"就是通过关系型数据库的自增主键产生来唯一的\",{\"1\":{\"33\":1}}],[\"就是对应元素本身\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"就是当内存不足的时候\",{\"1\":{\"168\":1}}],[\"就是很久很久都没有响应\",{\"1\":{\"163\":1,\"292\":1}}],[\"就是最左优先\",{\"1\":{\"116\":1}}],[\"就是小数位多少\",{\"1\":{\"99\":1}}],[\"就是b树\",{\"1\":{\"99\":1}}],[\"就是我一个号段还没用完之前\",{\"1\":{\"41\":1}}],[\"就是数据的唯一标识\",{\"1\":{\"28\":1}}],[\"就是第二层\",{\"1\":{\"23\":1}}],[\"就是按照\",{\"1\":{\"7\":1}}],[\"上都可以保存数据\",{\"1\":{\"1382\":1}}],[\"上位的时候\",{\"1\":{\"1379\":1}}],[\"上节点的变化来实现配置的动态更新\",{\"1\":{\"1346\":1}}],[\"上下文重新从内核态切换到用户态\",{\"1\":{\"1308\":1}}],[\"上下文切换对系统来说意味着消耗大量的\",{\"1\":{\"895\":1,\"922\":1}}],[\"上下文切换通常是计算密集型的\",{\"1\":{\"895\":1,\"922\":1}}],[\"上下文切换更频繁\",{\"1\":{\"858\":1}}],[\"上下文切换是现代操作系统的基本功能\",{\"1\":{\"821\":1}}],[\"上下文切换\",{\"1\":{\"821\":1,\"895\":1,\"922\":1}}],[\"上游订单系统将用户下单支付这一业务事件封装成独立的普通消息并发送至\",{\"1\":{\"1284\":1}}],[\"上进行注册\",{\"1\":{\"1199\":1}}],[\"上会有一个专门用来进行\",{\"1\":{\"1199\":1}}],[\"上层需要定义消息格式用于定义\",{\"1\":{\"1161\":1}}],[\"上发表\",{\"1\":{\"1072\":1}}],[\"上提出\",{\"1\":{\"1066\":1}}],[\"上边自定义的tryrelease如果返回true\",{\"1\":{\"1014\":1}}],[\"上图中每一个\",{\"1\":{\"1354\":1}}],[\"上图中有颜色的为\",{\"1\":{\"1003\":1}}],[\"上图说明\",{\"1\":{\"950\":1,\"954\":1,\"958\":1}}],[\"上运行比如\",{\"1\":{\"820\":1}}],[\"上运行多个线程效率一定会高吗\",{\"0\":{\"819\":1}}],[\"上运行的\",{\"1\":{\"377\":1}}],[\"上执行\",{\"1\":{\"816\":1}}],[\"上支持多对多和一对一\",{\"1\":{\"808\":1,\"1053\":1}}],[\"上一个任务的结果为\",{\"1\":{\"781\":2}}],[\"上一篇文章介绍了\",{\"1\":{\"567\":1}}],[\"上等待的线程就会被唤醒并继续执行\",{\"1\":{\"752\":1}}],[\"上直接实现前驱和后继指针\",{\"1\":{\"708\":1}}],[\"上实现前驱和后继指针呢\",{\"1\":{\"708\":1}}],[\"上实现一些自定义的逻辑或功能\",{\"1\":{\"6\":1}}],[\"上的消息读写都会受到影响\",{\"1\":{\"1281\":1}}],[\"上的队列越多\",{\"1\":{\"1281\":1}}],[\"上的冲突日志会被领导者的日志覆盖\",{\"1\":{\"1112\":1}}],[\"上的一篇\",{\"1\":{\"1084\":1}}],[\"上的每一个节点建立一条双向链表\",{\"1\":{\"708\":1}}],[\"上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树\",{\"1\":{\"708\":1}}],[\"上的节点\",{\"1\":{\"702\":1}}],[\"上的结点数小于等于这个值时树转链表\",{\"1\":{\"619\":1}}],[\"上的结点数大于等于这个值时会转成红黑树\",{\"1\":{\"619\":1}}],[\"上的副本\",{\"1\":{\"226\":1}}],[\"上文中提到了提高并发能力\",{\"1\":{\"1281\":1}}],[\"上文解释了\",{\"1\":{\"1012\":1}}],[\"上文提到过\",{\"1\":{\"712\":1}}],[\"上文获取元素时都会调用到\",{\"1\":{\"605\":1}}],[\"上文讲述\",{\"1\":{\"601\":1}}],[\"上述就是我对于整个消息存储架构的大概理解\",{\"1\":{\"1315\":1}}],[\"上述消费逻辑由消费者客户端接口定义\",{\"1\":{\"1297\":1}}],[\"上述消费者的消费行为从关联的消费者分组中统一获取\",{\"1\":{\"1297\":1}}],[\"上述节点简单介绍以及他们之间的关系\",{\"1\":{\"1128\":1}}],[\"上述的一些问题你是否都已经掌握的很清楚了呢\",{\"1\":{\"1026\":1}}],[\"上述代码每次运行结果都会是\",{\"1\":{\"1020\":1}}],[\"上述代码首先创建了一个\",{\"1\":{\"767\":1}}],[\"上述方法的流程图如下\",{\"1\":{\"1012\":1}}],[\"上述程序输出如下\",{\"1\":{\"807\":1}}],[\"上述步骤的源码上文已经解释过了\",{\"1\":{\"712\":1}}],[\"上述步骤执行完成\",{\"1\":{\"603\":2}}],[\"上述操作已经将\",{\"1\":{\"710\":1}}],[\"上述操作让前驱节点和后继节点完成关联\",{\"1\":{\"710\":1}}],[\"上述这些信息中\",{\"1\":{\"331\":1}}],[\"上同时只有一个线程可以操作\",{\"1\":{\"579\":1}}],[\"上锁\",{\"1\":{\"536\":1,\"605\":1}}],[\"上锁并将c中的元素存放到arrayblockingqueue底层的数组中\",{\"1\":{\"534\":1}}],[\"上使用会存在一些小问题\",{\"1\":{\"287\":1}}],[\"上\",{\"0\":{\"240\":1,\"637\":1,\"804\":1},\"1\":{\"256\":1,\"286\":1,\"287\":1,\"288\":1,\"334\":1,\"402\":1,\"724\":1,\"753\":1,\"819\":1,\"883\":1,\"1196\":1,\"1197\":1,\"1199\":2,\"1263\":1,\"1281\":2,\"1301\":1,\"1302\":1,\"1348\":1,\"1362\":1,\"1382\":1}}],[\"上面显示的一些信息比如\",{\"1\":{\"1329\":1}}],[\"上面我讲过了\",{\"1\":{\"1380\":1}}],[\"上面我讲了那么多的\",{\"1\":{\"1312\":1}}],[\"上面我讲解了\",{\"1\":{\"1281\":1}}],[\"上面我们已经提到过了\",{\"1\":{\"1388\":1}}],[\"上面我们不是说只有\",{\"1\":{\"1379\":1}}],[\"上面我们只是加了鸡腿和土豆丝\",{\"1\":{\"1271\":1}}],[\"上面我们有提及threadlocalmap的两种过期key数据清理方式\",{\"1\":{\"1037\":1}}],[\"上面我们己经提到了\",{\"1\":{\"796\":1}}],[\"上面给我抛出那么多问题\",{\"1\":{\"1276\":1}}],[\"上面两种方法是我觉得比较好理解的\",{\"1\":{\"1202\":1}}],[\"上面两个语句等价于下面一条语句\",{\"1\":{\"634\":1}}],[\"上面也说过了\",{\"1\":{\"1199\":1}}],[\"上面讲的大家可能不太好理解\",{\"1\":{\"1139\":1}}],[\"上面多次提及到threadlocalmap过期\",{\"1\":{\"1042\":1}}],[\"上面有分析清理的详细流程\",{\"1\":{\"1038\":1}}],[\"上面有一段代码用到了创建\",{\"1\":{\"882\":1}}],[\"上面已经看完了set\",{\"1\":{\"1039\":1}}],[\"上面已经用图的方式解析了set\",{\"1\":{\"1036\":1}}],[\"上面已经提到过\",{\"1\":{\"631\":1}}],[\"上面向前迭代的操作是为了更新探测清理过期数据的起始下标slottoexpunge的值\",{\"1\":{\"1035\":1}}],[\"上面提到的\",{\"1\":{\"974\":1}}],[\"上面提到的公示也只是参考\",{\"1\":{\"922\":1}}],[\"上面提到的几个方法底层基本都是通过同步器\",{\"1\":{\"748\":1}}],[\"上面这张图也为我们引出了\",{\"1\":{\"1196\":1}}],[\"上面这段代码在调用\",{\"1\":{\"785\":1}}],[\"上面这些参数我们都可以自定义\",{\"1\":{\"40\":1}}],[\"上面三个类提供的方法几乎相同\",{\"1\":{\"763\":1,\"766\":1,\"767\":1,\"768\":1}}],[\"上面\",{\"1\":{\"679\":1}}],[\"上面探究了获取\",{\"1\":{\"571\":1}}],[\"上面的同步刷盘和异步刷盘是在单个结点层面的\",{\"1\":{\"1314\":1}}],[\"上面的字节码中包含一个\",{\"1\":{\"851\":1}}],[\"上面的例子符合产生死锁的四个必要条件\",{\"1\":{\"823\":1}}],[\"上面的示例中\",{\"1\":{\"756\":1,\"911\":1}}],[\"上面的代码可能会存在死锁的情况\",{\"1\":{\"919\":1}}],[\"上面的代码可以改写为\",{\"1\":{\"694\":1}}],[\"上面的代码还可以继续优化\",{\"1\":{\"909\":1}}],[\"上面的代码中\",{\"1\":{\"753\":1}}],[\"上面的源码分析了\",{\"1\":{\"571\":1}}],[\"上面的说法已经在\",{\"1\":{\"387\":1}}],[\"上面的操作也不去执行了\",{\"1\":{\"125\":1}}],[\"上面说完了查询的流程\",{\"1\":{\"89\":1}}],[\"上面介绍到的分布式锁的实现会存在一些问题\",{\"1\":{\"51\":1}}],[\"上面介绍的几个常见的网关系统\",{\"1\":{\"10\":1}}],[\"上面介绍了这么多功能\",{\"1\":{\"1\":1}}],[\"应的概念\",{\"1\":{\"1253\":1}}],[\"应该不算陌生\",{\"1\":{\"1341\":1}}],[\"应该给它多配置几个队列\",{\"1\":{\"1281\":1}}],[\"应该设置合理的超时时间\",{\"1\":{\"924\":1}}],[\"应该显式地关闭线程池\",{\"1\":{\"924\":1}}],[\"应该算是在高并发环境中性能最好的队列了\",{\"1\":{\"794\":1}}],[\"应该在\",{\"1\":{\"484\":1}}],[\"应该清楚\",{\"1\":{\"93\":1}}],[\"应该够运营同学挥霍了\",{\"1\":{\"19\":1}}],[\"应该是对应于\",{\"1\":{\"384\":1}}],[\"应该是\",{\"1\":{\"5\":1,\"68\":1,\"449\":1}}],[\"应用这个策略\",{\"1\":{\"1263\":1}}],[\"应用软件是为用户服务的\",{\"1\":{\"1218\":1}}],[\"应用软件可以借助中间件在不同的技术架构之间共享信息与资源\",{\"1\":{\"1218\":1}}],[\"应用级服务发现\",{\"1\":{\"1168\":1}}],[\"应用层协议\",{\"1\":{\"1154\":1}}],[\"应用到自己的状态机中\",{\"1\":{\"1110\":1,\"1112\":1}}],[\"应用目录下\",{\"1\":{\"359\":1}}],[\"应用目录下的类\",{\"1\":{\"359\":1}}],[\"应用的\",{\"1\":{\"486\":1}}],[\"应用的线程里设置线程线程上下文类加载器为\",{\"1\":{\"359\":2}}],[\"应用的类\",{\"1\":{\"359\":1}}],[\"应用都会创建一个单独的\",{\"1\":{\"359\":2}}],[\"应用之间的通信又不是只能由消息队列解决\",{\"1\":{\"1271\":1}}],[\"应用之间的类隔\",{\"1\":{\"359\":1}}],[\"应用之间的类实现隔离的具体原理\",{\"1\":{\"359\":1}}],[\"应用之间共享的\",{\"1\":{\"359\":1}}],[\"应用之间共享的类比如\",{\"1\":{\"359\":1}}],[\"应用和\",{\"1\":{\"359\":1}}],[\"应用所需的资源如文本\",{\"1\":{\"351\":1}}],[\"应用场景\",{\"0\":{\"178\":1,\"182\":1,\"186\":1,\"190\":1,\"194\":1,\"203\":1,\"207\":1,\"211\":1,\"1346\":1}}],[\"应用在所有路由上的过滤器\",{\"1\":{\"73\":1}}],[\"应用在单个路由或一组路由上的过滤器\",{\"1\":{\"73\":1}}],[\"应用程序可以使用此操作来最小化arraylist实例的存储\",{\"1\":{\"553\":1}}],[\"应用程序可以使用ensurecapacity操作来增加\",{\"1\":{\"549\":1}}],[\"应用程序不会抛出该类对象\",{\"1\":{\"524\":1}}],[\"应用程序的相关信息\",{\"1\":{\"377\":1}}],[\"应用程序的详细信息\",{\"1\":{\"377\":1}}],[\"应用程序类加载器\",{\"1\":{\"353\":1}}],[\"应用程序\",{\"1\":{\"7\":1}}],[\"应用\",{\"0\":{\"248\":1,\"1017\":1},\"1\":{\"6\":1,\"448\":2}}],[\"库\",{\"1\":{\"6\":1}}],[\"库来实现响应式编程模型\",{\"1\":{\"5\":1,\"68\":1}}],[\"与它关联的内容是数字\",{\"1\":{\"1325\":1}}],[\"与它关联的字符串是\",{\"1\":{\"1325\":1}}],[\"与它日志一致的地方\",{\"1\":{\"1112\":1}}],[\"与之对应的是\",{\"1\":{\"1194\":1}}],[\"与周边生态系统的兼容性是最好的没有之一\",{\"1\":{\"1191\":1}}],[\"与自定义同步器无关\",{\"1\":{\"1007\":1}}],[\"与按\",{\"1\":{\"974\":1}}],[\"与线程\",{\"1\":{\"972\":1}}],[\"与线程对象绑定的类的静态属性\",{\"1\":{\"929\":1}}],[\"与此线程有关的inheritablethreadlocal值\",{\"1\":{\"883\":1}}],[\"与此线程有关的threadlocal值\",{\"1\":{\"883\":1}}],[\"与此形成对比的是\",{\"1\":{\"693\":1}}],[\"与进程不同的是同类的多个线程共享进程的堆和方法区资源\",{\"1\":{\"807\":1}}],[\"与数组相比\",{\"1\":{\"647\":1}}],[\"与copyof\",{\"1\":{\"634\":1}}],[\"与前面的e\",{\"1\":{\"622\":1}}],[\"与缓存区\",{\"1\":{\"499\":1}}],[\"与永久代很大的不同就是\",{\"1\":{\"496\":1}}],[\"与程序计数器一样\",{\"1\":{\"493\":1}}],[\"与性能有关的最常见实践之一是根据应用程序要求初始化堆内存\",{\"1\":{\"478\":1}}],[\"与年老代的比值\",{\"1\":{\"449\":1}}],[\"与硬件不直接交互\",{\"1\":{\"417\":1}}],[\"与其他收集器的单线程相比\",{\"1\":{\"401\":1}}],[\"与其他几种引用都不同\",{\"1\":{\"392\":1}}],[\"与mget\",{\"1\":{\"287\":1}}],[\"与操作相对应的文件事件就会产生\",{\"1\":{\"265\":1}}],[\"与快照持久化相比\",{\"1\":{\"229\":1}}],[\"与原库的值不同\",{\"1\":{\"89\":2}}],[\"与查询流程不一样的是\",{\"1\":{\"89\":1}}],[\"与传统数据库不同的是\",{\"1\":{\"242\":1}}],[\"与传统\",{\"1\":{\"8\":1}}],[\"与\",{\"0\":{\"134\":1,\"552\":1,\"656\":1,\"667\":1,\"668\":1,\"1002\":1},\"1\":{\"6\":1,\"8\":1,\"10\":1,\"48\":1,\"236\":1,\"237\":1,\"257\":1,\"280\":1,\"282\":1,\"286\":1,\"287\":1,\"333\":1,\"407\":1,\"408\":1,\"449\":1,\"451\":1,\"479\":1,\"549\":1,\"634\":1,\"720\":1,\"749\":1,\"753\":1,\"798\":1,\"841\":2,\"976\":2,\"990\":2,\"999\":1,\"1249\":1,\"1252\":2}}],[\"官网提供的\",{\"1\":{\"1179\":1}}],[\"官网提供的在线\",{\"1\":{\"242\":1}}],[\"官网的一篇文章中提到说推荐使用\",{\"1\":{\"1147\":1}}],[\"官网也解释了自己为啥不支持回滚\",{\"1\":{\"281\":1}}],[\"官网相关介绍\",{\"1\":{\"280\":1}}],[\"官网建议4核的机器建议设置为2或3个线程\",{\"1\":{\"267\":1}}],[\"官网上面也给了比较详细的说明redis\",{\"1\":{\"236\":1}}],[\"官网上找到\",{\"1\":{\"174\":1}}],[\"官网对应的介绍\",{\"1\":{\"174\":1,\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1}}],[\"官网介绍\",{\"1\":{\"10\":1}}],[\"官网地址\",{\"1\":{\"6\":1,\"7\":1,\"8\":1,\"9\":1}}],[\"官网\",{\"1\":{\"5\":1,\"68\":1,\"377\":1,\"1122\":1,\"1168\":1,\"1170\":1,\"1171\":1,\"1182\":1,\"1235\":1,\"1236\":2,\"1237\":1,\"1238\":1}}],[\"官方教程\",{\"1\":{\"1178\":1}}],[\"官方当年颁布获得\",{\"1\":{\"1178\":1}}],[\"官方介绍\",{\"1\":{\"1178\":1}}],[\"官方有详细的源码分析\",{\"1\":{\"1143\":1}}],[\"官方的\",{\"1\":{\"1178\":2}}],[\"官方的话来说\",{\"1\":{\"1129\":1}}],[\"官方的原话\",{\"1\":{\"218\":1}}],[\"官方提供了以下四种方式创建虚拟线程\",{\"1\":{\"1057\":1}}],[\"官方提供的架构图就是一个\",{\"1\":{\"1354\":1}}],[\"官方提供的分片集群解决方案\",{\"1\":{\"286\":1}}],[\"官方提供的\",{\"1\":{\"35\":1}}],[\"官方在\",{\"1\":{\"377\":1}}],[\"官方文档对负载均衡这部分的介绍非常详细\",{\"1\":{\"1140\":1}}],[\"官方文档的介绍\",{\"1\":{\"1122\":1}}],[\"官方文档进行了修改导致\",{\"1\":{\"1120\":1}}],[\"官方文档似乎没有解释\",{\"1\":{\"449\":1}}],[\"官方文档引用\",{\"1\":{\"386\":1}}],[\"官方文档有详细的介绍\",{\"1\":{\"219\":1}}],[\"官方文档\",{\"1\":{\"78\":1,\"221\":1,\"237\":1,\"252\":1,\"360\":1,\"479\":1,\"480\":1,\"1214\":1}}],[\"官方文档地址\",{\"1\":{\"72\":1,\"224\":1,\"235\":1}}],[\"官方文档提供的方案总是基于配置文件或代码配置的方式\",{\"1\":{\"72\":1}}],[\"官方文档中还有一个关于这些序列化协议的性能对比图可供参考\",{\"1\":{\"1147\":1}}],[\"官方文档中的框架设计章节\",{\"1\":{\"1128\":1}}],[\"官方文档中的案例\",{\"1\":{\"873\":1}}],[\"官方文档中的介绍如下\",{\"1\":{\"40\":1}}],[\"官方文档中也有对应的原话\",{\"1\":{\"218\":1}}],[\"官方文档中有对应的详细说明\",{\"1\":{\"205\":1}}],[\"官方文档中找到\",{\"1\":{\"49\":1}}],[\"官方博客中的一张图\",{\"1\":{\"69\":1}}],[\"官方推荐新生代占\",{\"1\":{\"455\":1}}],[\"官方推荐配置为\",{\"1\":{\"450\":1}}],[\"官方推荐配置为整个堆的\",{\"1\":{\"449\":1}}],[\"官方推荐的一种方式\",{\"1\":{\"356\":1}}],[\"官方推荐生产环境使用\",{\"1\":{\"242\":1}}],[\"官方推荐\",{\"1\":{\"7\":1}}],[\"官方\",{\"1\":{\"4\":1,\"42\":1,\"354\":1}}],[\"不理解可以看前面的选举算法\",{\"1\":{\"1380\":1}}],[\"不参与选举过程中的投票\",{\"1\":{\"1355\":1}}],[\"不使用任何\",{\"1\":{\"1351\":1}}],[\"不分\",{\"1\":{\"1315\":1}}],[\"不相关了\",{\"1\":{\"1304\":1}}],[\"不相同\",{\"1\":{\"622\":1}}],[\"不相同就通过拉链法解决冲突\",{\"1\":{\"618\":1,\"682\":1}}],[\"不知道大家是否还记得我讲了什么\",{\"1\":{\"1391\":1}}],[\"不知道是不是需要给消费者消费的问题\",{\"1\":{\"1304\":1}}],[\"不知道你们有没有接触过\",{\"1\":{\"1281\":1}}],[\"不就是\",{\"1\":{\"1379\":1,\"1383\":1}}],[\"不就是这样的么\",{\"1\":{\"1281\":1}}],[\"不就乱了么\",{\"1\":{\"124\":1}}],[\"不叫消息队列叫什么\",{\"1\":{\"1277\":1}}],[\"不保证消息可靠性等等\",{\"1\":{\"1191\":1}}],[\"不保证每次请求的可用性比如在\",{\"1\":{\"1069\":1}}],[\"不得不说\",{\"1\":{\"1170\":1}}],[\"不行\",{\"1\":{\"1151\":1}}],[\"不懂的人看了还是不懂\",{\"1\":{\"1150\":1}}],[\"不少解释显得非常官方\",{\"1\":{\"1150\":1}}],[\"不仔细看官方对活跃数的定义\",{\"1\":{\"1142\":1}}],[\"不想依赖\",{\"1\":{\"1132\":1}}],[\"不夸张地说\",{\"1\":{\"1065\":1}}],[\"不讲述包含共享锁和\",{\"1\":{\"999\":1}}],[\"不光实现了\",{\"1\":{\"900\":1}}],[\"不光可以帮助我们调用远程服务\",{\"1\":{\"1122\":1}}],[\"不光可以直观地查看某个类对应的字节码文件\",{\"1\":{\"325\":1}}],[\"不光可以保存文本数据还可以保存二进制数据\",{\"1\":{\"176\":1}}],[\"不清楚什么是上下文切换的话\",{\"1\":{\"895\":1,\"922\":1}}],[\"不利于我们定位问题\",{\"1\":{\"894\":1,\"920\":1}}],[\"不存储元素\",{\"1\":{\"892\":1,\"938\":1}}],[\"不存在同步的构造方法一说\",{\"1\":{\"849\":1}}],[\"不存在锁竞争造成线程阻塞\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"不存在其他线程修改的情况\",{\"1\":{\"693\":1}}],[\"不存在一个线程操作该\",{\"1\":{\"693\":1}}],[\"不存在\",{\"1\":{\"571\":1}}],[\"不存在垃圾回收\",{\"1\":{\"440\":1}}],[\"不存在线程安全问题\",{\"1\":{\"424\":1}}],[\"不存在这个问题\",{\"1\":{\"256\":1}}],[\"不存在时设置\",{\"1\":{\"177\":1}}],[\"不存在最佳模式\",{\"1\":{\"144\":1}}],[\"不存在的话\",{\"1\":{\"47\":1,\"307\":1}}],[\"不存在与现实生活中\",{\"1\":{\"29\":1}}],[\"不存在单点问题\",{\"1\":{\"10\":1}}],[\"不处理新任务\",{\"1\":{\"891\":1,\"936\":1}}],[\"不互斥\",{\"1\":{\"848\":1}}],[\"不依赖于类的特定实例\",{\"1\":{\"848\":1}}],[\"不满足\",{\"1\":{\"840\":1,\"989\":1}}],[\"不涉及到对象类\",{\"1\":{\"826\":1}}],[\"不剥夺条件\",{\"1\":{\"823\":1}}],[\"不论你了不了解消息队列\",{\"1\":{\"1217\":1}}],[\"不论是从功能完善程度\",{\"1\":{\"1172\":1}}],[\"不论是本地锁还是分布式锁\",{\"1\":{\"47\":1}}],[\"不论系统有几个\",{\"1\":{\"816\":1}}],[\"不太了解的小伙伴可以看看这篇文章\",{\"1\":{\"744\":1}}],[\"不太推荐\",{\"1\":{\"314\":1}}],[\"不为null的话\",{\"1\":{\"1335\":1}}],[\"不为空\",{\"1\":{\"834\":1}}],[\"不为\",{\"1\":{\"731\":1,\"752\":1,\"908\":1,\"1033\":1}}],[\"不也使得使用\",{\"1\":{\"708\":1}}],[\"不重要\",{\"0\":{\"695\":1}}],[\"不冲突\",{\"1\":{\"691\":1}}],[\"不加锁\",{\"1\":{\"577\":1}}],[\"不一样\",{\"1\":{\"1311\":1}}],[\"不一定非得基于\",{\"1\":{\"1161\":1}}],[\"不一定可以读取到最新写入的值\",{\"1\":{\"1078\":1}}],[\"不一定包含的元素越多\",{\"1\":{\"163\":1,\"291\":1}}],[\"不一致\",{\"1\":{\"571\":1}}],[\"不比\",{\"1\":{\"558\":1}}],[\"不去计算\",{\"1\":{\"558\":1}}],[\"不成立\",{\"1\":{\"557\":1}}],[\"不难猜出通过继承\",{\"1\":{\"533\":1}}],[\"不提供指针来直接访问内存\",{\"1\":{\"517\":2}}],[\"不容易出现内存泄漏和内存溢出问题\",{\"1\":{\"490\":1}}],[\"不再依赖\",{\"1\":{\"1200\":1,\"1235\":1,\"1344\":1}}],[\"不再是\",{\"1\":{\"688\":1}}],[\"不再是之前的\",{\"1\":{\"575\":1}}],[\"不再需要像\",{\"1\":{\"490\":1}}],[\"不再要求各个属性表具有严格的顺序\",{\"1\":{\"333\":1}}],[\"不包括对象头\",{\"1\":{\"504\":1}}],[\"不包括实例变量\",{\"1\":{\"429\":1}}],[\"不包含永久区\",{\"1\":{\"452\":1}}],[\"不断的完善和修复问题\",{\"1\":{\"408\":1}}],[\"不管内容有无变化\",{\"1\":{\"1349\":1}}],[\"不管是\",{\"1\":{\"1155\":1}}],[\"不管是公平锁还是非公平锁\",{\"1\":{\"1018\":1}}],[\"不管是插入操作还是读取操作\",{\"1\":{\"541\":1,\"797\":1}}],[\"不管该实例对象是成员变量\",{\"1\":{\"972\":1}}],[\"不管读锁是不是被当前线程持有\",{\"1\":{\"868\":1}}],[\"不管有多少个线程同时访问\",{\"1\":{\"818\":1}}],[\"不管哪种返回方式\",{\"1\":{\"493\":1}}],[\"不管当前内存空间足够与否\",{\"1\":{\"392\":1,\"884\":1}}],[\"不管主键还是非主键\",{\"1\":{\"105\":1}}],[\"不在同一个线程内\",{\"1\":{\"974\":1}}],[\"不在\",{\"1\":{\"359\":1}}],[\"不被篡改\",{\"1\":{\"358\":1}}],[\"不要认为消息队列只能利用发布\",{\"1\":{\"1222\":1}}],[\"不要以为代码中没有显示使用线程池就不存在线程池了\",{\"1\":{\"929\":1}}],[\"不要下意识地认为\",{\"1\":{\"656\":1,\"724\":1}}],[\"不要在代码中使用它\",{\"1\":{\"677\":1}}],[\"不要在\",{\"1\":{\"631\":1}}],[\"不要被误解了就好\",{\"1\":{\"356\":1}}],[\"不要将其和我们平时理解的关系型数据库的事务混淆了\",{\"1\":{\"279\":1}}],[\"不引用任何一个常量池项\",{\"1\":{\"328\":1}}],[\"不推荐使用\",{\"1\":{\"767\":2,\"917\":1,\"1239\":1,\"1240\":1}}],[\"不推荐\",{\"1\":{\"316\":1,\"695\":1,\"779\":1,\"1252\":1}}],[\"不了解布隆过滤器\",{\"1\":{\"307\":1}}],[\"不了解这部分内容的小伙伴\",{\"1\":{\"35\":1}}],[\"不适用于计算密集型任务\",{\"1\":{\"1056\":1}}],[\"不适用于执行顺序有依赖关系的一批命令\",{\"1\":{\"287\":1}}],[\"不适合保存大量数据\",{\"1\":{\"1346\":1}}],[\"不适合老年代\",{\"1\":{\"397\":1}}],[\"不适合范围查询的场景\",{\"1\":{\"96\":1}}],[\"不允许使用以下方式处理消息\",{\"1\":{\"1292\":1}}],[\"不允许存在恶意节点\",{\"1\":{\"1090\":1}}],[\"不允许在工作内存中直接使用一个未被初始化\",{\"1\":{\"972\":1}}],[\"不允许在应用中自行显式创建线程\",{\"1\":{\"889\":1}}],[\"不允许一个线程无原因地\",{\"1\":{\"972\":1}}],[\"不允许返回值\",{\"1\":{\"778\":1}}],[\"不允许分割\",{\"1\":{\"281\":1}}],[\"不允许有\",{\"1\":{\"677\":1}}],[\"不允许有重复元素\",{\"1\":{\"189\":1}}],[\"不允许有空值\",{\"1\":{\"104\":1}}],[\"不需要做任何判断操作\",{\"1\":{\"1252\":1}}],[\"不需要了解底层网络的通信机制\",{\"1\":{\"1232\":1}}],[\"不需要应用修改代码\",{\"1\":{\"1231\":1}}],[\"不需要专门部署\",{\"1\":{\"1085\":1}}],[\"不需要唤醒\",{\"1\":{\"1014\":1}}],[\"不需要关注底层具体的实现流程\",{\"1\":{\"1003\":1}}],[\"不需要一直等到获取锁之后\",{\"1\":{\"863\":1}}],[\"不需要一条一条地执行命令\",{\"1\":{\"236\":1}}],[\"不需要获取同步的\",{\"1\":{\"807\":1}}],[\"不需要加锁\",{\"1\":{\"764\":1}}],[\"不需要记各种细节\",{\"1\":{\"685\":1}}],[\"不需要记具体的方法\",{\"1\":{\"544\":1}}],[\"不需要扩容\",{\"1\":{\"668\":1}}],[\"不需要就选择实现\",{\"1\":{\"646\":1}}],[\"不需要排序时就选择\",{\"1\":{\"646\":1}}],[\"不需要程序员⼿动释放⽆⽤内存\",{\"1\":{\"517\":2}}],[\"不需要再重复安装jre\",{\"1\":{\"516\":1}}],[\"不需要被监视的程序基于特殊\",{\"1\":{\"377\":1}}],[\"不需要额外创建多余的线程来监听客户端的大量连接\",{\"1\":{\"265\":1}}],[\"不支持队列层面的广播消费\",{\"1\":{\"1250\":1}}],[\"不支持重试\",{\"1\":{\"1210\":1}}],[\"不支持跨语言调用\",{\"1\":{\"1147\":1}}],[\"不支持阻塞操作\",{\"1\":{\"897\":1}}],[\"不支持条件变量\",{\"1\":{\"873\":1}}],[\"不支持存储\",{\"1\":{\"668\":1}}],[\"不支持随机快速访问\",{\"1\":{\"655\":1,\"726\":1}}],[\"不支持高效的随机元素访问\",{\"1\":{\"552\":1,\"656\":1}}],[\"不支持\",{\"1\":{\"245\":1}}],[\"不支持热更新\",{\"1\":{\"10\":1}}],[\"不建议频繁创建和销毁生产者\",{\"0\":{\"1290\":1}}],[\"不建议单一进程创建大量生产者\",{\"0\":{\"1289\":1}}],[\"不建议单独使用\",{\"1\":{\"236\":1}}],[\"不建议学习\",{\"1\":{\"1239\":1}}],[\"不建议向arraylist\",{\"1\":{\"551\":1,\"652\":1}}],[\"不建议你使用\",{\"1\":{\"244\":1}}],[\"不建议这样做\",{\"1\":{\"182\":1,\"1250\":1}}],[\"不建议和其他多核\",{\"1\":{\"169\":1}}],[\"不同消息队列收到的消息则可能是无顺序的\",{\"1\":{\"1299\":1}}],[\"不同类型的\",{\"1\":{\"1249\":1}}],[\"不同就采用头插法插入元素\",{\"1\":{\"622\":1}}],[\"不同点\",{\"1\":{\"517\":1,\"520\":1}}],[\"不同于一般的\",{\"1\":{\"871\":1}}],[\"不同于类的构造器\",{\"1\":{\"430\":1}}],[\"不同于\",{\"1\":{\"224\":1,\"282\":1}}],[\"不同\",{\"1\":{\"160\":1,\"690\":1,\"1114\":1}}],[\"不同的类型对应着不同的路由策略\",{\"1\":{\"1249\":1}}],[\"不同的开发语言等条件的限制\",{\"1\":{\"1230\":1}}],[\"不同的消息队列都有自己的一套消息模型\",{\"1\":{\"1192\":1}}],[\"不同的节点进行数据\",{\"1\":{\"1083\":1}}],[\"不同的操作系统内存模型不同\",{\"1\":{\"971\":1}}],[\"不同的\",{\"1\":{\"968\":1}}],[\"不同的线程池会选用不同的阻塞队列作为任务队列\",{\"1\":{\"897\":1}}],[\"不同的线程池会选用不同的阻塞队列\",{\"1\":{\"892\":1,\"938\":1}}],[\"不同的线程可能在不同的时间片获得\",{\"1\":{\"686\":1}}],[\"不同的字符串可能哈希出来的位置相同\",{\"1\":{\"307\":1}}],[\"不同的事务访问不同版本的数据快照\",{\"1\":{\"141\":1}}],[\"不同的存储引擎共用一个server\",{\"1\":{\"83\":1}}],[\"不同的服务\",{\"1\":{\"60\":1,\"63\":1}}],[\"不同的版本对应的\",{\"1\":{\"37\":1}}],[\"不同的插件实现不同的功能\",{\"1\":{\"9\":1}}],[\"不直接更新\",{\"1\":{\"147\":1}}],[\"不然大家没法交流\",{\"1\":{\"1155\":1}}],[\"不然会出现生产问题\",{\"1\":{\"928\":1}}],[\"不然就会出现如下所示的错误\",{\"1\":{\"298\":1}}],[\"不然很有可能会造成不一致\",{\"1\":{\"140\":1}}],[\"不然等程序查完之后\",{\"1\":{\"124\":1}}],[\"不然的话\",{\"1\":{\"48\":1}}],[\"不必读取数据行\",{\"1\":{\"104\":1}}],[\"不是内容\",{\"1\":{\"1382\":1}}],[\"不是所谓的\",{\"0\":{\"1068\":1}}],[\"不是所有编程语言都原生支持协程\",{\"1\":{\"1056\":1}}],[\"不是错误或者超时的响应\",{\"1\":{\"1067\":1}}],[\"不是直接实现\",{\"1\":{\"874\":1}}],[\"不是很重要\",{\"1\":{\"870\":1}}],[\"不是说好了\",{\"1\":{\"835\":1}}],[\"不是线程安全的\",{\"1\":{\"792\":1,\"882\":1}}],[\"不是并发\",{\"1\":{\"753\":1}}],[\"不是头节点也不是尾节点\",{\"1\":{\"731\":1}}],[\"不是红黑树节点则说明为链表结点\",{\"1\":{\"622\":1}}],[\"不是静态常量\",{\"1\":{\"344\":1}}],[\"不是重点\",{\"1\":{\"231\":1}}],[\"不是\",{\"1\":{\"201\":1}}],[\"不是四舍五入\",{\"1\":{\"99\":1}}],[\"不是一个好的选择\",{\"1\":{\"10\":1}}],[\"不会再去请求注册中心\",{\"1\":{\"1390\":1}}],[\"不会再直接读取\",{\"1\":{\"341\":1}}],[\"不会导致不可用\",{\"1\":{\"1240\":1}}],[\"不会丢失数据\",{\"1\":{\"1240\":1}}],[\"不会一直卡在当前消息\",{\"1\":{\"1209\":2}}],[\"不会\",{\"1\":{\"1137\":1}}],[\"不会像\",{\"1\":{\"1069\":1}}],[\"不会拒绝任务\",{\"1\":{\"951\":1}}],[\"不会被少数运行缓慢的服务器来影响整体系统性能\",{\"1\":{\"1106\":1}}],[\"不会被清理掉\",{\"1\":{\"884\":1}}],[\"不会被其他操作\",{\"1\":{\"287\":1}}],[\"不会产生死锁问题\",{\"1\":{\"860\":1}}],[\"不会发生互斥现象\",{\"1\":{\"848\":1}}],[\"不会发生死锁的问题\",{\"1\":{\"54\":1}}],[\"不会消耗过多的执行资源\",{\"1\":{\"844\":1,\"993\":1}}],[\"不会出现数据不一致的情况\",{\"1\":{\"694\":1}}],[\"不会直接修改原数组\",{\"1\":{\"585\":1,\"793\":1}}],[\"不会进入\",{\"1\":{\"558\":1}}],[\"不会等待并阻塞线程\",{\"1\":{\"536\":3}}],[\"不会耗尽内存\",{\"1\":{\"480\":1}}],[\"不会去加载你写的\",{\"1\":{\"358\":1}}],[\"不会立即执行这些命令\",{\"1\":{\"280\":1}}],[\"不会立即同步到硬盘\",{\"1\":{\"230\":1}}],[\"不会造成缓冲区溢出\",{\"1\":{\"176\":1}}],[\"不会造成阻塞\",{\"1\":{\"140\":1}}],[\"不会阻塞当前的命令执行\",{\"1\":{\"160\":1,\"232\":1}}],[\"不会阻塞\",{\"1\":{\"158\":1,\"227\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"125\":1}}],[\"不会影响其他线程对共享资源的访问\",{\"1\":{\"61\":1}}],[\"不能立即返回用户订单提交成功\",{\"1\":{\"1220\":1}}],[\"不能超过系统能够承受的上限\",{\"1\":{\"819\":1}}],[\"不能访问异步计算的结果\",{\"1\":{\"779\":1}}],[\"不能解决\",{\"1\":{\"762\":1}}],[\"不能为\",{\"0\":{\"693\":1},\"1\":{\"693\":1}}],[\"不能为空\",{\"1\":{\"577\":1}}],[\"不能使用其修改集合相关的方法\",{\"1\":{\"634\":1}}],[\"不能无限生成\",{\"1\":{\"449\":1,\"458\":1}}],[\"不能无限期等待\",{\"1\":{\"61\":1}}],[\"不能小于\",{\"1\":{\"307\":1}}],[\"不能通过\",{\"1\":{\"267\":1}}],[\"不能创建子节点\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1,\"1382\":1}}],[\"不能获取多锁\",{\"1\":{\"53\":1}}],[\"不能混合使用\",{\"1\":{\"19\":1}}],[\"不可靠\",{\"1\":{\"1151\":1}}],[\"不可不说的\",{\"1\":{\"876\":1,\"1002\":1,\"1022\":1}}],[\"不可中断锁\",{\"1\":{\"863\":1}}],[\"不可以插入\",{\"1\":{\"799\":1}}],[\"不可用this\",{\"1\":{\"521\":1}}],[\"不可设置过大\",{\"1\":{\"461\":1}}],[\"不可达\",{\"1\":{\"391\":1}}],[\"不可见\",{\"1\":{\"141\":1}}],[\"不可能再提交这个提案\",{\"1\":{\"1380\":1}}],[\"不可能同时达到\",{\"1\":{\"1068\":1}}],[\"不可能\",{\"1\":{\"132\":6}}],[\"不可能a扣了钱\",{\"1\":{\"125\":1}}],[\"不可重入且不支持条件变量\",{\"1\":{\"871\":1}}],[\"不可重入的分布式锁基本可以满足绝大部分业务场景了\",{\"1\":{\"50\":1}}],[\"不可重复性是指添加的元素按照\",{\"1\":{\"664\":1}}],[\"不可重复的\",{\"1\":{\"640\":1}}],[\"不可重复读以及幻读\",{\"1\":{\"132\":1}}],[\"不可重复读或幻读都有可能发生\",{\"1\":{\"132\":1}}],[\"不可重复读重点在修改\",{\"1\":{\"130\":1}}],[\"不可重复读是读取了其他事务更改的数据\",{\"1\":{\"130\":1}}],[\"不可重复读和幻读的区别\",{\"0\":{\"130\":1}}],[\"不可重复读\",{\"0\":{\"128\":1},\"1\":{\"132\":2}}],[\"不可避免地\",{\"1\":{\"96\":1}}],[\"不可破解\",{\"1\":{\"19\":1}}],[\"不具备动态添加\",{\"1\":{\"649\":1}}],[\"不具备锁失效机制\",{\"1\":{\"62\":1}}],[\"不具备\",{\"1\":{\"49\":1}}],[\"不仅支持\",{\"1\":{\"1068\":1,\"1069\":1}}],[\"不仅捕获运行时异常\",{\"1\":{\"962\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"887\":1,\"933\":1}}],[\"不仅包括堆内存\",{\"1\":{\"375\":1}}],[\"不仅要看类的全名是否相同\",{\"1\":{\"357\":1}}],[\"不仅仅是加机器那么简单\",{\"1\":{\"1367\":1}}],[\"不仅仅是当前\",{\"1\":{\"266\":1}}],[\"不仅仅支持简单的\",{\"1\":{\"245\":1}}],[\"不仅仅包括多种分布式锁的实现\",{\"1\":{\"49\":1}}],[\"不仅提供统一的路由方式\",{\"1\":{\"5\":1,\"68\":1}}],[\"不用等待返回结果\",{\"1\":{\"815\":1}}],[\"不用太纠结下面每个线程的作用\",{\"1\":{\"807\":1}}],[\"不用傻傻等待耗时任务执行完成\",{\"1\":{\"773\":1,\"899\":1}}],[\"不用管\",{\"1\":{\"38\":1}}],[\"不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码\",{\"1\":{\"17\":1}}],[\"不安全\",{\"1\":{\"37\":1}}],[\"不够用的话\",{\"1\":{\"34\":1}}],[\"不过稍微有点复杂而已\",{\"1\":{\"1388\":1}}],[\"不过最主要的还是需要\",{\"1\":{\"1303\":1}}],[\"不过你最好带着问题去阅读和了解喔\",{\"1\":{\"1276\":1}}],[\"不过也相应的增加了所需要的存储空间\",{\"1\":{\"1197\":1}}],[\"不过笔者倒是很少看到有公司使用\",{\"1\":{\"1169\":1}}],[\"不过两者的本质都是对对象监视器\",{\"1\":{\"853\":1}}],[\"不过一般没有必要这样做\",{\"1\":{\"749\":1}}],[\"不过均摊后的插入操作依然为\",{\"1\":{\"668\":1}}],[\"不过它们之间也存在下面这些区别\",{\"1\":{\"542\":1,\"543\":1,\"672\":1}}],[\"不过我们也可以指定排序的比较器\",{\"1\":{\"679\":1}}],[\"不过我们基本不会涉及这两块的内容\",{\"1\":{\"422\":1}}],[\"不过我们需要加一个锁\",{\"1\":{\"145\":1}}],[\"不过这里的读锁是不可重入的\",{\"1\":{\"871\":1}}],[\"不过这里的写锁是不可重入的\",{\"1\":{\"871\":1}}],[\"不过这个方法有一种情况就是出现对象的循环引用时\",{\"1\":{\"445\":1}}],[\"不过这个是可视化的\",{\"1\":{\"376\":1}}],[\"不过这也间接性地解决了永久代的\",{\"1\":{\"443\":1}}],[\"不过这样不太灵活\",{\"1\":{\"286\":1}}],[\"不过有一点需要注意的是\",{\"1\":{\"342\":1}}],[\"不过带来了部分额外的内存开销\",{\"1\":{\"180\":1,\"195\":1}}],[\"不过概率非常小\",{\"1\":{\"145\":1}}],[\"不过增加了复杂度\",{\"1\":{\"33\":1,\"34\":1}}],[\"不过\",{\"1\":{\"5\":1,\"6\":1,\"10\":1,\"30\":1,\"34\":1,\"40\":1,\"41\":1,\"43\":1,\"47\":1,\"48\":1,\"62\":1,\"68\":1,\"77\":1,\"157\":1,\"184\":1,\"212\":1,\"218\":1,\"236\":1,\"244\":1,\"245\":1,\"251\":2,\"264\":1,\"266\":1,\"280\":1,\"283\":1,\"286\":2,\"287\":1,\"288\":1,\"298\":2,\"301\":1,\"340\":2,\"341\":1,\"351\":1,\"356\":1,\"392\":1,\"408\":2,\"451\":1,\"493\":1,\"542\":1,\"543\":1,\"551\":1,\"564\":1,\"585\":1,\"589\":1,\"629\":1,\"631\":1,\"652\":1,\"672\":1,\"688\":1,\"713\":1,\"724\":1,\"838\":3,\"847\":1,\"857\":1,\"873\":1,\"884\":1,\"897\":2,\"929\":1,\"971\":1,\"972\":1,\"987\":3,\"995\":1,\"1084\":1,\"1088\":1,\"1096\":1,\"1099\":1,\"1123\":2,\"1131\":1,\"1147\":1,\"1169\":1,\"1170\":2,\"1177\":1,\"1178\":1,\"1200\":1,\"1235\":1,\"1258\":1,\"1305\":1,\"1344\":1}}],[\"也随之变为\",{\"1\":{\"1380\":1}}],[\"也能够向\",{\"1\":{\"1353\":1}}],[\"也能分析\",{\"1\":{\"412\":1}}],[\"也提供了相应\",{\"1\":{\"1311\":1}}],[\"也同样适用于\",{\"1\":{\"1303\":1}}],[\"也做了集群部署\",{\"1\":{\"1281\":1}}],[\"也正是如此\",{\"1\":{\"1245\":1}}],[\"也正因为如此\",{\"1\":{\"807\":1}}],[\"也被归类为消息队列的原因\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"也被称为\",{\"1\":{\"499\":1}}],[\"也被称为斜树\",{\"1\":{\"97\":1}}],[\"也跟\",{\"1\":{\"1158\":1}}],[\"也一定相同\",{\"1\":{\"1112\":1}}],[\"也一样\",{\"1\":{\"537\":1}}],[\"也允许这样的重排序\",{\"1\":{\"974\":1}}],[\"也至多只会创建\",{\"1\":{\"949\":1}}],[\"也支持\",{\"1\":{\"1069\":1}}],[\"也支持公平锁和非公平锁\",{\"1\":{\"865\":1}}],[\"也支持自定义同步器同时实现独占和共享两种方式\",{\"1\":{\"743\":1,\"1007\":1}}],[\"也将版本号\",{\"1\":{\"840\":1,\"989\":1}}],[\"也读入此用户信息\",{\"1\":{\"840\":1,\"989\":1}}],[\"也即回到\",{\"1\":{\"820\":1}}],[\"也即大概只有\",{\"1\":{\"820\":1}}],[\"也要适度\",{\"1\":{\"819\":1}}],[\"也只能是这样了\",{\"1\":{\"1264\":1}}],[\"也只能从头到尾遍历链表\",{\"1\":{\"800\":1}}],[\"也只是通过\",{\"1\":{\"621\":1}}],[\"也算是一个小亮点了\",{\"1\":{\"788\":1}}],[\"也属于\",{\"1\":{\"755\":1,\"910\":1}}],[\"也初始化为\",{\"1\":{\"742\":1,\"904\":1}}],[\"也执行\",{\"1\":{\"686\":1}}],[\"也执行查询用户已经抢购的数量\",{\"1\":{\"60\":1}}],[\"也没关系\",{\"1\":{\"941\":1}}],[\"也没有什么特别的含义\",{\"1\":{\"507\":1}}],[\"也没毛病\",{\"1\":{\"227\":1}}],[\"也称上下文\",{\"1\":{\"821\":1}}],[\"也称主线程\",{\"1\":{\"806\":1}}],[\"也称编译错误\",{\"1\":{\"524\":1}}],[\"也称作\",{\"1\":{\"503\":1}}],[\"也称为主键索引\",{\"1\":{\"111\":1}}],[\"也需要将前一个节点指向尾节点\",{\"1\":{\"1011\":1}}],[\"也需要和其他运行时数据区域比如程序计数器配合\",{\"1\":{\"493\":1}}],[\"也需要\",{\"1\":{\"445\":1}}],[\"也可能直接问什么是消息队列\",{\"1\":{\"1245\":1}}],[\"也可能会因为移除或者扩容将\",{\"1\":{\"708\":1}}],[\"也可能是释放了锁以后被唤醒\",{\"1\":{\"1015\":1}}],[\"也可能是\",{\"1\":{\"782\":1}}],[\"也可能是链表已存在\",{\"1\":{\"571\":1}}],[\"也可能是一个链表的表头\",{\"1\":{\"571\":1}}],[\"也可能是指向一个代表对象的句柄或其他与此对象相关的位置\",{\"1\":{\"493\":1}}],[\"也可能是代码中创建的对象大且多\",{\"1\":{\"444\":1}}],[\"也可以在节点下面创建子节点\",{\"1\":{\"1348\":1}}],[\"也可以在运行时按需扩展\",{\"1\":{\"491\":1}}],[\"也可以将一个微服务设计成幂等的\",{\"1\":{\"1303\":1}}],[\"也可以自己实现\",{\"1\":{\"1299\":1}}],[\"也可以要求同步到指定数量的节点\",{\"1\":{\"1263\":1}}],[\"也可以根据实际业务情况动态地扩展\",{\"1\":{\"1246\":1}}],[\"也可以根据实际业务情况动态地扩展集群中节点\",{\"1\":{\"1237\":1}}],[\"也可以应用在现在比较火的微服务系统中\",{\"1\":{\"1123\":1}}],[\"也可以与客户端进行通信\",{\"1\":{\"1106\":1}}],[\"也可以说是未雨绸缪\",{\"1\":{\"985\":1}}],[\"也可以通过接口提前修改\",{\"1\":{\"1293\":1}}],[\"也可以通过接⼝\",{\"1\":{\"518\":1}}],[\"也可以通过插件机制来实现自己的交换器\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"也可以通过构造器来显式的指定使用公平锁\",{\"1\":{\"857\":1}}],[\"也可以通过在构造函数中传入\",{\"1\":{\"799\":1}}],[\"也可以通过自定义类实现\",{\"1\":{\"799\":1}}],[\"也可以实现线程安全\",{\"1\":{\"764\":1}}],[\"也可以解决使用\",{\"1\":{\"762\":1,\"767\":1}}],[\"也可以叫做投票员\",{\"1\":{\"1098\":1}}],[\"也可以叫做协调者\",{\"1\":{\"1098\":1}}],[\"也可以叫做加锁\",{\"1\":{\"752\":1}}],[\"也可以叫同步点\",{\"1\":{\"755\":1,\"910\":1}}],[\"也可以是默认实现的方法\",{\"1\":{\"744\":1}}],[\"也可以是通过工具动态生成或者通过网络下载得来\",{\"1\":{\"351\":1}}],[\"也可以用于实现栈\",{\"1\":{\"668\":1}}],[\"也可以存储对象\",{\"1\":{\"649\":1}}],[\"也可以不连续\",{\"1\":{\"491\":1}}],[\"也可以修改或者添加部分字段\",{\"1\":{\"255\":1}}],[\"也可以设置下面两个配置项\",{\"1\":{\"233\":1}}],[\"也可以设置为undo表空间\",{\"1\":{\"141\":1}}],[\"也可以使用迭代器进行操作\",{\"1\":{\"732\":1}}],[\"也可以使用\",{\"1\":{\"7\":1,\"1213\":1}}],[\"也采用标记\",{\"1\":{\"408\":1}}],[\"也并非是\",{\"1\":{\"391\":1}}],[\"也会将自己服务器设置为\",{\"1\":{\"1380\":1}}],[\"也会减少一次\",{\"1\":{\"1311\":1}}],[\"也会保证操作\",{\"1\":{\"974\":1}}],[\"也会像\",{\"1\":{\"604\":1}}],[\"也会出现\",{\"1\":{\"494\":1}}],[\"也会分为fromplace和toplace\",{\"1\":{\"443\":1}}],[\"也会用来加载这些业务类\",{\"1\":{\"359\":1}}],[\"也会用来加载\",{\"1\":{\"359\":1}}],[\"也会被自动删除\",{\"1\":{\"53\":1}}],[\"也保证了\",{\"1\":{\"358\":1}}],[\"也不参与\",{\"1\":{\"1355\":1}}],[\"也不参与写操作的\",{\"1\":{\"1355\":1}}],[\"也不想自己造一个小的\",{\"1\":{\"1132\":1}}],[\"也不需要担心\",{\"1\":{\"1099\":1}}],[\"也不需要获得对象锁\",{\"1\":{\"826\":1}}],[\"也不保证多少时间之后读取到的数据是最新的\",{\"1\":{\"1078\":1}}],[\"也不是说\",{\"1\":{\"1314\":1}}],[\"也不是尾节点\",{\"1\":{\"1013\":2}}],[\"也不是虚拟机规范中定义的内存区域\",{\"1\":{\"499\":1}}],[\"也不允许去\",{\"1\":{\"972\":1}}],[\"也不推荐使用\",{\"1\":{\"961\":1}}],[\"也不会抛出异常\",{\"1\":{\"891\":1}}],[\"也不会有死锁的问题\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"也不会导致\",{\"1\":{\"694\":1}}],[\"也不会靠随意回收具有强引用的对象来解决内存不足问题\",{\"1\":{\"392\":1}}],[\"也不能使用\",{\"1\":{\"688\":1}}],[\"也不能实现类似数据库回滚的原子性\",{\"1\":{\"288\":1}}],[\"也不存在于数据库中\",{\"1\":{\"306\":1,\"311\":1}}],[\"也比较重要\",{\"1\":{\"263\":1,\"831\":1}}],[\"也叫\",{\"1\":{\"1032\":1,\"1084\":1,\"1314\":1}}],[\"也叫递归锁\",{\"1\":{\"860\":1}}],[\"也叫作容器\",{\"1\":{\"639\":1}}],[\"也叫作辅助索引\",{\"1\":{\"114\":1}}],[\"也叫消费者\",{\"1\":{\"251\":1}}],[\"也是每个节点都放这个\",{\"1\":{\"1263\":1}}],[\"也是一个键值对的形式\",{\"1\":{\"1252\":1}}],[\"也是将消息路由到\",{\"1\":{\"1252\":1}}],[\"也是消息的终点\",{\"1\":{\"1250\":1}}],[\"也是分布式的\",{\"1\":{\"1240\":1}}],[\"也是最安全的\",{\"1\":{\"1206\":1}}],[\"也是通过建立\",{\"1\":{\"1158\":1}}],[\"也是通过过滤器来处理请求\",{\"1\":{\"5\":1,\"68\":1}}],[\"也是服务发现的一种\",{\"1\":{\"1157\":1}}],[\"也是清空该槽位数据\",{\"1\":{\"1037\":1}}],[\"也是碰到entry为null的桶结束\",{\"1\":{\"1036\":1}}],[\"也是基于这玩意\",{\"1\":{\"871\":1,\"874\":1}}],[\"也是可以考虑使用乐观锁的\",{\"1\":{\"838\":1,\"987\":1}}],[\"也是可以的\",{\"1\":{\"356\":1}}],[\"也是共享锁的一种实现\",{\"1\":{\"749\":1}}],[\"也是在程序中所定义的各种类型的字段内容\",{\"1\":{\"507\":1}}],[\"也是线程私有的\",{\"1\":{\"493\":1}}],[\"也是\",{\"1\":{\"166\":1,\"1172\":1}}],[\"也涉及到删除和释放所有的键值对\",{\"1\":{\"166\":1}}],[\"也有两个阶段\",{\"1\":{\"1372\":1}}],[\"也有很多复杂度不是\",{\"1\":{\"629\":1}}],[\"也有很多同学发表了自己的观点\",{\"1\":{\"567\":1}}],[\"也有自己在学习的一些线上课程的总结\",{\"1\":{\"472\":1}}],[\"也有百度\",{\"1\":{\"472\":1}}],[\"也有首次请求数据一定不再\",{\"1\":{\"146\":1}}],[\"也有可能产生数据不一致性的问题\",{\"1\":{\"145\":1}}],[\"也有介绍到\",{\"1\":{\"42\":1}}],[\"也有\",{\"1\":{\"37\":1}}],[\"也有一些局限性和不足之处\",{\"1\":{\"10\":1}}],[\"也分别是\",{\"1\":{\"23\":1}}],[\"也就意味着它没有主节点\",{\"1\":{\"1281\":1}}],[\"也就意味着效率会有一定损耗\",{\"1\":{\"821\":1}}],[\"也就说不需要保证\",{\"1\":{\"1068\":1}}],[\"也就不存在\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"也就不存在二义性问题\",{\"1\":{\"693\":1}}],[\"也就不适合使用数据库进行存储\",{\"1\":{\"19\":1}}],[\"也就没办法解决二义性问题了\",{\"1\":{\"693\":1}}],[\"也就导致实际上只有一个元素被添加到了\",{\"1\":{\"686\":1}}],[\"也就越稀疏\",{\"1\":{\"619\":1}}],[\"也就越少\",{\"1\":{\"619\":1}}],[\"也就越密\",{\"1\":{\"619\":1}}],[\"也就越多\",{\"1\":{\"619\":1}}],[\"也就无法加载它们\",{\"1\":{\"359\":1}}],[\"也就是用\",{\"1\":{\"1310\":1}}],[\"也就是用户看到的组成兑换码的字符\",{\"1\":{\"19\":1}}],[\"也就是图示的切换\",{\"1\":{\"1308\":2}}],[\"也就是对同一个消息的处理结果\",{\"1\":{\"1303\":1}}],[\"也就是接收消息的一方\",{\"1\":{\"1254\":1}}],[\"也就是你一个我一个的消费\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"也就是上文中提到的简易版拜占庭\",{\"1\":{\"1106\":1}}],[\"也就是牺牲数据的一致性来满足系统的高可用性\",{\"1\":{\"1074\":1}}],[\"也就是没有恶意节点\",{\"1\":{\"1096\":1}}],[\"也就是没有虚拟线程之前\",{\"1\":{\"1053\":1}}],[\"也就是没有任何引用\",{\"1\":{\"1030\":1}}],[\"也就是size\",{\"1\":{\"1038\":1}}],[\"也就是expungestaleentry方法\",{\"1\":{\"1037\":1}}],[\"也就是会出现我们\",{\"1\":{\"1030\":1}}],[\"也就是会让链表的长度增加\",{\"1\":{\"619\":1}}],[\"也就是我们写的代码就能拿到文件的数据\",{\"1\":{\"1308\":1}}],[\"也就是我们常说的弱引用类型\",{\"1\":{\"1029\":1}}],[\"也就是我们上面提到的\",{\"1\":{\"808\":1}}],[\"也就是虚节点\",{\"1\":{\"1013\":1}}],[\"也就是本文的核心\",{\"1\":{\"1002\":1}}],[\"也就是获取锁失败\",{\"1\":{\"1002\":1}}],[\"也就是获取锁成功\",{\"1\":{\"1002\":1}}],[\"也就是running或者shutdown状态下\",{\"1\":{\"941\":1}}],[\"也就是直接在调用execute方法的线程中运行\",{\"1\":{\"891\":1,\"936\":1}}],[\"也就是当读多写少的时候\",{\"1\":{\"872\":1}}],[\"也就是当前节点的后继节点的下标\",{\"1\":{\"732\":1}}],[\"也就是加\",{\"1\":{\"851\":1}}],[\"也就是不成功就一直循环执行直到成功\",{\"1\":{\"844\":1,\"993\":1}}],[\"也就是不保证线程安全\",{\"1\":{\"552\":1,\"656\":1}}],[\"也就是数据\",{\"1\":{\"838\":1,\"987\":1}}],[\"也就是数据在网络上传输的时间\",{\"1\":{\"285\":1}}],[\"也就是一个平台线程对应一个系统内核线程\",{\"1\":{\"1053\":1}}],[\"也就是一个\",{\"1\":{\"808\":1}}],[\"也就是达到了可以执行await\",{\"1\":{\"756\":1,\"911\":1}}],[\"也就是让锁恢复到未锁定状态\",{\"1\":{\"742\":1}}],[\"也就是待删除节点\",{\"1\":{\"731\":1}}],[\"也就是它的前一节点信息\",{\"1\":{\"729\":1}}],[\"也就是从链表中移除了这个元素\",{\"1\":{\"711\":1}}],[\"也就是从连接器到执行器的部分\",{\"1\":{\"83\":1}}],[\"也就是要尽量把数据分配均匀\",{\"1\":{\"684\":1}}],[\"也就是趋近于\",{\"1\":{\"619\":1}}],[\"也就是每一个\",{\"1\":{\"579\":1}}],[\"也就是每次查询都是跟数据库里当前所有事务提交状态来比对数据是否可见\",{\"1\":{\"141\":1}}],[\"也就是无界的\",{\"1\":{\"542\":1,\"672\":1}}],[\"也就是未逃逸出去\",{\"1\":{\"495\":1}}],[\"也就是字节码\",{\"1\":{\"494\":1,\"812\":1}}],[\"也就是年轻代中\",{\"1\":{\"451\":1}}],[\"也就是新生代大小\",{\"1\":{\"451\":1}}],[\"也就是强\",{\"1\":{\"446\":1}}],[\"也就是父类加载器都没有找到加载所需的\",{\"1\":{\"433\":1}}],[\"也就是得到类或者字段\",{\"1\":{\"343\":1}}],[\"也就是都是以第一次查询时当时数据库里所有事务提交状态来比对数据是否可见\",{\"1\":{\"141\":1}}],[\"也就是按照关键字进行排序\",{\"1\":{\"99\":1}}],[\"也就是先将\",{\"1\":{\"75\":1}}],[\"也就是说在消息队列中的分布式事务是\",{\"1\":{\"1304\":1}}],[\"也就是说在多年以前\",{\"1\":{\"1155\":1}}],[\"也就是说如果我们此时我们需要将一个消息发送给多个消费者\",{\"1\":{\"1278\":1}}],[\"也就是说我们后面的一系列服务都是需要同样的消息来进行处理\",{\"1\":{\"1272\":1}}],[\"也就是说相同参数的请求总是发到同一个服务提供者\",{\"1\":{\"1143\":1}}],[\"也就是说服务提供者中的每一个方法的活跃数都是互相独立的\",{\"1\":{\"1142\":1}}],[\"也就是说分区容错性\",{\"1\":{\"1068\":1}}],[\"也就是说当网络分区之后\",{\"1\":{\"1068\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"273\":1}}],[\"也就是说每个线程有一个自己的threadlocalmap\",{\"1\":{\"1029\":1}}],[\"也就是说正在等待的线程可以选择放弃等待\",{\"1\":{\"862\":1}}],[\"也就是说操作一旦开始\",{\"1\":{\"841\":1,\"990\":1}}],[\"也就是说默认可以同时支持\",{\"1\":{\"690\":1}}],[\"也就是说创建一个链表数组\",{\"1\":{\"618\":1,\"682\":1}}],[\"也就是说初始其实是空数组\",{\"1\":{\"553\":1}}],[\"也就是说永久代以及元空间是\",{\"1\":{\"496\":1}}],[\"也就是说老年代和新生代所占比值为\",{\"1\":{\"479\":1}}],[\"也就是说它们都是\",{\"1\":{\"421\":1}}],[\"也就是说字符串常量池被单独拿到堆\",{\"1\":{\"393\":1}}],[\"也就是说堆不存在该类的实例对象\",{\"1\":{\"345\":1}}],[\"也就是说这些请求最终都落到了数据库上\",{\"1\":{\"306\":1}}],[\"也就是说行的位置\",{\"1\":{\"108\":1}}],[\"也就是说\",{\"1\":{\"60\":1,\"76\":1,\"98\":1,\"125\":1,\"219\":1,\"236\":1,\"288\":1,\"352\":2,\"353\":1,\"456\":1,\"480\":1,\"493\":1,\"496\":1,\"619\":1,\"677\":1,\"680\":1,\"684\":1,\"690\":1,\"693\":1,\"752\":1,\"808\":2,\"835\":1,\"837\":1,\"892\":1,\"895\":1,\"908\":1,\"922\":1,\"938\":1,\"972\":1,\"974\":1,\"986\":1,\"1014\":1,\"1015\":1,\"1099\":1,\"1257\":1,\"1298\":1,\"1311\":1,\"1314\":1,\"1345\":1}}],[\"也就是说单台机器每毫秒最多可以生成\",{\"1\":{\"38\":1}}],[\"也就是前一个节点被删除之后\",{\"1\":{\"55\":1}}],[\"也就是\",{\"1\":{\"49\":1,\"89\":1,\"359\":1,\"393\":1,\"394\":1,\"861\":1,\"1002\":1,\"1006\":1,\"1067\":1,\"1152\":1,\"1264\":1}}],[\"也就是锁\",{\"1\":{\"48\":1}}],[\"也就是分布式系统单独有一个发号器服务\",{\"1\":{\"30\":1}}],[\"也就是可以将对象转换为字节流进行持久化存储或网络传输\",{\"1\":{\"549\":1,\"586\":1,\"727\":1}}],[\"也就是可以\",{\"1\":{\"19\":1}}],[\"也就是限制某一时刻内的请求数\",{\"1\":{\"2\":1}}],[\"和前面的持久顺序性节点一样\",{\"1\":{\"1382\":1}}],[\"和前驱节点\",{\"1\":{\"711\":1}}],[\"和一开始选举一样\",{\"1\":{\"1380\":1}}],[\"和一个fatherclassloader\",{\"1\":{\"356\":1}}],[\"和介绍\",{\"1\":{\"1378\":1}}],[\"和子节点个数\",{\"1\":{\"1349\":1}}],[\"和具体消息内容\",{\"1\":{\"1315\":1}}],[\"和事务消息\",{\"1\":{\"1304\":1}}],[\"和普通消息发送相比\",{\"1\":{\"1286\":1}}],[\"和普通消息不同的是\",{\"1\":{\"1285\":1}}],[\"和集群\",{\"1\":{\"1281\":1}}],[\"和所有\",{\"1\":{\"1281\":1}}],[\"和队列存放在哪呢\",{\"1\":{\"1281\":1}}],[\"和队列的关系\",{\"1\":{\"1281\":1}}],[\"和标签\",{\"1\":{\"1254\":1}}],[\"和消费者\",{\"0\":{\"1254\":1}}],[\"和消息\",{\"1\":{\"1315\":1}}],[\"和消息的存活时间\",{\"1\":{\"1257\":1}}],[\"和消息队列本质上是网络通讯的两种不同的实现机制\",{\"1\":{\"1232\":1}}],[\"和消息队列都是分布式微服务系统中重要的组件之一\",{\"1\":{\"1232\":1}}],[\"和消息队列的区别\",{\"0\":{\"1232\":1}}],[\"和消息接受者\",{\"1\":{\"1222\":1}}],[\"和消息体\",{\"1\":{\"1159\":1}}],[\"和实际运行结果完全不一样\",{\"1\":{\"1208\":1}}],[\"和自动提交一样\",{\"1\":{\"1207\":1}}],[\"和端口信息\",{\"1\":{\"1157\":1}}],[\"和各类\",{\"1\":{\"1154\":1,\"1161\":1}}],[\"和各种\",{\"1\":{\"978\":1}}],[\"和提议的值\",{\"1\":{\"1098\":1}}],[\"和已下线状态\",{\"1\":{\"1085\":1}}],[\"和已创建的最大事务id\",{\"1\":{\"141\":1}}],[\"和可用性\",{\"1\":{\"1073\":1}}],[\"和expungestaleentry\",{\"1\":{\"1036\":1}}],[\"和cleansomeslots\",{\"1\":{\"1035\":1}}],[\"和compareandsetstate\",{\"1\":{\"742\":1,\"904\":1}}],[\"和乐观锁\",{\"1\":{\"985\":1}}],[\"和操作\",{\"1\":{\"974\":1}}],[\"和我们上面说的\",{\"1\":{\"895\":1,\"922\":1}}],[\"和其他消息队列相比\",{\"0\":{\"1191\":1}}],[\"和其他的几个策略不同\",{\"1\":{\"891\":1}}],[\"和其前驱\",{\"1\":{\"711\":1}}],[\"和notify\",{\"1\":{\"862\":1}}],[\"和非公平锁\",{\"1\":{\"857\":1}}],[\"和内存资源\",{\"1\":{\"957\":1}}],[\"和内存消耗\",{\"1\":{\"298\":1}}],[\"和内核线程三者的关系可以阅读我写的这篇文章\",{\"1\":{\"808\":1}}],[\"和使用哈希算法实现\",{\"1\":{\"800\":1}}],[\"和任务\",{\"1\":{\"781\":1}}],[\"和异步任务\",{\"1\":{\"781\":1}}],[\"和share\",{\"1\":{\"743\":1}}],[\"和arraylist的详细对比\",{\"1\":{\"724\":1}}],[\"和arrayblockingqueue类似\",{\"1\":{\"671\":1}}],[\"和迭代\",{\"1\":{\"713\":1}}],[\"和后继节点\",{\"1\":{\"710\":1,\"711\":1}}],[\"和hashmap\",{\"1\":{\"679\":1}}],[\"和getvalue\",{\"1\":{\"625\":1}}],[\"和元素之间的比较规则\",{\"1\":{\"610\":1}}],[\"和toindex之间的元素\",{\"1\":{\"553\":1}}],[\"和上面的类似\",{\"1\":{\"949\":1}}],[\"和上面介绍的\",{\"1\":{\"535\":1}}],[\"和上一个方法一样\",{\"1\":{\"533\":1}}],[\"和上一次重写时\",{\"1\":{\"233\":1}}],[\"和接口的实现\",{\"1\":{\"519\":1}}],[\"和符号引用\",{\"1\":{\"497\":1}}],[\"和最小大小\",{\"1\":{\"496\":1}}],[\"和最大\",{\"1\":{\"478\":1}}],[\"和最大空间\",{\"1\":{\"456\":1}}],[\"和配置的最大堆内存有关\",{\"1\":{\"495\":1}}],[\"和虚拟机栈所发挥的作用非常相似\",{\"1\":{\"494\":1,\"812\":1}}],[\"和数据一致性\",{\"1\":{\"1368\":1}}],[\"和数据结构上的栈类似\",{\"1\":{\"493\":1}}],[\"和数据库打交道的时候\",{\"1\":{\"124\":1}}],[\"和数据库主键自增方案的缺点类似\",{\"1\":{\"35\":1}}],[\"和之前的版本略有不同\",{\"1\":{\"491\":1}}],[\"和老年代\",{\"1\":{\"452\":1}}],[\"和初始\",{\"1\":{\"451\":1}}],[\"和两个\",{\"1\":{\"449\":1}}],[\"和年龄\",{\"1\":{\"444\":1}}],[\"和栈一样\",{\"1\":{\"423\":1}}],[\"和用户线程\",{\"1\":{\"406\":1}}],[\"和线程池内有效线程的数量\",{\"1\":{\"941\":1}}],[\"和线程名称信息\",{\"1\":{\"807\":1}}],[\"和线程\",{\"1\":{\"370\":1,\"823\":1,\"972\":2}}],[\"和jinfo一样\",{\"1\":{\"368\":1}}],[\"和卸载\",{\"1\":{\"338\":1}}],[\"和第\",{\"1\":{\"327\":2,\"552\":1,\"656\":1}}],[\"和带宽\",{\"1\":{\"297\":1}}],[\"和write\",{\"1\":{\"285\":1}}],[\"和订阅者\",{\"1\":{\"251\":1}}],[\"和专业的消息队列相比\",{\"1\":{\"182\":1,\"251\":2}}],[\"和缓存\",{\"1\":{\"145\":1}}],[\"和串行化\",{\"1\":{\"125\":1}}],[\"和原始\",{\"1\":{\"40\":1}}],[\"和路由监控等插件\",{\"1\":{\"9\":1}}],[\"和\",{\"0\":{\"236\":1,\"245\":1,\"478\":1,\"516\":1,\"517\":1,\"542\":1,\"543\":1,\"550\":1,\"560\":1,\"611\":1,\"649\":1,\"650\":1,\"651\":1,\"661\":1,\"665\":1,\"672\":1,\"677\":1,\"678\":1,\"679\":1,\"688\":1,\"692\":1,\"693\":1,\"713\":1,\"719\":1,\"855\":1,\"859\":1,\"900\":1,\"962\":1,\"976\":1,\"1153\":1,\"1156\":1,\"1180\":1,\"1198\":1,\"1225\":1,\"1248\":1},\"1\":{\"5\":1,\"6\":2,\"8\":3,\"10\":2,\"21\":1,\"23\":4,\"35\":1,\"41\":1,\"50\":1,\"51\":1,\"53\":1,\"68\":1,\"71\":1,\"72\":1,\"75\":1,\"89\":2,\"96\":1,\"117\":1,\"132\":1,\"133\":1,\"145\":1,\"146\":2,\"147\":3,\"157\":2,\"174\":1,\"181\":1,\"192\":1,\"193\":2,\"195\":2,\"201\":2,\"202\":1,\"212\":1,\"224\":1,\"231\":2,\"235\":3,\"236\":3,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"251\":1,\"256\":1,\"261\":2,\"263\":1,\"265\":1,\"280\":1,\"282\":1,\"287\":1,\"301\":2,\"344\":1,\"359\":4,\"380\":1,\"382\":1,\"390\":1,\"396\":1,\"402\":1,\"407\":1,\"408\":1,\"422\":1,\"443\":2,\"444\":2,\"448\":1,\"449\":1,\"454\":1,\"472\":1,\"485\":1,\"491\":1,\"494\":1,\"495\":1,\"496\":1,\"498\":1,\"503\":1,\"524\":1,\"529\":1,\"531\":1,\"533\":1,\"534\":1,\"535\":4,\"537\":2,\"541\":1,\"542\":1,\"543\":1,\"552\":1,\"557\":1,\"558\":1,\"559\":1,\"571\":2,\"577\":1,\"598\":2,\"607\":1,\"611\":1,\"616\":1,\"621\":1,\"632\":1,\"639\":1,\"651\":2,\"656\":1,\"665\":2,\"667\":1,\"668\":1,\"669\":1,\"672\":1,\"677\":2,\"686\":1,\"688\":3,\"693\":2,\"694\":3,\"708\":2,\"719\":1,\"731\":2,\"732\":1,\"747\":1,\"748\":1,\"755\":2,\"765\":1,\"774\":1,\"779\":1,\"781\":5,\"782\":1,\"792\":1,\"807\":1,\"808\":1,\"810\":1,\"816\":2,\"820\":1,\"834\":1,\"838\":1,\"851\":1,\"853\":1,\"857\":1,\"860\":1,\"861\":1,\"865\":1,\"873\":1,\"881\":1,\"883\":1,\"889\":2,\"892\":2,\"900\":2,\"901\":1,\"905\":1,\"910\":2,\"917\":2,\"924\":1,\"934\":1,\"937\":2,\"938\":2,\"949\":1,\"951\":2,\"953\":1,\"955\":1,\"972\":2,\"974\":2,\"987\":1,\"1002\":2,\"1007\":1,\"1011\":2,\"1012\":1,\"1019\":1,\"1021\":1,\"1053\":1,\"1066\":1,\"1068\":2,\"1070\":1,\"1073\":1,\"1074\":1,\"1085\":1,\"1086\":1,\"1103\":1,\"1105\":4,\"1108\":1,\"1112\":5,\"1115\":2,\"1122\":1,\"1130\":1,\"1131\":1,\"1132\":1,\"1147\":1,\"1151\":1,\"1152\":2,\"1155\":1,\"1156\":1,\"1159\":1,\"1161\":2,\"1169\":1,\"1172\":3,\"1179\":1,\"1191\":1,\"1192\":1,\"1218\":1,\"1231\":1,\"1238\":1,\"1240\":7,\"1248\":1,\"1249\":3,\"1252\":6,\"1253\":1,\"1257\":1,\"1277\":1,\"1280\":1,\"1281\":4,\"1292\":1,\"1296\":1,\"1299\":1,\"1303\":1,\"1312\":1,\"1315\":4,\"1331\":1,\"1344\":1,\"1351\":1,\"1355\":3,\"1357\":1,\"1367\":1,\"1370\":1,\"1371\":1,\"1372\":1,\"1378\":1,\"1379\":4,\"1380\":4,\"1382\":2,\"1387\":1,\"1390\":1}}],[\"observing\",{\"1\":{\"1356\":1}}],[\"observer观察者\",{\"1\":{\"1378\":1}}],[\"observer\",{\"1\":{\"1355\":6,\"1356\":2,\"1378\":1,\"1379\":3}}],[\"obj2\",{\"1\":{\"661\":1}}],[\"obj1\",{\"1\":{\"661\":1}}],[\"obj\",{\"1\":{\"523\":1,\"630\":3,\"661\":1,\"697\":1,\"882\":2}}],[\"objb\",{\"1\":{\"390\":5}}],[\"obja\",{\"1\":{\"390\":5}}],[\"objectmessage\",{\"1\":{\"1226\":1}}],[\"objectmonitor对象\",{\"1\":{\"851\":1}}],[\"objectmapper\",{\"1\":{\"77\":2}}],[\"objectfieldoffset\",{\"1\":{\"765\":2,\"1011\":5}}],[\"object类\",{\"1\":{\"633\":1}}],[\"object>>\",{\"1\":{\"1204\":1}}],[\"object>\",{\"1\":{\"632\":1,\"1204\":1}}],[\"object\",{\"1\":{\"307\":3,\"330\":2,\"351\":2,\"358\":7,\"370\":12,\"390\":1,\"391\":3,\"446\":1,\"533\":2,\"534\":1,\"535\":2,\"538\":3,\"550\":1,\"552\":2,\"553\":15,\"555\":6,\"557\":1,\"561\":2,\"562\":1,\"573\":1,\"578\":1,\"586\":1,\"587\":6,\"588\":2,\"589\":3,\"591\":4,\"592\":5,\"618\":1,\"619\":1,\"622\":1,\"623\":2,\"632\":3,\"634\":2,\"642\":2,\"644\":1,\"650\":1,\"656\":2,\"661\":3,\"682\":1,\"693\":2,\"697\":5,\"710\":1,\"711\":2,\"731\":1,\"823\":4,\"825\":1,\"826\":2,\"841\":5,\"848\":1,\"883\":2,\"884\":2,\"943\":1,\"990\":5,\"1001\":1,\"1030\":4,\"1032\":1,\"1036\":2,\"1046\":3,\"1299\":2}}],[\"objects\",{\"1\":{\"268\":1,\"351\":1,\"369\":1,\"553\":2,\"619\":4,\"630\":3,\"732\":1,\"779\":2}}],[\"objectid\",{\"1\":{\"35\":2}}],[\"o2\",{\"1\":{\"662\":2}}],[\"o1\",{\"1\":{\"662\":2}}],[\"overview\",{\"1\":{\"1169\":1}}],[\"over\",{\"1\":{\"633\":1,\"1166\":1}}],[\"overflow\",{\"1\":{\"553\":2,\"559\":1,\"748\":1,\"1007\":1,\"1018\":1}}],[\"overhead\",{\"1\":{\"495\":1,\"573\":1}}],[\"override\",{\"1\":{\"49\":1,\"56\":1,\"77\":1,\"354\":1,\"599\":2,\"634\":7,\"662\":1,\"663\":1,\"679\":1,\"706\":1,\"882\":2,\"894\":1,\"920\":1,\"940\":2,\"1020\":4,\"1043\":1,\"1046\":4,\"1047\":2,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1140\":1,\"1141\":1,\"1142\":1,\"1210\":1,\"1212\":1,\"1299\":1}}],[\"oldlen\",{\"1\":{\"1038\":3}}],[\"oldthr\",{\"1\":{\"624\":4}}],[\"oldtab中所有的entry数据都已经放入到新的tab中了\",{\"1\":{\"1038\":1}}],[\"oldtab\",{\"1\":{\"624\":7,\"1038\":3}}],[\"oldtable\",{\"1\":{\"572\":3}}],[\"oldcap\",{\"1\":{\"624\":9}}],[\"oldcapacity\",{\"1\":{\"553\":3,\"558\":9,\"572\":3}}],[\"oldcapacity为旧容量\",{\"1\":{\"553\":1,\"558\":1}}],[\"oldval\",{\"1\":{\"577\":5,\"697\":1}}],[\"oldvalue\",{\"1\":{\"553\":4,\"571\":4,\"591\":2,\"619\":2,\"622\":5,\"630\":3,\"712\":3}}],[\"oldsize\",{\"1\":{\"572\":1}}],[\"old收集器运行示意图\",{\"1\":{\"403\":1,\"405\":1}}],[\"old\",{\"0\":{\"404\":1,\"405\":1},\"1\":{\"382\":1,\"387\":1,\"400\":1,\"403\":1,\"405\":1,\"448\":1,\"495\":2}}],[\"oauth\",{\"1\":{\"293\":2}}],[\"oss\",{\"1\":{\"1200\":1}}],[\"osgi\",{\"1\":{\"1132\":1}}],[\"osc\",{\"1\":{\"1122\":1}}],[\"oschina\",{\"1\":{\"409\":1}}],[\"os\",{\"1\":{\"242\":1,\"1052\":1,\"1062\":11}}],[\"opt\",{\"1\":{\"1257\":1}}],[\"optimisticlock\",{\"1\":{\"985\":1}}],[\"optimization\",{\"1\":{\"218\":1,\"221\":1}}],[\"options\",{\"1\":{\"451\":1}}],[\"option\",{\"1\":{\"366\":1,\"480\":1}}],[\"op\",{\"1\":{\"687\":8}}],[\"ops\",{\"1\":{\"268\":1}}],[\"opcodes\",{\"1\":{\"268\":1}}],[\"operator\",{\"1\":{\"634\":1}}],[\"operation\",{\"1\":{\"202\":1}}],[\"operations\",{\"1\":{\"201\":1,\"553\":1}}],[\"open\",{\"1\":{\"1311\":1}}],[\"openjdk\",{\"1\":{\"485\":1}}],[\"openresty\",{\"0\":{\"6\":1},\"1\":{\"6\":9,\"7\":2,\"8\":1,\"10\":1}}],[\"openapi\",{\"1\":{\"2\":1}}],[\"oom\",{\"0\":{\"484\":1},\"1\":{\"218\":1,\"368\":1,\"412\":3,\"443\":1,\"444\":1,\"455\":2,\"456\":3,\"889\":3,\"892\":1,\"895\":1,\"897\":2,\"917\":5,\"922\":1,\"937\":3,\"938\":1,\"951\":1,\"955\":1,\"959\":1}}],[\"other\",{\"1\":{\"206\":3,\"480\":1,\"621\":1,\"781\":4,\"882\":1}}],[\"onnextbackoff\",{\"1\":{\"1210\":1}}],[\"ongardie\",{\"1\":{\"1117\":1}}],[\"onoutofmemoryerror\",{\"1\":{\"484\":1}}],[\"onoutofmemoryerror=\",{\"1\":{\"484\":2}}],[\"onesizefitsquorum\",{\"1\":{\"1117\":1}}],[\"one\",{\"1\":{\"302\":1,\"370\":1,\"377\":2,\"693\":2,\"705\":2,\"706\":1}}],[\"on\",{\"0\":{\"585\":1},\"1\":{\"201\":1,\"369\":1,\"572\":1,\"584\":1,\"585\":3,\"588\":1,\"793\":1,\"871\":1,\"1011\":3,\"1014\":1}}],[\"onlyifabsent为false或者旧值为null\",{\"1\":{\"622\":1}}],[\"onlyifabsent\",{\"1\":{\"571\":2,\"577\":3,\"622\":2,\"680\":1,\"686\":2,\"712\":2}}],[\"only\",{\"1\":{\"35\":1,\"224\":1,\"229\":1,\"282\":1,\"618\":1,\"682\":1,\"708\":1,\"767\":2,\"871\":1,\"941\":1}}],[\"ofseconds\",{\"1\":{\"1293\":2}}],[\"ofvirtual\",{\"0\":{\"1059\":1},\"1\":{\"1057\":1,\"1059\":2,\"1060\":1}}],[\"off\",{\"1\":{\"1210\":3}}],[\"offerlast\",{\"1\":{\"667\":1}}],[\"offerfirst\",{\"1\":{\"667\":1}}],[\"offer的线程\",{\"1\":{\"604\":1}}],[\"offerpollexample\",{\"1\":{\"531\":1}}],[\"offer\",{\"1\":{\"531\":6,\"533\":10,\"535\":1,\"536\":7,\"537\":4,\"539\":2,\"541\":1,\"603\":7,\"667\":1,\"897\":1,\"941\":1,\"958\":2,\"1177\":1}}],[\"offfer\",{\"1\":{\"530\":1}}],[\"offsetweight\",{\"1\":{\"1142\":3}}],[\"offset\",{\"1\":{\"201\":1,\"202\":4,\"212\":1,\"261\":2,\"571\":1,\"841\":4,\"990\":4,\"1141\":2,\"1202\":2,\"1205\":9,\"1207\":3,\"1209\":1,\"1280\":1,\"1315\":2}}],[\"of\",{\"1\":{\"201\":1,\"205\":2,\"256\":7,\"270\":1,\"272\":1,\"293\":6,\"302\":2,\"351\":2,\"354\":1,\"356\":2,\"480\":3,\"511\":1,\"570\":2,\"593\":1,\"618\":1,\"634\":3,\"677\":1,\"682\":1,\"708\":2,\"798\":2,\"843\":1,\"918\":2,\"974\":1,\"992\":1,\"1011\":2,\"1014\":1,\"1022\":1,\"1097\":2,\"1209\":1}}],[\"o操作过程\",{\"1\":{\"99\":1}}],[\"oracceptstage\",{\"1\":{\"781\":2}}],[\"oracle\",{\"1\":{\"334\":1,\"345\":1,\"360\":2,\"386\":2,\"409\":1,\"480\":1,\"511\":1,\"876\":2,\"1178\":4}}],[\"orange\",{\"1\":{\"634\":2,\"733\":4}}],[\"original\",{\"1\":{\"562\":3,\"571\":1}}],[\"oriented\",{\"1\":{\"201\":1}}],[\"or\",{\"1\":{\"120\":2,\"202\":1,\"261\":1,\"351\":1,\"356\":3,\"571\":2,\"634\":1,\"680\":1,\"708\":1,\"756\":1,\"820\":1,\"911\":1}}],[\"ordering\",{\"1\":{\"767\":2,\"974\":1}}],[\"ordered\",{\"1\":{\"570\":1}}],[\"order\",{\"1\":{\"77\":1,\"1011\":1}}],[\"org\",{\"1\":{\"6\":1,\"8\":1,\"9\":1,\"11\":1,\"221\":1,\"365\":1,\"1045\":1,\"1100\":1,\"1131\":7,\"1140\":1,\"1143\":1,\"1168\":1,\"1171\":1,\"1185\":1,\"1214\":1,\"1235\":2,\"1236\":1,\"1238\":1}}],[\"owningthread\",{\"1\":{\"56\":4}}],[\"outofboundsmsg\",{\"1\":{\"553\":3}}],[\"outofmemory\",{\"1\":{\"392\":1,\"484\":1}}],[\"outofmemoryerror\",{\"1\":{\"392\":1,\"435\":1,\"439\":1,\"480\":2,\"484\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":3,\"496\":3,\"497\":1,\"499\":1,\"553\":1,\"559\":1}}],[\"output\",{\"1\":{\"370\":1,\"662\":1,\"663\":1,\"823\":1}}],[\"out\",{\"1\":{\"53\":6,\"270\":1,\"272\":1,\"353\":1,\"370\":6,\"433\":1,\"451\":14,\"498\":1,\"531\":11,\"551\":1,\"561\":1,\"562\":1,\"564\":2,\"593\":10,\"599\":3,\"625\":20,\"631\":1,\"634\":6,\"649\":5,\"652\":1,\"662\":8,\"663\":1,\"679\":1,\"704\":1,\"705\":1,\"706\":1,\"713\":5,\"732\":2,\"733\":8,\"749\":2,\"753\":3,\"756\":1,\"757\":6,\"763\":3,\"766\":4,\"767\":14,\"768\":2,\"778\":1,\"779\":3,\"780\":1,\"781\":6,\"782\":5,\"785\":1,\"807\":1,\"823\":6,\"824\":3,\"835\":1,\"851\":1,\"852\":1,\"860\":2,\"882\":2,\"909\":2,\"911\":1,\"940\":3,\"944\":2,\"1020\":1,\"1028\":2,\"1030\":2,\"1043\":2,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":2,\"1213\":1,\"1293\":1}}],[\"ok\",{\"1\":{\"35\":1,\"48\":1,\"177\":4,\"185\":1,\"206\":1,\"270\":1,\"280\":17,\"298\":1,\"302\":1,\"927\":1,\"1155\":1}}],[\"o\",{\"0\":{\"157\":1},\"1\":{\"5\":1,\"19\":1,\"68\":1,\"97\":1,\"98\":1,\"157\":9,\"176\":2,\"230\":1,\"256\":2,\"265\":3,\"285\":2,\"293\":5,\"301\":9,\"319\":3,\"499\":3,\"533\":2,\"538\":4,\"552\":5,\"553\":11,\"588\":3,\"591\":1,\"592\":3,\"599\":3,\"619\":4,\"629\":3,\"632\":11,\"634\":2,\"653\":8,\"654\":3,\"656\":7,\"658\":2,\"663\":3,\"668\":1,\"669\":1,\"691\":2,\"697\":1,\"724\":2,\"725\":3,\"729\":2,\"731\":3,\"800\":1,\"808\":1,\"841\":4,\"895\":4,\"922\":4,\"990\":4,\"1030\":5,\"1056\":1,\"1204\":2,\"1209\":3}}],[\"i=3\",{\"1\":{\"968\":1}}],[\"i=2\",{\"1\":{\"968\":1}}],[\"i=1\",{\"1\":{\"968\":1}}],[\"i=0\",{\"1\":{\"634\":1,\"882\":1}}],[\"iwehdio\",{\"1\":{\"913\":1}}],[\"i<10\",{\"1\":{\"882\":1}}],[\"i<n\",{\"1\":{\"634\":1,\"1290\":1}}],[\"ie\",{\"1\":{\"756\":2,\"911\":2,\"1155\":1}}],[\"ilp\",{\"1\":{\"969\":1}}],[\"il\",{\"1\":{\"634\":2}}],[\"illegalmonitorstateexception\",{\"1\":{\"1014\":1}}],[\"illegalmonitorstateexception的异常的原因\",{\"1\":{\"851\":1}}],[\"illegalthreadstateexception\",{\"1\":{\"941\":1}}],[\"illegal\",{\"1\":{\"553\":1,\"555\":1,\"621\":2,\"677\":2}}],[\"illegalaccessexception\",{\"1\":{\"1030\":1}}],[\"illegalaccesserror\",{\"1\":{\"341\":1}}],[\"illegalargumentexception\",{\"1\":{\"534\":2,\"553\":1,\"555\":1,\"570\":1,\"621\":2,\"677\":2,\"748\":2,\"752\":1,\"756\":1,\"798\":2,\"890\":1,\"911\":1,\"936\":1}}],[\"illegalstateexception\",{\"1\":{\"53\":1,\"533\":2,\"536\":2,\"539\":1,\"732\":1}}],[\"i++\",{\"1\":{\"531\":1,\"534\":1,\"553\":4,\"561\":1,\"564\":2,\"572\":1,\"632\":2,\"634\":1,\"649\":1,\"706\":1,\"713\":2,\"730\":1,\"749\":1,\"753\":2,\"757\":2,\"835\":1,\"882\":1,\"909\":1,\"940\":1,\"968\":2,\"1001\":1,\"1020\":1,\"1062\":1,\"1141\":2,\"1142\":2,\"1209\":1,\"1290\":1}}],[\"ibm\",{\"1\":{\"377\":1}}],[\"ibd文件\",{\"1\":{\"94\":1}}],[\"itr\",{\"1\":{\"553\":1}}],[\"itrs\",{\"1\":{\"535\":2}}],[\"iteratorbinarysearch\",{\"1\":{\"658\":1}}],[\"iterator\",{\"1\":{\"553\":1,\"631\":6,\"713\":2}}],[\"iterator<e>\",{\"1\":{\"553\":1}}],[\"item\",{\"1\":{\"727\":2,\"730\":3,\"731\":4,\"732\":2}}],[\"itemat\",{\"1\":{\"536\":3}}],[\"items\",{\"1\":{\"293\":3,\"534\":2,\"535\":11,\"536\":2,\"537\":1,\"538\":4}}],[\"itself\",{\"1\":{\"356\":2}}],[\"its\",{\"1\":{\"351\":1,\"356\":1,\"553\":3}}],[\"it\",{\"1\":{\"302\":1,\"351\":1,\"412\":1,\"553\":1,\"564\":1,\"571\":1,\"634\":3,\"882\":1,\"1322\":1}}],[\"ignored\",{\"1\":{\"1062\":1}}],[\"ignore\",{\"1\":{\"220\":1,\"629\":1}}],[\"isr\",{\"1\":{\"1206\":1}}],[\"isrunning\",{\"1\":{\"941\":4}}],[\"isblank\",{\"1\":{\"1046\":1}}],[\"isgc\",{\"1\":{\"1030\":2}}],[\"isalive\",{\"1\":{\"941\":1}}],[\"isacquiredinthisprocess\",{\"1\":{\"53\":4}}],[\"isterminated\",{\"0\":{\"946\":1},\"1\":{\"940\":2,\"946\":1}}],[\"isshutdown\",{\"0\":{\"946\":1},\"1\":{\"891\":1,\"946\":1}}],[\"issue645\",{\"1\":{\"749\":1}}],[\"issue672\",{\"1\":{\"386\":1}}],[\"issue747\",{\"1\":{\"393\":1}}],[\"issue1199\",{\"1\":{\"386\":1}}],[\"issue552\",{\"1\":{\"386\":1,\"495\":1}}],[\"issue871\",{\"1\":{\"359\":1}}],[\"issue\",{\"1\":{\"231\":1,\"233\":1,\"280\":1,\"281\":3,\"345\":1,\"480\":2,\"498\":1,\"687\":1,\"708\":1,\"762\":1,\"895\":1,\"922\":1,\"968\":1,\"1007\":1,\"1069\":1}}],[\"isdone\",{\"1\":{\"773\":1,\"774\":1,\"777\":2,\"782\":1,\"899\":1}}],[\"iscancelled\",{\"1\":{\"773\":1,\"774\":1,\"899\":1}}],[\"ismarked\",{\"1\":{\"767\":5}}],[\"ismale=1\",{\"1\":{\"117\":1}}],[\"isheldexclusively\",{\"1\":{\"744\":1,\"1007\":1,\"1020\":1}}],[\"iselementindex\",{\"1\":{\"730\":1}}],[\"isempty\",{\"1\":{\"553\":1,\"599\":1,\"625\":2,\"629\":4,\"632\":2,\"941\":1,\"1062\":1,\"1210\":1}}],[\"isnotblank\",{\"1\":{\"1046\":1}}],[\"isnull\",{\"1\":{\"732\":1}}],[\"isn\",{\"1\":{\"693\":1}}],[\"isnan\",{\"1\":{\"621\":1,\"677\":1}}],[\"is\",{\"1\":{\"201\":2,\"243\":1,\"256\":2,\"293\":1,\"298\":1,\"302\":3,\"320\":2,\"351\":6,\"369\":1,\"370\":2,\"386\":2,\"449\":1,\"480\":2,\"553\":2,\"558\":2,\"571\":3,\"693\":2,\"756\":1,\"757\":4,\"767\":2,\"798\":1,\"882\":1,\"911\":1,\"941\":1,\"1011\":1,\"1096\":1}}],[\"isolation\",{\"1\":{\"125\":1,\"281\":1}}],[\"images\",{\"1\":{\"918\":1,\"1088\":1}}],[\"imooc\",{\"1\":{\"720\":1}}],[\"immutablelist\",{\"1\":{\"634\":2}}],[\"impl\",{\"1\":{\"1169\":1}}],[\"implementation\",{\"1\":{\"577\":1}}],[\"implements\",{\"1\":{\"77\":1,\"330\":1,\"533\":1,\"549\":1,\"553\":1,\"586\":1,\"599\":1,\"600\":1,\"619\":2,\"634\":1,\"663\":1,\"690\":1,\"713\":2,\"727\":1,\"732\":1,\"740\":1,\"774\":1,\"797\":1,\"857\":1,\"865\":1,\"871\":1,\"882\":1,\"883\":1,\"891\":1,\"894\":1,\"901\":1,\"903\":1,\"920\":1,\"934\":1,\"940\":1,\"961\":1,\"1046\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1131\":1,\"1140\":1}}],[\"import\",{\"1\":{\"429\":1,\"625\":3,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"882\":2,\"894\":3,\"920\":3,\"940\":4,\"1131\":4}}],[\"im\",{\"1\":{\"415\":1,\"801\":1}}],[\"img\",{\"1\":{\"106\":1,\"107\":1,\"109\":1,\"135\":2,\"137\":1,\"140\":1,\"141\":4,\"261\":1,\"1011\":1}}],[\"ifndef\",{\"1\":{\"268\":1}}],[\"ifdef\",{\"1\":{\"218\":1}}],[\"if\",{\"1\":{\"47\":2,\"49\":3,\"53\":1,\"56\":4,\"70\":1,\"218\":1,\"307\":2,\"351\":1,\"353\":1,\"357\":4,\"386\":1,\"495\":1,\"531\":1,\"533\":2,\"534\":1,\"535\":3,\"536\":3,\"537\":2,\"538\":4,\"553\":29,\"555\":4,\"557\":2,\"558\":5,\"559\":1,\"564\":2,\"570\":4,\"571\":20,\"572\":3,\"573\":2,\"576\":3,\"577\":16,\"578\":5,\"587\":2,\"591\":1,\"592\":1,\"599\":1,\"603\":1,\"604\":6,\"619\":4,\"621\":7,\"622\":13,\"623\":5,\"624\":14,\"629\":2,\"630\":2,\"632\":6,\"658\":1,\"663\":2,\"677\":3,\"680\":2,\"683\":7,\"686\":4,\"693\":1,\"694\":2,\"710\":6,\"711\":5,\"712\":4,\"713\":5,\"729\":3,\"730\":3,\"731\":7,\"732\":4,\"748\":8,\"752\":6,\"756\":13,\"780\":2,\"798\":2,\"834\":2,\"883\":1,\"890\":2,\"891\":1,\"900\":1,\"906\":3,\"911\":13,\"924\":1,\"936\":2,\"941\":19,\"1001\":1,\"1002\":1,\"1007\":4,\"1008\":2,\"1011\":9,\"1012\":6,\"1013\":6,\"1014\":12,\"1015\":3,\"1018\":8,\"1030\":2,\"1031\":1,\"1036\":13,\"1037\":4,\"1038\":5,\"1041\":3,\"1042\":1,\"1043\":2,\"1046\":2,\"1047\":1,\"1062\":2,\"1141\":3,\"1142\":6,\"1204\":1,\"1209\":1,\"1210\":5,\"1213\":1}}],[\"ip\",{\"1\":{\"22\":4,\"207\":1,\"302\":1,\"373\":2,\"1085\":1,\"1151\":1,\"1157\":5,\"1199\":1,\"1351\":2,\"1390\":2}}],[\"ids\",{\"1\":{\"1199\":1}}],[\"idx\",{\"1\":{\"572\":3}}],[\"ide\",{\"1\":{\"1132\":2}}],[\"ideally\",{\"1\":{\"708\":1}}],[\"idea\",{\"1\":{\"325\":1,\"882\":2,\"1132\":1,\"1199\":1}}],[\"identical\",{\"1\":{\"41\":1}}],[\"identifier\",{\"1\":{\"37\":1,\"365\":1}}],[\"id且300不在\",{\"1\":{\"141\":1}}],[\"id不在视图数组中\",{\"1\":{\"141\":1}}],[\"id就是当前自己的事务是可见的\",{\"1\":{\"141\":1}}],[\"id就是当前自己的事务则是可见的\",{\"1\":{\"141\":1}}],[\"id在视图数组中\",{\"1\":{\"141\":1}}],[\"id<=max\",{\"1\":{\"141\":1}}],[\"id<=trx\",{\"1\":{\"141\":1}}],[\"id<min\",{\"1\":{\"141\":1}}],[\"id落在中间部分\",{\"1\":{\"141\":1}}],[\"id落在最右边部分\",{\"1\":{\"141\":1}}],[\"id落在最左边部分\",{\"1\":{\"141\":1}}],[\"id>max\",{\"1\":{\"141\":1}}],[\"id和roll\",{\"1\":{\"141\":1}}],[\"id5\",{\"1\":{\"117\":1}}],[\"id4\",{\"1\":{\"117\":1}}],[\"id3\",{\"1\":{\"117\":2}}],[\"id作为聚簇索引\",{\"1\":{\"113\":1}}],[\"id=2\",{\"1\":{\"89\":5}}],[\"id=1\",{\"1\":{\"81\":1,\"86\":2}}],[\"id+step\",{\"1\":{\"34\":1}}],[\"id`\",{\"1\":{\"33\":1,\"34\":4}}],[\"id了\",{\"1\":{\"29\":1}}],[\"id\",{\"0\":{\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1},\"1\":{\"15\":5,\"16\":1,\"17\":2,\"18\":2,\"19\":5,\"22\":6,\"24\":7,\"28\":8,\"29\":3,\"30\":16,\"33\":7,\"34\":22,\"35\":12,\"37\":5,\"38\":10,\"40\":3,\"41\":6,\"42\":5,\"43\":6,\"75\":1,\"86\":2,\"89\":1,\"96\":5,\"106\":1,\"120\":1,\"125\":2,\"141\":9,\"168\":2,\"257\":3,\"261\":1,\"262\":1,\"307\":3,\"365\":2,\"366\":1,\"484\":1,\"630\":1,\"807\":1,\"1046\":1,\"1098\":1,\"1202\":1,\"1260\":1,\"1275\":1,\"1346\":1,\"1349\":4,\"1351\":1,\"1379\":3,\"1382\":3,\"1389\":2}}],[\"inet\",{\"1\":{\"1151\":1}}],[\"invocation\",{\"1\":{\"1123\":1,\"1130\":1,\"1131\":3,\"1140\":6,\"1141\":3,\"1142\":4}}],[\"invoke\",{\"1\":{\"1129\":1}}],[\"invoker<\",{\"1\":{\"1140\":1}}],[\"invoker<t>\",{\"1\":{\"1131\":1,\"1140\":2,\"1141\":1,\"1142\":2}}],[\"invokers\",{\"1\":{\"1131\":1,\"1140\":2,\"1141\":5,\"1142\":8}}],[\"invoker\",{\"0\":{\"1129\":1},\"1\":{\"1129\":8,\"1130\":1,\"1131\":1,\"1140\":1,\"1142\":10}}],[\"invokestatic\",{\"1\":{\"344\":2}}],[\"invokedynamic\",{\"1\":{\"328\":1}}],[\"inheritthreadlocals\",{\"1\":{\"1043\":2}}],[\"inheritablethreadlocal<>\",{\"1\":{\"1043\":1}}],[\"inheritablethreadlocaldemo\",{\"1\":{\"1043\":1}}],[\"inheritablethreadlocal\",{\"0\":{\"1043\":1},\"1\":{\"1043\":5}}],[\"inheritablethreadlocals\",{\"1\":{\"883\":2,\"1043\":3}}],[\"inner\",{\"1\":{\"941\":1}}],[\"innodb存储引擎并不是真正的删除原来的记录\",{\"1\":{\"141\":1}}],[\"innodb存储引擎通过事务的undo日志巧妙地实现了多版本的数据快照\",{\"1\":{\"141\":1}}],[\"innodb引擎默认隔离级别\",{\"1\":{\"132\":1}}],[\"innodb索引原理\",{\"1\":{\"120\":1}}],[\"innodb索引有聚簇索引和辅助索引\",{\"1\":{\"112\":1}}],[\"innodb二级索引\",{\"1\":{\"114\":1}}],[\"innodb的表要求必须要有聚簇索引\",{\"1\":{\"113\":1}}],[\"innodb必须要有\",{\"1\":{\"112\":1}}],[\"innodb必须有个密集索引\",{\"1\":{\"106\":1}}],[\"innodb数据通过page存储\",{\"1\":{\"109\":1}}],[\"innodb在移动行时无须更新辅助索引中的这个\",{\"1\":{\"108\":1}}],[\"innodb为什么使用聚簇索引呢\",{\"0\":{\"108\":1}}],[\"innodb生成一个隐藏主键作为密集索引\",{\"1\":{\"106\":1}}],[\"innodb使用的是聚簇索引\",{\"1\":{\"106\":1}}],[\"innodb\",{\"1\":{\"37\":1,\"83\":2,\"89\":5,\"90\":2,\"94\":1,\"101\":2,\"105\":1,\"117\":2,\"124\":2,\"147\":1}}],[\"init方法在thread的构造方法中被调用\",{\"1\":{\"1043\":1}}],[\"inittable\",{\"0\":{\"576\":1},\"1\":{\"576\":1,\"577\":1}}],[\"init\",{\"0\":{\"506\":1},\"1\":{\"1043\":1}}],[\"initialvalue\",{\"1\":{\"882\":1}}],[\"initialmark\",{\"1\":{\"767\":5}}],[\"initialstamp\",{\"1\":{\"767\":5}}],[\"initialref\",{\"1\":{\"767\":10}}],[\"initial\",{\"1\":{\"570\":3,\"619\":1,\"621\":1,\"624\":4,\"677\":1,\"1032\":3}}],[\"initialcapacity\",{\"1\":{\"553\":5,\"555\":5,\"570\":6,\"621\":10,\"677\":8,\"709\":6}}],[\"initialheapsize=262921408\",{\"1\":{\"403\":1}}],[\"initializaton\",{\"1\":{\"480\":1}}],[\"initialization\",{\"1\":{\"338\":1,\"480\":1,\"576\":1,\"1011\":1}}],[\"initialized\",{\"1\":{\"1011\":1}}],[\"initializes\",{\"1\":{\"576\":1}}],[\"initialize\",{\"1\":{\"480\":1,\"1011\":2}}],[\"initializing\",{\"1\":{\"345\":1}}],[\"induced\",{\"1\":{\"480\":1}}],[\"indexfile\",{\"1\":{\"1315\":3}}],[\"indexfor\",{\"1\":{\"622\":1}}],[\"index=3\",{\"1\":{\"1037\":1}}],[\"index=3位置的entry变成了null\",{\"1\":{\"1037\":1}}],[\"index=4\",{\"1\":{\"1037\":1}}],[\"index=5\",{\"1\":{\"1037\":1,\"1040\":2}}],[\"index=5的数据被清理掉\",{\"1\":{\"1037\":1}}],[\"index=7\",{\"1\":{\"1035\":2}}],[\"index=i\",{\"1\":{\"766\":6}}],[\"indexedbinarysearch\",{\"1\":{\"658\":1}}],[\"index+\",{\"1\":{\"572\":1}}],[\"index++\",{\"1\":{\"553\":2,\"713\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"553\":3}}],[\"indexofsublist\",{\"1\":{\"697\":1}}],[\"indexof\",{\"1\":{\"553\":3,\"592\":2,\"632\":2,\"634\":1}}],[\"index\",{\"1\":{\"111\":3,\"117\":1,\"120\":6,\"181\":2,\"209\":1,\"212\":2,\"213\":1,\"331\":2,\"377\":1,\"409\":1,\"552\":4,\"553\":55,\"560\":1,\"561\":9,\"571\":9,\"588\":1,\"589\":7,\"591\":8,\"634\":4,\"656\":4,\"683\":3,\"711\":1,\"713\":1,\"729\":6,\"730\":13,\"731\":4,\"756\":3,\"911\":3,\"1036\":1,\"1040\":2,\"1110\":2,\"1112\":2,\"1114\":1,\"1178\":1}}],[\"influxdb\",{\"1\":{\"1087\":1}}],[\"inflatetable\",{\"1\":{\"622\":1}}],[\"inf\",{\"1\":{\"359\":1,\"1131\":2}}],[\"infrastructure\",{\"1\":{\"205\":1}}],[\"information\",{\"1\":{\"370\":1}}],[\"info\",{\"1\":{\"168\":1,\"219\":3,\"325\":4,\"328\":15,\"331\":3,\"332\":3,\"333\":1,\"364\":2,\"918\":6,\"1204\":2,\"1209\":2,\"1212\":1,\"1213\":1,\"1252\":1,\"1281\":2}}],[\"infoq\",{\"1\":{\"11\":1,\"982\":1}}],[\"insync\",{\"1\":{\"1206\":5}}],[\"instruction\",{\"1\":{\"969\":1}}],[\"instant\",{\"1\":{\"598\":1}}],[\"instanceof\",{\"1\":{\"577\":1,\"619\":1,\"622\":1,\"623\":1,\"624\":1,\"658\":1,\"711\":1}}],[\"instance\",{\"1\":{\"49\":1,\"356\":3,\"390\":3}}],[\"insert\",{\"1\":{\"33\":2,\"34\":1,\"125\":2,\"353\":1}}],[\"in\",{\"1\":{\"41\":1,\"86\":2,\"120\":2,\"125\":2,\"293\":2,\"302\":1,\"356\":1,\"360\":1,\"377\":2,\"386\":1,\"449\":1,\"571\":3,\"576\":1,\"624\":1,\"693\":4,\"708\":2,\"871\":1,\"876\":2,\"918\":1,\"944\":1,\"974\":1,\"1011\":2,\"1096\":1,\"1132\":1}}],[\"inc的值进行修改\",{\"1\":{\"835\":1}}],[\"inc的值并对其进行修改\",{\"1\":{\"835\":1}}],[\"inc++\",{\"1\":{\"835\":6}}],[\"inc\",{\"1\":{\"835\":12}}],[\"incorrectly\",{\"1\":{\"555\":1,\"587\":1}}],[\"increase\",{\"1\":{\"835\":5,\"1333\":1}}],[\"increments\",{\"1\":{\"553\":4,\"557\":1,\"561\":1}}],[\"incrementandget\",{\"1\":{\"56\":2,\"764\":1,\"894\":1,\"920\":1}}],[\"increment\",{\"1\":{\"33\":1,\"185\":1,\"357\":1,\"688\":1,\"764\":2,\"838\":1,\"987\":1,\"1032\":3}}],[\"incr\",{\"1\":{\"35\":2,\"177\":2,\"178\":1,\"231\":3}}],[\"incubator\",{\"1\":{\"9\":1,\"1168\":1}}],[\"intset\",{\"1\":{\"174\":2}}],[\"integrate\",{\"1\":{\"573\":1}}],[\"integer>\",{\"1\":{\"713\":2}}],[\"integer\",{\"1\":{\"35\":1,\"47\":3,\"177\":7,\"181\":5,\"185\":2,\"189\":6,\"193\":2,\"202\":6,\"206\":7,\"251\":2,\"261\":7,\"270\":2,\"302\":4,\"307\":1,\"328\":1,\"529\":1,\"553\":2,\"558\":1,\"559\":3,\"624\":2,\"629\":2,\"634\":4,\"649\":1,\"662\":2,\"679\":5,\"706\":1,\"713\":2,\"767\":3,\"798\":3,\"889\":6,\"892\":3,\"917\":3,\"937\":6,\"938\":3,\"949\":1,\"951\":1,\"955\":1,\"957\":3,\"959\":1,\"961\":2,\"1062\":3,\"1209\":2,\"1213\":2}}],[\"interrupted\",{\"1\":{\"748\":1,\"752\":1,\"756\":3,\"906\":1,\"911\":3,\"1012\":4,\"1015\":9}}],[\"interruptedexception\",{\"1\":{\"370\":2,\"531\":3,\"533\":4,\"535\":2,\"537\":2,\"604\":1,\"748\":4,\"749\":3,\"752\":4,\"753\":3,\"756\":4,\"757\":6,\"773\":2,\"781\":3,\"782\":2,\"785\":2,\"823\":2,\"824\":1,\"835\":1,\"882\":2,\"899\":2,\"906\":3,\"909\":2,\"911\":4,\"924\":2,\"927\":1,\"940\":1,\"944\":2,\"1020\":1,\"1030\":1,\"1062\":1,\"1209\":1,\"1210\":1}}],[\"interrupt\",{\"1\":{\"531\":2,\"756\":2,\"911\":2,\"1015\":1}}],[\"interface\",{\"1\":{\"391\":1,\"533\":1,\"597\":1,\"658\":1,\"670\":1,\"773\":1,\"778\":2,\"779\":2,\"865\":1,\"899\":1,\"943\":2,\"1131\":1,\"1210\":1}}],[\"interfacemethodref\",{\"1\":{\"328\":1}}],[\"interfaces\",{\"0\":{\"330\":1},\"1\":{\"325\":3,\"330\":3}}],[\"internalerror\",{\"1\":{\"553\":1}}],[\"internals\",{\"1\":{\"56\":1}}],[\"internallock\",{\"1\":{\"56\":3}}],[\"internallock方法\",{\"1\":{\"56\":1}}],[\"internallockleasetime\",{\"1\":{\"49\":3}}],[\"interprocesslock\",{\"1\":{\"53\":2}}],[\"interprocessmultilock\",{\"1\":{\"53\":3}}],[\"interprocessmutex中的一个静态内部类\",{\"1\":{\"56\":1}}],[\"interprocessmutex\",{\"1\":{\"53\":2,\"56\":3}}],[\"interprocessreadwritelock\",{\"1\":{\"53\":1}}],[\"interprocesssemaphoremutex\",{\"1\":{\"53\":2}}],[\"into\",{\"1\":{\"33\":4,\"34\":1,\"125\":2,\"351\":1}}],[\"int\",{\"1\":{\"18\":1,\"34\":4,\"37\":1,\"256\":2,\"268\":4,\"342\":2,\"429\":1,\"430\":1,\"438\":2,\"493\":1,\"530\":2,\"531\":3,\"533\":4,\"534\":4,\"536\":1,\"538\":2,\"552\":4,\"553\":46,\"555\":2,\"557\":4,\"558\":5,\"559\":2,\"560\":1,\"561\":7,\"562\":8,\"564\":6,\"570\":9,\"571\":11,\"572\":11,\"573\":1,\"576\":2,\"577\":3,\"578\":2,\"588\":2,\"589\":4,\"590\":1,\"591\":5,\"592\":1,\"599\":1,\"618\":4,\"619\":12,\"621\":5,\"622\":5,\"623\":2,\"624\":6,\"629\":3,\"631\":1,\"632\":3,\"634\":12,\"649\":1,\"656\":4,\"658\":1,\"662\":1,\"663\":5,\"677\":5,\"679\":3,\"680\":1,\"682\":4,\"683\":3,\"686\":2,\"688\":4,\"696\":3,\"697\":5,\"706\":3,\"708\":1,\"709\":3,\"711\":1,\"712\":1,\"713\":3,\"729\":2,\"730\":8,\"731\":2,\"732\":2,\"733\":1,\"742\":6,\"744\":5,\"747\":2,\"748\":13,\"749\":4,\"752\":9,\"753\":5,\"756\":9,\"757\":9,\"763\":11,\"764\":3,\"765\":1,\"766\":20,\"767\":7,\"768\":4,\"798\":1,\"835\":3,\"841\":3,\"843\":2,\"882\":1,\"889\":3,\"890\":2,\"904\":6,\"905\":2,\"906\":2,\"909\":3,\"911\":9,\"928\":5,\"936\":2,\"937\":3,\"940\":4,\"941\":13,\"949\":2,\"961\":2,\"974\":3,\"990\":3,\"992\":2,\"1001\":1,\"1004\":1,\"1006\":5,\"1007\":8,\"1008\":2,\"1012\":3,\"1013\":2,\"1014\":5,\"1015\":1,\"1018\":3,\"1020\":4,\"1032\":5,\"1036\":17,\"1037\":6,\"1038\":7,\"1041\":3,\"1042\":3,\"1062\":2,\"1140\":5,\"1141\":8,\"1142\":16,\"1209\":1,\"1210\":1,\"1290\":1,\"1333\":2}}],[\"i\",{\"1\":{\"5\":1,\"19\":4,\"68\":1,\"100\":1,\"125\":1,\"230\":1,\"265\":3,\"273\":5,\"285\":2,\"293\":3,\"298\":2,\"499\":3,\"531\":4,\"534\":4,\"536\":2,\"538\":4,\"552\":5,\"553\":24,\"561\":3,\"564\":6,\"572\":3,\"577\":5,\"622\":7,\"629\":3,\"631\":3,\"632\":8,\"649\":4,\"656\":5,\"686\":2,\"696\":1,\"706\":3,\"713\":4,\"730\":6,\"749\":3,\"753\":5,\"757\":6,\"763\":13,\"766\":18,\"808\":1,\"835\":2,\"841\":4,\"895\":4,\"909\":3,\"922\":4,\"940\":3,\"990\":4,\"1001\":2,\"1020\":2,\"1032\":3,\"1036\":36,\"1037\":12,\"1038\":1,\"1041\":8,\"1042\":6,\"1056\":1,\"1062\":2,\"1141\":9,\"1142\":9,\"1209\":3,\"1290\":1}}],[\"ioc\",{\"1\":{\"1131\":1,\"1132\":3}}],[\"ioexception\",{\"1\":{\"56\":1}}],[\"io\",{\"0\":{\"1308\":1},\"1\":{\"4\":2,\"5\":1,\"49\":1,\"68\":1,\"69\":1,\"78\":2,\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1,\"196\":2,\"205\":1,\"213\":1,\"218\":1,\"219\":1,\"221\":1,\"224\":1,\"233\":2,\"235\":1,\"237\":1,\"242\":1,\"243\":1,\"245\":2,\"264\":1,\"265\":3,\"267\":8,\"280\":1,\"285\":1,\"320\":1,\"353\":1,\"377\":3,\"549\":2,\"553\":1,\"634\":1,\"727\":1,\"740\":1,\"816\":5,\"819\":6,\"821\":1,\"857\":1,\"865\":1,\"871\":1,\"895\":5,\"903\":1,\"922\":5,\"1062\":2,\"1117\":1,\"1170\":1,\"1178\":1,\"1238\":1,\"1241\":1,\"1308\":1,\"1310\":3}}],[\"其编号假设为\",{\"1\":{\"1373\":1}}],[\"其解决的问题就是在分布式系统中如何就某个值\",{\"1\":{\"1372\":1}}],[\"其一致性是通过基于\",{\"1\":{\"1367\":1}}],[\"其为分布式系统提供一致性服务\",{\"1\":{\"1367\":1}}],[\"其看到的服务端数据模型都是一致的\",{\"1\":{\"1345\":1}}],[\"其主要功能包括\",{\"1\":{\"1367\":1}}],[\"其主要原因是\",{\"1\":{\"1314\":1}}],[\"其主要目的是为了简化多线程编程\",{\"1\":{\"971\":1,\"973\":1,\"981\":2}}],[\"其要求是给\",{\"1\":{\"1303\":1}}],[\"其作为范围是\",{\"1\":{\"1178\":1}}],[\"其作用就是判断\",{\"1\":{\"752\":1}}],[\"其由主要面向移动应用开发并基于\",{\"1\":{\"1170\":1}}],[\"其社区活跃度以及生态都要好很多\",{\"1\":{\"1169\":1}}],[\"其默认在建立底层\",{\"1\":{\"1158\":1}}],[\"其正确性主要是源于复制状态机的性质\",{\"1\":{\"1106\":1}}],[\"其简化了\",{\"1\":{\"1097\":1,\"1099\":1}}],[\"其来源于对大规模互联网系统分布式实践的总结\",{\"1\":{\"1073\":1}}],[\"其特性如下\",{\"1\":{\"1001\":1}}],[\"其本质就是定义了一种\",{\"1\":{\"974\":1}}],[\"其本质均为在\",{\"1\":{\"17\":1}}],[\"其还规定了从\",{\"1\":{\"971\":1,\"981\":1}}],[\"其提供了一种限制和管理线程资源的方式\",{\"1\":{\"933\":1}}],[\"其提供了一个专门用来监控和续期锁的\",{\"1\":{\"49\":1}}],[\"其上下文切换和模式切换的时间消耗非常少\",{\"1\":{\"895\":1,\"922\":1}}],[\"其并发控制采用可重入锁\",{\"1\":{\"797\":1}}],[\"其参数表示屏障拦截的线程数量\",{\"1\":{\"756\":1,\"911\":1}}],[\"其与\",{\"1\":{\"669\":1}}],[\"其依然存在一些缺点\",{\"1\":{\"585\":1}}],[\"其效果相当于oldcapacity\",{\"1\":{\"553\":1,\"558\":1}}],[\"其核心思想是\",{\"1\":{\"585\":1}}],[\"其核心思想是读不加锁\",{\"1\":{\"141\":1}}],[\"其核心逻辑和\",{\"1\":{\"535\":1}}],[\"其核心逻辑和put\",{\"1\":{\"535\":1}}],[\"其目的是为了能够在\",{\"1\":{\"451\":1}}],[\"其最主要的原因是它很难解决对象之间循环引用的问题\",{\"1\":{\"390\":1}}],[\"其余三个都是在这个构造方法的基础上产生\",{\"1\":{\"936\":1}}],[\"其余三个验证阶段都是基于方法区的存储结构上进行的\",{\"1\":{\"341\":1}}],[\"其余均会失败\",{\"1\":{\"841\":1,\"990\":1}}],[\"其余空间\",{\"1\":{\"553\":1}}],[\"其余行为\",{\"1\":{\"402\":1}}],[\"其余的类加载器都应有自己的父类加载器\",{\"1\":{\"356\":1}}],[\"其它机器\",{\"1\":{\"1263\":1}}],[\"其它线程才有机会获取该锁\",{\"1\":{\"904\":1}}],[\"其它线程阻塞\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"其它和\",{\"1\":{\"193\":2}}],[\"其底层实现主要依赖这\",{\"1\":{\"174\":1}}],[\"其属性有\",{\"1\":{\"141\":1}}],[\"其原因是\",{\"1\":{\"98\":1,\"796\":1}}],[\"其架构模式是插件式的\",{\"1\":{\"83\":1}}],[\"其架构如下图所示\",{\"1\":{\"42\":1}}],[\"其实对于会话来说你可以理解为\",{\"1\":{\"1383\":1}}],[\"其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的\",{\"1\":{\"1280\":1}}],[\"其实主要就是\",{\"1\":{\"1380\":1}}],[\"其实和初始化选举差不多\",{\"1\":{\"1380\":1}}],[\"其实和我们最开始画的那张乞丐版的架构图也没什么区别\",{\"1\":{\"1281\":1}}],[\"其实他们是\",{\"1\":{\"1371\":1}}],[\"其实解释到分布式这个概念的时候\",{\"1\":{\"1367\":1}}],[\"其实很简单\",{\"1\":{\"1299\":1}}],[\"其实上面我已经说了\",{\"1\":{\"1274\":1}}],[\"其实比\",{\"1\":{\"1161\":1}}],[\"其实如果我们约定好头部的第几位是\",{\"1\":{\"1159\":1}}],[\"其实已经很清晰了\",{\"1\":{\"1036\":1}}],[\"其实并不存储任何信息\",{\"1\":{\"1011\":1}}],[\"其实并没有实际的许可证这个对象\",{\"1\":{\"749\":1}}],[\"其实在\",{\"1\":{\"1002\":1}}],[\"其实是一种调用方式\",{\"0\":{\"1154\":1}}],[\"其实是一个复合操作\",{\"1\":{\"835\":1}}],[\"其实是不对的\",{\"1\":{\"1030\":1}}],[\"其实是两把锁\",{\"1\":{\"865\":1}}],[\"其实是迭代到尾部元素时再判断整个链表长度大于等于\",{\"1\":{\"708\":1}}],[\"其实使用了tryreleaseshared方法以\",{\"1\":{\"752\":1,\"908\":1}}],[\"其实\",{\"1\":{\"579\":1,\"835\":1,\"1011\":1,\"1155\":1,\"1159\":1,\"1298\":2}}],[\"其实也很简单\",{\"1\":{\"1388\":1}}],[\"其实也有一段趣闻\",{\"1\":{\"1343\":1}}],[\"其实也可以做到类似的功能\",{\"1\":{\"1154\":1}}],[\"其实也就是把高4位与segmentmask\",{\"1\":{\"571\":1}}],[\"其实也不一定是要满足\",{\"1\":{\"444\":1}}],[\"其实也不用管太多\",{\"1\":{\"425\":1}}],[\"其实现的入队和出队操作的整体框架\",{\"1\":{\"533\":1}}],[\"其实还有一些打印及\",{\"1\":{\"449\":1}}],[\"其实就有点类似于两个人吵架\",{\"1\":{\"1375\":1}}],[\"其实就是两个完全不同的概念\",{\"1\":{\"1367\":1}}],[\"其实就是调用上述提到的\",{\"1\":{\"1311\":1}}],[\"其实就是\",{\"1\":{\"1157\":1,\"1349\":1}}],[\"其实就是在处理\",{\"1\":{\"1013\":1}}],[\"其实就是一个安全检查\",{\"1\":{\"429\":1}}],[\"其实就是链表数据结构的实现\",{\"1\":{\"180\":1}}],[\"其实就类似于一台小电脑运行在\",{\"1\":{\"417\":1}}],[\"其实抛开这么专业的句子不说\",{\"1\":{\"417\":1}}],[\"其实准确分类只有两大种\",{\"1\":{\"387\":1}}],[\"其实这里涉及到了\",{\"1\":{\"1315\":1}}],[\"其实这样做也是可以的\",{\"1\":{\"708\":1}}],[\"其实这个问题可以将它广义化\",{\"1\":{\"1305\":1}}],[\"其实这个也是一个隔离的作用\",{\"1\":{\"433\":1}}],[\"其实这个双亲翻译的容易让别人误解\",{\"1\":{\"356\":1}}],[\"其实这些复杂的步骤并不需要我们手动实现\",{\"1\":{\"72\":1}}],[\"其实除了加载类之外\",{\"1\":{\"351\":1}}],[\"其实单机版\",{\"1\":{\"51\":1}}],[\"其中节点类型可以分为\",{\"1\":{\"1382\":1}}],[\"其中高\",{\"1\":{\"1379\":1}}],[\"其中尤其需要注意的是\",{\"1\":{\"1351\":1}}],[\"其中介绍了\",{\"1\":{\"1281\":1}}],[\"其中最重要的是\",{\"1\":{\"1159\":1}}],[\"其中sock\",{\"1\":{\"1151\":1}}],[\"其中大多数节点必须同意任何变更才能被视为有效\",{\"1\":{\"1069\":1}}],[\"其中包括事务内容\",{\"1\":{\"1370\":1}}],[\"其中包括set数据\",{\"1\":{\"1039\":1}}],[\"其中包含了各种并发流程控制工具\",{\"1\":{\"529\":1}}],[\"其中一个已经执行完成\",{\"1\":{\"919\":1}}],[\"其中一种推荐的方式是基于\",{\"1\":{\"72\":1}}],[\"其中有一项就是\",{\"1\":{\"895\":1,\"922\":1}}],[\"其中的\",{\"1\":{\"843\":1,\"992\":1}}],[\"其中的元素只有到了其指定的延迟时间\",{\"1\":{\"671\":1}}],[\"其中堆是进程中最大的一块内存\",{\"1\":{\"813\":1}}],[\"其中阻塞队列的典型例子是\",{\"1\":{\"794\":1}}],[\"其中定义了\",{\"1\":{\"773\":1,\"899\":1}}],[\"其中唯一的线程安全\",{\"1\":{\"583\":1,\"793\":1}}],[\"其中提供了很多线程安全且并发性能良好的容器\",{\"1\":{\"583\":1,\"793\":1}}],[\"其中验证\",{\"1\":{\"427\":1}}],[\"其中\",{\"1\":{\"285\":1,\"338\":1,\"529\":1,\"588\":1,\"756\":1,\"851\":1,\"853\":1,\"895\":1,\"911\":1,\"922\":1,\"1184\":1,\"1210\":1,\"1252\":1,\"1264\":1,\"1279\":1,\"1315\":1,\"1361\":1}}],[\"其中只有后四种实际用到\",{\"1\":{\"256\":1}}],[\"其中分为两部分\",{\"1\":{\"19\":1}}],[\"其内部逻辑如下\",{\"1\":{\"533\":1}}],[\"其内部集成了大量精良的\",{\"1\":{\"6\":1}}],[\"其内置了多种类型的锁比如可重入锁\",{\"1\":{\"50\":1}}],[\"其他角色都没有得到更新吧\",{\"1\":{\"1379\":1}}],[\"其他没有批准的并没有执行该提案内容\",{\"1\":{\"1374\":1}}],[\"其他机器可通过监听\",{\"1\":{\"1346\":1}}],[\"其他几个都是\",{\"1\":{\"1240\":1}}],[\"其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么\",{\"1\":{\"936\":1}}],[\"其他副本称为\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"其他还有很多可供扩展的选择\",{\"1\":{\"1131\":1}}],[\"其他节点赢得选举\",{\"1\":{\"1111\":1}}],[\"其他节点的读写操作正常的话\",{\"1\":{\"1068\":1}}],[\"其他节点至少有ceil\",{\"1\":{\"99\":1}}],[\"其他参数和\",{\"1\":{\"953\":1}}],[\"其他参数介绍\",{\"0\":{\"460\":1}}],[\"其他请求读锁和写锁的线程必须等待\",{\"1\":{\"871\":1}}],[\"其他阻塞的线程才能获取到\",{\"1\":{\"747\":1,\"905\":1}}],[\"其他等待的线程才能有机会获取该锁\",{\"1\":{\"742\":1}}],[\"其他的\",{\"1\":{\"1354\":1}}],[\"其他的诸如\",{\"1\":{\"740\":1,\"903\":1}}],[\"其他的线程将该\",{\"1\":{\"693\":2}}],[\"其他的模块均由平台类加载器所加载\",{\"1\":{\"353\":1}}],[\"其他段的数据也能被其他线程访问\",{\"1\":{\"690\":1}}],[\"其他方法都是直接调用\",{\"1\":{\"678\":1}}],[\"其他方法都需要依靠\",{\"1\":{\"270\":1}}],[\"其他情况增删元素的平均时间复杂度都是\",{\"1\":{\"656\":1,\"724\":1}}],[\"其他情况\",{\"1\":{\"553\":2}}],[\"其他线程再\",{\"1\":{\"904\":1}}],[\"其他线程也一样\",{\"1\":{\"882\":1}}],[\"其他线程也访问同步方法\",{\"1\":{\"688\":1}}],[\"其他线程可以尝试获取锁\",{\"1\":{\"851\":1}}],[\"其他线程可以立即看到修改后的值\",{\"1\":{\"835\":1}}],[\"其他线程可以继续对队列进行操作\",{\"1\":{\"535\":1}}],[\"其他线程需要等待\",{\"1\":{\"819\":1}}],[\"其他线程需要等待当前线程释放后才能访问\",{\"1\":{\"60\":1}}],[\"其他线程还可以继续使用\",{\"1\":{\"816\":1}}],[\"其他线程都会阻塞\",{\"1\":{\"747\":1,\"905\":1}}],[\"其他\",{\"0\":{\"485\":1},\"1\":{\"377\":1,\"753\":1}}],[\"其他类加载器均由\",{\"1\":{\"354\":1}}],[\"其他所有的\",{\"1\":{\"493\":1}}],[\"其他所有的类加载器都是在\",{\"1\":{\"353\":1}}],[\"其他所有请求可能都会超时\",{\"1\":{\"165\":1}}],[\"其他文件生成比如\",{\"1\":{\"340\":1}}],[\"其他命令都能正常执行\",{\"1\":{\"281\":1}}],[\"其他客户端\",{\"1\":{\"280\":1}}],[\"其他操作\",{\"1\":{\"128\":1,\"129\":1}}],[\"其他资料中第二步是去查询缓存\",{\"1\":{\"85\":1}}],[\"其他语言的解决方案\",{\"1\":{\"49\":1}}],[\"其他负载均衡设备\",{\"1\":{\"1\":1}}],[\"其次可以起到填充数据的目的\",{\"1\":{\"19\":1}}],[\"其性能相比较于\",{\"1\":{\"10\":1}}],[\"其优点有\",{\"1\":{\"10\":1}}],[\"其诞生的目标是为了替代老牌网关\",{\"1\":{\"5\":1,\"68\":1}}],[\"ws\",{\"1\":{\"1012\":4,\"1013\":4,\"1014\":3}}],[\"w\",{\"1\":{\"941\":5}}],[\"wc\",{\"1\":{\"941\":3}}],[\"wcasresult=true\",{\"1\":{\"767\":2}}],[\"wcasresult=\",{\"1\":{\"767\":2}}],[\"wcasresult\",{\"1\":{\"767\":4}}],[\"wrong\",{\"1\":{\"927\":2}}],[\"writelock\",{\"1\":{\"865\":3,\"871\":1}}],[\"writerlock\",{\"1\":{\"865\":1}}],[\"writer\",{\"1\":{\"688\":1}}],[\"writeobject\",{\"1\":{\"678\":1}}],[\"writes\",{\"1\":{\"267\":1}}],[\"write将数据写入到了系统内核缓冲区之后直接返回了\",{\"1\":{\"230\":1}}],[\"write但不fsync\",{\"1\":{\"161\":1,\"231\":1}}],[\"write+fsync\",{\"1\":{\"161\":1,\"231\":1}}],[\"write\",{\"0\":{\"146\":1,\"147\":1,\"585\":1},\"1\":{\"146\":2,\"147\":5,\"161\":6,\"230\":2,\"231\":4,\"265\":1,\"570\":1,\"584\":1,\"585\":3,\"588\":1,\"688\":2,\"793\":1,\"972\":2,\"1308\":3,\"1310\":4,\"1311\":1,\"1351\":1,\"1384\":1}}],[\"wt\",{\"1\":{\"895\":4,\"922\":4}}],[\"wtail\",{\"1\":{\"871\":1}}],[\"won\",{\"1\":{\"882\":1}}],[\"worder\",{\"1\":{\"1015\":1}}],[\"workeradded\",{\"1\":{\"941\":3}}],[\"workerstarted\",{\"1\":{\"941\":4}}],[\"workers\",{\"1\":{\"941\":3}}],[\"workercountof\",{\"1\":{\"941\":4}}],[\"workercount\",{\"1\":{\"941\":2}}],[\"worker\",{\"1\":{\"940\":2,\"941\":3,\"1019\":1,\"1262\":1}}],[\"workerthread类实现了runnable\",{\"1\":{\"940\":1}}],[\"work\",{\"1\":{\"553\":3,\"1097\":1,\"1117\":1,\"1259\":1}}],[\"workqueue\",{\"1\":{\"530\":2,\"890\":5,\"894\":1,\"896\":1,\"897\":1,\"920\":1,\"923\":1,\"936\":5,\"940\":1,\"941\":3}}],[\"world\",{\"1\":{\"41\":1,\"401\":2,\"407\":1,\"408\":1,\"649\":7,\"779\":8,\"780\":4,\"781\":4,\"785\":1,\"1351\":1}}],[\"wbit\",{\"1\":{\"871\":2}}],[\"wuwenliang\",{\"1\":{\"1185\":1}}],[\"wu\",{\"1\":{\"625\":1}}],[\"www\",{\"1\":{\"237\":1,\"274\":1,\"293\":1,\"298\":1,\"360\":1,\"377\":1,\"475\":1,\"511\":3,\"612\":1,\"688\":1,\"720\":2,\"758\":1,\"876\":1,\"913\":3,\"982\":1,\"1100\":1,\"1171\":1,\"1199\":1,\"1218\":1,\"1237\":2}}],[\"wangwu\",{\"1\":{\"663\":1}}],[\"wang\",{\"1\":{\"625\":2}}],[\"was\",{\"1\":{\"571\":1,\"624\":1}}],[\"wasm\",{\"1\":{\"8\":6}}],[\"waterystone\",{\"1\":{\"758\":1,\"913\":1}}],[\"water\",{\"1\":{\"480\":1}}],[\"watcher机制等等\",{\"1\":{\"1391\":1}}],[\"watcher机制\",{\"1\":{\"1385\":1}}],[\"watcher\",{\"0\":{\"1352\":1,\"1385\":1},\"1\":{\"53\":1,\"55\":2,\"1069\":1,\"1346\":2,\"1352\":4,\"1353\":1,\"1381\":1,\"1385\":4,\"1387\":2,\"1388\":1,\"1390\":2}}],[\"watch\",{\"1\":{\"49\":6,\"280\":10}}],[\"warning\",{\"1\":{\"1252\":1}}],[\"warmup\",{\"1\":{\"1140\":1}}],[\"warrant\",{\"1\":{\"708\":1}}],[\"war\",{\"1\":{\"340\":1}}],[\"waitstrategy\",{\"1\":{\"1182\":1,\"1183\":1}}],[\"waitstatusoffset\",{\"1\":{\"1011\":1}}],[\"waitstatus\",{\"1\":{\"742\":1,\"904\":1,\"1005\":2,\"1011\":1,\"1012\":4,\"1013\":6,\"1014\":8}}],[\"waiter\",{\"1\":{\"688\":2}}],[\"waiting\",{\"1\":{\"370\":8,\"604\":1,\"688\":1,\"756\":1,\"820\":6,\"823\":4,\"824\":3,\"826\":1,\"911\":1}}],[\"wait\",{\"0\":{\"825\":1,\"826\":1},\"1\":{\"55\":1,\"820\":3,\"821\":1,\"825\":5,\"826\":1,\"851\":1}}],[\"wire\",{\"1\":{\"1231\":1}}],[\"wisdom\",{\"1\":{\"633\":1}}],[\"will\",{\"1\":{\"298\":1,\"302\":1,\"356\":1,\"1333\":1}}],[\"winners\",{\"1\":{\"1178\":1}}],[\"win\",{\"1\":{\"553\":1,\"558\":1}}],[\"winhex\",{\"1\":{\"324\":1}}],[\"wingsxdu\",{\"1\":{\"237\":1}}],[\"windows\",{\"1\":{\"168\":1,\"368\":1,\"417\":1,\"806\":3,\"808\":1,\"968\":1,\"1053\":1}}],[\"withmode\",{\"1\":{\"1335\":4,\"1337\":1}}],[\"without\",{\"1\":{\"1241\":1}}],[\"withinitial\",{\"1\":{\"882\":1,\"1028\":1}}],[\"withscores\",{\"1\":{\"193\":3}}],[\"with\",{\"1\":{\"49\":1,\"293\":8,\"302\":1,\"555\":1,\"570\":1,\"571\":4,\"708\":1,\"798\":2,\"824\":1,\"884\":1}}],[\"wikipedia\",{\"1\":{\"1100\":1}}],[\"wiki\",{\"1\":{\"4\":2,\"42\":2,\"72\":1,\"1100\":1,\"1169\":1}}],[\"what\",{\"1\":{\"320\":2}}],[\"which\",{\"1\":{\"201\":1,\"370\":2,\"571\":1}}],[\"while\",{\"1\":{\"56\":1,\"302\":1,\"353\":1,\"386\":1,\"495\":1,\"531\":1,\"535\":2,\"537\":2,\"538\":1,\"570\":2,\"571\":3,\"576\":1,\"578\":1,\"599\":1,\"604\":1,\"623\":1,\"624\":1,\"683\":1,\"688\":1,\"713\":1,\"940\":1,\"1012\":1,\"1013\":2,\"1037\":2,\"1038\":1,\"1041\":1,\"1042\":1}}],[\"whead\",{\"1\":{\"871\":1}}],[\"whether\",{\"1\":{\"693\":1}}],[\"when\",{\"1\":{\"298\":1,\"356\":1,\"577\":1,\"688\":1,\"708\":2,\"1096\":1}}],[\"whencompleteasync\",{\"1\":{\"779\":2}}],[\"whencomplete\",{\"1\":{\"49\":1,\"779\":5,\"786\":1}}],[\"where\",{\"1\":{\"34\":3,\"81\":1,\"86\":2,\"89\":1,\"117\":1,\"120\":3,\"135\":1,\"141\":1,\"511\":1}}],[\"why\",{\"1\":{\"11\":1,\"243\":2,\"274\":1,\"896\":1}}],[\"weibocom\",{\"1\":{\"1169\":1}}],[\"weights\",{\"1\":{\"1141\":3,\"1142\":3}}],[\"weight\",{\"1\":{\"1140\":1,\"1141\":3}}],[\"weixin\",{\"1\":{\"156\":1,\"171\":2,\"320\":3,\"567\":1,\"876\":1,\"1241\":1}}],[\"weakcompareandset\",{\"1\":{\"767\":4}}],[\"weak\",{\"1\":{\"767\":2}}],[\"weakreference<threadlocal<\",{\"1\":{\"884\":1}}],[\"weakreference\",{\"1\":{\"392\":1,\"1030\":1}}],[\"well\",{\"1\":{\"293\":1,\"298\":1,\"708\":1}}],[\"we\",{\"1\":{\"256\":1,\"480\":1,\"708\":1,\"756\":2,\"911\":2}}],[\"wenkuvipcashier\",{\"1\":{\"24\":1}}],[\"wenku\",{\"1\":{\"24\":1}}],[\"webapps\",{\"1\":{\"359\":1}}],[\"webappclassloader对应\",{\"1\":{\"359\":1}}],[\"webappclassloader\",{\"1\":{\"359\":8}}],[\"webassembly\",{\"1\":{\"8\":1}}],[\"webflux\",{\"1\":{\"5\":2,\"9\":1,\"68\":2}}],[\"web\",{\"1\":{\"2\":1,\"6\":3,\"21\":2,\"69\":1,\"359\":14,\"448\":2,\"929\":1,\"1122\":1}}],[\"cversion\",{\"1\":{\"1327\":1,\"1329\":2,\"1330\":1,\"1349\":2,\"1350\":1,\"1382\":1}}],[\"ctime\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":3,\"1382\":1}}],[\"ctlof\",{\"1\":{\"941\":1}}],[\"ctl\",{\"1\":{\"941\":8}}],[\"czxid\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":3,\"1382\":2}}],[\"cd\",{\"1\":{\"1322\":1}}],[\"cells\",{\"1\":{\"1042\":1}}],[\"center\",{\"1\":{\"876\":1,\"1096\":1}}],[\"ceil函数为取上限\",{\"1\":{\"99\":1}}],[\"cyclic\",{\"1\":{\"755\":1,\"910\":1}}],[\"cyclicbarrierexample2\",{\"1\":{\"757\":1}}],[\"cyclicbarrierexample1\",{\"1\":{\"757\":1}}],[\"cyclicbarrierexception\",{\"1\":{\"757\":1}}],[\"cyclicbarrier\",{\"0\":{\"754\":1,\"910\":1,\"911\":1},\"1\":{\"755\":2,\"756\":7,\"757\":10,\"910\":2,\"911\":7}}],[\"cyclibarrier\",{\"1\":{\"755\":1,\"910\":1}}],[\"cycle\",{\"1\":{\"220\":2,\"820\":1}}],[\"cglib\",{\"1\":{\"523\":1}}],[\"c1\",{\"1\":{\"441\":2}}],[\"cmd>\",{\"1\":{\"1112\":1}}],[\"cmd>其中\",{\"1\":{\"1110\":1}}],[\"cmd\",{\"1\":{\"484\":3,\"1110\":1,\"1112\":1}}],[\"cmdline\",{\"1\":{\"365\":1}}],[\"cms\",{\"0\":{\"406\":1},\"1\":{\"380\":1,\"386\":2,\"402\":1,\"403\":1,\"404\":1,\"406\":4,\"407\":3,\"408\":1,\"412\":2,\"449\":2,\"482\":1,\"486\":1,\"503\":1}}],[\"cs\",{\"1\":{\"982\":1,\"1303\":1}}],[\"cst\",{\"1\":{\"369\":1,\"940\":20,\"1327\":2,\"1329\":2,\"1330\":2,\"1349\":2}}],[\"csdn\",{\"1\":{\"334\":1,\"360\":1,\"522\":1,\"612\":1,\"1030\":1}}],[\"cj\",{\"1\":{\"359\":1}}],[\"c++是多继承\",{\"1\":{\"517\":1}}],[\"c++支持多继承\",{\"1\":{\"517\":1}}],[\"c++有指针概念\",{\"1\":{\"517\":1}}],[\"c++程序开发程序员这样为每一个\",{\"1\":{\"490\":1}}],[\"c++\",{\"0\":{\"517\":1},\"1\":{\"353\":2,\"593\":2,\"841\":1,\"990\":1,\"1238\":1,\"1337\":1}}],[\"c++实现的\",{\"1\":{\"851\":1}}],[\"c++实现\",{\"1\":{\"353\":1}}],[\"cpp\",{\"1\":{\"498\":1}}],[\"cp\",{\"1\":{\"325\":1,\"328\":1,\"1068\":5,\"1069\":2,\"1070\":2,\"1071\":1,\"1074\":1,\"1368\":1}}],[\"cpu\",{\"0\":{\"169\":1,\"819\":1,\"968\":1},\"1\":{\"17\":1,\"169\":4,\"220\":2,\"236\":1,\"266\":1,\"272\":3,\"297\":1,\"298\":1,\"377\":1,\"402\":1,\"403\":3,\"405\":1,\"406\":1,\"407\":4,\"535\":5,\"576\":1,\"686\":1,\"816\":9,\"819\":11,\"820\":2,\"821\":6,\"833\":1,\"838\":1,\"841\":2,\"844\":4,\"873\":1,\"895\":23,\"922\":23,\"957\":1,\"967\":1,\"968\":18,\"969\":2,\"971\":2,\"972\":1,\"973\":1,\"981\":2,\"987\":1,\"990\":2,\"993\":4,\"995\":1,\"996\":1,\"1012\":1,\"1056\":1,\"1183\":5,\"1184\":9,\"1308\":1,\"1310\":1,\"1311\":3}}],[\"cc\",{\"1\":{\"221\":1}}],[\"c=c+1\",{\"1\":{\"89\":1}}],[\"craig\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"crash\",{\"1\":{\"89\":6}}],[\"crc64\",{\"1\":{\"234\":1}}],[\"creation\",{\"1\":{\"339\":1}}],[\"creatingparentsifneeded\",{\"1\":{\"1335\":4,\"1337\":1}}],[\"creating\",{\"1\":{\"69\":1,\"78\":2,\"571\":1}}],[\"createmode\",{\"1\":{\"1335\":5,\"1337\":1}}],[\"createmap\",{\"1\":{\"883\":1,\"1031\":2}}],[\"createinheritedmap\",{\"1\":{\"1043\":1}}],[\"createthreadfactory\",{\"1\":{\"918\":1}}],[\"createtime\",{\"1\":{\"679\":1}}],[\"creates\",{\"1\":{\"570\":1,\"798\":2}}],[\"created\",{\"1\":{\"351\":2,\"368\":1,\"369\":1,\"1325\":1,\"1382\":2}}],[\"create\",{\"0\":{\"1325\":1},\"1\":{\"33\":1,\"34\":1,\"570\":1,\"571\":1,\"1311\":1,\"1325\":4,\"1335\":6,\"1337\":1,\"1349\":2,\"1351\":2,\"1384\":1}}],[\"childrenpaths\",{\"1\":{\"1338\":1}}],[\"choice\",{\"1\":{\"1178\":4}}],[\"choose\",{\"1\":{\"274\":1}}],[\"chrome\",{\"1\":{\"1155\":1}}],[\"ch\",{\"1\":{\"511\":1,\"630\":1}}],[\"chengxiao\",{\"1\":{\"688\":1,\"913\":1}}],[\"chenxitag\",{\"1\":{\"511\":1}}],[\"checkforcomodification\",{\"1\":{\"732\":3}}],[\"checkexists\",{\"1\":{\"1335\":1}}],[\"checkelementindex\",{\"1\":{\"730\":1,\"731\":1}}],[\"checkedexception\",{\"1\":{\"524\":2}}],[\"checkpositionindex\",{\"1\":{\"729\":1}}],[\"checking\",{\"1\":{\"553\":1}}],[\"checknotnull\",{\"1\":{\"534\":1,\"535\":1,\"536\":1,\"537\":1}}],[\"checkcreateclassloader\",{\"1\":{\"356\":1}}],[\"checksum\",{\"1\":{\"234\":1}}],[\"check\",{\"1\":{\"86\":1,\"623\":1,\"693\":1,\"941\":1,\"1173\":1}}],[\"change\",{\"1\":{\"941\":1,\"1231\":1}}],[\"changed\",{\"1\":{\"571\":1,\"693\":1,\"882\":1}}],[\"changfubai\",{\"1\":{\"615\":1}}],[\"channel\",{\"1\":{\"251\":6,\"499\":1,\"1260\":1,\"1311\":2}}],[\"chasing\",{\"1\":{\"369\":1}}],[\"chapter5\",{\"1\":{\"1117\":1}}],[\"chapter\",{\"1\":{\"334\":1,\"345\":1,\"511\":1}}],[\"chain\",{\"1\":{\"69\":1}}],[\"charsets\",{\"1\":{\"353\":1}}],[\"charset=utf8mb4\",{\"1\":{\"33\":1,\"34\":1}}],[\"char\",{\"1\":{\"33\":1,\"103\":1,\"104\":1,\"218\":1,\"256\":11,\"485\":1,\"493\":1}}],[\"customer\",{\"1\":{\"1209\":2,\"1213\":2}}],[\"customthread\",{\"1\":{\"1058\":6,\"1059\":7,\"1060\":6,\"1061\":6}}],[\"custom\",{\"1\":{\"69\":1,\"78\":2,\"432\":1}}],[\"curator<\",{\"1\":{\"1332\":2}}],[\"curator4\",{\"1\":{\"1332\":1}}],[\"curatorframeworkfactory\",{\"1\":{\"1333\":2}}],[\"curatorframework\",{\"1\":{\"53\":1,\"1333\":3}}],[\"curator主要实现了下面四种锁\",{\"1\":{\"53\":1}}],[\"curator\",{\"0\":{\"1332\":1},\"1\":{\"53\":3,\"56\":1,\"1319\":1,\"1331\":1,\"1332\":3,\"1341\":1}}],[\"currentattempts\",{\"1\":{\"1210\":2}}],[\"currentattempts++\",{\"1\":{\"1210\":1}}],[\"currentmark\",{\"1\":{\"767\":2}}],[\"currentmark=true\",{\"1\":{\"767\":3}}],[\"currentmark=false\",{\"1\":{\"767\":3}}],[\"currentmark=\",{\"1\":{\"767\":6}}],[\"currentstamp\",{\"1\":{\"767\":2}}],[\"currentstamp=88\",{\"1\":{\"767\":1}}],[\"currentstamp=999\",{\"1\":{\"767\":3}}],[\"currentstamp=0\",{\"1\":{\"767\":2}}],[\"currentstamp=\",{\"1\":{\"767\":6}}],[\"currentvalue\",{\"1\":{\"767\":4}}],[\"currentvalue=true\",{\"1\":{\"767\":4}}],[\"currentvalue=null\",{\"1\":{\"767\":2}}],[\"currentvalue=666\",{\"1\":{\"767\":4}}],[\"currentvalue=0\",{\"1\":{\"767\":2}}],[\"currentvalue=\",{\"1\":{\"767\":12}}],[\"currenttimemillis\",{\"1\":{\"564\":4,\"599\":2,\"713\":8,\"781\":5,\"1062\":2}}],[\"currentthread\",{\"1\":{\"56\":5,\"359\":1,\"370\":6,\"604\":1,\"756\":1,\"823\":6,\"824\":3,\"882\":2,\"883\":2,\"911\":1,\"940\":2,\"1002\":1,\"1007\":1,\"1008\":1,\"1011\":5,\"1014\":2,\"1015\":1,\"1030\":1,\"1031\":1}}],[\"current\",{\"1\":{\"34\":6,\"233\":1,\"632\":3,\"713\":7,\"748\":4,\"843\":6,\"992\":6,\"1007\":3,\"1011\":1,\"1018\":4,\"1141\":2,\"1142\":2}}],[\"curl\",{\"1\":{\"7\":1}}],[\"ca\",{\"1\":{\"1068\":2,\"1070\":1,\"1074\":1}}],[\"cap\",{\"0\":{\"1065\":1,\"1066\":1,\"1069\":1},\"1\":{\"570\":5,\"571\":4,\"677\":2,\"1065\":1,\"1066\":3,\"1067\":6,\"1068\":3,\"1069\":1,\"1070\":2,\"1071\":2,\"1073\":2,\"1074\":3,\"1077\":1,\"1079\":2,\"1368\":1}}],[\"capacity参数指定的元素数\",{\"1\":{\"564\":1}}],[\"capacity是survivor空间的大小\",{\"1\":{\"386\":1,\"495\":1}}],[\"capacity\",{\"1\":{\"386\":2,\"480\":2,\"495\":2,\"534\":9,\"553\":4,\"555\":2,\"557\":1,\"564\":1,\"570\":6,\"571\":1,\"576\":1,\"619\":4,\"621\":6,\"624\":8,\"677\":6,\"683\":1,\"706\":6,\"708\":1,\"712\":3,\"798\":9,\"799\":1,\"896\":1,\"923\":1,\"940\":2,\"941\":2,\"1032\":3}}],[\"calculatewarmupweight\",{\"1\":{\"1140\":1}}],[\"calculatecapacity\",{\"1\":{\"553\":2,\"557\":2}}],[\"calculation\",{\"1\":{\"780\":1}}],[\"callback\",{\"1\":{\"1055\":1}}],[\"callable接口的\",{\"1\":{\"934\":1}}],[\"callable接口\",{\"1\":{\"934\":1}}],[\"callable<v>\",{\"1\":{\"900\":1,\"943\":1}}],[\"callable<t>\",{\"1\":{\"900\":1}}],[\"callable\",{\"0\":{\"900\":1,\"943\":1},\"1\":{\"900\":10,\"934\":5,\"940\":1,\"943\":5}}],[\"calls\",{\"1\":{\"693\":1}}],[\"calling\",{\"1\":{\"571\":1}}],[\"callerrunspolicy\",{\"1\":{\"891\":4,\"927\":1,\"936\":2,\"940\":2}}],[\"callers\",{\"1\":{\"585\":1}}],[\"callersensitive\",{\"1\":{\"351\":1,\"353\":1}}],[\"called\",{\"1\":{\"356\":1}}],[\"call\",{\"1\":{\"47\":2,\"49\":2,\"900\":1,\"943\":1,\"1154\":1,\"1165\":1}}],[\"caffeine\",{\"1\":{\"299\":1}}],[\"catalinaclassloader\",{\"1\":{\"359\":4}}],[\"catalinaclassloader对应<tomcat\",{\"1\":{\"359\":1}}],[\"catch\",{\"1\":{\"357\":1,\"370\":2,\"531\":2,\"534\":1,\"553\":1,\"749\":2,\"753\":1,\"756\":2,\"757\":9,\"765\":1,\"781\":3,\"782\":3,\"785\":2,\"823\":2,\"824\":1,\"882\":1,\"909\":2,\"911\":2,\"924\":1,\"940\":1,\"944\":2,\"1011\":1,\"1020\":1,\"1030\":1,\"1062\":1,\"1293\":2}}],[\"cat\",{\"1\":{\"168\":1}}],[\"cachedthreadpool的execute\",{\"1\":{\"958\":1}}],[\"cachedthreadpool\",{\"0\":{\"956\":1,\"959\":1},\"1\":{\"888\":1,\"889\":1,\"892\":2,\"917\":1,\"937\":2,\"938\":2,\"957\":4,\"958\":2,\"959\":1}}],[\"cachevalue\",{\"1\":{\"307\":3}}],[\"cache优化热点key问题\",{\"1\":{\"299\":1}}],[\"cache\",{\"0\":{\"145\":1},\"1\":{\"145\":19,\"146\":18,\"147\":5,\"299\":1,\"307\":3,\"316\":5,\"412\":1,\"706\":6,\"720\":1,\"968\":9,\"1184\":4}}],[\"card\",{\"1\":{\"96\":5}}],[\"cancommit\",{\"1\":{\"1371\":2}}],[\"cancelacquire\",{\"1\":{\"1012\":1,\"1013\":4,\"1015\":1}}],[\"cancelled\",{\"0\":{\"1013\":1},\"1\":{\"1005\":1,\"1013\":5,\"1014\":3}}],[\"cancel\",{\"1\":{\"773\":1,\"774\":1,\"899\":1,\"934\":1}}],[\"cancelexpirationrenewal\",{\"1\":{\"49\":1}}],[\"candidate\",{\"1\":{\"1108\":3,\"1109\":3,\"1111\":8,\"1114\":2,\"1115\":1}}],[\"cannot\",{\"1\":{\"756\":1,\"911\":1,\"1043\":1}}],[\"can\",{\"1\":{\"49\":1,\"293\":1,\"298\":1,\"302\":1,\"480\":1,\"571\":2,\"693\":3,\"1333\":1}}],[\"cas抢锁\",{\"1\":{\"1007\":1}}],[\"case\",{\"1\":{\"871\":2}}],[\"caspair\",{\"1\":{\"843\":1,\"992\":1}}],[\"casresult=true\",{\"1\":{\"767\":2}}],[\"casresult=\",{\"1\":{\"767\":2}}],[\"casresult\",{\"1\":{\"767\":4}}],[\"cas修改state的值\",{\"1\":{\"748\":1}}],[\"cas失败了会循环重新获取最新的值尝试获取\",{\"1\":{\"748\":1}}],[\"cas操作\",{\"1\":{\"742\":1,\"904\":1}}],[\"castabat\",{\"1\":{\"577\":1}}],[\"cas\",{\"0\":{\"841\":1,\"990\":1},\"1\":{\"503\":3,\"571\":3,\"576\":1,\"577\":2,\"579\":1,\"598\":1,\"688\":1,\"691\":1,\"692\":1,\"742\":1,\"748\":2,\"752\":3,\"762\":2,\"765\":2,\"767\":3,\"792\":1,\"794\":2,\"838\":2,\"839\":2,\"841\":12,\"843\":2,\"844\":1,\"845\":3,\"904\":1,\"906\":2,\"908\":1,\"941\":1,\"978\":1,\"987\":2,\"988\":2,\"990\":12,\"992\":2,\"993\":1,\"994\":3,\"995\":4,\"996\":1,\"1002\":2,\"1004\":1,\"1006\":1,\"1007\":1,\"1179\":2,\"1184\":1}}],[\"cas+失败重试\",{\"1\":{\"503\":1}}],[\"cashier\",{\"1\":{\"24\":1}}],[\"cassandra\",{\"1\":{\"7\":2,\"10\":1,\"1068\":1,\"1078\":4,\"1085\":1,\"1091\":1}}],[\"cb4a9ede\",{\"1\":{\"37\":1}}],[\"clz\",{\"1\":{\"1030\":2}}],[\"clh\",{\"1\":{\"742\":10,\"752\":1,\"871\":1,\"874\":3,\"904\":5,\"1004\":3,\"1005\":1,\"1016\":1}}],[\"cleansomeslots\",{\"1\":{\"1036\":6,\"1038\":1,\"1042\":2}}],[\"cleaner\",{\"1\":{\"446\":1}}],[\"clear\",{\"1\":{\"553\":4,\"591\":1,\"593\":2,\"634\":5,\"731\":1,\"733\":1,\"1028\":2}}],[\"cl\",{\"1\":{\"359\":3}}],[\"cli\",{\"1\":{\"168\":1,\"169\":1,\"219\":1,\"293\":2,\"298\":2}}],[\"clientexception\",{\"1\":{\"1293\":2}}],[\"clientconfiguration\",{\"1\":{\"1293\":1}}],[\"clientid=consumer\",{\"1\":{\"1209\":1}}],[\"clientserviceprovider\",{\"1\":{\"1293\":2}}],[\"clients\",{\"1\":{\"1209\":1}}],[\"client\",{\"1\":{\"42\":1,\"53\":5,\"401\":1,\"1155\":2,\"1166\":4,\"1231\":1,\"1252\":4}}],[\"classcastexception\",{\"1\":{\"524\":1,\"799\":1}}],[\"classname\",{\"1\":{\"408\":1,\"523\":1}}],[\"classnotfoundexception\",{\"1\":{\"357\":3}}],[\"classpath\",{\"1\":{\"353\":1,\"425\":1,\"432\":1}}],[\"class<\",{\"1\":{\"352\":1,\"354\":1,\"357\":1,\"1030\":3}}],[\"class<t>\",{\"1\":{\"351\":1}}],[\"classes\",{\"1\":{\"351\":2,\"352\":2,\"356\":1}}],[\"classloaders\",{\"1\":{\"360\":1}}],[\"classloader的子类重写\",{\"1\":{\"354\":1}}],[\"classloader抽象类\",{\"1\":{\"353\":1,\"354\":1}}],[\"classloader\",{\"1\":{\"340\":4,\"351\":12,\"352\":3,\"353\":18,\"354\":4,\"356\":14,\"357\":1,\"359\":4,\"360\":6,\"366\":1,\"394\":1,\"426\":1,\"432\":4,\"433\":2}}],[\"class类名\",{\"1\":{\"328\":2,\"329\":1}}],[\"classfile\",{\"1\":{\"325\":5,\"498\":1}}],[\"class文件是不同的语言在\",{\"1\":{\"324\":1}}],[\"class文件的二进制格式可以使用\",{\"1\":{\"324\":1}}],[\"class文件最终运行在\",{\"1\":{\"324\":1}}],[\"class\",{\"0\":{\"325\":1,\"327\":1,\"330\":2},\"1\":{\"56\":1,\"77\":1,\"324\":1,\"325\":10,\"326\":3,\"327\":6,\"328\":2,\"329\":3,\"330\":2,\"332\":1,\"333\":2,\"334\":3,\"339\":3,\"340\":1,\"341\":3,\"342\":2,\"344\":1,\"345\":1,\"349\":1,\"351\":19,\"352\":1,\"353\":5,\"354\":2,\"356\":10,\"357\":2,\"360\":2,\"366\":1,\"370\":1,\"384\":2,\"390\":1,\"394\":1,\"418\":1,\"419\":2,\"420\":1,\"424\":1,\"425\":3,\"426\":3,\"428\":2,\"432\":1,\"433\":2,\"438\":1,\"480\":2,\"493\":1,\"496\":1,\"497\":1,\"516\":1,\"523\":2,\"531\":3,\"533\":1,\"549\":1,\"553\":4,\"555\":2,\"561\":1,\"562\":1,\"564\":2,\"586\":1,\"587\":4,\"599\":1,\"600\":1,\"619\":3,\"625\":1,\"630\":1,\"634\":3,\"663\":1,\"679\":1,\"688\":1,\"690\":1,\"706\":1,\"708\":2,\"713\":2,\"727\":2,\"732\":1,\"740\":1,\"748\":3,\"749\":1,\"752\":1,\"753\":1,\"757\":2,\"763\":1,\"764\":2,\"765\":1,\"766\":1,\"767\":4,\"768\":3,\"774\":1,\"797\":1,\"807\":1,\"823\":1,\"834\":2,\"835\":1,\"848\":5,\"851\":3,\"852\":2,\"857\":1,\"860\":1,\"865\":1,\"871\":1,\"882\":1,\"883\":1,\"884\":1,\"891\":1,\"894\":1,\"901\":1,\"903\":1,\"909\":1,\"920\":1,\"928\":1,\"934\":2,\"940\":2,\"961\":1,\"1002\":2,\"1008\":1,\"1011\":5,\"1020\":3,\"1028\":1,\"1030\":1,\"1032\":2,\"1043\":1,\"1046\":2,\"1047\":1,\"1058\":2,\"1059\":2,\"1060\":2,\"1061\":2,\"1062\":1,\"1131\":1,\"1140\":1,\"1141\":1,\"1142\":2,\"1212\":1}}],[\"clocks\",{\"1\":{\"974\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"553\":1}}],[\"clone\",{\"1\":{\"553\":2,\"572\":1,\"678\":1}}],[\"cloneable\",{\"1\":{\"549\":3,\"553\":1,\"586\":2,\"619\":1,\"727\":2}}],[\"clojure\",{\"1\":{\"324\":1}}],[\"close\",{\"1\":{\"53\":1,\"265\":1,\"268\":3,\"553\":1,\"558\":1,\"1062\":1}}],[\"cloud<\",{\"1\":{\"4\":2}}],[\"cloud\",{\"0\":{\"5\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":1},\"1\":{\"4\":3,\"5\":8,\"10\":5,\"11\":2,\"67\":1,\"68\":11,\"69\":3,\"70\":1,\"72\":6,\"75\":1,\"76\":3,\"77\":2,\"78\":5,\"876\":1,\"1123\":1,\"1172\":1,\"1281\":2}}],[\"clustered\",{\"1\":{\"111\":1}}],[\"cluster\",{\"1\":{\"35\":3,\"49\":1,\"242\":1,\"245\":1,\"286\":3,\"287\":1,\"288\":1,\"299\":1,\"318\":7,\"1085\":15,\"1092\":1,\"1130\":1,\"1131\":4,\"1196\":1,\"1281\":1,\"1367\":3}}],[\"cnblogs\",{\"1\":{\"688\":1,\"720\":1,\"758\":1,\"913\":3}}],[\"cnt\",{\"1\":{\"687\":2}}],[\"cn\",{\"1\":{\"11\":1,\"24\":3,\"274\":1,\"334\":1,\"377\":1,\"545\":1,\"720\":1,\"913\":1,\"982\":1,\"1025\":1,\"1117\":2,\"1150\":1,\"1200\":1}}],[\"coordination\",{\"0\":{\"1399\":1}}],[\"coordinator\",{\"1\":{\"1098\":1}}],[\"coolshell\",{\"1\":{\"334\":1}}],[\"cout减1\",{\"1\":{\"911\":1}}],[\"coundownlatch\",{\"1\":{\"753\":1}}],[\"countercells\",{\"1\":{\"629\":1}}],[\"countercell\",{\"1\":{\"629\":2}}],[\"count++\",{\"1\":{\"535\":1,\"764\":1,\"1020\":1,\"1038\":1}}],[\"countdown\",{\"1\":{\"531\":1,\"742\":1,\"752\":4,\"753\":4,\"908\":1,\"909\":1}}],[\"countdownlatchexample1\",{\"1\":{\"909\":1}}],[\"countdownlatchexample\",{\"1\":{\"753\":1}}],[\"countdownlatch\",{\"0\":{\"750\":1,\"907\":1,\"908\":1,\"909\":1},\"1\":{\"531\":5,\"742\":3,\"743\":1,\"748\":1,\"749\":1,\"751\":3,\"752\":6,\"753\":18,\"755\":4,\"904\":1,\"907\":3,\"908\":1,\"909\":7,\"910\":4,\"1019\":2}}],[\"counting\",{\"1\":{\"205\":1}}],[\"count\",{\"1\":{\"189\":2,\"210\":1,\"260\":2,\"325\":10,\"328\":3,\"330\":2,\"331\":5,\"332\":3,\"333\":2,\"531\":2,\"534\":1,\"535\":4,\"536\":2,\"537\":2,\"538\":1,\"571\":2,\"713\":7,\"748\":1,\"751\":1,\"752\":8,\"753\":6,\"756\":12,\"764\":5,\"907\":1,\"908\":1,\"909\":3,\"911\":11,\"1007\":1,\"1018\":2,\"1020\":2,\"1038\":2}}],[\"covering\",{\"1\":{\"756\":1,\"911\":1}}],[\"cow\",{\"1\":{\"585\":2}}],[\"copyonwritearraylist提供了两个用于判断指定元素是否在列表中的方法\",{\"1\":{\"592\":1}}],[\"copyonwritearraylist删除元素相关的方法一共有\",{\"1\":{\"591\":1}}],[\"copyonwritearraylist中并没有size属性copyonwritearraylist的底层数组的长度就是元素个数\",{\"1\":{\"590\":1}}],[\"copyonwritearraylist中的array数组每次复制都刚好能够容纳下所有元素\",{\"1\":{\"590\":1}}],[\"copyonwritearraylist<>\",{\"1\":{\"593\":1}}],[\"copyonwritearraylist<string>\",{\"1\":{\"593\":1}}],[\"copyonwritearraylist<\",{\"1\":{\"587\":1}}],[\"copyonwritearraylist<e>\",{\"1\":{\"586\":1}}],[\"copyonwritearraylist为例介绍\",{\"1\":{\"585\":1}}],[\"copyonwritearraylist名字中的\",{\"1\":{\"585\":1}}],[\"copyonwritearraylist\",{\"0\":{\"582\":1,\"583\":1,\"584\":1,\"586\":1,\"593\":1,\"793\":1},\"1\":{\"583\":1,\"584\":4,\"585\":1,\"586\":4,\"587\":7,\"588\":8,\"589\":1,\"593\":1,\"651\":1,\"791\":1,\"793\":8}}],[\"copyof功能是实现数组的复制\",{\"1\":{\"553\":1}}],[\"copyof\",{\"0\":{\"560\":1,\"562\":1},\"1\":{\"553\":6,\"555\":1,\"558\":1,\"562\":4,\"563\":2,\"587\":2,\"588\":3,\"591\":1,\"634\":1}}],[\"copy\",{\"0\":{\"585\":1},\"1\":{\"562\":3,\"584\":1,\"585\":5,\"588\":1,\"793\":1}}],[\"copying\",{\"1\":{\"397\":1}}],[\"code\",{\"1\":{\"412\":1,\"553\":1,\"756\":1,\"798\":3,\"824\":1,\"911\":1}}],[\"code=pcoperatebanner\",{\"1\":{\"24\":1}}],[\"correctness\",{\"1\":{\"1011\":1}}],[\"corresponds\",{\"1\":{\"86\":1}}],[\"coredns\",{\"1\":{\"1157\":1}}],[\"core参数为false的话表明队列也满了\",{\"1\":{\"941\":1}}],[\"core参数为true的话表示使用线程池的基本大小\",{\"1\":{\"941\":1}}],[\"core\",{\"1\":{\"940\":2,\"941\":2,\"1132\":1}}],[\"corepoolsize\",{\"1\":{\"530\":1,\"889\":4,\"890\":8,\"894\":1,\"896\":1,\"920\":1,\"923\":1,\"928\":2,\"936\":7,\"937\":4,\"940\":1,\"941\":4,\"949\":3,\"950\":2,\"951\":3,\"953\":1,\"954\":1,\"961\":4}}],[\"cornerstone\",{\"1\":{\"205\":1}}],[\"coll\",{\"1\":{\"697\":4}}],[\"collisions\",{\"1\":{\"618\":1,\"682\":1}}],[\"collect\",{\"1\":{\"630\":1,\"634\":2,\"909\":1}}],[\"collection接口\",{\"1\":{\"639\":1}}],[\"collectionutils\",{\"1\":{\"632\":2,\"634\":1}}],[\"collection\",{\"1\":{\"534\":1,\"602\":1,\"625\":1,\"631\":1,\"634\":2,\"641\":1,\"667\":1,\"697\":5,\"698\":2,\"732\":1,\"796\":1}}],[\"collection<t>\",{\"1\":{\"698\":1}}],[\"collection<string>\",{\"1\":{\"625\":1}}],[\"collection<\",{\"1\":{\"533\":2,\"534\":1,\"553\":5,\"555\":1,\"587\":1,\"591\":1,\"592\":2,\"602\":1,\"728\":1}}],[\"collections\",{\"0\":{\"695\":1},\"1\":{\"49\":1,\"480\":1,\"633\":1,\"634\":1,\"658\":2,\"661\":1,\"662\":7,\"695\":1,\"698\":2,\"792\":1,\"1293\":1}}],[\"collected\",{\"1\":{\"382\":1,\"495\":1}}],[\"collectorimpl<>\",{\"1\":{\"630\":1}}],[\"collector<t\",{\"1\":{\"630\":1}}],[\"collectors\",{\"1\":{\"630\":3,\"634\":2,\"909\":1}}],[\"collector\",{\"1\":{\"7\":1,\"386\":2}}],[\"column\",{\"1\":{\"120\":1,\"221\":1,\"1185\":1}}],[\"connectstring\",{\"1\":{\"1333\":2}}],[\"connect\",{\"1\":{\"1333\":1}}],[\"connected\",{\"1\":{\"1325\":2,\"1326\":1,\"1327\":1,\"1328\":2,\"1329\":1,\"1330\":1,\"1331\":1,\"1349\":1}}],[\"connector\",{\"1\":{\"1238\":1}}],[\"connection\",{\"1\":{\"56\":1,\"84\":1,\"1158\":1,\"1383\":1}}],[\"conditon\",{\"1\":{\"871\":1,\"873\":1}}],[\"conditionwaiter\",{\"1\":{\"604\":2}}],[\"condition是\",{\"1\":{\"544\":1,\"862\":1}}],[\"condition接口的补充\",{\"1\":{\"544\":1,\"862\":1}}],[\"condition\",{\"1\":{\"117\":1,\"544\":2,\"598\":1,\"601\":1,\"604\":1,\"607\":2,\"608\":1,\"755\":1,\"862\":1,\"910\":1,\"999\":1,\"1005\":3,\"1007\":1}}],[\"converted\",{\"1\":{\"708\":1}}],[\"convert\",{\"1\":{\"599\":1}}],[\"concurrnethashmap\",{\"1\":{\"569\":1}}],[\"concurrentkafkalistenercontainerfactory\",{\"1\":{\"1211\":2}}],[\"concurrentskiplistmap\",{\"0\":{\"800\":1},\"1\":{\"791\":1,\"800\":2}}],[\"concurrentskiplistmaps\",{\"1\":{\"693\":1}}],[\"concurrent包下面的所有的类都是\",{\"1\":{\"631\":1}}],[\"concurrentmap<string\",{\"1\":{\"1142\":4}}],[\"concurrentmap<thread\",{\"1\":{\"56\":2}}],[\"concurrentmap\",{\"1\":{\"1142\":1}}],[\"concurrentmaps\",{\"1\":{\"693\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"631\":1,\"713\":2}}],[\"concurrenthashmap<>\",{\"1\":{\"1142\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"1142\":1}}],[\"concurrenthashmaps\",{\"1\":{\"693\":1}}],[\"concurrenthashmap\",{\"0\":{\"567\":1,\"568\":1,\"574\":1,\"688\":1,\"689\":1,\"692\":1,\"693\":1,\"694\":1,\"792\":1},\"1\":{\"567\":1,\"569\":3,\"570\":5,\"571\":1,\"572\":1,\"575\":2,\"576\":1,\"578\":1,\"579\":2,\"629\":2,\"646\":1,\"651\":1,\"677\":1,\"685\":1,\"688\":11,\"690\":3,\"691\":3,\"693\":8,\"694\":6,\"791\":1,\"792\":5}}],[\"concurrentlinkedqueue这个队列使用链表作为其数据结构\",{\"1\":{\"794\":1}}],[\"concurrentlinkedqueue\",{\"0\":{\"543\":1,\"794\":1},\"1\":{\"543\":4,\"629\":1,\"791\":1,\"794\":6,\"796\":1,\"1179\":1}}],[\"concurrent\",{\"1\":{\"402\":1,\"406\":2,\"529\":1,\"583\":2,\"597\":1,\"598\":1,\"629\":1,\"693\":3,\"740\":1,\"762\":2,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"773\":1,\"791\":1,\"793\":1,\"801\":1,\"838\":2,\"894\":3,\"899\":1,\"903\":1,\"920\":3,\"940\":3,\"944\":3,\"964\":1,\"982\":1,\"987\":2,\"1002\":2,\"1006\":1,\"1008\":3,\"1011\":5,\"1012\":5,\"1013\":2,\"1014\":6,\"1015\":3,\"1018\":3,\"1022\":1,\"1252\":2}}],[\"concurrencylevel\",{\"1\":{\"570\":9}}],[\"concurrency\",{\"1\":{\"141\":1,\"570\":2}}],[\"content\",{\"1\":{\"1117\":1,\"1159\":2}}],[\"context\",{\"1\":{\"1047\":5}}],[\"continue\",{\"1\":{\"941\":1}}],[\"containerid\",{\"1\":{\"1322\":2}}],[\"container\",{\"1\":{\"1128\":1,\"1210\":2,\"1212\":2}}],[\"contain\",{\"1\":{\"680\":1,\"708\":1}}],[\"containsvalue\",{\"1\":{\"625\":2}}],[\"containskey等\",{\"1\":{\"694\":1}}],[\"containskey\",{\"1\":{\"625\":2,\"632\":2,\"693\":1,\"694\":2}}],[\"containsall\",{\"1\":{\"592\":2}}],[\"contains\",{\"1\":{\"351\":1,\"533\":1,\"538\":2,\"553\":1,\"592\":2,\"632\":7,\"634\":1,\"693\":2}}],[\"control\",{\"1\":{\"141\":1,\"1384\":1}}],[\"confirm\",{\"1\":{\"1261\":2}}],[\"configuration\",{\"1\":{\"364\":2,\"928\":1}}],[\"config\",{\"1\":{\"7\":2,\"49\":1,\"72\":2,\"220\":6,\"267\":1,\"302\":3,\"1130\":1}}],[\"confluent\",{\"1\":{\"1241\":1}}],[\"conf\",{\"1\":{\"226\":1,\"267\":2,\"298\":1,\"302\":1}}],[\"consul\",{\"1\":{\"896\":1,\"923\":1,\"1085\":1,\"1091\":1,\"1097\":1,\"1157\":1}}],[\"consumeoffset\",{\"1\":{\"1315\":2}}],[\"consumequeue文件大小约\",{\"1\":{\"1315\":1}}],[\"consumequeue\",{\"1\":{\"1315\":12}}],[\"consumerqueue\",{\"1\":{\"1315\":1}}],[\"consumer3\",{\"1\":{\"1280\":1}}],[\"consumer2\",{\"1\":{\"1280\":1}}],[\"consumer1\",{\"1\":{\"1280\":1}}],[\"consumerfactory\",{\"1\":{\"1211\":2}}],[\"consumerfactory<string\",{\"1\":{\"1211\":1}}],[\"consumerrecord\",{\"1\":{\"1210\":1}}],[\"consumer<t>\",{\"1\":{\"779\":2}}],[\"consumer<\",{\"1\":{\"634\":1,\"779\":5,\"781\":2,\"1212\":1}}],[\"consumer\",{\"0\":{\"1196\":1,\"1248\":1,\"1254\":1},\"1\":{\"531\":4,\"779\":2,\"1128\":1,\"1182\":1,\"1196\":2,\"1199\":2,\"1205\":1,\"1209\":2,\"1210\":4,\"1212\":2,\"1248\":2,\"1262\":3,\"1263\":1,\"1280\":4,\"1281\":4,\"1306\":2,\"1315\":1}}],[\"consume\",{\"1\":{\"302\":1}}],[\"consecutive\",{\"1\":{\"572\":1}}],[\"conscious\",{\"1\":{\"553\":1}}],[\"consistenthashloadbalance\",{\"0\":{\"1143\":1},\"1\":{\"1143\":5}}],[\"consistent\",{\"1\":{\"1073\":1}}],[\"consistency\",{\"1\":{\"125\":1,\"281\":1,\"1067\":3,\"1368\":1}}],[\"consider\",{\"1\":{\"894\":1,\"920\":1}}],[\"considerations\",{\"1\":{\"480\":1}}],[\"constructor\",{\"1\":{\"523\":1}}],[\"constitutes\",{\"1\":{\"351\":1}}],[\"constant\",{\"0\":{\"328\":1},\"1\":{\"325\":3,\"328\":18,\"497\":1,\"618\":1,\"682\":1}}],[\"const表很快\",{\"1\":{\"120\":1}}],[\"const\",{\"1\":{\"120\":2}}],[\"comsumer\",{\"1\":{\"1316\":1}}],[\"computation\",{\"1\":{\"780\":2}}],[\"computer\",{\"1\":{\"1022\":1}}],[\"computeifpresent\",{\"1\":{\"694\":1}}],[\"computeifabsent\",{\"1\":{\"694\":3,\"1142\":2}}],[\"compute\",{\"1\":{\"386\":1,\"495\":1,\"694\":1}}],[\"completionexception\",{\"1\":{\"780\":1}}],[\"completionstage\",{\"1\":{\"774\":4,\"901\":3}}],[\"completionstage<\",{\"1\":{\"781\":2}}],[\"completionstage<u>>\",{\"1\":{\"781\":3}}],[\"completionstage<t>\",{\"1\":{\"774\":1,\"901\":1}}],[\"completionstage<boolean>\",{\"1\":{\"49\":2}}],[\"completeexceptionally\",{\"1\":{\"780\":2}}],[\"completedfuture\",{\"1\":{\"777\":4,\"779\":4}}],[\"complete\",{\"1\":{\"777\":3}}],[\"completablefuture来实现异步消息处理\",{\"1\":{\"788\":1}}],[\"completablefuture的时候一定要以正确的方式进行异常处理\",{\"1\":{\"786\":1}}],[\"completablefuture的get\",{\"1\":{\"785\":1}}],[\"completablefuture<object>\",{\"1\":{\"782\":1}}],[\"completablefuture<void>\",{\"1\":{\"778\":3,\"779\":6,\"781\":2,\"782\":4,\"909\":4}}],[\"completablefuture<u>\",{\"1\":{\"777\":2,\"778\":2,\"779\":3,\"780\":3,\"781\":3}}],[\"completablefuture<string>\",{\"1\":{\"777\":1,\"778\":1,\"779\":3,\"780\":3,\"781\":4,\"782\":2,\"785\":1}}],[\"completablefuture<>\",{\"1\":{\"777\":1,\"780\":1}}],[\"completablefuture<rpcresponse<object>>\",{\"1\":{\"777\":1}}],[\"completablefuture<t>\",{\"1\":{\"774\":1,\"779\":3,\"901\":1}}],[\"completablefuture\",{\"0\":{\"772\":1,\"774\":1,\"775\":1,\"776\":1,\"781\":1,\"782\":1,\"783\":1,\"901\":1},\"1\":{\"772\":3,\"774\":5,\"776\":2,\"777\":8,\"778\":2,\"779\":5,\"780\":6,\"781\":13,\"782\":14,\"784\":3,\"785\":1,\"786\":2,\"788\":4,\"901\":4,\"909\":6,\"913\":1}}],[\"comparator接口实际上是出自\",{\"1\":{\"661\":1}}],[\"comparator\",{\"0\":{\"661\":1,\"662\":1},\"1\":{\"661\":2,\"669\":1,\"696\":1,\"697\":2,\"799\":1,\"897\":1}}],[\"comparator<person>\",{\"1\":{\"679\":1}}],[\"comparator<integer>\",{\"1\":{\"662\":1}}],[\"comparator<\",{\"1\":{\"634\":1}}],[\"comparable<person>\",{\"1\":{\"663\":1}}],[\"comparable<\",{\"1\":{\"658\":1}}],[\"comparable<delayed>\",{\"1\":{\"597\":1}}],[\"comparable\",{\"0\":{\"661\":1},\"1\":{\"610\":1,\"661\":2,\"669\":1,\"799\":1,\"897\":1}}],[\"compareandincrementworkercount\",{\"1\":{\"941\":1}}],[\"compareandsetnext\",{\"1\":{\"1013\":2}}],[\"compareandsetwaitstatus\",{\"1\":{\"1012\":1,\"1013\":1,\"1014\":1}}],[\"compareandsethead\",{\"1\":{\"1011\":2}}],[\"compareandsettail\",{\"1\":{\"1011\":5,\"1013\":1,\"1014\":2}}],[\"compareandset\",{\"1\":{\"763\":1,\"766\":1,\"767\":9,\"843\":2,\"992\":2}}],[\"compareandsetstate\",{\"1\":{\"742\":1,\"748\":2,\"752\":1,\"904\":1,\"1002\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1018\":2,\"1020\":1}}],[\"compareandswaplong\",{\"1\":{\"841\":1,\"871\":2,\"990\":1}}],[\"compareandswaplong方法来实现的对object\",{\"1\":{\"841\":1,\"990\":1}}],[\"compareandswapint\",{\"1\":{\"576\":1,\"742\":1,\"765\":1,\"841\":2,\"904\":1,\"990\":2}}],[\"compareandswapobject\",{\"1\":{\"571\":1,\"841\":1,\"990\":1,\"1011\":1}}],[\"compare\",{\"1\":{\"599\":1,\"662\":1,\"679\":3,\"742\":1,\"765\":1,\"767\":4,\"841\":1,\"904\":1,\"978\":1,\"990\":1,\"995\":1}}],[\"compareto\",{\"0\":{\"663\":1},\"1\":{\"599\":2,\"610\":1,\"661\":1,\"662\":1,\"663\":1,\"799\":1,\"897\":1}}],[\"compact\",{\"1\":{\"398\":1}}],[\"compiler\",{\"1\":{\"366\":1}}],[\"component\",{\"1\":{\"77\":1,\"1046\":2}}],[\"commonerrorhandler\",{\"1\":{\"1212\":2}}],[\"commonpool\",{\"1\":{\"784\":1}}],[\"commons\",{\"1\":{\"634\":1}}],[\"commonclassloader\",{\"1\":{\"359\":2}}],[\"commonclassloader作为\",{\"1\":{\"359\":1}}],[\"commonclassloader对应<tomcat>\",{\"1\":{\"359\":1}}],[\"common\",{\"1\":{\"359\":1,\"871\":1}}],[\"command\",{\"1\":{\"302\":1,\"756\":3,\"911\":3,\"934\":1,\"940\":3,\"941\":13}}],[\"commands\",{\"1\":{\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1,\"196\":2,\"219\":1,\"274\":1,\"293\":1,\"298\":1}}],[\"commandstats统计信息分析出命令不合理开销时间\",{\"1\":{\"169\":1}}],[\"commandexecutor\",{\"1\":{\"49\":1}}],[\"comment\",{\"1\":{\"34\":4}}],[\"commitloq\",{\"1\":{\"1315\":1}}],[\"commitlog\",{\"1\":{\"1315\":9}}],[\"commitindex\",{\"1\":{\"1110\":1}}],[\"committed\",{\"1\":{\"125\":1,\"132\":2,\"1112\":1}}],[\"commit之后即可改变底层数据库数据\",{\"1\":{\"125\":1}}],[\"commit\",{\"1\":{\"33\":1,\"89\":1,\"90\":1,\"125\":1,\"1207\":1,\"1370\":3,\"1371\":1,\"1380\":4}}],[\"com\",{\"1\":{\"4\":2,\"5\":1,\"6\":1,\"7\":3,\"8\":1,\"9\":1,\"11\":1,\"24\":1,\"68\":1,\"72\":1,\"78\":1,\"156\":1,\"171\":2,\"196\":2,\"213\":1,\"218\":1,\"237\":1,\"256\":1,\"268\":1,\"274\":2,\"293\":1,\"298\":1,\"320\":3,\"334\":1,\"345\":1,\"360\":4,\"377\":1,\"386\":1,\"409\":1,\"475\":1,\"511\":6,\"545\":2,\"567\":1,\"688\":1,\"720\":2,\"758\":2,\"801\":1,\"876\":6,\"913\":4,\"929\":1,\"982\":1,\"996\":2,\"999\":1,\"1092\":1,\"1100\":1,\"1117\":2,\"1131\":2,\"1168\":1,\"1169\":2,\"1170\":1,\"1171\":1,\"1178\":2,\"1199\":1,\"1218\":1,\"1236\":1,\"1237\":2,\"1238\":1,\"1241\":1,\"1252\":5}}],[\"c\",{\"1\":{\"6\":3,\"23\":4,\"89\":7,\"125\":1,\"141\":1,\"176\":4,\"180\":1,\"218\":1,\"242\":1,\"256\":10,\"325\":1,\"352\":2,\"354\":1,\"357\":9,\"365\":2,\"367\":5,\"368\":2,\"369\":3,\"370\":2,\"422\":1,\"435\":1,\"441\":1,\"445\":2,\"490\":1,\"531\":2,\"533\":2,\"534\":2,\"553\":13,\"555\":3,\"570\":4,\"571\":3,\"587\":5,\"591\":1,\"592\":3,\"602\":2,\"634\":2,\"696\":1,\"697\":3,\"698\":1,\"728\":2,\"752\":4,\"833\":1,\"851\":1,\"941\":16,\"975\":2,\"1007\":3,\"1014\":3,\"1018\":4,\"1068\":5,\"1070\":1,\"1073\":1,\"1074\":1,\"1087\":5,\"1105\":4,\"1155\":3,\"1161\":2,\"1209\":3,\"1237\":1,\"1245\":1,\"1246\":1,\"1335\":1}}],[\"hbase\",{\"1\":{\"1068\":1,\"1181\":2,\"1344\":2}}],[\"hhmm\",{\"1\":{\"882\":12}}],[\"hd\",{\"1\":{\"683\":4}}],[\"hdel\",{\"1\":{\"185\":1}}],[\"hugecapacity\",{\"0\":{\"559\":1},\"1\":{\"553\":2,\"558\":3,\"559\":2}}],[\"hprof格式\",{\"1\":{\"484\":1}}],[\"hprof\",{\"1\":{\"368\":2,\"369\":2,\"484\":1}}],[\"h3\",{\"1\":{\"366\":1}}],[\"h<lines>\",{\"1\":{\"366\":1}}],[\"h\",{\"1\":{\"256\":1,\"268\":4,\"572\":3,\"573\":4,\"578\":5,\"618\":10,\"682\":10,\"1011\":8,\"1014\":13,\"1037\":12,\"1038\":5}}],[\"hidden\",{\"1\":{\"1252\":3}}],[\"histogram\",{\"1\":{\"1179\":1}}],[\"history\",{\"1\":{\"231\":3}}],[\"hinted\",{\"1\":{\"1078\":1}}],[\"hincrby\",{\"1\":{\"185\":2}}],[\"hippo4j\",{\"1\":{\"896\":1,\"923\":1}}],[\"hi\",{\"1\":{\"649\":2}}],[\"hitail\",{\"1\":{\"624\":6}}],[\"hihead\",{\"1\":{\"624\":3}}],[\"high\",{\"1\":{\"480\":1,\"1200\":1}}],[\"higher\",{\"1\":{\"480\":1}}],[\"hibernate\",{\"1\":{\"412\":1}}],[\"hll\",{\"1\":{\"206\":9}}],[\"hlen\",{\"1\":{\"185\":1,\"293\":2}}],[\"hyper\",{\"1\":{\"1154\":1}}],[\"hyperloglog\",{\"0\":{\"204\":1,\"262\":1},\"1\":{\"199\":1,\"205\":10,\"206\":5,\"212\":3,\"213\":3,\"242\":1,\"253\":1,\"262\":4,\"294\":1}}],[\"hyperloglog更适合一些\",{\"1\":{\"190\":1,\"259\":1}}],[\"hystrix\",{\"1\":{\"4\":2}}],[\"hmget\",{\"1\":{\"185\":1,\"186\":1,\"286\":1}}],[\"hmset\",{\"1\":{\"185\":2,\"186\":1,\"286\":1}}],[\"hget\",{\"1\":{\"185\":4,\"186\":1}}],[\"hgetall\",{\"1\":{\"157\":1,\"185\":2,\"301\":1,\"319\":1}}],[\"hsetnx\",{\"1\":{\"185\":1}}],[\"hset\",{\"1\":{\"185\":2,\"186\":1}}],[\"hscan\",{\"1\":{\"157\":1,\"301\":1,\"319\":1}}],[\"holder\",{\"1\":{\"1028\":6}}],[\"holding\",{\"1\":{\"688\":1}}],[\"hood\",{\"1\":{\"511\":1}}],[\"hosee\",{\"1\":{\"409\":1}}],[\"hostname=外网访问\",{\"1\":{\"373\":1}}],[\"host\",{\"1\":{\"75\":1}}],[\"home\",{\"1\":{\"353\":2}}],[\"hotspot\",{\"0\":{\"500\":1},\"1\":{\"342\":2,\"364\":1,\"380\":2,\"386\":1,\"387\":1,\"393\":3,\"399\":1,\"400\":1,\"403\":1,\"406\":1,\"407\":1,\"443\":1,\"444\":1,\"448\":1,\"480\":1,\"485\":1,\"489\":1,\"494\":1,\"495\":1,\"496\":4,\"498\":2,\"500\":1,\"507\":3,\"510\":1,\"808\":1,\"812\":1,\"851\":1,\"1053\":1}}],[\"hot\",{\"1\":{\"298\":1}}],[\"hotkeys\",{\"1\":{\"298\":4}}],[\"hotkey\",{\"0\":{\"295\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1},\"1\":{\"296\":3,\"297\":3,\"298\":8,\"299\":3,\"320\":1}}],[\"hogwartsrico\",{\"1\":{\"213\":1}}],[\"howtodoinjava\",{\"1\":{\"820\":1}}],[\"however\",{\"1\":{\"218\":1,\"256\":1}}],[\"how\",{\"1\":{\"51\":1,\"1053\":1}}],[\"half\",{\"1\":{\"1304\":6}}],[\"ha\",{\"1\":{\"1275\":1,\"1281\":1}}],[\"handoff\",{\"1\":{\"1078\":1}}],[\"handleasync\",{\"1\":{\"780\":2}}],[\"handlepromotionfailure\",{\"1\":{\"388\":2}}],[\"handle\",{\"1\":{\"77\":1,\"388\":1,\"780\":3,\"786\":1}}],[\"handleremaining\",{\"1\":{\"1212\":3}}],[\"handlerinterceptoradapter\",{\"1\":{\"1046\":1}}],[\"handler\",{\"1\":{\"69\":2,\"218\":1,\"265\":5,\"530\":1,\"807\":1,\"890\":5,\"936\":5,\"940\":1,\"1046\":1,\"1182\":1}}],[\"hadoop\",{\"1\":{\"1341\":1,\"1344\":1}}],[\"had\",{\"1\":{\"756\":1,\"911\":1}}],[\"happens\",{\"0\":{\"974\":1,\"975\":1,\"976\":1},\"1\":{\"971\":1,\"974\":20,\"975\":9,\"976\":2,\"981\":1}}],[\"happen\",{\"1\":{\"756\":1,\"911\":1}}],[\"hagersten\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"hasqueuedpredecessors\",{\"1\":{\"1011\":2,\"1018\":1}}],[\"hasprevious\",{\"1\":{\"732\":2}}],[\"hasnext\",{\"1\":{\"732\":2}}],[\"has\",{\"1\":{\"293\":2,\"351\":1,\"356\":1}}],[\"hash分布非常均匀\",{\"1\":{\"1032\":1}}],[\"hash增量为\",{\"1\":{\"1032\":1}}],[\"hashiterator\",{\"1\":{\"713\":1}}],[\"hashing\",{\"1\":{\"37\":1}}],[\"hashtable\",{\"0\":{\"677\":1,\"688\":1},\"1\":{\"645\":2,\"677\":8,\"688\":5}}],[\"hash值与插入元素相等的结点\",{\"1\":{\"622\":1}}],[\"hashcodes\",{\"1\":{\"618\":1,\"682\":1,\"708\":2}}],[\"hashcode\",{\"1\":{\"577\":3,\"578\":1,\"618\":4,\"619\":3,\"664\":1,\"678\":3,\"680\":4,\"682\":4,\"708\":1,\"1037\":1,\"1315\":2}}],[\"hashentry\",{\"1\":{\"570\":1,\"571\":9,\"572\":1,\"575\":1,\"579\":2,\"688\":4,\"690\":6}}],[\"hashentry<k\",{\"1\":{\"570\":1,\"571\":14,\"572\":11,\"573\":3}}],[\"hashs\",{\"1\":{\"293\":1}}],[\"hashset<worker>\",{\"1\":{\"941\":1}}],[\"hashset<>\",{\"1\":{\"632\":2,\"941\":1}}],[\"hashset都会直接插入\",{\"1\":{\"680\":1}}],[\"hashset的add\",{\"1\":{\"680\":1}}],[\"hashset\",{\"0\":{\"665\":1,\"678\":1,\"680\":1},\"1\":{\"188\":1,\"195\":1,\"259\":1,\"632\":2,\"643\":2,\"646\":1,\"665\":4,\"678\":6,\"680\":3,\"698\":1}}],[\"hash维护简单的购物车信息\",{\"1\":{\"257\":1}}],[\"hashmap中解决冲突的方法是在数组上构造一个链表结构\",{\"1\":{\"1033\":1}}],[\"hashmap的removenode完成元素移除后会调用afternoderemoval进行移除后置操作\",{\"1\":{\"711\":1}}],[\"hashmap1\",{\"1\":{\"688\":1}}],[\"hashmap其他常用方法\",{\"1\":{\"625\":1}}],[\"hashmap<>\",{\"1\":{\"713\":1}}],[\"hashmap<e\",{\"1\":{\"632\":1}}],[\"hashmap<string\",{\"1\":{\"625\":2}}],[\"hashmap<k\",{\"1\":{\"619\":1}}],[\"hashmapdemo\",{\"1\":{\"625\":1}}],[\"hashmap\",{\"0\":{\"615\":1,\"616\":1,\"620\":1,\"625\":1,\"677\":1,\"678\":1,\"679\":1,\"681\":1,\"684\":1,\"685\":1,\"686\":1,\"687\":1,\"713\":1,\"719\":1},\"1\":{\"184\":1,\"192\":1,\"195\":1,\"567\":2,\"569\":2,\"570\":2,\"579\":1,\"616\":7,\"618\":6,\"619\":2,\"621\":6,\"622\":2,\"625\":1,\"632\":1,\"643\":2,\"645\":5,\"646\":1,\"665\":1,\"677\":12,\"678\":4,\"682\":6,\"683\":3,\"684\":3,\"685\":6,\"686\":4,\"687\":1,\"688\":3,\"690\":1,\"691\":1,\"693\":3,\"694\":1,\"698\":1,\"702\":4,\"704\":2,\"708\":13,\"709\":1,\"710\":1,\"711\":3,\"712\":6,\"713\":7,\"715\":3,\"719\":5,\"720\":1,\"791\":1,\"792\":4,\"883\":1,\"1033\":1,\"1210\":1}}],[\"hash\",{\"0\":{\"96\":1,\"183\":1,\"255\":1,\"257\":1,\"1032\":1,\"1033\":1},\"1\":{\"157\":1,\"174\":2,\"178\":1,\"184\":3,\"185\":1,\"195\":1,\"196\":1,\"242\":1,\"245\":1,\"249\":1,\"253\":1,\"255\":3,\"257\":4,\"271\":1,\"286\":3,\"287\":1,\"288\":1,\"291\":1,\"293\":1,\"294\":2,\"301\":1,\"571\":19,\"572\":4,\"573\":2,\"577\":9,\"578\":6,\"618\":13,\"619\":6,\"621\":1,\"622\":19,\"623\":8,\"624\":4,\"680\":1,\"682\":13,\"683\":6,\"684\":3,\"686\":10,\"691\":1,\"692\":1,\"693\":1,\"708\":2,\"710\":1,\"711\":1,\"712\":2,\"1032\":2,\"1033\":1,\"1037\":1,\"1143\":1,\"1299\":1,\"1315\":1}}],[\"have\",{\"1\":{\"86\":2,\"218\":1,\"356\":1,\"618\":1,\"682\":1,\"693\":1}}],[\"hessian2\",{\"1\":{\"1146\":2,\"1147\":1}}],[\"hessian\",{\"1\":{\"1123\":1}}],[\"heuristically\",{\"1\":{\"1036\":1,\"1042\":1}}],[\"hell\",{\"1\":{\"1055\":1}}],[\"hello\",{\"1\":{\"649\":3,\"777\":2,\"778\":4,\"779\":12,\"780\":2,\"781\":4,\"785\":1}}],[\"helloworld\",{\"1\":{\"418\":3}}],[\"held\",{\"1\":{\"370\":2}}],[\"helptransfer\",{\"1\":{\"577\":1}}],[\"help\",{\"0\":{\"1324\":1},\"1\":{\"293\":1,\"298\":1,\"876\":1,\"1012\":1,\"1013\":1,\"1015\":1,\"1324\":1}}],[\"heartbeat\",{\"1\":{\"1116\":1}}],[\"headoffset\",{\"1\":{\"1011\":1}}],[\"head\",{\"1\":{\"657\":2,\"680\":1,\"710\":3,\"711\":2,\"712\":3,\"798\":1,\"1011\":11,\"1012\":2,\"1013\":6,\"1014\":6,\"1015\":1}}],[\"headers\",{\"1\":{\"1249\":1,\"1252\":6}}],[\"headerfuture\",{\"1\":{\"782\":1,\"909\":1}}],[\"headerfuture=completablefuture\",{\"1\":{\"782\":1,\"909\":1}}],[\"header\",{\"1\":{\"17\":2,\"256\":4,\"1046\":1,\"1159\":4}}],[\"heapdumppath\",{\"1\":{\"484\":1}}],[\"heapdumppath=\",{\"1\":{\"484\":1}}],[\"heapdumppath=你要输出的日志路径\",{\"1\":{\"455\":1}}],[\"heapdumponoutofmemoryerror\",{\"1\":{\"484\":1}}],[\"heapdump\",{\"0\":{\"369\":1},\"1\":{\"364\":1,\"369\":1,\"412\":1,\"486\":1}}],[\"heap\",{\"1\":{\"364\":1,\"368\":4,\"369\":2,\"382\":1,\"393\":1,\"449\":1,\"478\":1,\"484\":1,\"495\":3,\"498\":1}}],[\"here\",{\"1\":{\"256\":1,\"882\":1}}],[\"hexists\",{\"1\":{\"49\":1,\"185\":2}}],[\"htm\",{\"1\":{\"612\":1}}],[\"html>\",{\"1\":{\"688\":1}}],[\"html\",{\"1\":{\"78\":1,\"213\":1,\"274\":1,\"334\":3,\"345\":2,\"360\":1,\"364\":1,\"369\":1,\"377\":3,\"386\":1,\"409\":2,\"511\":2,\"720\":1,\"758\":2,\"876\":2,\"913\":3,\"982\":3,\"999\":1,\"1117\":1,\"1178\":1,\"1237\":1}}],[\"html5\",{\"1\":{\"17\":1}}],[\"http2\",{\"0\":{\"1160\":1},\"1\":{\"1160\":1,\"1161\":1}}],[\"http2在前者的基础上做了很多改进\",{\"1\":{\"1159\":1}}],[\"http原理\",{\"1\":{\"1159\":1}}],[\"http报文\",{\"1\":{\"1159\":1}}],[\"http1\",{\"1\":{\"1158\":1,\"1159\":2,\"1161\":2}}],[\"http调用\",{\"1\":{\"1154\":1}}],[\"http\",{\"0\":{\"1150\":1,\"1153\":1,\"1155\":1,\"1156\":1,\"1174\":1},\"1\":{\"7\":2,\"17\":2,\"42\":3,\"237\":1,\"360\":1,\"364\":1,\"369\":3,\"511\":1,\"887\":1,\"932\":1,\"982\":1,\"1100\":1,\"1150\":1,\"1152\":1,\"1154\":4,\"1155\":7,\"1156\":1,\"1157\":1,\"1158\":2,\"1159\":4,\"1161\":4,\"1167\":2,\"1168\":1,\"1169\":1,\"1170\":1,\"1174\":1,\"1218\":1,\"1235\":1,\"1303\":1}}],[\"httpservletresponse\",{\"1\":{\"1046\":3}}],[\"httpservletrequest\",{\"1\":{\"1046\":3}}],[\"https\",{\"1\":{\"4\":2,\"5\":2,\"6\":2,\"7\":3,\"8\":2,\"9\":2,\"11\":4,\"24\":3,\"49\":1,\"68\":2,\"69\":1,\"72\":1,\"78\":3,\"156\":1,\"171\":2,\"177\":1,\"181\":1,\"185\":1,\"189\":1,\"193\":1,\"196\":4,\"205\":1,\"213\":2,\"218\":2,\"219\":1,\"221\":2,\"224\":1,\"235\":1,\"237\":3,\"256\":1,\"268\":1,\"274\":2,\"280\":1,\"285\":1,\"293\":1,\"298\":1,\"320\":5,\"334\":3,\"345\":1,\"360\":4,\"377\":4,\"386\":1,\"409\":2,\"415\":1,\"475\":1,\"511\":6,\"522\":1,\"545\":3,\"567\":1,\"612\":2,\"633\":1,\"688\":1,\"720\":3,\"758\":2,\"801\":2,\"876\":6,\"913\":5,\"929\":1,\"982\":3,\"996\":2,\"999\":1,\"1025\":1,\"1030\":1,\"1092\":1,\"1100\":1,\"1117\":4,\"1140\":1,\"1143\":1,\"1150\":1,\"1168\":2,\"1169\":1,\"1170\":2,\"1171\":2,\"1178\":3,\"1185\":1,\"1199\":1,\"1200\":1,\"1214\":1,\"1218\":1,\"1235\":1,\"1236\":2,\"1237\":2,\"1238\":2,\"1241\":2}}],[\"gb\",{\"1\":{\"478\":3,\"485\":1}}],[\"gap\",{\"1\":{\"412\":1}}],[\"garbage\",{\"1\":{\"382\":1,\"407\":2,\"480\":1,\"495\":1}}],[\"gatewayfilter\",{\"1\":{\"73\":1}}],[\"gateway常见问题总结\",{\"0\":{\"67\":1}}],[\"gateway\",{\"0\":{\"5\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":1},\"1\":{\"5\":8,\"7\":1,\"10\":4,\"11\":2,\"67\":1,\"68\":8,\"69\":6,\"70\":2,\"72\":4,\"75\":1,\"76\":3,\"77\":2,\"78\":4}}],[\"g1mixedgclivethresholdpercent\",{\"1\":{\"385\":1}}],[\"g1heapregionsize\",{\"1\":{\"385\":1}}],[\"g1\",{\"0\":{\"407\":1},\"1\":{\"380\":1,\"385\":1,\"400\":1,\"407\":13,\"408\":2,\"448\":3,\"482\":1}}],[\"g\",{\"1\":{\"375\":1,\"478\":1,\"704\":2,\"756\":6,\"788\":1,\"911\":6,\"1043\":1}}],[\"gif\",{\"1\":{\"1088\":1}}],[\"gilbert\",{\"1\":{\"1066\":1}}],[\"gitbooks\",{\"1\":{\"1117\":1}}],[\"gityuan\",{\"1\":{\"360\":1}}],[\"github\",{\"1\":{\"4\":3,\"5\":2,\"6\":2,\"7\":2,\"8\":2,\"9\":2,\"68\":2,\"72\":1,\"213\":1,\"218\":1,\"244\":1,\"256\":1,\"268\":1,\"377\":3,\"498\":1,\"929\":1,\"1117\":2,\"1168\":2,\"1169\":1,\"1170\":2,\"1178\":3,\"1200\":1,\"1236\":1,\"1238\":1}}],[\"given\",{\"1\":{\"351\":1,\"571\":1,\"677\":1,\"798\":1}}],[\"gcs\",{\"1\":{\"1238\":1}}],[\"gc后\",{\"1\":{\"1030\":2}}],[\"gclogfilesize=50m\",{\"1\":{\"483\":1}}],[\"gc日志输出的文件路径\",{\"1\":{\"483\":1}}],[\"gc来判断\",{\"1\":{\"480\":1}}],[\"gctest\",{\"1\":{\"384\":2}}],[\"gcutil\",{\"1\":{\"366\":1}}],[\"gcpermcapacity\",{\"1\":{\"366\":1}}],[\"gcoldcapacity\",{\"1\":{\"366\":1}}],[\"gcold\",{\"1\":{\"366\":1}}],[\"gcnewcapcacity\",{\"1\":{\"366\":1}}],[\"gcnew\",{\"1\":{\"366\":1}}],[\"gccapacity\",{\"1\":{\"366\":1}}],[\"gc\",{\"0\":{\"387\":1,\"463\":1,\"483\":1,\"1030\":1},\"1\":{\"345\":3,\"366\":4,\"367\":2,\"375\":13,\"377\":1,\"380\":2,\"382\":1,\"384\":5,\"386\":2,\"387\":13,\"388\":8,\"390\":1,\"391\":5,\"406\":3,\"407\":3,\"412\":7,\"431\":1,\"443\":1,\"444\":11,\"445\":5,\"446\":2,\"449\":1,\"451\":2,\"454\":1,\"463\":1,\"479\":4,\"480\":4,\"482\":1,\"483\":5,\"484\":1,\"485\":1,\"486\":4,\"495\":2,\"498\":3,\"503\":3,\"505\":1,\"507\":1,\"517\":1,\"553\":3,\"711\":1,\"712\":2,\"731\":3,\"732\":1,\"884\":1,\"1012\":1,\"1013\":1,\"1015\":1,\"1030\":2,\"1062\":1}}],[\"guarantees\",{\"1\":{\"767\":2}}],[\"guava\",{\"1\":{\"412\":1,\"634\":1,\"894\":1,\"920\":1}}],[\"guang19\",{\"1\":{\"345\":1}}],[\"gui\",{\"1\":{\"366\":1}}],[\"guide哥\",{\"1\":{\"835\":1}}],[\"guidelines\",{\"1\":{\"480\":1}}],[\"guidegege\",{\"1\":{\"185\":2}}],[\"guide\",{\"1\":{\"185\":3,\"777\":1,\"876\":1,\"1178\":1,\"1349\":1}}],[\"grpc\",{\"0\":{\"1170\":1},\"1\":{\"1161\":1,\"1167\":1,\"1170\":7,\"1171\":1,\"1172\":2}}],[\"green\",{\"1\":{\"808\":1}}],[\"greater\",{\"1\":{\"798\":1}}],[\"grep\",{\"1\":{\"168\":2,\"219\":1}}],[\"grape\",{\"1\":{\"733\":4}}],[\"grow\",{\"0\":{\"558\":1},\"1\":{\"553\":2,\"557\":5,\"558\":2,\"559\":1,\"588\":1}}],[\"groovy\",{\"1\":{\"324\":1}}],[\"groupid=apple\",{\"1\":{\"1209\":1}}],[\"groupid\",{\"1\":{\"1209\":1,\"1213\":1}}],[\"groupid>\",{\"1\":{\"4\":2,\"1332\":2}}],[\"group\",{\"1\":{\"982\":1,\"1280\":6}}],[\"group=sorted\",{\"1\":{\"193\":1}}],[\"group=set\",{\"1\":{\"189\":1}}],[\"group=string\",{\"1\":{\"177\":1}}],[\"group=hash\",{\"1\":{\"185\":1}}],[\"group=list\",{\"1\":{\"181\":1}}],[\"globalerrorwebexceptionhandler\",{\"1\":{\"77\":1}}],[\"globalfilter\",{\"1\":{\"73\":1}}],[\"general\",{\"1\":{\"480\":1}}],[\"generation\",{\"0\":{\"479\":1},\"1\":{\"382\":3,\"479\":2,\"495\":3,\"756\":4,\"911\":4}}],[\"generated\",{\"1\":{\"561\":1,\"749\":1,\"757\":4}}],[\"generate\",{\"1\":{\"351\":1}}],[\"generator\",{\"1\":{\"34\":1}}],[\"generator`\",{\"1\":{\"34\":4}}],[\"gen\",{\"1\":{\"449\":2}}],[\"geohash\",{\"1\":{\"210\":1}}],[\"georadiusbymember\",{\"1\":{\"210\":3,\"211\":1}}],[\"georadius\",{\"1\":{\"210\":6,\"211\":1}}],[\"geodist\",{\"1\":{\"210\":2}}],[\"geopos\",{\"1\":{\"210\":2}}],[\"geoadd\",{\"1\":{\"210\":2,\"211\":1}}],[\"geospatial\",{\"0\":{\"208\":1},\"1\":{\"209\":1,\"212\":2,\"253\":1}}],[\"geo\",{\"1\":{\"199\":1,\"209\":2,\"210\":5,\"212\":1,\"242\":1}}],[\"getdata\",{\"1\":{\"1335\":1,\"1337\":1}}],[\"getdeliveryattempts\",{\"1\":{\"1210\":1}}],[\"getdelay\",{\"1\":{\"597\":3,\"599\":2,\"604\":2,\"610\":2}}],[\"getdeclaredfield\",{\"1\":{\"765\":1,\"1011\":5,\"1030\":4}}],[\"getinterval\",{\"1\":{\"1210\":1}}],[\"getbytes\",{\"1\":{\"1335\":1,\"1337\":2}}],[\"getbackoffexecution\",{\"1\":{\"1210\":1}}],[\"getbit\",{\"1\":{\"202\":2,\"203\":1}}],[\"getfailedrecordinstance\",{\"1\":{\"1210\":1}}],[\"getfirst\",{\"1\":{\"667\":1,\"730\":2}}],[\"getfindclasses\",{\"1\":{\"357\":1}}],[\"getfindclasstime\",{\"1\":{\"357\":1}}],[\"getmaxattempts\",{\"1\":{\"1210\":2}}],[\"getmapping\",{\"1\":{\"927\":1}}],[\"getmap\",{\"1\":{\"883\":2,\"1031\":1}}],[\"getmessageid\",{\"1\":{\"1293\":1}}],[\"getmessage\",{\"1\":{\"1204\":1}}],[\"getmethodname\",{\"1\":{\"1142\":1}}],[\"getweight\",{\"1\":{\"1140\":1,\"1141\":1,\"1142\":1}}],[\"getheader\",{\"1\":{\"1046\":1}}],[\"getentryaftermiss\",{\"1\":{\"1041\":2}}],[\"getentry\",{\"1\":{\"1041\":2}}],[\"getentryname\",{\"1\":{\"49\":1}}],[\"getexclusiveownerthread\",{\"1\":{\"1007\":1,\"1014\":1,\"1018\":2}}],[\"geturl\",{\"1\":{\"1142\":1}}],[\"getusernum\",{\"1\":{\"974\":1}}],[\"getuniqueinstance\",{\"1\":{\"834\":2}}],[\"getunsafe\",{\"1\":{\"765\":1}}],[\"getqueue\",{\"1\":{\"918\":1}}],[\"getsuperclass\",{\"1\":{\"1030\":2}}],[\"gets\",{\"1\":{\"778\":1}}],[\"getstamp\",{\"1\":{\"767\":5}}],[\"getstatus\",{\"1\":{\"1142\":2}}],[\"getstate\",{\"1\":{\"742\":1,\"748\":2,\"752\":2,\"904\":1,\"1006\":1,\"1007\":1,\"1014\":1,\"1020\":1}}],[\"getstatic\",{\"1\":{\"344\":2}}],[\"getlast\",{\"1\":{\"667\":1,\"730\":2}}],[\"getlocknodebytes\",{\"1\":{\"56\":1}}],[\"getlockname\",{\"1\":{\"49\":1}}],[\"getlock\",{\"1\":{\"49\":1}}],[\"getlockwatchdogtimeout\",{\"1\":{\"49\":2}}],[\"getactive\",{\"1\":{\"1142\":2}}],[\"getactivecount\",{\"1\":{\"918\":1}}],[\"getandadd\",{\"1\":{\"763\":2,\"766\":2,\"1032\":1}}],[\"getanddecrement\",{\"1\":{\"763\":1,\"766\":1}}],[\"getandincrement\",{\"1\":{\"763\":2,\"766\":2,\"768\":1,\"835\":1}}],[\"getandset\",{\"1\":{\"763\":2,\"766\":2}}],[\"getage\",{\"1\":{\"663\":4,\"679\":5,\"767\":2,\"768\":1}}],[\"getarray\",{\"1\":{\"587\":1,\"588\":1,\"589\":2,\"590\":1,\"591\":1,\"592\":2}}],[\"getproducerrecord\",{\"1\":{\"1204\":2}}],[\"getpoolsize\",{\"1\":{\"918\":1}}],[\"getphonenumber\",{\"1\":{\"630\":1}}],[\"getparentdelegationtime\",{\"1\":{\"357\":1}}],[\"getparent\",{\"1\":{\"353\":2}}],[\"getname\",{\"1\":{\"630\":1,\"663\":2,\"767\":2,\"768\":1,\"882\":2,\"940\":2}}],[\"getnode\",{\"1\":{\"623\":2,\"710\":2}}],[\"getteachernum\",{\"1\":{\"974\":1}}],[\"getters\",{\"1\":{\"630\":1}}],[\"getthreadname\",{\"1\":{\"807\":1}}],[\"getthreadid\",{\"1\":{\"807\":1}}],[\"getthreadmxbean\",{\"1\":{\"807\":1,\"1062\":1}}],[\"gettreenode\",{\"1\":{\"623\":1}}],[\"getvalue\",{\"1\":{\"619\":2,\"621\":1,\"625\":1,\"679\":1,\"704\":1,\"705\":1}}],[\"getkey\",{\"1\":{\"619\":2,\"621\":1,\"625\":1,\"704\":1,\"705\":1}}],[\"get方法是弱一致性的\",{\"1\":{\"589\":1}}],[\"getobjectvolatile\",{\"1\":{\"571\":3,\"573\":2}}],[\"getobject\",{\"1\":{\"571\":1}}],[\"getobjectinclnullbyid\",{\"1\":{\"307\":1}}],[\"getrecordmetadata\",{\"1\":{\"1204\":3}}],[\"getreference\",{\"1\":{\"767\":10}}],[\"getruntime\",{\"1\":{\"451\":12,\"928\":1}}],[\"getrawname\",{\"1\":{\"49\":3}}],[\"getchildren\",{\"1\":{\"1338\":1}}],[\"getchannel\",{\"1\":{\"1310\":1}}],[\"getcopyofcontextmap\",{\"1\":{\"1047\":1}}],[\"getcompletedtaskcount\",{\"1\":{\"918\":1}}],[\"getcount\",{\"1\":{\"764\":2}}],[\"getcontextclassloader\",{\"1\":{\"359\":1}}],[\"getconnectionmanager\",{\"1\":{\"49\":1}}],[\"getclass\",{\"1\":{\"523\":1,\"553\":2,\"555\":1,\"587\":2,\"634\":2,\"1030\":3}}],[\"getclassloadinglock\",{\"1\":{\"357\":1}}],[\"getclassloader\",{\"1\":{\"351\":2,\"353\":1}}],[\"getclient\",{\"1\":{\"53\":1}}],[\"get\",{\"0\":{\"573\":1,\"578\":1,\"623\":1,\"710\":1,\"785\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1327\":1},\"1\":{\"35\":1,\"47\":1,\"56\":1,\"177\":5,\"178\":2,\"280\":5,\"302\":4,\"307\":2,\"370\":10,\"553\":1,\"573\":2,\"578\":3,\"589\":4,\"591\":1,\"593\":2,\"623\":1,\"625\":4,\"630\":1,\"634\":4,\"688\":1,\"693\":2,\"694\":1,\"705\":2,\"706\":1,\"710\":3,\"713\":4,\"730\":3,\"733\":1,\"763\":1,\"764\":1,\"766\":2,\"767\":4,\"768\":1,\"773\":2,\"774\":3,\"777\":4,\"778\":3,\"779\":4,\"780\":3,\"781\":2,\"782\":1,\"785\":2,\"823\":10,\"824\":9,\"881\":1,\"882\":2,\"883\":1,\"884\":1,\"899\":2,\"901\":1,\"934\":1,\"941\":6,\"944\":8,\"1026\":2,\"1028\":4,\"1030\":6,\"1036\":4,\"1037\":2,\"1038\":2,\"1041\":2,\"1042\":1,\"1043\":2,\"1046\":1,\"1062\":2,\"1141\":3,\"1142\":5,\"1204\":2,\"1210\":3,\"1311\":1,\"1327\":2,\"1349\":3}}],[\"geekbang\",{\"1\":{\"221\":1,\"1185\":1}}],[\"geek\",{\"1\":{\"15\":1}}],[\"google\",{\"1\":{\"1170\":1}}],[\"goodbye\",{\"1\":{\"649\":6}}],[\"gossip\",{\"0\":{\"1082\":1,\"1084\":1,\"1085\":1,\"1086\":1,\"1090\":1},\"1\":{\"1083\":1,\"1084\":9,\"1085\":8,\"1086\":1,\"1088\":4,\"1090\":3,\"1091\":2,\"1092\":1}}],[\"golang\",{\"1\":{\"593\":4,\"1168\":1}}],[\"goguide\",{\"1\":{\"280\":2}}],[\"go\",{\"1\":{\"7\":1,\"8\":2,\"164\":1,\"293\":1,\"1158\":1,\"1170\":1,\"1238\":1}}],[\"架构极简\",{\"1\":{\"1236\":1}}],[\"架构下\",{\"1\":{\"1155\":1}}],[\"架构的一些自测小问题\",{\"0\":{\"1133\":1}}],[\"架构中的核心角色有哪些\",{\"0\":{\"1128\":1}}],[\"架构师都不能完整的描述应用的架构关系\",{\"1\":{\"1123\":1}}],[\"架构呢\",{\"1\":{\"1068\":1}}],[\"架构也支持\",{\"1\":{\"1068\":1}}],[\"架构全面优于\",{\"1\":{\"8\":1,\"10\":1}}],[\"架构图中的第一层\",{\"1\":{\"1006\":1}}],[\"架构图\",{\"1\":{\"8\":1}}],[\"架构\",{\"0\":{\"1127\":1,\"1377\":1},\"1\":{\"4\":1,\"9\":1,\"1068\":5,\"1155\":2,\"1161\":2,\"1236\":1}}],[\"性能是不错的\",{\"1\":{\"1344\":1}}],[\"性能上会有较大影响\",{\"1\":{\"1313\":1}}],[\"性能极其好\",{\"1\":{\"1240\":2}}],[\"性能很好\",{\"1\":{\"1183\":1}}],[\"性能很差\",{\"1\":{\"412\":1}}],[\"性能要更好\",{\"1\":{\"1161\":1}}],[\"性能可能比很多\",{\"1\":{\"1159\":1,\"1161\":1}}],[\"性能可能会受到影响\",{\"1\":{\"585\":1}}],[\"性能非常好\",{\"1\":{\"1147\":1}}],[\"性能非常高\",{\"1\":{\"181\":1,\"243\":1}}],[\"性能调优实战\",{\"1\":{\"890\":1,\"936\":1}}],[\"性能调优方式了\",{\"1\":{\"412\":1}}],[\"性能虽好\",{\"1\":{\"873\":1}}],[\"性能最低\",{\"1\":{\"687\":1}}],[\"性能最高\",{\"1\":{\"687\":1}}],[\"性能通常会更好\",{\"1\":{\"656\":1,\"724\":1}}],[\"性能不再是问题\",{\"1\":{\"579\":1}}],[\"性能不错并且生成的\",{\"1\":{\"35\":2}}],[\"性能差\",{\"1\":{\"523\":1,\"1147\":1}}],[\"性能优化和问题排查相关的文章\",{\"1\":{\"486\":1}}],[\"性能优化很难\",{\"1\":{\"412\":1,\"486\":1}}],[\"性能优化如何做\",{\"1\":{\"284\":1}}],[\"性能优化\",{\"0\":{\"284\":1}}],[\"性能受到的影响较小\",{\"1\":{\"231\":1}}],[\"性能的影响比较大\",{\"1\":{\"298\":1}}],[\"性能的影响\",{\"1\":{\"220\":1}}],[\"性能的关键因素\",{\"1\":{\"156\":1}}],[\"性能急剧下降\",{\"1\":{\"168\":1}}],[\"性能更好的关键原因\",{\"1\":{\"872\":1}}],[\"性能更好\",{\"1\":{\"164\":1,\"293\":1,\"858\":1,\"873\":1}}],[\"性能更强大\",{\"1\":{\"10\":1}}],[\"性能从高到低依次是\",{\"1\":{\"120\":1}}],[\"性能也越好\",{\"1\":{\"1142\":1}}],[\"性能也非常高\",{\"1\":{\"51\":1}}],[\"性能也很高效\",{\"1\":{\"47\":1}}],[\"性能比较差\",{\"1\":{\"51\":1}}],[\"性能和可用性都有很大提升\",{\"1\":{\"42\":1}}],[\"性能\",{\"1\":{\"8\":1,\"10\":1,\"217\":1,\"226\":1,\"969\":1,\"981\":1,\"1062\":1}}],[\"性能得到了大幅改进\",{\"1\":{\"4\":1}}],[\"性能较差一些\",{\"1\":{\"858\":1}}],[\"性能较差\",{\"1\":{\"4\":1}}],[\"xuyasong\",{\"1\":{\"1100\":1}}],[\"xiaohong\",{\"1\":{\"663\":1}}],[\"xieqijun\",{\"1\":{\"1103\":1}}],[\"xie\",{\"1\":{\"11\":1,\"982\":1}}],[\"xloggc\",{\"1\":{\"483\":1}}],[\"xnoclassgc\",{\"1\":{\"467\":1}}],[\"xss\",{\"1\":{\"449\":2,\"458\":1}}],[\"xmpp\",{\"1\":{\"1245\":2}}],[\"xml\",{\"1\":{\"523\":1}}],[\"xmn256m\",{\"1\":{\"479\":1}}],[\"xmn<young\",{\"1\":{\"479\":1}}],[\"xmn\",{\"1\":{\"449\":2,\"452\":1,\"479\":1}}],[\"xmn参数\",{\"1\":{\"412\":1}}],[\"xmx5g\",{\"1\":{\"478\":1}}],[\"xmx<heap\",{\"1\":{\"478\":1}}],[\"xmx20m\",{\"1\":{\"451\":1,\"455\":1}}],[\"xmx=\",{\"1\":{\"451\":4}}],[\"xmx\",{\"0\":{\"478\":1},\"1\":{\"444\":1,\"449\":2,\"451\":4}}],[\"xmx参数配置\",{\"1\":{\"495\":1}}],[\"xmx参数\",{\"1\":{\"412\":1}}],[\"xms2g\",{\"1\":{\"478\":1}}],[\"xms<heap\",{\"1\":{\"478\":1}}],[\"xms=xmx\",{\"1\":{\"452\":1}}],[\"xms5m\",{\"1\":{\"451\":1,\"455\":1}}],[\"xms\",{\"0\":{\"478\":1},\"1\":{\"444\":1,\"449\":2,\"451\":4}}],[\"xxthreadstacksize\",{\"1\":{\"459\":1,\"461\":1}}],[\"xx\",{\"1\":{\"367\":5,\"368\":1,\"384\":1,\"385\":3,\"386\":3,\"388\":2,\"400\":1,\"403\":12,\"408\":1,\"443\":1,\"444\":3,\"449\":11,\"451\":1,\"452\":2,\"453\":1,\"454\":2,\"455\":2,\"456\":2,\"462\":1,\"463\":1,\"464\":1,\"465\":1,\"466\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"479\":8,\"480\":7,\"482\":4,\"483\":11,\"484\":5,\"485\":10,\"495\":1,\"496\":6,\"498\":1,\"1155\":2}}],[\"xxx=com\",{\"1\":{\"1131\":2}}],[\"xxxloadbalance\",{\"1\":{\"1131\":5}}],[\"xxx\",{\"1\":{\"353\":1,\"1131\":4}}],[\"xyang81\",{\"1\":{\"360\":1}}],[\"xbootclasspath参数指定的路径下的所有类\",{\"1\":{\"353\":1}}],[\"xverify\",{\"1\":{\"341\":1}}],[\"xor\",{\"1\":{\"202\":1}}],[\"x\",{\"1\":{\"4\":2,\"5\":3,\"7\":1,\"68\":3,\"96\":1,\"242\":1,\"535\":4,\"536\":3,\"640\":2,\"730\":8,\"731\":35,\"1296\":3,\"1297\":3,\"1332\":1}}],[\"1g=1073741824\",{\"1\":{\"1315\":1}}],[\"1g\",{\"1\":{\"1315\":1}}],[\"1+0\",{\"1\":{\"895\":1,\"922\":1}}],[\"1+wt\",{\"1\":{\"895\":1,\"922\":1}}],[\"1is\",{\"1\":{\"757\":4}}],[\"1=20\",{\"1\":{\"749\":1}}],[\"1=7\",{\"1\":{\"708\":1}}],[\"19730582\",{\"1\":{\"1218\":1}}],[\"1978\",{\"1\":{\"974\":1}}],[\"1998\",{\"1\":{\"1096\":2}}],[\"1990\",{\"1\":{\"1096\":1,\"1097\":1}}],[\"1906\",{\"1\":{\"1069\":1}}],[\"19\",{\"1\":{\"712\":3,\"1053\":1}}],[\"19164407\",{\"1\":{\"687\":1}}],[\"1987\",{\"1\":{\"1084\":1}}],[\"198\",{\"1\":{\"687\":1}}],[\"1947\",{\"1\":{\"480\":1}}],[\"1l\",{\"1\":{\"577\":1,\"927\":1,\"940\":2}}],[\"1是3\",{\"1\":{\"572\":1}}],[\"1<<16\",{\"1\":{\"570\":1}}],[\"1st\",{\"1\":{\"622\":1,\"683\":1}}],[\"1s\",{\"1\":{\"370\":1,\"599\":4,\"823\":1,\"1062\":1}}],[\"1q\",{\"1\":{\"320\":1}}],[\"1w\",{\"1\":{\"246\":1}}],[\"1分钟\",{\"1\":{\"226\":1}}],[\"1分析的过程\",{\"1\":{\"141\":1}}],[\"1m\",{\"1\":{\"449\":1,\"458\":1,\"1348\":1}}],[\"1mb\",{\"1\":{\"163\":1,\"291\":1}}],[\"1ms\",{\"1\":{\"41\":1}}],[\"1中再次查询相同的语句\",{\"1\":{\"141\":1}}],[\"1时\",{\"1\":{\"141\":1}}],[\"1在执行select\",{\"1\":{\"141\":1}}],[\"1k=16\",{\"1\":{\"110\":1}}],[\"1761\",{\"1\":{\"1007\":1}}],[\"1773\",{\"1\":{\"564\":1}}],[\"1737\",{\"1\":{\"895\":1,\"922\":1}}],[\"17340\",{\"1\":{\"365\":2,\"367\":5,\"368\":1,\"370\":1}}],[\"17396\",{\"1\":{\"365\":2,\"370\":1}}],[\"172\",{\"1\":{\"298\":9,\"302\":1}}],[\"17\",{\"1\":{\"49\":1,\"218\":1,\"221\":1,\"293\":4,\"298\":9,\"302\":1,\"679\":1}}],[\"1806ms\",{\"1\":{\"1062\":1}}],[\"1848\",{\"1\":{\"968\":1}}],[\"186345456\",{\"1\":{\"687\":1}}],[\"186192\",{\"1\":{\"612\":1}}],[\"18163138123\",{\"1\":{\"630\":1}}],[\"18m\",{\"1\":{\"451\":1}}],[\"18b4aac2\",{\"1\":{\"353\":1}}],[\"18\",{\"1\":{\"40\":1,\"328\":1,\"679\":1,\"800\":3,\"1257\":1}}],[\"1~41\",{\"1\":{\"38\":1}}],[\"160ms\",{\"1\":{\"1271\":1}}],[\"1663627873\",{\"1\":{\"1218\":1}}],[\"1695088059523\",{\"1\":{\"781\":1}}],[\"1695088059023\",{\"1\":{\"781\":2}}],[\"1695088058521\",{\"1\":{\"781\":1}}],[\"1695088058520\",{\"1\":{\"781\":1}}],[\"163\",{\"1\":{\"687\":1}}],[\"16384\",{\"1\":{\"318\":1}}],[\"16492\",{\"1\":{\"365\":1}}],[\"16504\",{\"1\":{\"365\":1}}],[\"1684326682\",{\"1\":{\"302\":1}}],[\"1683638276\",{\"1\":{\"298\":1}}],[\"1683638274\",{\"1\":{\"298\":1}}],[\"1683638271\",{\"1\":{\"298\":1}}],[\"1683638270\",{\"1\":{\"298\":2}}],[\"1683638269\",{\"1\":{\"298\":1}}],[\"1683638268\",{\"1\":{\"298\":1}}],[\"1683638267\",{\"1\":{\"298\":1}}],[\"1683638260\",{\"1\":{\"298\":1}}],[\"16=18720条这样的数据\",{\"1\":{\"110\":1}}],[\"16\",{\"1\":{\"37\":1,\"67\":1,\"218\":1,\"256\":2,\"328\":1,\"370\":1,\"569\":2,\"570\":9,\"616\":1,\"618\":1,\"619\":3,\"677\":2,\"679\":1,\"682\":1,\"690\":2,\"692\":1,\"705\":1,\"1019\":2}}],[\"14285282\",{\"1\":{\"913\":1}}],[\"1411\",{\"1\":{\"687\":1}}],[\"147296098\",{\"1\":{\"511\":1}}],[\"14\",{\"1\":{\"328\":1,\"412\":1,\"940\":20,\"1096\":1}}],[\"144236\",{\"1\":{\"298\":1}}],[\"14=1170\",{\"1\":{\"110\":1}}],[\"1403169275002\",{\"1\":{\"22\":1}}],[\"1439\",{\"1\":{\"233\":1}}],[\"143\",{\"1\":{\"22\":1,\"713\":1}}],[\"133\",{\"1\":{\"971\":1,\"974\":2,\"981\":1,\"982\":2}}],[\"139\",{\"1\":{\"687\":1}}],[\"1316ms\",{\"1\":{\"1062\":1}}],[\"1310\",{\"1\":{\"479\":1}}],[\"131419\",{\"1\":{\"369\":1}}],[\"1324119927\",{\"1\":{\"370\":1}}],[\"13792\",{\"1\":{\"370\":1}}],[\"13\",{\"1\":{\"19\":1,\"22\":1,\"267\":1,\"710\":2,\"711\":2,\"835\":1,\"876\":1}}],[\"150ms\",{\"1\":{\"1271\":3}}],[\"1500\",{\"1\":{\"835\":1}}],[\"1551065180\",{\"1\":{\"687\":1}}],[\"1550612500\",{\"1\":{\"687\":1}}],[\"1554828440\",{\"1\":{\"687\":1}}],[\"151717241\",{\"1\":{\"511\":1}}],[\"15m\",{\"1\":{\"451\":1}}],[\"15分钟\",{\"1\":{\"226\":1}}],[\"15\",{\"1\":{\"19\":2,\"218\":1,\"328\":1,\"386\":5,\"408\":1,\"444\":4,\"495\":1,\"558\":3,\"570\":1,\"597\":1,\"876\":1}}],[\"1190000038373546\",{\"1\":{\"1092\":1}}],[\"1190000040032006\",{\"1\":{\"196\":1}}],[\"1176230\",{\"1\":{\"876\":1}}],[\"1170117016=21902400条这样的记录\",{\"1\":{\"110\":1}}],[\"113810985\",{\"1\":{\"612\":1}}],[\"112\",{\"1\":{\"498\":1}}],[\"1116\",{\"1\":{\"687\":1}}],[\"1111\",{\"1\":{\"571\":1}}],[\"111\",{\"1\":{\"342\":2}}],[\"116\",{\"1\":{\"210\":7}}],[\"11\",{\"0\":{\"471\":1},\"1\":{\"19\":1,\"328\":1,\"557\":2,\"558\":3,\"677\":1,\"686\":2,\"876\":1,\"940\":20,\"1206\":1,\"1214\":1,\"1326\":1,\"1329\":1,\"1330\":1,\"1349\":2}}],[\"123\",{\"1\":{\"1325\":2}}],[\"1204\",{\"1\":{\"480\":1}}],[\"12000\",{\"1\":{\"302\":1}}],[\"1207\",{\"1\":{\"293\":1}}],[\"12k\",{\"1\":{\"205\":2,\"212\":1}}],[\"128k\",{\"1\":{\"449\":1}}],[\"128\",{\"1\":{\"37\":2,\"302\":4}}],[\"127\",{\"1\":{\"35\":3,\"48\":1,\"270\":3,\"280\":1,\"298\":1,\"302\":3,\"1322\":1,\"1325\":2,\"1326\":1,\"1328\":2,\"1329\":1,\"1330\":1,\"1331\":1,\"1333\":1,\"1349\":1}}],[\"12\",{\"1\":{\"19\":3,\"35\":1,\"37\":1,\"38\":1,\"328\":1,\"369\":1,\"480\":2,\"618\":1,\"619\":1,\"682\":1,\"712\":1,\"758\":1,\"940\":20,\"999\":1,\"1068\":1,\"1173\":1,\"1209\":3,\"1264\":1,\"1327\":1}}],[\"10～500ms\",{\"1\":{\"1116\":1}}],[\"10277ms\",{\"1\":{\"1062\":1}}],[\"10214ms\",{\"1\":{\"1062\":1}}],[\"1024m\",{\"1\":{\"479\":1}}],[\"1024\",{\"1\":{\"384\":7,\"451\":28}}],[\"103726942\",{\"1\":{\"1030\":1}}],[\"10+10\",{\"1\":{\"558\":1}}],[\"10ms\",{\"1\":{\"1271\":1}}],[\"10m\",{\"1\":{\"451\":1}}],[\"107341997\",{\"1\":{\"522\":1}}],[\"1073741824\",{\"1\":{\"19\":1,\"1315\":1}}],[\"1078694789\",{\"1\":{\"370\":1}}],[\"10764\",{\"1\":{\"370\":1}}],[\"10表示分析进程\",{\"1\":{\"366\":1}}],[\"10w+\",{\"1\":{\"246\":1}}],[\"1064\",{\"1\":{\"86\":1}}],[\"10s\",{\"1\":{\"49\":1,\"251\":1}}],[\"101\",{\"1\":{\"34\":6}}],[\"1009\",{\"1\":{\"1062\":2}}],[\"10086\",{\"1\":{\"307\":1}}],[\"100\",{\"1\":{\"30\":1,\"34\":4,\"60\":1,\"98\":2,\"124\":3,\"141\":5,\"233\":1,\"244\":1,\"293\":1,\"298\":1,\"386\":1,\"495\":1,\"927\":1,\"940\":2,\"941\":1,\"1001\":2,\"1183\":1,\"1193\":1,\"1213\":2,\"1228\":1}}],[\"1000w\",{\"1\":{\"713\":2}}],[\"1000ms\",{\"1\":{\"366\":1}}],[\"1000mb\",{\"1\":{\"163\":1,\"292\":1}}],[\"1000\",{\"1\":{\"22\":2,\"49\":1,\"163\":1,\"292\":1,\"366\":1,\"370\":3,\"384\":4,\"599\":1,\"691\":1,\"713\":1,\"749\":2,\"753\":2,\"757\":2,\"781\":1,\"782\":4,\"823\":3,\"824\":1,\"882\":2,\"928\":1,\"1211\":1,\"1213\":1,\"1264\":2,\"1333\":1}}],[\"10000+字\",{\"1\":{\"1026\":1}}],[\"10000000\",{\"1\":{\"564\":2}}],[\"1000000\",{\"1\":{\"302\":1}}],[\"10000\",{\"1\":{\"19\":1,\"226\":1,\"302\":3,\"1020\":1,\"1062\":3}}],[\"1003\",{\"1\":{\"22\":1}}],[\"1001000100000000101110011001101101110011000000000000000000000\",{\"1\":{\"19\":1}}],[\"10\",{\"0\":{\"470\":1},\"1\":{\"19\":2,\"22\":2,\"33\":1,\"34\":2,\"38\":1,\"49\":2,\"53\":1,\"98\":2,\"117\":3,\"168\":1,\"226\":1,\"251\":1,\"302\":1,\"328\":1,\"366\":1,\"375\":1,\"391\":1,\"412\":1,\"449\":1,\"451\":1,\"453\":1,\"455\":1,\"486\":1,\"531\":8,\"553\":1,\"555\":3,\"557\":5,\"558\":2,\"561\":1,\"562\":2,\"631\":1,\"663\":2,\"686\":2,\"687\":3,\"712\":1,\"757\":2,\"784\":2,\"785\":1,\"797\":1,\"820\":1,\"909\":1,\"927\":1,\"940\":3,\"941\":1,\"1062\":2,\"1141\":2,\"1144\":2,\"1204\":1,\"1209\":4,\"1210\":5,\"1293\":1,\"1327\":3,\"1329\":3,\"1330\":2,\"1382\":1}}],[\"10e4dab2de0bdb6f2c3c93da6\",{\"1\":{\"11\":1}}],[\"1\",{\"0\":{\"17\":1,\"21\":1,\"127\":1,\"418\":2,\"425\":1,\"427\":1,\"428\":2,\"429\":1,\"430\":1,\"431\":1,\"435\":1,\"438\":1,\"451\":1,\"458\":1,\"461\":1,\"476\":1,\"478\":1,\"482\":1,\"568\":2,\"569\":1,\"574\":1,\"575\":1,\"692\":2,\"917\":1,\"1000\":1,\"1001\":2,\"1002\":1,\"1004\":1,\"1005\":2,\"1006\":1,\"1009\":1,\"1010\":2,\"1011\":1,\"1012\":1,\"1018\":1,\"1104\":1,\"1105\":2,\"1106\":1,\"1108\":1,\"1114\":1},\"1\":{\"4\":1,\"5\":1,\"18\":1,\"19\":1,\"23\":4,\"33\":1,\"34\":5,\"35\":4,\"37\":3,\"47\":5,\"48\":1,\"49\":6,\"53\":4,\"56\":4,\"60\":8,\"68\":1,\"76\":1,\"77\":1,\"86\":1,\"89\":5,\"96\":1,\"99\":3,\"101\":1,\"106\":1,\"108\":1,\"125\":2,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"132\":1,\"141\":1,\"145\":8,\"157\":1,\"161\":1,\"163\":1,\"168\":1,\"176\":1,\"177\":7,\"181\":9,\"185\":2,\"189\":6,\"193\":9,\"201\":2,\"202\":6,\"203\":1,\"206\":3,\"210\":3,\"212\":1,\"213\":1,\"218\":1,\"219\":3,\"220\":1,\"226\":1,\"231\":1,\"236\":1,\"246\":1,\"256\":3,\"261\":11,\"262\":3,\"267\":1,\"268\":1,\"270\":6,\"272\":2,\"280\":6,\"281\":1,\"285\":1,\"292\":1,\"293\":10,\"294\":1,\"298\":13,\"301\":1,\"302\":7,\"307\":6,\"325\":1,\"327\":1,\"328\":4,\"334\":1,\"351\":1,\"370\":8,\"386\":4,\"390\":2,\"392\":1,\"396\":1,\"403\":2,\"412\":2,\"438\":1,\"443\":3,\"445\":1,\"448\":1,\"449\":12,\"451\":3,\"452\":1,\"453\":1,\"454\":2,\"455\":1,\"456\":2,\"475\":1,\"479\":5,\"480\":3,\"485\":1,\"491\":5,\"495\":4,\"496\":5,\"498\":1,\"507\":1,\"515\":1,\"523\":1,\"531\":6,\"552\":2,\"553\":15,\"557\":2,\"558\":8,\"561\":6,\"562\":2,\"570\":7,\"571\":5,\"572\":2,\"573\":1,\"576\":3,\"577\":3,\"578\":1,\"588\":1,\"589\":2,\"591\":6,\"593\":2,\"599\":2,\"601\":1,\"604\":1,\"618\":5,\"619\":3,\"621\":1,\"622\":4,\"623\":1,\"624\":3,\"625\":1,\"629\":3,\"631\":2,\"632\":3,\"634\":14,\"649\":3,\"653\":9,\"654\":2,\"656\":3,\"658\":1,\"662\":5,\"663\":2,\"668\":1,\"677\":4,\"682\":5,\"683\":4,\"684\":2,\"686\":13,\"688\":1,\"691\":1,\"692\":4,\"697\":1,\"704\":2,\"705\":2,\"706\":2,\"708\":1,\"713\":2,\"724\":1,\"725\":2,\"729\":1,\"730\":2,\"731\":1,\"733\":1,\"742\":2,\"747\":1,\"748\":4,\"749\":1,\"752\":8,\"753\":5,\"756\":2,\"757\":1,\"764\":1,\"766\":1,\"767\":2,\"779\":1,\"781\":2,\"807\":1,\"808\":2,\"823\":5,\"824\":6,\"834\":2,\"835\":4,\"840\":2,\"841\":4,\"843\":1,\"845\":1,\"848\":1,\"851\":2,\"864\":1,\"871\":1,\"882\":3,\"889\":2,\"892\":2,\"894\":2,\"904\":1,\"905\":1,\"906\":4,\"909\":1,\"911\":2,\"918\":2,\"920\":2,\"928\":2,\"934\":1,\"937\":2,\"938\":2,\"940\":24,\"941\":1,\"943\":2,\"944\":1,\"951\":1,\"953\":5,\"958\":1,\"961\":1,\"972\":5,\"974\":10,\"989\":2,\"990\":4,\"992\":1,\"994\":1,\"1001\":2,\"1002\":5,\"1005\":2,\"1008\":2,\"1010\":1,\"1011\":3,\"1012\":2,\"1013\":2,\"1014\":1,\"1016\":2,\"1018\":1,\"1020\":4,\"1027\":1,\"1032\":3,\"1036\":10,\"1037\":3,\"1038\":1,\"1041\":1,\"1042\":1,\"1062\":1,\"1068\":1,\"1090\":2,\"1106\":1,\"1141\":1,\"1142\":5,\"1158\":1,\"1159\":2,\"1161\":2,\"1199\":1,\"1200\":2,\"1202\":3,\"1206\":6,\"1209\":4,\"1210\":3,\"1213\":1,\"1235\":1,\"1240\":1,\"1251\":1,\"1252\":1,\"1253\":1,\"1264\":1,\"1275\":1,\"1293\":1,\"1306\":1,\"1308\":1,\"1310\":1,\"1311\":1,\"1322\":1,\"1325\":5,\"1326\":1,\"1327\":3,\"1328\":4,\"1329\":3,\"1330\":4,\"1331\":2,\"1333\":1,\"1349\":5,\"1357\":4,\"1358\":2,\"1380\":4}}],[\"0<\",{\"1\":{\"1332\":2}}],[\"09\",{\"1\":{\"982\":1}}],[\"07\",{\"1\":{\"913\":1}}],[\"0is\",{\"1\":{\"757\":4}}],[\"0表示成功\",{\"1\":{\"744\":1}}],[\"02\",{\"1\":{\"679\":1,\"1185\":1}}],[\"0f\",{\"1\":{\"621\":1}}],[\"0成立\",{\"1\":{\"557\":1}}],[\"0x3\",{\"1\":{\"1349\":1}}],[\"0x2\",{\"1\":{\"1349\":2}}],[\"0x0\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":1}}],[\"0x00000000d5efe1d0\",{\"1\":{\"370\":1}}],[\"0x00000000d5efe1c0\",{\"1\":{\"370\":1}}],[\"0x000000000333be88\",{\"1\":{\"370\":1}}],[\"0x000000000333e668\",{\"1\":{\"370\":1}}],[\"0x4a\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1}}],[\"0x4b\",{\"1\":{\"1327\":1}}],[\"0x47\",{\"1\":{\"1327\":1,\"1329\":2,\"1330\":2}}],[\"0x61c88647\",{\"1\":{\"1032\":3}}],[\"0xcafebabe\",{\"1\":{\"326\":1}}],[\"01二进制字节流\",{\"1\":{\"1152\":1}}],[\"01\",{\"1\":{\"360\":1,\"820\":1,\"1152\":2,\"1159\":3}}],[\"0l\",{\"1\":{\"342\":1,\"629\":2,\"756\":5,\"784\":1,\"871\":5,\"889\":2,\"911\":5,\"937\":2,\"949\":2,\"953\":2}}],[\"04\",{\"1\":{\"237\":1,\"369\":1}}],[\"05\",{\"1\":{\"221\":1,\"758\":1,\"999\":1,\"1349\":2}}],[\"06\",{\"1\":{\"213\":1}}],[\"0kb\",{\"1\":{\"168\":5}}],[\"0nqfq\",{\"1\":{\"156\":1}}],[\"00002\",{\"1\":{\"1335\":1}}],[\"00001\",{\"1\":{\"1335\":6,\"1336\":1,\"1337\":3}}],[\"00000000001073741824\",{\"1\":{\"1315\":1}}],[\"00000000000000000000\",{\"1\":{\"1315\":1}}],[\"0000\",{\"1\":{\"713\":1}}],[\"000\",{\"1\":{\"687\":3,\"785\":1}}],[\"00\",{\"1\":{\"125\":2,\"293\":19,\"679\":1}}],[\"001\",{\"1\":{\"7\":1}}],[\"0版本后被移除\",{\"0\":{\"85\":1}}],[\"0~3\",{\"1\":{\"35\":1}}],[\"0+\",{\"1\":{\"293\":1,\"294\":1}}],[\"0+版本对\",{\"1\":{\"1332\":1}}],[\"0+版本\",{\"1\":{\"35\":1}}],[\"0+100\",{\"1\":{\"34\":1}}],[\"0ad1348f\",{\"1\":{\"22\":1}}],[\"0ad1348f1403169275002100356696\",{\"1\":{\"22\":1}}],[\"08\",{\"1\":{\"11\":1,\"69\":1,\"78\":1,\"213\":1,\"835\":1,\"1209\":3}}],[\"03\",{\"1\":{\"11\":1,\"835\":1,\"876\":1,\"1209\":3}}],[\"0\",{\"0\":{\"235\":1,\"266\":1,\"267\":1},\"1\":{\"4\":1,\"19\":1,\"23\":11,\"34\":5,\"35\":7,\"38\":2,\"47\":2,\"48\":2,\"49\":1,\"50\":1,\"76\":1,\"85\":1,\"89\":4,\"125\":2,\"174\":1,\"181\":4,\"182\":1,\"189\":1,\"193\":14,\"201\":2,\"202\":6,\"203\":1,\"205\":1,\"206\":2,\"210\":1,\"212\":2,\"220\":1,\"224\":1,\"229\":1,\"231\":3,\"233\":5,\"235\":1,\"236\":1,\"244\":1,\"245\":1,\"249\":1,\"251\":4,\"256\":4,\"261\":5,\"264\":2,\"266\":6,\"267\":4,\"268\":4,\"270\":6,\"273\":1,\"280\":2,\"282\":1,\"283\":1,\"289\":1,\"293\":14,\"294\":3,\"298\":23,\"302\":7,\"307\":1,\"328\":2,\"330\":1,\"342\":2,\"351\":1,\"353\":1,\"386\":1,\"390\":2,\"396\":2,\"403\":2,\"430\":1,\"442\":1,\"445\":1,\"448\":1,\"449\":2,\"451\":12,\"458\":1,\"459\":1,\"495\":1,\"531\":2,\"534\":3,\"535\":4,\"536\":1,\"537\":3,\"538\":2,\"553\":32,\"555\":3,\"557\":3,\"558\":3,\"559\":1,\"561\":9,\"562\":4,\"564\":3,\"570\":12,\"571\":7,\"572\":1,\"576\":6,\"577\":4,\"578\":3,\"587\":1,\"591\":3,\"592\":4,\"593\":1,\"597\":1,\"604\":2,\"605\":1,\"618\":1,\"619\":5,\"621\":3,\"622\":2,\"623\":1,\"624\":7,\"629\":2,\"631\":1,\"632\":3,\"633\":5,\"634\":4,\"649\":4,\"653\":3,\"663\":1,\"677\":3,\"679\":2,\"682\":1,\"683\":1,\"693\":1,\"705\":1,\"706\":2,\"708\":1,\"713\":5,\"730\":1,\"732\":1,\"733\":1,\"742\":3,\"748\":8,\"749\":3,\"752\":16,\"753\":6,\"756\":5,\"757\":2,\"763\":3,\"764\":1,\"766\":5,\"767\":4,\"798\":1,\"820\":1,\"824\":1,\"835\":3,\"851\":2,\"871\":1,\"882\":3,\"888\":1,\"889\":2,\"890\":3,\"895\":1,\"904\":1,\"906\":2,\"908\":3,\"909\":1,\"911\":5,\"918\":1,\"922\":1,\"928\":2,\"936\":3,\"937\":2,\"940\":1,\"941\":2,\"943\":1,\"957\":3,\"961\":1,\"1001\":1,\"1002\":1,\"1005\":1,\"1007\":4,\"1008\":1,\"1012\":2,\"1013\":5,\"1014\":10,\"1018\":8,\"1019\":1,\"1020\":4,\"1028\":1,\"1035\":2,\"1036\":2,\"1038\":3,\"1042\":1,\"1062\":6,\"1076\":1,\"1085\":1,\"1116\":1,\"1141\":7,\"1142\":10,\"1151\":1,\"1161\":1,\"1170\":1,\"1199\":1,\"1206\":3,\"1209\":11,\"1210\":4,\"1213\":1,\"1240\":1,\"1253\":1,\"1257\":1,\"1258\":1,\"1310\":1,\"1315\":1,\"1322\":2,\"1325\":4,\"1326\":2,\"1327\":1,\"1328\":4,\"1329\":4,\"1330\":4,\"1331\":2,\"1333\":2,\"1349\":6,\"1380\":5,\"1382\":3}}],[\"2pc流程\",{\"1\":{\"1370\":1}}],[\"2pc\",{\"0\":{\"1370\":1},\"1\":{\"1304\":1,\"1369\":1,\"1370\":2,\"1371\":2,\"1372\":1,\"1391\":1}}],[\"2+1\",{\"1\":{\"1111\":1}}],[\"27\",{\"1\":{\"1037\":1,\"1349\":2}}],[\"276599\",{\"1\":{\"298\":1}}],[\"293\",{\"1\":{\"1022\":1}}],[\"2n\",{\"1\":{\"895\":4,\"922\":4,\"1357\":2}}],[\"2n+1\",{\"1\":{\"677\":1}}],[\"2acujjr4bhihlfsclgwysg\",{\"1\":{\"876\":1}}],[\"2级索引跳表\",{\"1\":{\"800\":1}}],[\"2is\",{\"1\":{\"757\":4}}],[\"22\",{\"1\":{\"767\":1,\"768\":3,\"1062\":2,\"1327\":1,\"1329\":2,\"1330\":2}}],[\"22931\",{\"1\":{\"720\":1}}],[\"221\",{\"1\":{\"687\":1}}],[\"23\",{\"1\":{\"704\":2,\"768\":2,\"982\":1,\"1143\":1}}],[\"23657748\",{\"1\":{\"687\":1}}],[\"2s\",{\"1\":{\"599\":3}}],[\"2865ms\",{\"1\":{\"1062\":1}}],[\"288\",{\"1\":{\"687\":1}}],[\"28位\",{\"1\":{\"571\":1}}],[\"28\",{\"1\":{\"570\":1,\"1185\":1}}],[\"289140\",{\"1\":{\"221\":1}}],[\"2的次方值\",{\"1\":{\"570\":1}}],[\"2的多少次方\",{\"1\":{\"570\":1}}],[\"2的b+树\",{\"1\":{\"110\":1}}],[\"2=49\",{\"1\":{\"558\":1}}],[\"2w+\",{\"1\":{\"412\":1}}],[\"2500\",{\"1\":{\"835\":2}}],[\"25619ms\",{\"1\":{\"1062\":1}}],[\"256m\",{\"1\":{\"479\":2}}],[\"256k\",{\"1\":{\"449\":2,\"458\":1}}],[\"25\",{\"1\":{\"403\":1}}],[\"2181命令连接\",{\"1\":{\"1322\":1}}],[\"2181\",{\"1\":{\"1321\":2,\"1325\":2,\"1326\":1,\"1328\":2,\"1329\":1,\"1330\":1,\"1331\":1,\"1333\":1,\"1349\":1}}],[\"21807104\",{\"1\":{\"480\":1}}],[\"21\",{\"1\":{\"687\":1,\"808\":1,\"912\":1,\"1051\":1,\"1057\":1}}],[\"2147\",{\"1\":{\"708\":1}}],[\"2147483647\",{\"1\":{\"684\":1}}],[\"2147483648\",{\"1\":{\"684\":1}}],[\"214195251464844m\",{\"1\":{\"451\":1}}],[\"2158\",{\"1\":{\"564\":1}}],[\"211\",{\"1\":{\"403\":3}}],[\"2104299\",{\"1\":{\"11\":1}}],[\"2g\",{\"1\":{\"219\":1}}],[\"2^32\",{\"1\":{\"201\":2}}],[\"2^12\",{\"1\":{\"38\":1}}],[\"24\",{\"1\":{\"185\":3,\"217\":1,\"360\":1,\"388\":2,\"913\":1}}],[\"2分析以加强自己的理解\",{\"1\":{\"141\":1}}],[\"2条数据\",{\"1\":{\"141\":1}}],[\"264\",{\"1\":{\"293\":1}}],[\"26\",{\"1\":{\"69\":1,\"78\":1,\"185\":1,\"369\":1}}],[\"2ezwdj0\",{\"1\":{\"24\":1}}],[\"205\",{\"1\":{\"944\":1}}],[\"20ms\",{\"1\":{\"820\":1}}],[\"2010\",{\"1\":{\"1178\":1}}],[\"2011\",{\"1\":{\"1178\":3}}],[\"2015\",{\"1\":{\"1160\":1}}],[\"2013\",{\"1\":{\"1097\":1}}],[\"2012\",{\"1\":{\"1068\":1}}],[\"2014\",{\"1\":{\"982\":1}}],[\"2018\",{\"1\":{\"876\":1,\"1349\":2}}],[\"2017\",{\"1\":{\"486\":1,\"913\":1}}],[\"2019\",{\"1\":{\"369\":1,\"758\":1,\"999\":1,\"1327\":2,\"1329\":2,\"1330\":2}}],[\"2016\",{\"1\":{\"51\":1,\"360\":1,\"633\":1,\"876\":1,\"1276\":1}}],[\"20w\",{\"1\":{\"273\":1}}],[\"200ms\",{\"1\":{\"1271\":2}}],[\"2001\",{\"1\":{\"1096\":1}}],[\"2008\",{\"1\":{\"1072\":1}}],[\"2009\",{\"1\":{\"1062\":2}}],[\"2005\",{\"1\":{\"1022\":1}}],[\"20000\",{\"1\":{\"1020\":1}}],[\"2000\",{\"1\":{\"296\":1,\"384\":1,\"599\":1,\"781\":1,\"1066\":1}}],[\"2000w\",{\"1\":{\"273\":1}}],[\"200\",{\"1\":{\"141\":5,\"1062\":1}}],[\"20\",{\"1\":{\"33\":1,\"34\":3,\"98\":3,\"220\":2,\"293\":1,\"480\":3,\"618\":1,\"663\":2,\"682\":1,\"749\":1,\"767\":2,\"808\":1,\"1315\":3,\"1327\":2,\"1329\":2,\"1330\":2}}],[\"2047601319t66\",{\"1\":{\"24\":1}}],[\"209\",{\"1\":{\"22\":1,\"1062\":2}}],[\"20254ms\",{\"1\":{\"1062\":1}}],[\"2021\",{\"1\":{\"412\":3,\"486\":3}}],[\"20210309\",{\"1\":{\"261\":3}}],[\"20210308~20210309\",{\"1\":{\"261\":2}}],[\"20210308\",{\"1\":{\"261\":4}}],[\"2021这篇文章\",{\"1\":{\"2\":1}}],[\"2020年06月15日\",{\"1\":{\"679\":1}}],[\"2020\",{\"1\":{\"213\":1,\"221\":1,\"412\":1,\"486\":1,\"940\":20,\"1122\":1}}],[\"2022\",{\"1\":{\"69\":1,\"78\":1,\"237\":1,\"251\":1,\"412\":2,\"486\":4,\"835\":1,\"841\":1,\"990\":1,\"1185\":1}}],[\"2023\",{\"1\":{\"11\":1,\"412\":4,\"1209\":3}}],[\"2\",{\"0\":{\"18\":1,\"22\":1,\"128\":1,\"425\":1,\"427\":1,\"428\":1,\"429\":2,\"430\":1,\"431\":1,\"432\":2,\"433\":1,\"436\":1,\"439\":1,\"452\":1,\"459\":1,\"462\":1,\"477\":1,\"478\":1,\"479\":2,\"480\":1,\"483\":1,\"570\":1,\"574\":1,\"576\":1,\"684\":1,\"918\":1,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":2,\"1007\":2,\"1011\":1,\"1013\":1,\"1019\":1,\"1068\":1,\"1106\":1,\"1107\":1,\"1108\":1,\"1109\":2,\"1110\":1,\"1115\":1},\"1\":{\"4\":2,\"5\":2,\"18\":1,\"19\":2,\"23\":8,\"33\":1,\"34\":1,\"35\":2,\"37\":1,\"38\":1,\"42\":1,\"49\":2,\"60\":3,\"68\":2,\"86\":1,\"99\":5,\"101\":1,\"106\":1,\"108\":1,\"117\":1,\"125\":2,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"132\":1,\"141\":1,\"145\":5,\"162\":1,\"168\":1,\"174\":2,\"177\":3,\"181\":4,\"185\":2,\"189\":5,\"193\":14,\"202\":1,\"206\":1,\"210\":2,\"218\":2,\"246\":1,\"251\":3,\"256\":3,\"261\":2,\"262\":1,\"268\":2,\"280\":3,\"281\":1,\"283\":1,\"293\":1,\"298\":1,\"302\":2,\"307\":1,\"334\":2,\"344\":1,\"370\":7,\"392\":3,\"412\":1,\"438\":1,\"445\":1,\"448\":1,\"449\":2,\"478\":1,\"479\":2,\"480\":1,\"496\":3,\"507\":1,\"511\":2,\"515\":1,\"523\":1,\"531\":4,\"553\":1,\"557\":2,\"558\":6,\"561\":5,\"562\":2,\"570\":4,\"576\":1,\"577\":1,\"589\":1,\"599\":2,\"604\":1,\"616\":2,\"621\":1,\"625\":1,\"631\":1,\"634\":10,\"653\":8,\"654\":1,\"668\":1,\"677\":6,\"683\":1,\"684\":4,\"686\":5,\"688\":1,\"704\":2,\"705\":3,\"706\":5,\"725\":1,\"729\":1,\"733\":4,\"756\":1,\"757\":1,\"764\":1,\"766\":2,\"779\":1,\"781\":2,\"807\":1,\"808\":2,\"823\":5,\"824\":7,\"835\":2,\"840\":2,\"848\":1,\"882\":2,\"892\":1,\"894\":1,\"911\":1,\"920\":1,\"928\":1,\"934\":1,\"938\":1,\"940\":4,\"941\":1,\"944\":1,\"951\":1,\"958\":1,\"961\":1,\"969\":1,\"972\":7,\"974\":10,\"989\":2,\"1001\":2,\"1002\":2,\"1005\":1,\"1011\":2,\"1013\":2,\"1016\":3,\"1036\":6,\"1038\":3,\"1066\":1,\"1068\":1,\"1090\":2,\"1097\":2,\"1108\":1,\"1141\":1,\"1144\":1,\"1168\":1,\"1170\":1,\"1200\":2,\"1202\":2,\"1206\":1,\"1208\":1,\"1231\":1,\"1235\":2,\"1248\":1,\"1252\":1,\"1308\":1,\"1310\":1,\"1311\":1,\"1330\":1,\"1332\":2,\"1344\":1,\"1349\":1,\"1357\":3,\"1358\":5,\"1380\":2}}],[\"m3\",{\"1\":{\"1375\":2}}],[\"m2\",{\"1\":{\"1375\":4}}],[\"m1\",{\"1\":{\"1375\":3}}],[\"mtime\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":2,\"1382\":1}}],[\"mtbf\",{\"1\":{\"1116\":3}}],[\"mzxid\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":2,\"1382\":2}}],[\"m=\",{\"1\":{\"1290\":1}}],[\"md\",{\"1\":{\"1117\":1}}],[\"mdc\",{\"1\":{\"1045\":1,\"1046\":3,\"1047\":3}}],[\"mqs\",{\"1\":{\"1299\":1}}],[\"mqtt3\",{\"1\":{\"1253\":1}}],[\"mqtt\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"mq事务\",{\"1\":{\"1223\":1}}],[\"mq\",{\"0\":{\"1048\":1},\"1\":{\"1048\":1,\"1223\":1,\"1224\":4,\"1240\":1,\"1261\":3,\"1263\":1,\"1264\":4,\"1276\":2,\"1299\":1,\"1304\":2,\"1313\":2}}],[\"mmap\",{\"0\":{\"1310\":1},\"1\":{\"1310\":6,\"1311\":4}}],[\"mm\",{\"1\":{\"882\":10}}],[\"mxbean\",{\"1\":{\"807\":1}}],[\"m>\",{\"1\":{\"630\":1}}],[\"must\",{\"1\":{\"1011\":2}}],[\"mutex\",{\"1\":{\"847\":1}}],[\"much\",{\"1\":{\"218\":1}}],[\"multiproducersequencer\",{\"1\":{\"1182\":1}}],[\"multiples\",{\"1\":{\"618\":1,\"682\":1}}],[\"multiplexing\",{\"1\":{\"265\":1}}],[\"multithread\",{\"1\":{\"807\":1}}],[\"multi\",{\"0\":{\"1099\":1},\"1\":{\"141\":1,\"231\":5,\"233\":1,\"274\":2,\"280\":9,\"820\":1,\"1097\":5,\"1099\":7}}],[\"multilock\",{\"1\":{\"50\":1}}],[\"mget可能还是需要多次网络传输\",{\"1\":{\"286\":1}}],[\"mget\",{\"1\":{\"177\":2,\"286\":3,\"319\":1}}],[\"mb\",{\"1\":{\"163\":1,\"201\":2,\"233\":1,\"292\":1,\"478\":1,\"479\":1,\"480\":4,\"485\":1}}],[\"mp\",{\"1\":{\"156\":1,\"171\":2,\"320\":3,\"567\":1,\"876\":1,\"1241\":1}}],[\"mvcc的实现依赖于undo日志和read\",{\"1\":{\"141\":1}}],[\"mvcc实现原理是数据快照\",{\"1\":{\"141\":1}}],[\"mvcc全称叫做多版本并发控制\",{\"1\":{\"141\":1}}],[\"mvcc\",{\"1\":{\"141\":1}}],[\"mvvc\",{\"0\":{\"141\":1}}],[\"mean\",{\"1\":{\"1116\":1}}],[\"means\",{\"1\":{\"459\":1}}],[\"mechine\",{\"1\":{\"1112\":1}}],[\"meet\",{\"1\":{\"1085\":3}}],[\"mesh\",{\"1\":{\"1168\":1}}],[\"messagequeue\",{\"1\":{\"1299\":1}}],[\"messagequeueselector\",{\"1\":{\"1286\":1,\"1299\":2}}],[\"messageid=\",{\"1\":{\"1293\":1}}],[\"messageview\",{\"1\":{\"1293\":4}}],[\"messageviewlist\",{\"1\":{\"1293\":2}}],[\"messagebuilder\",{\"1\":{\"1290\":1}}],[\"messagelistenerorderly\",{\"1\":{\"1286\":1}}],[\"messagelistenerconcurrently\",{\"1\":{\"1286\":1}}],[\"messagelistenercontainer\",{\"1\":{\"1210\":1,\"1212\":1}}],[\"messagetype\",{\"1\":{\"1285\":1,\"1286\":1}}],[\"message\",{\"0\":{\"1397\":1},\"1\":{\"1028\":2,\"1130\":1,\"1200\":1,\"1209\":3,\"1213\":3,\"1226\":2,\"1230\":1,\"1237\":1,\"1245\":1,\"1256\":1,\"1257\":1,\"1290\":1,\"1293\":2,\"1299\":1}}],[\"messages\",{\"1\":{\"1028\":7}}],[\"mesi\",{\"1\":{\"968\":1,\"981\":1}}],[\"meituan\",{\"1\":{\"758\":1,\"876\":1,\"982\":1,\"999\":1}}],[\"meta\",{\"1\":{\"1131\":2}}],[\"metadata\",{\"1\":{\"480\":2}}],[\"metaspacegc\",{\"1\":{\"480\":1}}],[\"metaspacesize参数指定的量\",{\"1\":{\"480\":1}}],[\"metaspacesize=n\",{\"1\":{\"480\":1,\"496\":1}}],[\"metaspacesize\",{\"1\":{\"443\":1,\"480\":8,\"496\":1}}],[\"metaspace\",{\"1\":{\"382\":1,\"393\":2,\"443\":2,\"480\":9,\"495\":1,\"496\":5,\"498\":1}}],[\"methodname\",{\"1\":{\"1142\":2}}],[\"method2\",{\"1\":{\"860\":5}}],[\"method1\",{\"1\":{\"860\":3}}],[\"methodhandle\",{\"1\":{\"328\":1,\"344\":1}}],[\"methodtype\",{\"1\":{\"328\":1}}],[\"methodref\",{\"1\":{\"328\":1}}],[\"method\",{\"1\":{\"325\":1,\"332\":3,\"354\":1,\"498\":2,\"511\":1,\"523\":1,\"553\":1,\"561\":1,\"571\":1,\"848\":2,\"851\":1,\"852\":1,\"1003\":1,\"1123\":1,\"1142\":2}}],[\"methods\",{\"0\":{\"332\":1},\"1\":{\"325\":3,\"332\":4,\"573\":1}}],[\"medium\",{\"1\":{\"274\":1}}],[\"merge等\",{\"1\":{\"694\":1}}],[\"mergefunction\",{\"1\":{\"630\":3}}],[\"merge\",{\"1\":{\"120\":2,\"630\":5}}],[\"mem=\",{\"1\":{\"451\":8}}],[\"memcached\",{\"0\":{\"245\":1},\"1\":{\"224\":1,\"244\":3,\"245\":9,\"282\":1}}],[\"mem\",{\"1\":{\"219\":5,\"451\":1}}],[\"memorymodel\",{\"1\":{\"982\":1}}],[\"memory值就是内存碎片的大小\",{\"1\":{\"219\":1}}],[\"memory\",{\"0\":{\"970\":1},\"1\":{\"83\":1,\"90\":1,\"218\":2,\"219\":4,\"221\":1,\"270\":1,\"272\":1,\"293\":1,\"302\":2,\"364\":1,\"368\":1,\"412\":2,\"451\":4,\"511\":1,\"968\":3,\"969\":4,\"971\":1,\"982\":2,\"1184\":1,\"1310\":1}}],[\"members\",{\"1\":{\"293\":2}}],[\"member2\",{\"1\":{\"189\":1,\"193\":1,\"210\":2,\"260\":1}}],[\"member1\",{\"1\":{\"189\":1,\"193\":1,\"210\":3,\"260\":1}}],[\"member\",{\"1\":{\"75\":7,\"189\":1,\"193\":2,\"210\":1}}],[\"m为树的深度\",{\"1\":{\"99\":1}}],[\"msb\",{\"1\":{\"256\":1}}],[\"msg\",{\"1\":{\"1299\":2}}],[\"msg3\",{\"1\":{\"251\":1}}],[\"msg2\",{\"1\":{\"251\":1}}],[\"msg1\",{\"1\":{\"251\":2}}],[\"mset等等\",{\"1\":{\"319\":1}}],[\"mset等原生批量操作命令一样\",{\"1\":{\"287\":1}}],[\"mset\",{\"1\":{\"177\":2,\"286\":1}}],[\"ms\",{\"1\":{\"98\":2,\"1240\":2}}],[\"m\",{\"1\":{\"98\":2,\"99\":2,\"157\":4,\"210\":1,\"301\":4,\"365\":1,\"407\":1,\"451\":12,\"478\":1,\"621\":5,\"630\":1,\"698\":1,\"882\":10,\"1140\":1,\"1290\":1}}],[\"myid\",{\"1\":{\"1380\":4}}],[\"myisam使用的为非聚簇索引\",{\"1\":{\"107\":1}}],[\"myisam\",{\"1\":{\"83\":1,\"89\":2,\"90\":1,\"101\":2,\"105\":1,\"124\":2}}],[\"mythreadpooltaskexecutor\",{\"1\":{\"1047\":1}}],[\"myrunnable\",{\"1\":{\"940\":4}}],[\"myarray2\",{\"1\":{\"634\":2}}],[\"myarray\",{\"1\":{\"634\":9}}],[\"mybatis\",{\"1\":{\"359\":1}}],[\"my\",{\"1\":{\"293\":2,\"409\":1,\"1199\":3}}],[\"mykey\",{\"1\":{\"202\":6}}],[\"myzset4\",{\"1\":{\"193\":2}}],[\"myzset3\",{\"1\":{\"193\":2}}],[\"myzset2\",{\"1\":{\"193\":5}}],[\"myzset\",{\"1\":{\"193\":11}}],[\"myset3\",{\"1\":{\"189\":2}}],[\"myset2\",{\"1\":{\"189\":5,\"298\":1}}],[\"myset\",{\"1\":{\"189\":10,\"298\":6}}],[\"mysql事务\",{\"1\":{\"141\":1}}],[\"mysql事务详解\",{\"0\":{\"123\":1}}],[\"mysql在读已提交和可重复读隔离级别下都实现了mvcc机制\",{\"1\":{\"141\":1}}],[\"mysql在可重复读事务隔离级别下为了保证事务较高的隔离性\",{\"1\":{\"141\":1}}],[\"mysql锁技术\",{\"0\":{\"140\":1}}],[\"mysql锁技术以及mvcc基础\",{\"0\":{\"139\":1}}],[\"mysql索引\",{\"1\":{\"120\":1}}],[\"mysql索引详解\",{\"0\":{\"93\":1}}],[\"mysql实际决定使用的键\",{\"1\":{\"120\":1}}],[\"mysql可能使用的键\",{\"1\":{\"120\":1}}],[\"mysql可以分为\",{\"1\":{\"81\":1}}],[\"mysql还可以有多辅助\",{\"1\":{\"111\":1}}],[\"mysql中innodb引擎要求每张表都有要有一个聚簇索引\",{\"1\":{\"111\":1}}],[\"mysql官方对索引定义\",{\"1\":{\"94\":1}}],[\"mysql>\",{\"1\":{\"81\":1,\"86\":1,\"89\":1,\"117\":1,\"125\":7}}],[\"mysql基础框架\",{\"0\":{\"80\":1}}],[\"mysql\",{\"0\":{\"81\":1,\"85\":1},\"1\":{\"24\":1,\"29\":2,\"33\":1,\"34\":1,\"37\":1,\"62\":1,\"63\":1,\"81\":2,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":5,\"88\":1,\"89\":5,\"90\":2,\"101\":1,\"105\":1,\"117\":2,\"120\":2,\"124\":1,\"136\":1,\"141\":1,\"147\":1,\"160\":1,\"232\":1,\"236\":1,\"246\":1,\"273\":1,\"302\":1,\"359\":1,\"1184\":1,\"1207\":1},\"2\":{\"92\":1}}],[\"mylist2\",{\"1\":{\"181\":2}}],[\"mylist\",{\"1\":{\"181\":9,\"251\":4,\"634\":15}}],[\"middleware\",{\"1\":{\"1218\":1}}],[\"millis\",{\"1\":{\"820\":2}}],[\"milliseconds\",{\"1\":{\"49\":1,\"599\":1,\"784\":1,\"889\":2,\"937\":2,\"949\":2,\"953\":2,\"1001\":1,\"1062\":2}}],[\"might\",{\"1\":{\"555\":1,\"587\":1,\"693\":1}}],[\"mixed\",{\"1\":{\"387\":1,\"403\":1}}],[\"misc包下的unsafe类提供了compareandswapobject\",{\"1\":{\"841\":1,\"990\":1}}],[\"misc\",{\"1\":{\"353\":2,\"357\":3}}],[\"microkernel\",{\"1\":{\"1132\":1}}],[\"microseconds\",{\"1\":{\"302\":1}}],[\"microservices\",{\"1\":{\"11\":1}}],[\"mic6a9mfegdandd3mmffsg\",{\"1\":{\"320\":1}}],[\"mi\",{\"1\":{\"210\":1}}],[\"mina\",{\"1\":{\"1130\":1}}],[\"minutes\",{\"1\":{\"894\":1,\"920\":1,\"924\":1}}],[\"minexpand\",{\"1\":{\"553\":2,\"564\":2}}],[\"minexpand的值为10\",{\"1\":{\"553\":1}}],[\"minexpand的值为0\",{\"1\":{\"553\":1}}],[\"mincapacity\",{\"1\":{\"553\":20,\"557\":15,\"558\":8,\"559\":5,\"564\":4}}],[\"minheapfreeratio\",{\"1\":{\"449\":1,\"451\":1}}],[\"minorgc\",{\"1\":{\"386\":1}}],[\"minor\",{\"0\":{\"327\":1},\"1\":{\"325\":1,\"327\":1,\"375\":4,\"380\":1,\"384\":3,\"386\":1,\"387\":1,\"388\":6,\"444\":6,\"479\":1}}],[\"min\",{\"1\":{\"141\":1,\"220\":1,\"233\":1,\"562\":1,\"570\":1,\"619\":1,\"683\":1,\"697\":2,\"1206\":5}}],[\"motan\",{\"0\":{\"1169\":1},\"1\":{\"1167\":1,\"1169\":9,\"1172\":2}}],[\"motherclassloader\",{\"1\":{\"356\":1}}],[\"movable\",{\"1\":{\"711\":2}}],[\"move\",{\"1\":{\"710\":1}}],[\"moved\",{\"1\":{\"577\":2,\"1383\":1}}],[\"modified\",{\"1\":{\"1349\":2,\"1382\":2}}],[\"module\",{\"1\":{\"1253\":1}}],[\"modules\",{\"1\":{\"1132\":1}}],[\"modcount\",{\"1\":{\"553\":5,\"557\":1,\"561\":1,\"619\":1,\"713\":2,\"732\":2}}],[\"modcount++\",{\"1\":{\"553\":6,\"557\":1,\"622\":1,\"729\":2,\"731\":1}}],[\"mode\",{\"1\":{\"403\":1,\"687\":2,\"1011\":2,\"1014\":2,\"1248\":1}}],[\"modelandview\",{\"1\":{\"1046\":1}}],[\"model\",{\"0\":{\"970\":1,\"1348\":1},\"1\":{\"356\":2,\"511\":1,\"968\":1,\"971\":1,\"982\":1}}],[\"more\",{\"1\":{\"266\":1}}],[\"most\",{\"1\":{\"218\":1}}],[\"mongering\",{\"0\":{\"1088\":1},\"1\":{\"1086\":1,\"1087\":1,\"1088\":1,\"1089\":2,\"1091\":1}}],[\"mongodb\",{\"1\":{\"35\":3}}],[\"monitorexit\",{\"1\":{\"851\":6,\"852\":1,\"853\":3}}],[\"monitorenter\",{\"1\":{\"851\":5,\"852\":1,\"853\":3}}],[\"monitoring\",{\"1\":{\"364\":1,\"366\":1}}],[\"monitor\",{\"1\":{\"298\":5,\"319\":1,\"370\":2,\"807\":1,\"847\":1,\"851\":2,\"853\":2,\"1128\":1,\"1130\":1}}],[\"mono<void>\",{\"1\":{\"77\":1}}],[\"mobile\",{\"1\":{\"2\":1}}],[\"made\",{\"1\":{\"1096\":2}}],[\"ma\",{\"1\":{\"720\":1}}],[\"matchvalue\",{\"1\":{\"711\":2}}],[\"matching\",{\"1\":{\"570\":1}}],[\"mat\",{\"1\":{\"412\":3}}],[\"math\",{\"1\":{\"353\":1,\"553\":1,\"557\":1,\"562\":1}}],[\"mayinterruptifrunning\",{\"1\":{\"773\":1,\"774\":1,\"899\":1,\"934\":1}}],[\"may\",{\"1\":{\"356\":1,\"369\":1,\"693\":1,\"767\":2}}],[\"maintenance\",{\"1\":{\"1084\":1}}],[\"mainlock\",{\"1\":{\"941\":5}}],[\"main\",{\"1\":{\"344\":1,\"353\":1,\"365\":1,\"370\":5,\"384\":2,\"390\":1,\"425\":4,\"433\":3,\"451\":1,\"531\":3,\"561\":1,\"562\":1,\"564\":2,\"625\":1,\"663\":1,\"679\":1,\"693\":2,\"749\":1,\"752\":1,\"753\":1,\"756\":1,\"757\":2,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"806\":2,\"807\":6,\"823\":5,\"824\":6,\"827\":1,\"835\":1,\"882\":1,\"909\":1,\"911\":1,\"940\":1,\"944\":1,\"968\":2,\"1020\":1,\"1028\":1,\"1030\":1,\"1043\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1,\"1131\":1}}],[\"major\",{\"0\":{\"327\":1},\"1\":{\"325\":1,\"327\":1,\"375\":3,\"387\":3}}],[\"magic\",{\"0\":{\"326\":1},\"1\":{\"325\":1,\"326\":2}}],[\"malloc\",{\"1\":{\"218\":2}}],[\"master\",{\"1\":{\"218\":1,\"318\":1,\"1117\":2,\"1141\":1,\"1281\":3,\"1344\":2,\"1346\":1,\"1354\":3,\"1355\":1,\"1381\":1,\"1387\":7}}],[\"mandatory\",{\"1\":{\"1252\":1}}],[\"managementfactory\",{\"1\":{\"807\":1,\"1062\":1}}],[\"management\",{\"1\":{\"237\":1,\"373\":3}}],[\"man\",{\"1\":{\"125\":2}}],[\"manually\",{\"1\":{\"573\":1}}],[\"manual\",{\"1\":{\"86\":1,\"196\":1,\"285\":1,\"320\":1}}],[\"mark\",{\"1\":{\"396\":2,\"398\":1,\"406\":2,\"480\":1,\"767\":4}}],[\"mark为1\",{\"1\":{\"141\":1}}],[\"martin\",{\"1\":{\"51\":3,\"630\":1,\"1178\":1}}],[\"marcosbarbero\",{\"1\":{\"4\":1}}],[\"mapmode\",{\"1\":{\"1310\":1}}],[\"mapmessage\",{\"1\":{\"1226\":1,\"1231\":1}}],[\"mapmerger\",{\"1\":{\"630\":1}}],[\"mappedbytebuffer\",{\"1\":{\"1310\":2}}],[\"mapped\",{\"1\":{\"693\":1}}],[\"mapping\",{\"1\":{\"69\":1,\"571\":1,\"712\":1}}],[\"map中的所有键值对\",{\"1\":{\"625\":1}}],[\"map内部会执行两次遍历\",{\"1\":{\"625\":1}}],[\"map<string\",{\"1\":{\"1047\":2}}],[\"map<integer\",{\"1\":{\"713\":2}}],[\"map<\",{\"1\":{\"621\":2}}],[\"map<k\",{\"1\":{\"619\":1,\"630\":1,\"698\":1}}],[\"mapsupplier\",{\"1\":{\"630\":2}}],[\"maps\",{\"1\":{\"56\":1,\"571\":1,\"693\":2}}],[\"map\",{\"0\":{\"630\":1,\"640\":1,\"645\":1,\"676\":1},\"1\":{\"49\":1,\"364\":1,\"368\":1,\"570\":1,\"616\":1,\"619\":6,\"621\":2,\"625\":24,\"630\":5,\"632\":2,\"639\":1,\"640\":1,\"644\":1,\"646\":1,\"678\":2,\"680\":1,\"693\":4,\"694\":13,\"698\":1,\"704\":7,\"705\":10,\"706\":1,\"712\":2,\"713\":8,\"719\":1,\"791\":1,\"800\":3,\"883\":3,\"909\":1,\"1031\":3,\"1142\":2,\"1210\":7,\"1310\":2}}],[\"machine\",{\"1\":{\"334\":1,\"339\":1,\"345\":1,\"356\":1,\"365\":1,\"377\":1,\"417\":1,\"511\":1}}],[\"mac\",{\"1\":{\"37\":4}}],[\"maxn\",{\"1\":{\"1373\":2}}],[\"maxnewsize=1024m\",{\"1\":{\"479\":1}}],[\"maxnewsize=<young\",{\"1\":{\"479\":1}}],[\"maxnewsize指定\",{\"1\":{\"479\":1}}],[\"maxnewsize\",{\"1\":{\"449\":1,\"454\":1,\"479\":1}}],[\"maxretries\",{\"1\":{\"1333\":1}}],[\"maxdelay\",{\"1\":{\"1213\":1}}],[\"maxpoolsize\",{\"1\":{\"928\":3,\"941\":1}}],[\"maxpermsize=n\",{\"1\":{\"480\":1,\"496\":1}}],[\"maxpermsize\",{\"1\":{\"449\":1,\"456\":2,\"496\":1}}],[\"maxelements\",{\"1\":{\"533\":1}}],[\"maxgcpausemillis\",{\"1\":{\"449\":1}}],[\"maxheapfreeratio\",{\"1\":{\"449\":1,\"451\":1,\"485\":1}}],[\"maxheapsize=4206742528\",{\"1\":{\"403\":1}}],[\"maxheapsize=2124414976\",{\"1\":{\"367\":1}}],[\"maxheapsize\",{\"1\":{\"367\":2}}],[\"maxmetapacesize\",{\"1\":{\"480\":1}}],[\"maxmetaspacesize=n\",{\"1\":{\"480\":1,\"496\":1}}],[\"maxmetaspacesize\",{\"1\":{\"443\":1,\"480\":2,\"496\":1}}],[\"maxmemory\",{\"1\":{\"168\":1,\"218\":1,\"298\":4,\"451\":4}}],[\"maxtenuringthreshold=threshold这里有个说明\",{\"1\":{\"386\":1}}],[\"maxtenuringthreshold\",{\"1\":{\"386\":4,\"444\":3,\"464\":1,\"495\":4}}],[\"maximumpool\",{\"1\":{\"957\":1,\"958\":3}}],[\"maximumpoolsize被设置为\",{\"1\":{\"957\":1}}],[\"maximumpoolsize\",{\"1\":{\"530\":1,\"890\":6,\"894\":1,\"896\":1,\"920\":1,\"923\":1,\"936\":6,\"940\":1,\"941\":2,\"949\":2,\"951\":2,\"953\":1}}],[\"maximum\",{\"1\":{\"201\":1,\"386\":1,\"570\":2,\"571\":1,\"619\":1,\"621\":4,\"624\":4,\"677\":4,\"748\":1,\"1007\":1,\"1018\":2}}],[\"max\",{\"1\":{\"34\":10,\"141\":2,\"220\":1,\"302\":4,\"495\":1,\"529\":1,\"542\":1,\"553\":11,\"557\":1,\"558\":9,\"559\":11,\"570\":2,\"571\":1,\"624\":2,\"629\":2,\"671\":1,\"672\":1,\"697\":2,\"798\":3,\"889\":6,\"892\":3,\"917\":3,\"928\":1,\"929\":1,\"937\":6,\"938\":3,\"940\":2,\"949\":1,\"951\":1,\"955\":1,\"957\":3,\"959\":1,\"961\":2,\"1062\":11,\"1210\":3,\"1258\":1,\"1333\":2}}],[\"dma\",{\"1\":{\"1308\":1,\"1311\":1}}],[\"dms\",{\"1\":{\"1062\":1}}],[\"dledger\",{\"1\":{\"1314\":3}}],[\"dlx\",{\"1\":{\"1256\":3,\"1257\":1}}],[\"dlthandler\",{\"1\":{\"1213\":1}}],[\"dlq\",{\"1\":{\"1213\":1}}],[\"dns\",{\"1\":{\"1157\":3}}],[\"dɛk\",{\"1\":{\"727\":1}}],[\"droidyue\",{\"1\":{\"876\":1}}],[\"draintoexample\",{\"1\":{\"531\":1}}],[\"drainto\",{\"1\":{\"531\":4,\"533\":2}}],[\"driver\",{\"1\":{\"359\":2}}],[\"dzone\",{\"1\":{\"511\":1}}],[\"dcom\",{\"1\":{\"373\":3}}],[\"dc3f28057c20\",{\"1\":{\"293\":2}}],[\"djava\",{\"1\":{\"373\":1}}],[\"dynamic\",{\"1\":{\"176\":1,\"256\":1,\"896\":1,\"923\":1}}],[\"digest\",{\"1\":{\"1351\":1}}],[\"did\",{\"1\":{\"680\":1}}],[\"differ\",{\"1\":{\"618\":1,\"682\":1}}],[\"difference\",{\"1\":{\"237\":1}}],[\"different\",{\"1\":{\"201\":1}}],[\"discovery\",{\"1\":{\"1356\":1}}],[\"discardoldestpolicy\",{\"1\":{\"891\":1,\"936\":1}}],[\"discardpolicy\",{\"1\":{\"891\":1,\"936\":1}}],[\"discard\",{\"1\":{\"280\":3}}],[\"disruptor这篇文章\",{\"1\":{\"1184\":1}}],[\"disruptor\",{\"0\":{\"1178\":1,\"1179\":1,\"1180\":1,\"1181\":1,\"1182\":1,\"1183\":1,\"1184\":1},\"1\":{\"1177\":5,\"1178\":9,\"1179\":7,\"1180\":1,\"1181\":5,\"1182\":9,\"1183\":2,\"1184\":7,\"1185\":3}}],[\"disruptor常见问题总结\",{\"0\":{\"1177\":1}}],[\"dissertation\",{\"1\":{\"1117\":1}}],[\"dispatcher\",{\"1\":{\"807\":1}}],[\"disables\",{\"1\":{\"302\":1}}],[\"distribution\",{\"1\":{\"708\":1}}],[\"distributed\",{\"0\":{\"1399\":1},\"1\":{\"49\":1,\"51\":1,\"708\":1,\"974\":1,\"1367\":2}}],[\"distance\",{\"1\":{\"210\":3,\"696\":1}}],[\"distlock\",{\"1\":{\"49\":1}}],[\"direct\",{\"1\":{\"1249\":1,\"1252\":7}}],[\"directbytebuffer\",{\"1\":{\"499\":1}}],[\"directly\",{\"1\":{\"256\":1}}],[\"dirs\",{\"1\":{\"353\":1}}],[\"dir\",{\"1\":{\"229\":1}}],[\"dictionary\",{\"1\":{\"242\":1}}],[\"dict\",{\"1\":{\"174\":3,\"271\":3,\"273\":1}}],[\"dukes\",{\"1\":{\"1178\":1}}],[\"duke\",{\"1\":{\"1178\":5}}],[\"due\",{\"1\":{\"708\":1,\"941\":1}}],[\"duration\",{\"1\":{\"598\":1,\"1293\":2}}],[\"durability\",{\"1\":{\"125\":1,\"281\":1}}],[\"during\",{\"1\":{\"480\":2}}],[\"duplicate\",{\"1\":{\"369\":1}}],[\"dumpallthreads\",{\"1\":{\"807\":1,\"1062\":1}}],[\"dumping\",{\"1\":{\"368\":1}}],[\"dump\",{\"1\":{\"364\":1,\"368\":5,\"369\":1,\"377\":3,\"412\":4,\"455\":2}}],[\"dubbo提供的六大核心能力\",{\"1\":{\"1122\":1}}],[\"dubbo2\",{\"1\":{\"1120\":2}}],[\"dubbo3\",{\"1\":{\"1120\":3,\"1168\":1}}],[\"dubbo常见问题总结\",{\"0\":{\"1120\":1}}],[\"dubbo\",{\"0\":{\"1121\":1,\"1122\":1,\"1123\":1,\"1127\":1,\"1128\":1,\"1129\":1,\"1130\":1,\"1131\":2,\"1132\":1,\"1133\":1,\"1138\":1,\"1140\":1,\"1145\":1,\"1146\":1,\"1168\":1},\"1\":{\"2\":1,\"1069\":2,\"1120\":2,\"1122\":9,\"1123\":6,\"1128\":1,\"1129\":5,\"1130\":3,\"1131\":11,\"1132\":5,\"1140\":4,\"1141\":2,\"1142\":1,\"1143\":2,\"1144\":2,\"1146\":3,\"1147\":3,\"1167\":1,\"1168\":8,\"1169\":4,\"1170\":1,\"1172\":8,\"1237\":1,\"1271\":1,\"1328\":1,\"1341\":1,\"1349\":2}}],[\"d60bce986eaa\",{\"1\":{\"37\":1}}],[\"db\",{\"1\":{\"34\":1,\"41\":1,\"42\":4,\"145\":13,\"146\":6,\"147\":6,\"273\":5,\"298\":1,\"316\":1}}],[\"dwz\",{\"1\":{\"24\":3}}],[\"d\",{\"1\":{\"23\":2,\"125\":1,\"376\":1,\"531\":1,\"882\":10,\"894\":1,\"920\":1,\"1022\":1,\"1321\":1,\"1335\":1}}],[\"downloads\",{\"1\":{\"1235\":1}}],[\"dowait\",{\"1\":{\"756\":4,\"911\":4}}],[\"doselect\",{\"1\":{\"1140\":1,\"1141\":1,\"1142\":1}}],[\"dosomething\",{\"1\":{\"438\":1,\"909\":1}}],[\"doreleaseshared\",{\"1\":{\"748\":1,\"752\":1,\"906\":1}}],[\"doacquiresharedinterruptibly\",{\"1\":{\"748\":1,\"752\":1,\"906\":1}}],[\"done\",{\"1\":{\"782\":9,\"909\":1}}],[\"don\",{\"1\":{\"604\":1}}],[\"doug\",{\"1\":{\"530\":1,\"693\":1}}],[\"double\",{\"1\":{\"328\":1,\"386\":1,\"493\":1,\"495\":1,\"624\":1,\"649\":1}}],[\"dots\",{\"1\":{\"369\":1}}],[\"does\",{\"1\":{\"356\":1,\"553\":1,\"767\":2}}],[\"docommit\",{\"1\":{\"1371\":5}}],[\"docker\",{\"0\":{\"1321\":1},\"1\":{\"1321\":3,\"1322\":2}}],[\"doc\",{\"1\":{\"353\":1}}],[\"documentation\",{\"1\":{\"377\":2,\"1214\":1}}],[\"document\",{\"1\":{\"256\":1}}],[\"docs\",{\"1\":{\"7\":1,\"196\":1,\"205\":1,\"237\":1,\"285\":1,\"320\":1,\"334\":1,\"345\":1,\"360\":2,\"386\":2,\"409\":1,\"511\":1,\"876\":2,\"1140\":1,\"1143\":1}}],[\"dog\",{\"1\":{\"49\":6,\"633\":1}}],[\"do\",{\"1\":{\"11\":1,\"51\":1,\"267\":1,\"480\":2,\"538\":1,\"553\":3,\"623\":1,\"624\":1,\"683\":1,\"713\":1,\"1012\":1,\"1013\":1,\"1042\":1}}],[\"dead\",{\"1\":{\"1213\":1,\"1256\":2}}],[\"deadlock\",{\"1\":{\"370\":2}}],[\"deadlockdemo$$lambda$1\",{\"1\":{\"370\":1}}],[\"deadlockdemo$$lambda$2\",{\"1\":{\"370\":1}}],[\"deadlockdemo\",{\"1\":{\"370\":6,\"823\":1}}],[\"debug\",{\"1\":{\"1209\":1,\"1252\":1}}],[\"debug投稿\",{\"1\":{\"1150\":1}}],[\"deemed\",{\"1\":{\"756\":1,\"911\":1}}],[\"deck\",{\"1\":{\"727\":1}}],[\"decr\",{\"1\":{\"177\":2,\"178\":1}}],[\"detect\",{\"1\":{\"693\":1}}],[\"details\",{\"1\":{\"334\":1,\"360\":1,\"522\":1,\"612\":1,\"1030\":1}}],[\"deque<e>\",{\"1\":{\"727\":1}}],[\"deque\",{\"0\":{\"667\":1},\"1\":{\"667\":4,\"668\":1,\"727\":2,\"729\":1}}],[\"dequeue\",{\"1\":{\"535\":3,\"536\":1,\"537\":1}}],[\"depends\",{\"1\":{\"1011\":1}}],[\"dependent\",{\"1\":{\"480\":2}}],[\"dependency>\",{\"1\":{\"4\":2,\"1332\":2}}],[\"deprecated\",{\"1\":{\"446\":1}}],[\"deprecate\",{\"1\":{\"391\":1}}],[\"def\",{\"1\":{\"1030\":2}}],[\"definition\",{\"1\":{\"351\":1}}],[\"define\",{\"1\":{\"268\":5}}],[\"defined\",{\"1\":{\"201\":1,\"351\":1}}],[\"deferred\",{\"1\":{\"268\":3}}],[\"defrag\",{\"1\":{\"220\":4}}],[\"defaulterrorhandler\",{\"1\":{\"1209\":2,\"1210\":3,\"1211\":3,\"1212\":3}}],[\"defaultexecutor\",{\"1\":{\"779\":4,\"780\":1,\"781\":1}}],[\"defaulted\",{\"1\":{\"621\":1}}],[\"defaults\",{\"1\":{\"624\":1}}],[\"defaultcapacity\",{\"1\":{\"553\":5,\"555\":2,\"557\":1,\"564\":1}}],[\"default\",{\"1\":{\"33\":2,\"34\":1,\"344\":1,\"386\":1,\"459\":1,\"480\":1,\"495\":1,\"553\":7,\"555\":1,\"557\":1,\"564\":5,\"570\":7,\"576\":1,\"618\":1,\"619\":2,\"621\":3,\"624\":4,\"630\":1,\"677\":1,\"682\":1,\"779\":2,\"882\":11,\"1210\":6}}],[\"desired\",{\"1\":{\"386\":2,\"495\":2}}],[\"desktop\",{\"1\":{\"368\":2,\"369\":2}}],[\"desk2\",{\"1\":{\"261\":2}}],[\"desk1\",{\"1\":{\"261\":2}}],[\"descriptor\",{\"1\":{\"331\":1}}],[\"description\",{\"1\":{\"185\":2}}],[\"desc\",{\"1\":{\"210\":1}}],[\"destpos\",{\"1\":{\"561\":2}}],[\"dest\",{\"1\":{\"561\":2}}],[\"desthll\",{\"1\":{\"206\":2}}],[\"destkey\",{\"1\":{\"202\":1,\"206\":3}}],[\"destination\",{\"1\":{\"189\":6,\"193\":4}}],[\"demo\",{\"1\":{\"144\":1,\"459\":1,\"918\":1,\"939\":1,\"1252\":2,\"1263\":1}}],[\"delivery\",{\"1\":{\"1248\":1}}],[\"delta\",{\"1\":{\"763\":1,\"766\":1}}],[\"delay\",{\"1\":{\"599\":2,\"604\":3,\"1213\":1,\"1285\":1}}],[\"delayedworkqueue\",{\"1\":{\"889\":2,\"892\":3,\"913\":1,\"937\":2,\"938\":3,\"961\":3}}],[\"delayed>\",{\"1\":{\"600\":1}}],[\"delayedtask\",{\"1\":{\"599\":9}}],[\"delayed\",{\"0\":{\"610\":1},\"1\":{\"597\":2,\"599\":3,\"610\":2,\"1257\":1}}],[\"delayqueue类图\",{\"1\":{\"600\":1}}],[\"delayqueue<e\",{\"1\":{\"600\":1}}],[\"delayqueue\",{\"0\":{\"596\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"606\":1,\"607\":1,\"608\":1,\"609\":1,\"610\":1,\"611\":1},\"1\":{\"529\":1,\"597\":3,\"598\":7,\"599\":9,\"600\":3,\"601\":5,\"602\":2,\"603\":1,\"604\":4,\"607\":4,\"608\":1,\"609\":4,\"610\":2,\"611\":3,\"612\":1,\"644\":2,\"671\":1}}],[\"delerrorhandler\",{\"1\":{\"1212\":2}}],[\"deletingchildrenifneeded\",{\"1\":{\"1336\":1}}],[\"deletion\",{\"1\":{\"619\":1}}],[\"delete\",{\"0\":{\"1331\":1},\"1\":{\"490\":1,\"1331\":1,\"1336\":2,\"1351\":2,\"1384\":1}}],[\"delegate\",{\"1\":{\"356\":1,\"894\":5,\"920\":5}}],[\"delegation\",{\"1\":{\"356\":2}}],[\"del\",{\"1\":{\"47\":3,\"163\":1,\"177\":2,\"266\":1,\"292\":1,\"294\":1}}],[\"development\",{\"1\":{\"516\":1}}],[\"developerworks\",{\"1\":{\"377\":1}}],[\"developer\",{\"1\":{\"11\":1,\"876\":1,\"1241\":1}}],[\"dev\",{\"1\":{\"185\":2,\"1140\":1,\"1143\":1}}],[\"devops\",{\"1\":{\"8\":1}}],[\"dan\",{\"1\":{\"1072\":1}}],[\"date\",{\"1\":{\"835\":1,\"940\":3}}],[\"datalength\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":2,\"1382\":1}}],[\"dataversion\",{\"1\":{\"1327\":1,\"1329\":1,\"1330\":1,\"1349\":2,\"1350\":1}}],[\"database\",{\"1\":{\"237\":1,\"1084\":1}}],[\"data\",{\"0\":{\"1348\":1},\"1\":{\"7\":3,\"174\":2,\"196\":5,\"201\":1,\"205\":2,\"213\":2,\"298\":1,\"351\":1,\"412\":1,\"511\":1,\"632\":7,\"1202\":1,\"1349\":1}}],[\"dawell\",{\"1\":{\"820\":1}}],[\"daisy\",{\"1\":{\"767\":2}}],[\"day\",{\"1\":{\"205\":1,\"612\":1}}],[\"dashboard\",{\"1\":{\"7\":1}}],[\"<http\",{\"1\":{\"1185\":1}}],[\"<https\",{\"1\":{\"221\":1}}],[\"<u>\",{\"1\":{\"777\":1,\"778\":2,\"779\":3,\"780\":3,\"781\":3}}],[\"<binarysearch\",{\"1\":{\"658\":1}}],[\"<<\",{\"1\":{\"571\":2,\"572\":1,\"573\":2,\"619\":2,\"624\":2,\"1116\":2,\"1210\":2}}],[\"<<=\",{\"1\":{\"570\":2}}],[\"<p1\",{\"1\":{\"824\":1}}],[\"<p>\",{\"1\":{\"571\":1}}],[\"<pid>\",{\"1\":{\"484\":1}}],[\"<t\",{\"1\":{\"630\":1}}],[\"<tt>null<\",{\"1\":{\"571\":1}}],[\"<tt>key<\",{\"1\":{\"571\":2}}],[\"<tt>get<\",{\"1\":{\"571\":1}}],[\"<t>\",{\"1\":{\"553\":1,\"630\":1,\"632\":2,\"634\":2,\"658\":1,\"900\":1,\"934\":1,\"1131\":1,\"1140\":2,\"1141\":1,\"1142\":1}}],[\"<tomcat\",{\"1\":{\"359\":2}}],[\"<init>\",{\"1\":{\"506\":2}}],[\"<interval>\",{\"1\":{\"366\":1}}],[\"<1gb\",{\"1\":{\"449\":2,\"451\":2}}],[\"<0x00000000d5efe1d0>\",{\"1\":{\"370\":2}}],[\"<0x00000000d5efe1c0>\",{\"1\":{\"370\":2}}],[\"<count>\",{\"1\":{\"366\":1}}],[\"<clinit>\",{\"1\":{\"344\":3}}],[\"<version>4\",{\"1\":{\"1332\":2}}],[\"<version>2\",{\"1\":{\"4\":1}}],[\"<vmid>\",{\"1\":{\"366\":1}}],[\"<option>\",{\"1\":{\"366\":1}}],[\"<artifactid>curator\",{\"1\":{\"1332\":2}}],[\"<artifactid>spring\",{\"1\":{\"4\":2}}],[\"<app>\",{\"1\":{\"359\":1}}],[\"<8\",{\"1\":{\"256\":1}}],[\"<=\",{\"1\":{\"141\":1,\"531\":1,\"534\":1,\"537\":2,\"570\":1,\"604\":1,\"621\":1,\"629\":1,\"631\":1,\"677\":1,\"748\":1,\"756\":2,\"798\":1,\"890\":1,\"911\":2,\"936\":1,\"1013\":3,\"1014\":1,\"1210\":1}}],[\"<segment>\",{\"1\":{\"74\":1,\"75\":1}}],[\"<groupid>com\",{\"1\":{\"4\":1}}],[\"<groupid>org\",{\"1\":{\"4\":1,\"1332\":2}}],[\"<\",{\"1\":{\"4\":2,\"141\":2,\"256\":1,\"386\":2,\"484\":2,\"495\":2,\"553\":12,\"558\":1,\"559\":1,\"561\":1,\"564\":2,\"570\":4,\"571\":2,\"572\":1,\"576\":2,\"578\":1,\"592\":1,\"599\":2,\"621\":2,\"624\":4,\"629\":2,\"632\":2,\"649\":1,\"663\":1,\"677\":2,\"683\":1,\"704\":3,\"706\":3,\"710\":5,\"712\":1,\"713\":14,\"730\":2,\"732\":1,\"748\":5,\"749\":1,\"752\":3,\"753\":2,\"757\":2,\"766\":1,\"767\":2,\"835\":2,\"871\":1,\"890\":3,\"906\":1,\"909\":1,\"936\":3,\"940\":1,\"941\":4,\"1001\":1,\"1007\":1,\"1014\":2,\"1018\":2,\"1020\":1,\"1036\":1,\"1038\":2,\"1062\":1,\"1141\":3,\"1142\":4,\"1209\":1,\"1210\":2,\"1332\":2}}],[\"<dependency>\",{\"1\":{\"4\":2,\"1332\":2}}],[\"来选定一台称为\",{\"1\":{\"1355\":1}}],[\"来代表\",{\"1\":{\"1348\":1}}],[\"来代替\",{\"1\":{\"656\":1,\"724\":1}}],[\"来查找待消费的消息\",{\"1\":{\"1315\":1}}],[\"来查看\",{\"1\":{\"895\":1,\"922\":1}}],[\"来向同一主题的不同消息队列发送消息\",{\"1\":{\"1299\":1}}],[\"来维持的话\",{\"1\":{\"1281\":1}}],[\"来\",{\"1\":{\"1159\":1}}],[\"来修复老版本中\",{\"1\":{\"1143\":1}}],[\"来阻止follower开始选举\",{\"1\":{\"1116\":1}}],[\"来交换各个节点状态信息\",{\"1\":{\"1085\":1}}],[\"来关联\",{\"1\":{\"1045\":1}}],[\"来调用此方法\",{\"1\":{\"1037\":1}}],[\"来调整你的刷盘策略\",{\"1\":{\"1313\":1}}],[\"来调整\",{\"1\":{\"444\":1}}],[\"来深入解读\",{\"1\":{\"999\":1}}],[\"来了\",{\"1\":{\"982\":1}}],[\"来了解被引用的对象是否将要被垃圾回收\",{\"1\":{\"392\":1}}],[\"来将多条指令重叠执行\",{\"1\":{\"969\":1}}],[\"来提高这个集群的可用性\",{\"1\":{\"1358\":1}}],[\"来提高写并发性能\",{\"1\":{\"1181\":1}}],[\"来提交一个任务到线程池中去\",{\"1\":{\"941\":1}}],[\"来提示用户发生了并发修改异常\",{\"1\":{\"631\":1}}],[\"来回顾上面的内容\",{\"1\":{\"939\":1}}],[\"来通过写一个\",{\"1\":{\"939\":1}}],[\"来拒绝新来的任务\",{\"1\":{\"936\":1}}],[\"来取消此任务的执行\",{\"1\":{\"934\":1}}],[\"来启动线程比使用\",{\"1\":{\"934\":1}}],[\"来理解\",{\"1\":{\"900\":1}}],[\"来表示锁的状态和类型\",{\"1\":{\"874\":1}}],[\"来看它是如何实现的\",{\"1\":{\"861\":1}}],[\"来看看一个普通的\",{\"1\":{\"807\":1}}],[\"来更新\",{\"1\":{\"841\":1,\"990\":1}}],[\"来给我手写一下\",{\"1\":{\"834\":1}}],[\"来为每个线程分配所需资源\",{\"1\":{\"824\":1}}],[\"来指定排序规则\",{\"1\":{\"799\":1}}],[\"来替代\",{\"1\":{\"794\":1}}],[\"来创建\",{\"1\":{\"777\":1,\"888\":1,\"937\":1}}],[\"来使用\",{\"1\":{\"777\":1}}],[\"来处理\",{\"1\":{\"773\":1,\"782\":1,\"895\":1,\"899\":1,\"922\":1,\"1262\":1}}],[\"来完成获取资源线程的排队工作\",{\"1\":{\"742\":1,\"904\":1}}],[\"来计算一个新的\",{\"1\":{\"694\":1}}],[\"来防止其他线程的进入\",{\"1\":{\"688\":1}}],[\"来保持数据的一致性\",{\"1\":{\"1354\":1}}],[\"来保证同一个订单在同一个队列中就行了\",{\"1\":{\"1299\":1}}],[\"来保证\",{\"1\":{\"1281\":1,\"1303\":1}}],[\"来保证消息在分区内的顺序性\",{\"1\":{\"1202\":1}}],[\"来保证第一个性质\",{\"1\":{\"1112\":1}}],[\"来保证原子操作\",{\"1\":{\"978\":1}}],[\"来保证并发安全\",{\"1\":{\"691\":1}}],[\"来保证线程安全\",{\"1\":{\"688\":1}}],[\"来保存元素\",{\"1\":{\"643\":1}}],[\"来保存数据\",{\"1\":{\"412\":1}}],[\"来保存数据过期的时间\",{\"1\":{\"271\":1}}],[\"来操作\",{\"1\":{\"688\":1,\"792\":1}}],[\"来搜索的专家\",{\"1\":{\"640\":1}}],[\"来存储数据节点的\",{\"1\":{\"1389\":1}}],[\"来存储元素\",{\"1\":{\"607\":1}}],[\"来存储对象数据即可\",{\"1\":{\"255\":1}}],[\"来管理虚拟线程\",{\"1\":{\"1053\":1}}],[\"来管理延迟任务\",{\"1\":{\"601\":1}}],[\"来管理的\",{\"1\":{\"601\":1}}],[\"来比较mincapacity和\",{\"1\":{\"553\":1}}],[\"来控制整体可重入的情况\",{\"1\":{\"1018\":1}}],[\"来控制消费者结束\",{\"1\":{\"531\":1}}],[\"来控制一个\",{\"1\":{\"60\":1}}],[\"来的更加的轻量及可靠\",{\"1\":{\"446\":1}}],[\"来进行网络通信的\",{\"1\":{\"1379\":1}}],[\"来进行事务的回滚操作\",{\"1\":{\"1371\":1}}],[\"来进行通信共享信息\",{\"1\":{\"1085\":1}}],[\"来进行自救\",{\"1\":{\"446\":1}}],[\"来进行工作的\",{\"1\":{\"422\":1}}],[\"来进行\",{\"1\":{\"412\":1}}],[\"来进行排序\",{\"1\":{\"30\":1,\"1379\":1}}],[\"来缩短\",{\"1\":{\"407\":1}}],[\"来禁用该功能\",{\"1\":{\"403\":1}}],[\"来设置老年代与新生代内存的比值\",{\"1\":{\"479\":1}}],[\"来设置\",{\"1\":{\"386\":2,\"495\":1}}],[\"来设计制作一个排行榜\",{\"1\":{\"194\":1,\"258\":1}}],[\"来决定是否扩容\",{\"1\":{\"1038\":1}}],[\"来决定\",{\"1\":{\"426\":1}}],[\"来决定何时直接在老年代分配大对象\",{\"1\":{\"385\":1}}],[\"来决定哪些对象会直接进入老年代\",{\"1\":{\"385\":1}}],[\"来加载业务类\",{\"1\":{\"359\":1}}],[\"来打破双亲委托机制\",{\"1\":{\"359\":1}}],[\"来自官方网站\",{\"1\":{\"1297\":1}}],[\"来自说出你的愿望吧丷投稿\",{\"1\":{\"415\":1}}],[\"来自定义类加载器\",{\"1\":{\"357\":1}}],[\"来自issue745\",{\"1\":{\"344\":1}}],[\"来初始化要调用的类\",{\"1\":{\"344\":1}}],[\"来标识常量的类型\",{\"1\":{\"328\":1}}],[\"来聊聊\",{\"1\":{\"316\":1}}],[\"来监听来自客户端的大量连接\",{\"1\":{\"265\":1}}],[\"来作为\",{\"1\":{\"1202\":1}}],[\"来作为底层实现\",{\"1\":{\"256\":1}}],[\"来作为自己项目的分布式缓存了\",{\"1\":{\"245\":1}}],[\"来消费消息\",{\"1\":{\"251\":1,\"1196\":1}}],[\"来实际体验\",{\"1\":{\"242\":1}}],[\"来实现呢\",{\"1\":{\"1389\":1}}],[\"来实现选主的功能\",{\"1\":{\"1387\":1}}],[\"来实现消息存储的\",{\"1\":{\"1277\":1}}],[\"来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决\",{\"1\":{\"251\":1}}],[\"来实现延迟队列功能\",{\"1\":{\"1257\":1}}],[\"来实现等待和唤醒操作\",{\"1\":{\"1183\":1}}],[\"来实现工作进程内发生的消息传递\",{\"1\":{\"1181\":1}}],[\"来实现异步日志\",{\"1\":{\"1181\":2}}],[\"来实现此功能\",{\"1\":{\"1045\":1}}],[\"来实现这个机制\",{\"1\":{\"862\":1}}],[\"来实现锁的分配\",{\"1\":{\"742\":1,\"904\":1}}],[\"来实现队列要比\",{\"1\":{\"668\":1}}],[\"来实现歌名排序和歌星名排序\",{\"1\":{\"661\":1}}],[\"来实现缓存\",{\"1\":{\"245\":1}}],[\"来实现分布式缓存\",{\"1\":{\"244\":1}}],[\"来实现分布式锁\",{\"1\":{\"57\":1,\"249\":1}}],[\"来实现分布式锁的话\",{\"1\":{\"49\":1}}],[\"来实现的\",{\"1\":{\"133\":1,\"435\":1,\"643\":1,\"847\":1,\"857\":1,\"1002\":1,\"1045\":1}}],[\"来实现\",{\"1\":{\"53\":1,\"89\":1,\"251\":1,\"599\":1,\"808\":1,\"1272\":1}}],[\"来分配内存的\",{\"1\":{\"218\":1}}],[\"来恢复的时候就多了一个事务出来\",{\"1\":{\"89\":1}}],[\"来恢复临时库的话\",{\"1\":{\"89\":1}}],[\"来说如何去学习\",{\"1\":{\"1374\":1}}],[\"来说变化还是挺大的\",{\"1\":{\"578\":1}}],[\"来说变化比较大\",{\"1\":{\"575\":1}}],[\"来说是不可见的\",{\"1\":{\"522\":1}}],[\"来说是非常致命的\",{\"1\":{\"168\":1}}],[\"来说\",{\"1\":{\"53\":1,\"163\":1,\"291\":1,\"480\":1,\"702\":1,\"819\":1,\"971\":1,\"1251\":1,\"1332\":1,\"1374\":1}}],[\"来解决分布式事务问题的\",{\"1\":{\"1304\":1}}],[\"来解决内存缓存不一致性问题\",{\"1\":{\"981\":1}}],[\"来解决这个指令重排序问题\",{\"1\":{\"971\":1}}],[\"来解决\",{\"1\":{\"51\":1}}],[\"来判断否存在这个键值对\",{\"1\":{\"693\":1}}],[\"来判断指定元素是否存在于队列中\",{\"1\":{\"538\":1}}],[\"来判断\",{\"1\":{\"47\":1}}],[\"来插入数据\",{\"1\":{\"33\":2}}],[\"来做分布式项目的时候\",{\"1\":{\"1341\":1}}],[\"来做分布式锁是一种比较常见的方式\",{\"1\":{\"249\":1}}],[\"来做配置\",{\"1\":{\"1130\":1}}],[\"来做配置中心\",{\"1\":{\"10\":1}}],[\"来做示例说明\",{\"1\":{\"1037\":1}}],[\"来做判断是否存在这个键值对\",{\"1\":{\"693\":1}}],[\"来做消息队列的话\",{\"1\":{\"251\":1}}],[\"来做消息队列\",{\"1\":{\"251\":4}}],[\"来做缓存\",{\"1\":{\"244\":1}}],[\"来做\",{\"1\":{\"51\":1,\"1165\":1}}],[\"来做的\",{\"1\":{\"49\":1,\"251\":1}}],[\"来做限流\",{\"1\":{\"4\":1,\"747\":1,\"905\":1}}],[\"来支持更多的主流编程语言\",{\"1\":{\"8\":1}}],[\"来过滤请求\",{\"1\":{\"4\":1}}],[\"从同一客户端发起的事务请求\",{\"1\":{\"1345\":1}}],[\"从节点那部分未来得及复制的消息还会继续复制\",{\"1\":{\"1314\":1}}],[\"从节点处理读请求\",{\"1\":{\"299\":1}}],[\"从mqs中选择一个队列\",{\"1\":{\"1299\":1}}],[\"从计算机术语层面来说\",{\"1\":{\"1247\":1}}],[\"从计算机底层来说\",{\"1\":{\"816\":1}}],[\"从请求处理的时效性来看\",{\"1\":{\"1232\":1}}],[\"从架构上来看\",{\"1\":{\"1232\":1}}],[\"从架构图中可以得知\",{\"1\":{\"1007\":1}}],[\"从通信方式来看\",{\"1\":{\"1232\":1}}],[\"从用途来看\",{\"1\":{\"1232\":1}}],[\"从文中可以看出\",{\"1\":{\"1178\":1}}],[\"从发展历史来说\",{\"1\":{\"1161\":1}}],[\"从下图可以更直观地看出\",{\"1\":{\"1348\":1}}],[\"从下图可以看出\",{\"1\":{\"918\":1}}],[\"从下至上分为十层\",{\"1\":{\"1130\":1}}],[\"从开发角度来讲单体应用的代码都集中在一起\",{\"1\":{\"1126\":1}}],[\"从开始位置向后探测清理过期数据\",{\"1\":{\"1037\":1}}],[\"从table的起始位置往后清理\",{\"1\":{\"1038\":1}}],[\"从当前节点staleslot向后查找key值相等的entry元素\",{\"1\":{\"1035\":2}}],[\"从当代互联网发展趋势来说\",{\"1\":{\"816\":1}}],[\"从流程到方法逐一剖析\",{\"1\":{\"1003\":1}}],[\"从reentrantlock的实现看aqs的原理及应用\",{\"0\":{\"999\":1}}],[\"从理论上来说\",{\"1\":{\"895\":1,\"922\":1}}],[\"从输出中可以看出\",{\"1\":{\"882\":1}}],[\"从输出结果来看\",{\"1\":{\"706\":1,\"713\":1}}],[\"从输出结果可以看出\",{\"1\":{\"353\":1,\"599\":1}}],[\"从方法调用直至执行完成的过程\",{\"1\":{\"812\":1}}],[\"从名字可以看出\",{\"1\":{\"794\":1}}],[\"从名字中的mark\",{\"1\":{\"406\":1}}],[\"从链表中删除上次返回的节点\",{\"1\":{\"732\":1}}],[\"从前开始查找\",{\"1\":{\"730\":1}}],[\"从源码可以看出\",{\"1\":{\"710\":2,\"711\":1,\"712\":1}}],[\"从源码中可以发现\",{\"1\":{\"576\":1}}],[\"从源码中可以看到入队操作的逻辑就是在数组中追加一个新元素\",{\"1\":{\"535\":1}}],[\"从源码中不难看出这个构造方法是将外部传入的集合的元素在初始化时直接存放到阻塞队列中\",{\"1\":{\"534\":1}}],[\"从源码中我们可以看出\",{\"1\":{\"534\":1}}],[\"从源码中我们可以看到\",{\"1\":{\"533\":1}}],[\"从源码中我们就能看出当核心线程无法及时处理任务时\",{\"1\":{\"530\":1}}],[\"从性能的角度上\",{\"1\":{\"668\":1}}],[\"从内存中移除\",{\"1\":{\"609\":1}}],[\"从它们的索引中减去\",{\"1\":{\"591\":1}}],[\"从它的名字就可以看出它是一款优秀的垃圾收集器\",{\"1\":{\"406\":1}}],[\"从列表中的指定位置开始\",{\"1\":{\"553\":1}}],[\"从列表中删除上次被返回的元素\",{\"1\":{\"732\":1}}],[\"从列表中删除所有元素\",{\"1\":{\"553\":1}}],[\"从列表中删除指定元素的第一个出现\",{\"1\":{\"553\":1}}],[\"从列表中删除的元素\",{\"1\":{\"553\":1}}],[\"从此列表中删除其中不包含在指定集合中的所有元素\",{\"1\":{\"553\":1}}],[\"从此列表中删除指定集合中包含的所有元素\",{\"1\":{\"553\":1,\"591\":1}}],[\"从此列表中删除所有索引为fromindex\",{\"1\":{\"553\":1}}],[\"从指定的位置开始\",{\"1\":{\"553\":1}}],[\"从其索引中减去一个元素\",{\"1\":{\"553\":1}}],[\"从其名字就能看出来了\",{\"1\":{\"541\":1}}],[\"从第一个到最后一个元素\",{\"1\":{\"553\":2,\"562\":1}}],[\"从队列头部开始遍历\",{\"1\":{\"538\":1}}],[\"从队列中释放节点的疑虑打消了\",{\"1\":{\"1012\":1}}],[\"从队列中获取takeindex位置的元素\",{\"1\":{\"535\":1}}],[\"从队列中取出所有元素\",{\"1\":{\"531\":1}}],[\"从队列中取出元素\",{\"1\":{\"531\":2}}],[\"从队头取出一个元素\",{\"1\":{\"533\":1}}],[\"从类的继承关系我们可以大致得出\",{\"1\":{\"533\":1}}],[\"从类被加载到虚拟机内存中开始\",{\"1\":{\"427\":1}}],[\"从抽象类的特定和语义我们也可以猜出\",{\"1\":{\"533\":1}}],[\"从虚拟机的视角来看\",{\"1\":{\"506\":1}}],[\"从来没有一个叫永久代的东西\",{\"1\":{\"496\":1}}],[\"从垃圾回收的角度\",{\"1\":{\"495\":1}}],[\"从垃圾回收的角度来说\",{\"1\":{\"382\":1}}],[\"从实际案例聊聊\",{\"1\":{\"486\":1}}],[\"从该年龄段开始及大于的年龄对象就要进入老年代\",{\"1\":{\"444\":1}}],[\"从该表中读取一行\",{\"1\":{\"120\":1}}],[\"从局部上来看是基于\",{\"1\":{\"407\":1}}],[\"从整体来看是基于\",{\"1\":{\"407\":1}}],[\"从这两个角度来讲\",{\"1\":{\"1280\":1}}],[\"从这些节点开始向下搜索\",{\"1\":{\"391\":1}}],[\"从这个接口的方法参数你就可以发现其大量使用了\",{\"1\":{\"774\":1,\"901\":1}}],[\"从这个方法的源码可以看出\",{\"1\":{\"730\":1}}],[\"从这个节点往下搜索\",{\"1\":{\"445\":1}}],[\"从这个命令的运行结果\",{\"1\":{\"293\":1}}],[\"从这个项目的\",{\"1\":{\"244\":1}}],[\"从概念上讲\",{\"1\":{\"342\":1}}],[\"从外部加载的\",{\"1\":{\"341\":1}}],[\"从数据库中获取\",{\"1\":{\"307\":1}}],[\"从数据集\",{\"1\":{\"273\":1}}],[\"从缓存中获取数据\",{\"1\":{\"307\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"273\":4,\"298\":1}}],[\"从小到大排序\",{\"1\":{\"194\":2,\"258\":1}}],[\"从大到小排序\",{\"1\":{\"193\":1,\"194\":2,\"258\":1}}],[\"从高到底\",{\"1\":{\"193\":1}}],[\"从低到高\",{\"1\":{\"193\":1}}],[\"从客户端这一视角看\",{\"1\":{\"163\":1,\"292\":1}}],[\"从中读取数据并将数据写入其中\",{\"1\":{\"146\":1}}],[\"从上表中可以看出\",{\"1\":{\"1179\":1}}],[\"从上图可以看到消息发送者\",{\"1\":{\"1222\":1}}],[\"从上图可以看出\",{\"1\":{\"810\":1,\"1012\":1}}],[\"从上图来看\",{\"1\":{\"972\":1}}],[\"从上图我们可以看出\",{\"1\":{\"384\":1}}],[\"从上一个我们可以了解到通过\",{\"1\":{\"706\":1}}],[\"从上到下按照从早到晚的顺序\",{\"1\":{\"141\":1}}],[\"从上面这两段都可以看到\",{\"1\":{\"1018\":1}}],[\"从上面源代码可以看出新创建的\",{\"1\":{\"949\":1,\"953\":1}}],[\"从上面thread类\",{\"1\":{\"883\":1}}],[\"从上面我们可以看出\",{\"1\":{\"851\":1}}],[\"从上面很容易看出\",{\"1\":{\"800\":1}}],[\"从上面的代码可以知道\",{\"1\":{\"1211\":1}}],[\"从上面的内容可以看出\",{\"1\":{\"857\":1}}],[\"从上面的输出内容可以看出\",{\"1\":{\"807\":1}}],[\"从上面的源码可以看出\",{\"1\":{\"588\":1}}],[\"从上面的介绍中我们知道了程序计数器主要有两个作用\",{\"1\":{\"492\":1}}],[\"从上面的介绍中可以看出\",{\"1\":{\"37\":1}}],[\"从上面的介绍可以看出\",{\"1\":{\"351\":1,\"356\":1}}],[\"从上面\",{\"1\":{\"559\":1}}],[\"从上面索引过程我们可以看到\",{\"1\":{\"108\":1}}],[\"从底层存储方式维度划分\",{\"0\":{\"105\":1}}],[\"从左到右升序排列\",{\"1\":{\"100\":1}}],[\"从磁盘随机读一个数据块需要\",{\"1\":{\"98\":1}}],[\"从你输入的\",{\"1\":{\"86\":1}}],[\"从图中我们可以看出\",{\"1\":{\"533\":1,\"1199\":1}}],[\"从图中的委派关系中可以看出\",{\"1\":{\"359\":1}}],[\"从图中不难看出\",{\"1\":{\"83\":1}}],[\"从图中可以看出\",{\"1\":{\"60\":2}}],[\"从\",{\"0\":{\"968\":1,\"1151\":1},\"1\":{\"22\":1,\"76\":1,\"89\":1,\"145\":3,\"146\":1,\"174\":1,\"231\":1,\"283\":1,\"366\":2,\"407\":1,\"425\":1,\"448\":1,\"480\":1,\"495\":1,\"584\":1,\"758\":1,\"788\":1,\"793\":1,\"809\":1,\"883\":1,\"971\":1,\"1003\":1,\"1011\":1,\"1114\":1,\"1169\":1,\"1210\":1,\"1304\":1,\"1343\":1,\"1349\":1,\"1363\":1,\"1380\":1,\"1382\":1}}],[\"从技术角度看\",{\"1\":{\"18\":1,\"19\":1}}],[\"从而\",{\"1\":{\"1379\":1}}],[\"从而产生了\",{\"1\":{\"1371\":1}}],[\"从而可以实现文件高效的读写操作\",{\"1\":{\"1311\":1}}],[\"从而可以有选择性的进行线程通知\",{\"1\":{\"544\":1,\"862\":1}}],[\"从而利用\",{\"1\":{\"1184\":1}}],[\"从而降低熵值\",{\"1\":{\"1087\":1}}],[\"从而能通过逻辑时钟来对分布式系统中的事件的先后顺序进行判断\",{\"1\":{\"974\":1}}],[\"从而保障变量的可见性\",{\"1\":{\"969\":1}}],[\"从而保障指令执行的有序性\",{\"1\":{\"969\":1}}],[\"从而保证了数据的一致性\",{\"1\":{\"89\":1}}],[\"从而保证了锁释放操作的原子性\",{\"1\":{\"47\":1}}],[\"从而增加线程的执行时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"从而缩小线程池的大小\",{\"1\":{\"888\":1}}],[\"从而执行相应的同步调用\",{\"1\":{\"852\":1}}],[\"从而提高\",{\"1\":{\"844\":1,\"993\":1}}],[\"从而提高了\",{\"1\":{\"816\":1}}],[\"从而形成一个依赖关系\",{\"1\":{\"781\":1}}],[\"从而形成一个环形链表\",{\"1\":{\"685\":1}}],[\"从而避免了线程安全问题\",{\"1\":{\"881\":1}}],[\"从而避免\",{\"1\":{\"765\":1}}],[\"从而避免响应超时的问题\",{\"1\":{\"444\":1}}],[\"从而解决多线程并发访问集合时的线程安全问题\",{\"1\":{\"698\":1}}],[\"从而解决内存容量不足的情况\",{\"1\":{\"168\":1}}],[\"从而做相应的处理\",{\"1\":{\"693\":1}}],[\"从而来自定义元素优先级的先后\",{\"1\":{\"669\":1}}],[\"从而成为有界的\",{\"1\":{\"542\":1,\"672\":1}}],[\"从而先搜索到子类中的方法\",{\"1\":{\"519\":1}}],[\"从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了\",{\"1\":{\"492\":1,\"811\":1}}],[\"从而使得方法可以被调用\",{\"1\":{\"343\":1}}],[\"从而减少了从读缓冲区到用户缓冲区的一次\",{\"1\":{\"1310\":1}}],[\"从而减少线程资源的创建和上下文切换\",{\"1\":{\"1055\":1}}],[\"从而减少新生代的垃圾回收频率和成本\",{\"1\":{\"385\":1}}],[\"从而减少内存的使用\",{\"1\":{\"256\":1}}],[\"从而减轻了应用程序的职责\",{\"1\":{\"146\":1}}],[\"从而判断\",{\"1\":{\"234\":1}}],[\"从而导致\",{\"1\":{\"889\":3,\"892\":1,\"897\":1,\"917\":3,\"937\":3,\"938\":1,\"959\":1,\"962\":1}}],[\"从而导致客户端阻塞\",{\"1\":{\"157\":1}}],[\"从而导致索引失效\",{\"1\":{\"118\":1}}],[\"从而实现网站业务的可扩展性设计\",{\"1\":{\"1222\":1}}],[\"从而实现网关必备的各种功能\",{\"1\":{\"4\":1}}],[\"从而实现了线程隔离\",{\"1\":{\"1029\":1}}],[\"从而实现按照访问顺序迭代元素\",{\"1\":{\"717\":1}}],[\"从而实现代码的流程控制\",{\"1\":{\"492\":1,\"811\":1}}],[\"从而实现事务下对数据的隔离级别\",{\"1\":{\"141\":1}}],[\"从而调起支付\",{\"1\":{\"17\":1}}],[\"从而大大加快了执行速度\",{\"1\":{\"6\":1}}],[\"从而让我们能够在\",{\"1\":{\"6\":1}}],[\"从业务指标\",{\"1\":{\"2\":1}}],[\"j++\",{\"1\":{\"766\":1,\"835\":1,\"1038\":1}}],[\"jb51\",{\"1\":{\"612\":1}}],[\"jumps\",{\"1\":{\"633\":1}}],[\"juc原子类概览\",{\"1\":{\"762\":1,\"987\":1}}],[\"juc\",{\"0\":{\"1019\":1},\"1\":{\"529\":1,\"583\":1,\"597\":1,\"695\":1,\"698\":1,\"762\":1,\"793\":1,\"941\":1,\"1019\":1}}],[\"juejin\",{\"1\":{\"415\":1,\"545\":1,\"801\":1,\"913\":1,\"1025\":1,\"1150\":1}}],[\"just\",{\"1\":{\"256\":1,\"302\":1,\"576\":1,\"693\":1}}],[\"josh\",{\"1\":{\"656\":1,\"724\":1}}],[\"join\",{\"1\":{\"412\":1,\"531\":2,\"782\":3,\"909\":1,\"1020\":2,\"1030\":2}}],[\"job\",{\"1\":{\"268\":1}}],[\"jni\",{\"1\":{\"391\":1,\"445\":4,\"499\":1,\"841\":1,\"990\":1}}],[\"j\",{\"1\":{\"377\":1,\"571\":3,\"624\":7,\"696\":1,\"766\":3,\"835\":2,\"1022\":1,\"1038\":7}}],[\"jpg\",{\"1\":{\"1129\":1}}],[\"jprofiler\",{\"1\":{\"377\":2}}],[\"jps\",{\"0\":{\"365\":1},\"1\":{\"364\":1,\"365\":10,\"370\":1,\"377\":1}}],[\"jms\",{\"0\":{\"1225\":1,\"1226\":1,\"1227\":1,\"1231\":1},\"1\":{\"1192\":1,\"1222\":1,\"1226\":6,\"1230\":1,\"1231\":6,\"1245\":1}}],[\"jmm\",{\"0\":{\"831\":1,\"967\":1,\"970\":1,\"971\":2,\"972\":1,\"973\":1,\"976\":1},\"1\":{\"831\":3,\"833\":2,\"967\":2,\"969\":1,\"971\":4,\"972\":4,\"974\":5,\"976\":2,\"981\":1,\"982\":1}}],[\"jmxremote\",{\"1\":{\"373\":3}}],[\"jmx\",{\"1\":{\"372\":1,\"807\":1}}],[\"jmap有不少功能在\",{\"1\":{\"368\":1}}],[\"jmap\",{\"0\":{\"368\":1},\"1\":{\"364\":1,\"368\":3,\"377\":1,\"449\":1}}],[\"jconsole\",{\"0\":{\"372\":1,\"373\":1},\"1\":{\"372\":1,\"373\":3,\"375\":1}}],[\"jclasslib\",{\"1\":{\"325\":2}}],[\"jianshu\",{\"1\":{\"1171\":1,\"1199\":1}}],[\"jit\",{\"1\":{\"366\":2,\"495\":1,\"969\":1}}],[\"jinfo\",{\"0\":{\"367\":1},\"1\":{\"364\":1,\"367\":4,\"377\":1}}],[\"jhat\",{\"0\":{\"369\":1},\"1\":{\"364\":1,\"368\":1,\"369\":1,\"377\":1}}],[\"jeromememory\",{\"1\":{\"720\":1}}],[\"jep\",{\"1\":{\"391\":1}}],[\"jetbrains\",{\"1\":{\"365\":1}}],[\"jetty\",{\"1\":{\"359\":1}}],[\"jemalloc\",{\"1\":{\"218\":8}}],[\"jrockit\",{\"1\":{\"443\":2,\"496\":2}}],[\"jrebel\",{\"1\":{\"1178\":1}}],[\"jre\",{\"0\":{\"516\":1},\"1\":{\"353\":1,\"358\":1,\"516\":1}}],[\"jruby\",{\"1\":{\"324\":1}}],[\"json\",{\"1\":{\"1146\":1,\"1147\":1,\"1159\":3}}],[\"jsr\",{\"1\":{\"971\":1,\"974\":2,\"981\":1,\"982\":2}}],[\"jstack\",{\"0\":{\"370\":1},\"1\":{\"364\":1,\"370\":4,\"376\":1,\"377\":1}}],[\"jstat\",{\"0\":{\"366\":1},\"1\":{\"364\":1,\"366\":14,\"377\":1}}],[\"jsp\",{\"1\":{\"340\":1}}],[\"jsapi\",{\"1\":{\"17\":1}}],[\"jychen7\",{\"1\":{\"274\":1}}],[\"jan\",{\"1\":{\"1327\":2,\"1329\":2,\"1330\":2}}],[\"jack\",{\"1\":{\"630\":1}}],[\"jar是\",{\"1\":{\"353\":1}}],[\"jar等\",{\"1\":{\"353\":1}}],[\"jar\",{\"1\":{\"340\":1,\"353\":6,\"359\":1,\"365\":2,\"432\":3,\"433\":2}}],[\"jay\",{\"1\":{\"125\":2}}],[\"javaee\",{\"1\":{\"1226\":1}}],[\"java21\",{\"1\":{\"1062\":1}}],[\"java5\",{\"1\":{\"934\":1,\"971\":1}}],[\"java6\",{\"1\":{\"854\":1}}],[\"java并发常见面试题总结\",{\"0\":{\"804\":1,\"830\":1,\"879\":1}}],[\"java并发\",{\"2\":{\"760\":1,\"771\":1,\"790\":1,\"803\":1,\"829\":1,\"878\":1,\"915\":1,\"931\":1,\"966\":1,\"984\":1,\"998\":1,\"1024\":1,\"1050\":1,\"1064\":1}}],[\"java7\",{\"1\":{\"575\":1,\"578\":1,\"579\":2,\"688\":1,\"690\":1}}],[\"javadoop\",{\"1\":{\"575\":1,\"801\":1}}],[\"java8\",{\"1\":{\"575\":2,\"578\":1,\"579\":1,\"630\":1,\"631\":1,\"634\":1,\"688\":1,\"691\":1,\"744\":1,\"774\":1,\"882\":2,\"901\":1,\"909\":1,\"1062\":1}}],[\"java8之后可以\",{\"1\":{\"520\":1}}],[\"java集合常见面试题总结\",{\"0\":{\"637\":1,\"675\":1}}],[\"java集合使用注意事项总结\",{\"0\":{\"628\":1}}],[\"java集合\",{\"2\":{\"547\":1,\"566\":1,\"581\":1,\"595\":1,\"614\":1,\"627\":1,\"636\":1,\"674\":1,\"700\":1,\"722\":1,\"735\":1,\"738\":1}}],[\"java异常体系\",{\"0\":{\"524\":1}}],[\"javabean\",{\"1\":{\"523\":1}}],[\"java反射\",{\"1\":{\"523\":1}}],[\"java的泛型是伪泛型\",{\"1\":{\"522\":1}}],[\"java是单继承\",{\"1\":{\"517\":2}}],[\"java有jvm⾃动内存管理垃圾回收机制\",{\"1\":{\"517\":1}}],[\"java源码的编译器javac\",{\"1\":{\"516\":1}}],[\"java没有指针\",{\"1\":{\"515\":1}}],[\"java存储分配模型是防御恶意代码的主要方法之一\",{\"1\":{\"515\":1}}],[\"java特点\",{\"0\":{\"515\":1}}],[\"java内存区域详解\",{\"0\":{\"489\":1}}],[\"java11\",{\"1\":{\"408\":1}}],[\"javac\",{\"1\":{\"351\":1,\"851\":1}}],[\"java文件\",{\"1\":{\"351\":1}}],[\"javas\",{\"1\":{\"511\":1}}],[\"javase\",{\"1\":{\"334\":1,\"345\":1,\"360\":1,\"386\":1,\"409\":1,\"511\":1,\"876\":1}}],[\"javascript\",{\"1\":{\"7\":1,\"1237\":1,\"1246\":1}}],[\"javap\",{\"1\":{\"327\":1,\"328\":1,\"851\":1}}],[\"java9\",{\"1\":{\"327\":1,\"446\":1,\"634\":1}}],[\"javaguide的\",{\"1\":{\"1192\":1}}],[\"javaguide3\",{\"1\":{\"280\":2}}],[\"javaguide2\",{\"1\":{\"280\":2}}],[\"javaguide1\",{\"1\":{\"280\":1}}],[\"javaguide\",{\"1\":{\"35\":1,\"280\":6,\"284\":1,\"412\":1,\"475\":1,\"835\":1,\"841\":1,\"990\":1,\"1200\":2,\"1244\":1}}],[\"java\",{\"0\":{\"365\":1,\"372\":1,\"374\":1,\"418\":1,\"493\":1,\"517\":1,\"639\":1,\"791\":1,\"808\":1,\"831\":1,\"916\":1,\"932\":1,\"967\":1,\"970\":1,\"973\":1,\"1332\":1},\"1\":{\"4\":1,\"8\":1,\"10\":1,\"13\":1,\"47\":1,\"49\":2,\"50\":1,\"53\":1,\"55\":1,\"56\":1,\"60\":1,\"65\":1,\"150\":1,\"153\":1,\"180\":1,\"188\":1,\"192\":1,\"194\":1,\"195\":2,\"258\":1,\"259\":1,\"307\":1,\"324\":9,\"325\":1,\"326\":2,\"327\":4,\"328\":1,\"330\":6,\"333\":1,\"334\":4,\"339\":1,\"340\":1,\"341\":6,\"342\":4,\"343\":2,\"344\":2,\"345\":3,\"351\":9,\"353\":16,\"354\":1,\"357\":2,\"358\":3,\"359\":4,\"360\":8,\"364\":6,\"365\":1,\"368\":3,\"370\":15,\"372\":1,\"373\":1,\"374\":1,\"377\":7,\"380\":1,\"382\":5,\"386\":2,\"387\":3,\"388\":1,\"391\":3,\"392\":6,\"393\":1,\"394\":2,\"399\":1,\"400\":1,\"403\":4,\"407\":2,\"408\":2,\"409\":1,\"412\":1,\"417\":1,\"418\":2,\"422\":1,\"424\":1,\"425\":1,\"428\":1,\"429\":1,\"433\":2,\"438\":1,\"439\":1,\"441\":1,\"445\":6,\"446\":3,\"450\":2,\"451\":5,\"455\":3,\"472\":1,\"477\":2,\"480\":2,\"484\":1,\"485\":3,\"486\":2,\"489\":3,\"490\":3,\"491\":5,\"493\":6,\"494\":2,\"495\":9,\"496\":5,\"497\":1,\"498\":3,\"499\":4,\"500\":1,\"501\":1,\"503\":5,\"504\":1,\"506\":1,\"508\":1,\"509\":1,\"511\":4,\"516\":2,\"517\":2,\"524\":2,\"529\":4,\"542\":1,\"543\":1,\"545\":1,\"549\":3,\"551\":2,\"553\":1,\"558\":3,\"569\":2,\"570\":1,\"583\":2,\"593\":4,\"597\":1,\"598\":7,\"612\":2,\"616\":1,\"625\":4,\"628\":1,\"629\":2,\"630\":4,\"631\":2,\"632\":1,\"633\":1,\"634\":7,\"639\":3,\"647\":5,\"651\":1,\"652\":2,\"661\":2,\"671\":1,\"672\":1,\"680\":2,\"685\":1,\"691\":4,\"702\":1,\"715\":1,\"719\":1,\"724\":1,\"727\":1,\"736\":1,\"740\":2,\"742\":1,\"758\":1,\"762\":1,\"763\":1,\"766\":1,\"767\":3,\"768\":2,\"769\":1,\"772\":2,\"773\":3,\"774\":1,\"788\":1,\"791\":1,\"793\":1,\"794\":1,\"799\":1,\"800\":1,\"801\":2,\"806\":1,\"807\":4,\"808\":9,\"810\":2,\"811\":1,\"812\":4,\"816\":3,\"820\":7,\"827\":1,\"831\":2,\"833\":4,\"834\":2,\"835\":1,\"837\":1,\"838\":1,\"841\":2,\"847\":4,\"851\":2,\"853\":1,\"857\":1,\"865\":1,\"868\":1,\"871\":1,\"876\":10,\"882\":3,\"884\":1,\"887\":1,\"889\":2,\"890\":1,\"894\":3,\"896\":1,\"899\":3,\"901\":1,\"903\":2,\"912\":1,\"913\":5,\"920\":3,\"923\":1,\"929\":1,\"933\":1,\"934\":1,\"936\":1,\"937\":1,\"940\":6,\"943\":4,\"944\":4,\"950\":1,\"954\":1,\"958\":1,\"962\":1,\"963\":1,\"964\":4,\"967\":2,\"969\":1,\"971\":8,\"972\":6,\"973\":5,\"974\":2,\"976\":1,\"978\":1,\"979\":1,\"980\":1,\"981\":3,\"982\":8,\"986\":1,\"987\":1,\"990\":2,\"996\":2,\"999\":1,\"1002\":3,\"1006\":1,\"1008\":3,\"1011\":5,\"1012\":5,\"1013\":2,\"1014\":6,\"1015\":4,\"1018\":3,\"1022\":3,\"1030\":4,\"1036\":2,\"1041\":1,\"1051\":1,\"1053\":3,\"1056\":1,\"1057\":1,\"1062\":1,\"1123\":2,\"1131\":4,\"1132\":1,\"1147\":1,\"1166\":2,\"1168\":1,\"1171\":1,\"1172\":2,\"1178\":2,\"1185\":1,\"1191\":1,\"1226\":7,\"1231\":2,\"1237\":1,\"1238\":1,\"1240\":2,\"1245\":1,\"1246\":1,\"1252\":3,\"1276\":1,\"1292\":2,\"1310\":1,\"1311\":1,\"1319\":1,\"1331\":1,\"1332\":1,\"1335\":1,\"1337\":1},\"2\":{\"335\":1,\"346\":1,\"361\":1,\"378\":1,\"410\":1,\"413\":1,\"473\":1,\"487\":1,\"512\":1,\"525\":1,\"526\":1,\"546\":1,\"565\":1,\"580\":1,\"594\":1,\"613\":1,\"626\":1,\"635\":1,\"673\":1,\"699\":1,\"721\":1,\"734\":1,\"737\":1,\"759\":1,\"770\":1,\"789\":1,\"802\":1,\"828\":1,\"877\":1,\"914\":1,\"930\":1,\"965\":1,\"983\":1,\"997\":1,\"1023\":1,\"1049\":1,\"1063\":1}}],[\"jdk6\",{\"1\":{\"555\":1}}],[\"jdk包含jre\",{\"1\":{\"516\":1}}],[\"jdk5\",{\"1\":{\"449\":1,\"458\":1}}],[\"jdk20\",{\"1\":{\"400\":1}}],[\"jdk9\",{\"1\":{\"391\":1,\"407\":1,\"448\":1}}],[\"jdk监控和故障处理工具总结\",{\"0\":{\"363\":1}}],[\"jdk8\",{\"1\":{\"344\":1,\"386\":1,\"448\":2,\"496\":1,\"555\":1}}],[\"jdk11\",{\"1\":{\"557\":1}}],[\"jdk1\",{\"0\":{\"618\":1,\"619\":1,\"682\":1,\"683\":1,\"690\":1,\"691\":1,\"854\":1},\"1\":{\"184\":1,\"366\":2,\"384\":1,\"392\":2,\"393\":4,\"403\":2,\"404\":1,\"407\":1,\"480\":1,\"491\":2,\"496\":1,\"498\":4,\"499\":1,\"529\":5,\"544\":1,\"552\":2,\"553\":1,\"583\":2,\"586\":1,\"600\":1,\"616\":2,\"618\":4,\"619\":2,\"622\":1,\"634\":1,\"642\":2,\"645\":2,\"656\":2,\"668\":2,\"669\":1,\"677\":1,\"680\":2,\"682\":4,\"683\":3,\"685\":2,\"686\":2,\"688\":10,\"692\":2,\"694\":1,\"720\":1,\"727\":1,\"792\":4,\"793\":2,\"810\":2,\"854\":1,\"861\":1,\"862\":1,\"972\":1}}],[\"jdk\",{\"0\":{\"364\":1,\"371\":1,\"516\":1,\"692\":2},\"1\":{\"37\":2,\"60\":1,\"327\":2,\"342\":2,\"345\":2,\"351\":1,\"353\":2,\"356\":1,\"364\":1,\"372\":1,\"377\":1,\"382\":3,\"388\":2,\"400\":3,\"412\":1,\"433\":1,\"475\":1,\"480\":2,\"491\":5,\"495\":4,\"496\":4,\"498\":1,\"516\":1,\"523\":1,\"529\":1,\"612\":1,\"618\":4,\"634\":1,\"682\":4,\"686\":3,\"692\":4,\"731\":1,\"767\":2,\"791\":2,\"800\":2,\"808\":3,\"843\":1,\"845\":1,\"847\":1,\"851\":1,\"860\":1,\"861\":1,\"864\":1,\"871\":1,\"881\":1,\"895\":1,\"922\":1,\"929\":1,\"992\":1,\"994\":1,\"1043\":1,\"1052\":1,\"1062\":1,\"1132\":1,\"1146\":1,\"1147\":1,\"1179\":3}}],[\"jdbc\",{\"1\":{\"29\":1,\"359\":1}}],[\"jvm线上问题排查和性能调优案例\",{\"0\":{\"412\":1}}],[\"jvm垃圾回收详解\",{\"0\":{\"380\":1}}],[\"jvms\",{\"1\":{\"334\":2,\"345\":3,\"409\":1,\"511\":2}}],[\"jvm\",{\"0\":{\"415\":1,\"417\":1,\"449\":1,\"450\":1,\"457\":1,\"460\":1,\"861\":1},\"1\":{\"2\":1,\"60\":5,\"63\":2,\"299\":1,\"324\":1,\"340\":1,\"341\":3,\"344\":5,\"345\":2,\"351\":4,\"352\":1,\"353\":3,\"357\":2,\"358\":1,\"364\":3,\"365\":2,\"366\":1,\"367\":4,\"377\":1,\"380\":1,\"392\":1,\"393\":1,\"409\":1,\"412\":6,\"417\":2,\"418\":1,\"419\":2,\"424\":2,\"425\":6,\"429\":1,\"430\":1,\"441\":1,\"443\":3,\"444\":1,\"447\":1,\"449\":4,\"450\":2,\"451\":3,\"456\":1,\"475\":1,\"476\":1,\"478\":1,\"480\":2,\"482\":1,\"484\":3,\"485\":3,\"486\":7,\"489\":1,\"493\":1,\"495\":1,\"496\":2,\"498\":2,\"503\":1,\"511\":4,\"516\":1,\"522\":2,\"544\":1,\"633\":1,\"765\":1,\"767\":2,\"806\":1,\"807\":1,\"808\":3,\"809\":1,\"810\":1,\"820\":2,\"833\":1,\"834\":2,\"844\":1,\"848\":1,\"850\":1,\"852\":3,\"861\":1,\"862\":1,\"868\":1,\"969\":1,\"973\":2,\"975\":1,\"979\":1,\"993\":1,\"1052\":1,\"1053\":2,\"1178\":1},\"2\":{\"336\":1,\"347\":1,\"362\":1,\"379\":1,\"411\":1,\"414\":1,\"474\":1,\"488\":1,\"513\":1}}],[\"开玩笑地说\",{\"1\":{\"1343\":1}}],[\"开始计数\",{\"1\":{\"1382\":1}}],[\"开始计数的\",{\"1\":{\"328\":1}}],[\"开始之前\",{\"1\":{\"1332\":1}}],[\"开始读取数据\",{\"1\":{\"1308\":1}}],[\"开始掌权时\",{\"1\":{\"1112\":1}}],[\"开始自旋\",{\"1\":{\"1012\":1}}],[\"开始使用新的内存模型\",{\"1\":{\"971\":1}}],[\"开始遍历\",{\"1\":{\"713\":1}}],[\"开始的\",{\"1\":{\"708\":1}}],[\"开始的第一位是一个\",{\"1\":{\"328\":1}}],[\"开始进行元素获取的逻辑\",{\"1\":{\"604\":1}}],[\"开始已经默认开启逃逸分析\",{\"1\":{\"495\":1}}],[\"开始介绍类加载器和双亲委派模型之前\",{\"1\":{\"349\":1}}],[\"开始引入的\",{\"1\":{\"289\":1,\"294\":1}}],[\"开始执行时被创建\",{\"1\":{\"231\":1}}],[\"开始\",{\"1\":{\"174\":1,\"231\":1,\"366\":2,\"407\":1,\"448\":1,\"480\":1,\"535\":1,\"631\":1,\"788\":1,\"845\":1,\"971\":1,\"994\":1}}],[\"开始事务\",{\"1\":{\"127\":2,\"128\":2,\"129\":2,\"280\":1}}],[\"开始一个个回表\",{\"1\":{\"117\":1}}],[\"开始支持\",{\"1\":{\"35\":1,\"235\":1}}],[\"开源的一个分布式流式处理平台\",{\"1\":{\"1235\":1}}],[\"开源的一个高性能\",{\"1\":{\"1170\":1}}],[\"开源的跨语言的\",{\"1\":{\"1171\":1}}],[\"开源的分布式\",{\"1\":{\"38\":1}}],[\"开源版几乎已经没有被维护更新了\",{\"1\":{\"244\":1}}],[\"开源框架\",{\"0\":{\"39\":1}}],[\"开启线程\",{\"1\":{\"1062\":1}}],[\"开启日志文件分割\",{\"1\":{\"483\":1}}],[\"开启用户线程\",{\"1\":{\"406\":1}}],[\"开启或者关闭对应名称的参数\",{\"1\":{\"367\":1}}],[\"开启多线程后\",{\"1\":{\"267\":1}}],[\"开启\",{\"1\":{\"35\":1,\"161\":1,\"229\":1,\"233\":1,\"235\":1,\"289\":1,\"294\":1}}],[\"开发人员可以向这个节点中写入数据\",{\"1\":{\"1348\":1}}],[\"开发门槛低\",{\"1\":{\"1285\":1}}],[\"开发\",{\"1\":{\"1178\":1,\"1238\":1,\"1240\":3,\"1367\":1}}],[\"开发手册\",{\"1\":{\"628\":1,\"629\":1,\"630\":1,\"631\":1,\"632\":1,\"633\":1,\"634\":1,\"889\":2,\"937\":1}}],[\"开发通用框架\",{\"1\":{\"523\":1}}],[\"开发过程中\",{\"1\":{\"451\":1}}],[\"开发规范\",{\"1\":{\"319\":1}}],[\"开发者在代码中手动提交\",{\"1\":{\"1207\":1}}],[\"开发者说\",{\"1\":{\"971\":1}}],[\"开发者可以利用这些规范更方便地开发多线程程序\",{\"1\":{\"971\":1}}],[\"开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中\",{\"1\":{\"281\":1}}],[\"开发者们觉得没必要支持回滚\",{\"1\":{\"281\":1}}],[\"开发者除了能够使用\",{\"1\":{\"8\":1}}],[\"开发与运维\",{\"1\":{\"274\":1,\"320\":1}}],[\"开发与运维笔记\",{\"1\":{\"171\":1}}],[\"开发和测试最多的两个操作系统\",{\"1\":{\"242\":1}}],[\"开发的系统\",{\"1\":{\"1178\":1}}],[\"开发的小伙伴来说\",{\"1\":{\"49\":1}}],[\"开发的一款提供动态路由\",{\"1\":{\"4\":1}}],[\"开发插件\",{\"1\":{\"8\":1}}],[\"开放平台等特定客户端提供统一服务\",{\"1\":{\"2\":1}}],[\"是节点名称后自动添加一个由\",{\"1\":{\"1382\":1}}],[\"是会根据\",{\"1\":{\"1379\":1}}],[\"是目前公认的解决分布式一致性问题最有效的算法之一\",{\"1\":{\"1372\":1}}],[\"是目的\",{\"1\":{\"125\":1}}],[\"是因为这个时候我们肯定保证了在第一阶段所有的协调者全部返回了可以执行事务的响应\",{\"1\":{\"1371\":1}}],[\"是因为其内部复杂的实现\",{\"1\":{\"794\":1}}],[\"是高性能的\",{\"1\":{\"1362\":1}}],[\"是你使用\",{\"1\":{\"1349\":1}}],[\"是协调服务的典型场景\",{\"1\":{\"1344\":1,\"1362\":1}}],[\"是将书本放入指定的分类区域的\",{\"1\":{\"1315\":1}}],[\"是将每条请求共享资源的线程封装成一个\",{\"1\":{\"904\":1}}],[\"是个完美的方案\",{\"1\":{\"1314\":1}}],[\"是分布在不同\",{\"1\":{\"1314\":1}}],[\"是分布式和微服务系统中重要的组件之一\",{\"1\":{\"1218\":1}}],[\"是分布式系统设计理论\",{\"1\":{\"1079\":1}}],[\"是分布式系统下的\",{\"1\":{\"29\":1}}],[\"是分布式缓存最开始兴起的那会\",{\"1\":{\"244\":1}}],[\"是需要保证高可用的\",{\"1\":{\"1281\":1}}],[\"是下游的事情\",{\"1\":{\"1272\":1}}],[\"是下一代云原生分布式消息流平台\",{\"1\":{\"1238\":2,\"1240\":1}}],[\"是比较有代表性的\",{\"1\":{\"1263\":1}}],[\"是生产者\",{\"1\":{\"1260\":1}}],[\"是业内标准的\",{\"1\":{\"1240\":1}}],[\"是采用\",{\"1\":{\"1237\":1}}],[\"是阿里开源的一款云原生\",{\"1\":{\"1236\":1}}],[\"是双向直接网络通讯\",{\"1\":{\"1232\":2}}],[\"是双端队列\",{\"1\":{\"667\":1}}],[\"是应用层协议的一个开放标准\",{\"1\":{\"1230\":1}}],[\"是消息中间件中的一种特殊队列\",{\"1\":{\"1213\":1}}],[\"是真正保存消息的地方\",{\"1\":{\"1202\":1}}],[\"是蚂蚁金服开源的分布式应用链路追踪工具\",{\"1\":{\"1181\":1}}],[\"是我的知识星球的一个内部小册\",{\"1\":{\"1173\":1}}],[\"是我们自定义的类\",{\"1\":{\"433\":1}}],[\"是我们平时使用比较多的一个缓存读写模式\",{\"1\":{\"145\":1}}],[\"是新浪微博开源的一款\",{\"1\":{\"1169\":1}}],[\"是能收发数据\",{\"1\":{\"1161\":1}}],[\"是能回到零态的\",{\"1\":{\"904\":1}}],[\"是传输层的协议\",{\"1\":{\"1154\":1}}],[\"是被动的\",{\"1\":{\"1108\":1}}],[\"是数据库事务完整性的理论\",{\"1\":{\"1079\":1}}],[\"是数据的保存形式\",{\"1\":{\"174\":1}}],[\"是对\",{\"1\":{\"1074\":1}}],[\"是对对象的每个字段单独存储\",{\"1\":{\"255\":1}}],[\"是前提\",{\"1\":{\"1068\":1}}],[\"是弱引用\",{\"1\":{\"1026\":1}}],[\"是获取锁失败的情况下才会执行\",{\"1\":{\"1013\":1}}],[\"是获取锁逻辑\",{\"1\":{\"1007\":1}}],[\"是公平锁加锁时判断等待队列中是否存在有效节点的方法\",{\"1\":{\"1011\":1}}],[\"是公共且抽象的\",{\"1\":{\"498\":1}}],[\"是抽象方法\",{\"1\":{\"1007\":1}}],[\"是抽象方法的集合\",{\"1\":{\"520\":1}}],[\"是独占锁\",{\"1\":{\"1007\":1}}],[\"是允许编译器和处理器执行这种重排序的\",{\"1\":{\"974\":1}}],[\"是允许的\",{\"1\":{\"848\":1}}],[\"是通过数组实现的\",{\"1\":{\"1184\":1}}],[\"是通过框架来完成的\",{\"1\":{\"1014\":1}}],[\"是通过公平锁和非公平锁内部类实现的\",{\"1\":{\"1007\":1}}],[\"是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配\",{\"1\":{\"1004\":1}}],[\"是通过\",{\"1\":{\"961\":1,\"1389\":1}}],[\"是只有一个线程的线程池\",{\"1\":{\"953\":1}}],[\"是为每个线程池都定义一个还是说定义一个公共的线程池呢\",{\"1\":{\"919\":1}}],[\"是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题\",{\"1\":{\"968\":1}}],[\"是为了节省空间\",{\"1\":{\"633\":1}}],[\"是为了寻找这样一个节点\",{\"1\":{\"572\":1}}],[\"是为了实现公共类库\",{\"1\":{\"359\":1}}],[\"是强引用\",{\"1\":{\"884\":1}}],[\"是依赖于\",{\"1\":{\"861\":1}}],[\"是依赖于底层的操作系统的\",{\"1\":{\"847\":1}}],[\"是随机或者按照其他优先级排序的\",{\"1\":{\"858\":1}}],[\"是原子性的\",{\"1\":{\"835\":1}}],[\"是让当前线程暂停执行\",{\"1\":{\"826\":1}}],[\"是让获得对象锁的线程实现等待\",{\"1\":{\"826\":1}}],[\"是程序执行的最小单位\",{\"1\":{\"816\":1}}],[\"是系统运行程序的基本单位\",{\"1\":{\"806\":1}}],[\"是系统自动在内部新建一个数组\",{\"1\":{\"563\":1}}],[\"是返回结果值的类型\",{\"1\":{\"778\":1}}],[\"是共享锁的一种实现\",{\"1\":{\"748\":1,\"752\":1,\"906\":1,\"908\":1}}],[\"是尾节点\",{\"1\":{\"731\":1}}],[\"是头节点\",{\"1\":{\"731\":1}}],[\"是null\",{\"1\":{\"729\":1}}],[\"是按照双向链表的路径进行遍历的\",{\"1\":{\"713\":1}}],[\"是继承自\",{\"1\":{\"692\":1}}],[\"是在什么时间释放节点通知到被挂起的线程呢\",{\"1\":{\"1012\":1}}],[\"是在第二个节点开始的\",{\"1\":{\"1011\":1}}],[\"是在\",{\"1\":{\"668\":1,\"669\":1,\"708\":2}}],[\"是在编译过程中出现的错误\",{\"1\":{\"524\":1}}],[\"是单向链表\",{\"1\":{\"1004\":1}}],[\"是单端队列\",{\"1\":{\"667\":1}}],[\"是单线程模型\",{\"1\":{\"265\":1,\"266\":1,\"268\":1}}],[\"是单线程方式运行的\",{\"1\":{\"265\":1}}],[\"是泛型方法\",{\"1\":{\"634\":1}}],[\"是的话就返回\",{\"1\":{\"752\":1}}],[\"是的\",{\"1\":{\"621\":1}}],[\"是官方给出的一个比较好的临界值\",{\"1\":{\"619\":1}}],[\"是非常耗时的\",{\"1\":{\"624\":1}}],[\"是非线程安全的\",{\"1\":{\"616\":1,\"669\":1,\"677\":1}}],[\"是非原子操作\",{\"1\":{\"287\":2}}],[\"是常用的\",{\"1\":{\"616\":1}}],[\"是线程安全的\",{\"1\":{\"597\":1,\"677\":1,\"694\":1}}],[\"是链表\",{\"1\":{\"578\":1}}],[\"是相同的\",{\"1\":{\"571\":1}}],[\"是什么玩意\",{\"1\":{\"1380\":1}}],[\"是什么\",{\"0\":{\"541\":1,\"847\":1,\"857\":1,\"865\":1,\"871\":1,\"903\":1,\"1165\":1,\"1178\":1,\"1190\":1,\"1226\":1,\"1230\":1,\"1245\":1,\"1253\":1,\"1276\":1}}],[\"是何时进入字符串常量池的\",{\"1\":{\"511\":1}}],[\"是乐观锁的一种实现方式\",{\"1\":{\"503\":1}}],[\"是私有且具体的\",{\"1\":{\"498\":1}}],[\"是与具体某种虚拟机实现相关的物理概念\",{\"1\":{\"498\":1}}],[\"是时候忘掉\",{\"1\":{\"391\":1}}],[\"是有三个特点\",{\"1\":{\"1152\":1}}],[\"是有界队列\",{\"1\":{\"529\":1,\"542\":1,\"543\":1,\"672\":1,\"799\":1}}],[\"是有风险的\",{\"1\":{\"388\":1}}],[\"是有序递增的\",{\"1\":{\"35\":2}}],[\"是到目前为止随\",{\"1\":{\"377\":1}}],[\"是无法知道文件的具体的数据的\",{\"1\":{\"1311\":1}}],[\"是无法保证这三个操作是具有原子性的\",{\"1\":{\"835\":1}}],[\"是无法找到\",{\"1\":{\"359\":1}}],[\"是无序的\",{\"1\":{\"640\":2}}],[\"是无界的\",{\"1\":{\"543\":1,\"897\":1}}],[\"是无界队列\",{\"1\":{\"543\":1}}],[\"是无顺序的\",{\"1\":{\"37\":1}}],[\"是extclassloader\",{\"1\":{\"353\":1}}],[\"是appclassloader\",{\"1\":{\"353\":1}}],[\"是由若干条指令组成的\",{\"1\":{\"1344\":1}}],[\"是由业务逻辑主动调用接口获取消息\",{\"1\":{\"1293\":1}}],[\"是由阿里开源\",{\"1\":{\"1122\":1,\"1168\":1}}],[\"是由第三方供应商提供的\",{\"1\":{\"359\":1}}],[\"是由启动类加载器加载之外\",{\"1\":{\"353\":1}}],[\"是由\",{\"1\":{\"351\":1,\"359\":1,\"688\":1,\"690\":1,\"1006\":1}}],[\"是由客户端自己负责把数据写入\",{\"1\":{\"146\":1}}],[\"是类似于一个\",{\"1\":{\"579\":1}}],[\"是类加载的最后一步\",{\"1\":{\"344\":1}}],[\"是类还是接口\",{\"1\":{\"329\":1}}],[\"是各个线程共享的内存区域\",{\"1\":{\"341\":1,\"496\":1}}],[\"是交叉进行的\",{\"1\":{\"340\":1}}],[\"是可见的\",{\"1\":{\"974\":1}}],[\"是可以设置过期时间的\",{\"1\":{\"1264\":1}}],[\"是可以应用到状态机的操作\",{\"1\":{\"1110\":1}}],[\"是可以复用的\",{\"1\":{\"442\":1}}],[\"是可以追加写入的\",{\"1\":{\"89\":1}}],[\"是可控性最强的阶段\",{\"1\":{\"340\":1}}],[\"是实现基于产品应用程序的一种自然模式\",{\"1\":{\"1132\":1}}],[\"是实现可重入锁的关键\",{\"1\":{\"56\":1}}],[\"是实例变量还是类变量\",{\"1\":{\"331\":1}}],[\"是怎么写的\",{\"1\":{\"1008\":1}}],[\"是怎么产生的\",{\"0\":{\"292\":1}}],[\"是怎么对这批\",{\"1\":{\"272\":1}}],[\"是不分书的种类直接成批的塞上去的\",{\"1\":{\"1315\":1}}],[\"是不支持自动主从切换的\",{\"1\":{\"1314\":1}}],[\"是不支持回滚操作\",{\"1\":{\"287\":1}}],[\"是不能直接拿来用的\",{\"1\":{\"1152\":1}}],[\"是不需要进行特别的注意的\",{\"1\":{\"972\":1}}],[\"是不是也需要\",{\"1\":{\"1379\":1}}],[\"是不是有一点复杂\",{\"1\":{\"1315\":1}}],[\"是不是要搞集群\",{\"1\":{\"1275\":1}}],[\"是不是\",{\"1\":{\"1275\":1}}],[\"是不是很简单\",{\"1\":{\"1388\":1}}],[\"是不是很大程度上提高了系统性能呢\",{\"1\":{\"1126\":1}}],[\"是不是很像\",{\"1\":{\"621\":1}}],[\"是不是链表尾部位置\",{\"1\":{\"729\":1}}],[\"是不同的\",{\"1\":{\"449\":1}}],[\"是不存在于\",{\"1\":{\"443\":1}}],[\"是不认识文本文件的\",{\"1\":{\"418\":1}}],[\"是不合理的\",{\"1\":{\"306\":1}}],[\"是不可见的\",{\"1\":{\"141\":1}}],[\"是如何进行初始化选举的\",{\"1\":{\"1380\":1}}],[\"是如何设计它的存储结构了\",{\"1\":{\"1315\":1}}],[\"是如何通过公平锁和非公平锁与\",{\"1\":{\"1002\":1}}],[\"是如何抽象线程和主内存之间的关系\",{\"0\":{\"972\":1}}],[\"是如何分片的\",{\"1\":{\"318\":1}}],[\"是如何实现故障转移的\",{\"1\":{\"318\":1}}],[\"是如何判断数据是否过期的呢\",{\"0\":{\"271\":1}}],[\"是如何应用它的\",{\"1\":{\"205\":1}}],[\"是没办法避免的\",{\"1\":{\"897\":1}}],[\"是没办法满足需求的\",{\"1\":{\"257\":1}}],[\"是没有队列对应的\",{\"1\":{\"1280\":1}}],[\"是没有变化的\",{\"1\":{\"451\":1}}],[\"是没有永久代的\",{\"1\":{\"443\":1}}],[\"是没有\",{\"1\":{\"89\":1}}],[\"是基于主题\",{\"1\":{\"1315\":1}}],[\"是基于一系列优化策略的综合作用\",{\"1\":{\"1184\":1}}],[\"是基于可变长的数组和双指针来实现\",{\"1\":{\"668\":1}}],[\"是基于单线程实现的\",{\"1\":{\"611\":1}}],[\"是基于优先级队列和堆排序算法实现的\",{\"1\":{\"611\":1}}],[\"是基于\",{\"1\":{\"256\":1,\"372\":1,\"742\":1,\"755\":1,\"851\":1,\"910\":1,\"1073\":1}}],[\"是基于堆栈的虚拟机的二进制指令格式\",{\"1\":{\"8\":1}}],[\"是多线程\",{\"1\":{\"245\":1}}],[\"是安全的\",{\"1\":{\"176\":1}}],[\"是用于标记一些特殊信息\",{\"1\":{\"1159\":1}}],[\"是用于存放类似于元数据信息方面的数据的\",{\"1\":{\"420\":1}}],[\"是用\",{\"1\":{\"176\":1,\"904\":1}}],[\"是用来实现事务的持久性\",{\"1\":{\"135\":1}}],[\"是典型的\",{\"1\":{\"169\":1}}],[\"是同步更新\",{\"1\":{\"147\":1}}],[\"是已经提交了的数据\",{\"1\":{\"141\":1}}],[\"是rdbms常用的一种并发控制方法\",{\"1\":{\"141\":1}}],[\"是手段\",{\"1\":{\"125\":1}}],[\"是必须满足4个条件\",{\"1\":{\"125\":1}}],[\"是判断sql执行性能比较关键的一个字段\",{\"1\":{\"120\":2}}],[\"是最早尝试提供内存模型的语言\",{\"1\":{\"981\":1}}],[\"是最早尝试提供内存模型的编程语言\",{\"1\":{\"971\":1}}],[\"是最小的存储单位\",{\"1\":{\"109\":1}}],[\"是最好的\",{\"1\":{\"8\":1}}],[\"是存储引擎用于快速查找记录的一种数据结构\",{\"1\":{\"94\":1}}],[\"是两个独立的逻辑\",{\"1\":{\"89\":1}}],[\"是主键\",{\"1\":{\"89\":1}}],[\"是指使用字节流传输数据\",{\"1\":{\"1151\":1}}],[\"是指一个操作是不可中断的\",{\"1\":{\"762\":1}}],[\"是指在运行状态中\",{\"1\":{\"523\":1}}],[\"是指在一个事务内\",{\"1\":{\"128\":1}}],[\"是指\",{\"1\":{\"89\":1,\"524\":1}}],[\"是循环写的\",{\"1\":{\"89\":1}}],[\"是逻辑日志\",{\"1\":{\"89\":1}}],[\"是物理日志\",{\"1\":{\"89\":1}}],[\"是另一个公司以插件形式引入\",{\"1\":{\"89\":1}}],[\"是否挂了等等\",{\"1\":{\"1387\":1}}],[\"是否同意更新\",{\"1\":{\"1379\":1}}],[\"是否在线\",{\"1\":{\"1344\":1}}],[\"是否需要进攻就由大将军\",{\"1\":{\"1105\":1}}],[\"是否需要移除链表首元素\",{\"1\":{\"706\":1}}],[\"是否被其它线程修改了\",{\"1\":{\"838\":1,\"987\":1}}],[\"是否是消费者出现了大量的消费错误\",{\"1\":{\"1305\":1}}],[\"是否是\",{\"1\":{\"814\":1}}],[\"是否是一个树节点\",{\"1\":{\"622\":1}}],[\"是否大于\",{\"1\":{\"749\":1}}],[\"是否\",{\"1\":{\"658\":1}}],[\"是否相同\",{\"1\":{\"618\":1,\"682\":1}}],[\"是否支持快速随机访问\",{\"1\":{\"552\":1,\"656\":1}}],[\"是否保证线程安全\",{\"1\":{\"552\":1,\"656\":1}}],[\"是否阻塞\",{\"1\":{\"543\":1}}],[\"是否强制从主内存读写\",{\"1\":{\"331\":1}}],[\"是否为空\",{\"1\":{\"604\":1,\"630\":1}}],[\"是否为null\",{\"1\":{\"571\":3,\"1026\":1}}],[\"是否为\",{\"0\":{\"1030\":1},\"1\":{\"329\":1,\"571\":3,\"710\":1,\"712\":1,\"752\":1}}],[\"是否合法\",{\"1\":{\"307\":1}}],[\"是否有界\",{\"1\":{\"542\":1,\"543\":1,\"672\":1,\"1179\":1}}],[\"是否有损坏或者丢失的数据\",{\"1\":{\"234\":1}}],[\"是否有第二个锁\",{\"1\":{\"53\":2}}],[\"是否有第一个锁\",{\"1\":{\"53\":2}}],[\"是否存在\",{\"1\":{\"177\":1}}],[\"是否等于\",{\"1\":{\"117\":1}}],[\"是否符合\",{\"1\":{\"86\":1}}],[\"是否正确\",{\"1\":{\"86\":1}}],[\"是直接操作\",{\"1\":{\"51\":1}}],[\"是滴滴开源的一款基于数据库号段模式的唯一\",{\"1\":{\"42\":1}}],[\"是美团开源的一个分布式\",{\"1\":{\"41\":1}}],[\"是百度开源的一款基于\",{\"1\":{\"40\":1}}],[\"是肯定不会重复的\",{\"1\":{\"37\":1}}],[\"是根据索引列构建\",{\"1\":{\"114\":1}}],[\"是根据标识符\",{\"1\":{\"37\":1}}],[\"是根据时间和节点\",{\"1\":{\"37\":1}}],[\"是层的意思\",{\"1\":{\"23\":1}}],[\"是当前的进程\",{\"1\":{\"22\":1}}],[\"是产生\",{\"1\":{\"22\":1}}],[\"是请求在分布式系统中的整个链路视图\",{\"1\":{\"21\":1}}],[\"是开源\",{\"1\":{\"10\":1}}],[\"是使用\",{\"1\":{\"8\":1,\"1245\":1}}],[\"是一类提供系统软件和应用软件之间连接\",{\"1\":{\"1218\":1}}],[\"是一组\",{\"1\":{\"1069\":1}}],[\"是一定要满足的\",{\"1\":{\"1068\":1}}],[\"是一次性的\",{\"1\":{\"751\":1,\"907\":1}}],[\"是一款常用的日志框架\",{\"1\":{\"1181\":1}}],[\"是一款经得起生产考验的成熟稳定的\",{\"1\":{\"1172\":1}}],[\"是一款微服务框架\",{\"1\":{\"1168\":1}}],[\"是一款高性能\",{\"1\":{\"1122\":1}}],[\"是一款面向服务器的垃圾收集器\",{\"1\":{\"407\":1}}],[\"是一款基于\",{\"1\":{\"7\":1,\"8\":1,\"9\":1}}],[\"是一致的\",{\"1\":{\"340\":1,\"351\":1}}],[\"是一种通用的分布式一致性算法\",{\"1\":{\"1359\":1}}],[\"是一种内存映射文件的方法\",{\"1\":{\"1310\":1}}],[\"是一种接口原子型的消费者类型\",{\"1\":{\"1293\":1}}],[\"是一种先进先出的数据结构\",{\"1\":{\"1218\":1}}],[\"是一种更加灵活\",{\"1\":{\"1170\":1}}],[\"是一种提供了原子式管理同步状态\",{\"1\":{\"999\":1}}],[\"是一种\",{\"1\":{\"969\":1}}],[\"是一种隐式的链表队列\",{\"1\":{\"874\":1}}],[\"是一种数组和链表结构\",{\"1\":{\"690\":1}}],[\"是一种可重入锁\",{\"1\":{\"690\":1}}],[\"是一种不存储元素的阻塞队列\",{\"1\":{\"671\":1}}],[\"是一种计算机程序设计领域的优化策略\",{\"1\":{\"585\":1}}],[\"是一种老旧的集合\",{\"1\":{\"583\":1,\"793\":1}}],[\"是一种策略\",{\"1\":{\"484\":1}}],[\"是一种无序集合\",{\"1\":{\"259\":1}}],[\"是一种有名的基数计数概率算法\",{\"1\":{\"205\":1}}],[\"是一种二进制安全的数据类型\",{\"1\":{\"176\":1}}],[\"是一种特殊的唯一索引\",{\"1\":{\"104\":1}}],[\"是一种基于二叉树的数据结构\",{\"1\":{\"97\":1}}],[\"是一种非常快速的动态脚本语言\",{\"1\":{\"6\":1}}],[\"是一个在\",{\"1\":{\"1245\":1}}],[\"是一个消息服务的标准或者说是规范\",{\"1\":{\"1226\":1}}],[\"是一个分布式系统\",{\"1\":{\"1235\":1}}],[\"是一个分布式流式处理平台\",{\"1\":{\"1190\":1}}],[\"是一个分布式列存储数据库系统\",{\"1\":{\"1181\":1}}],[\"是一个固定大小的数组\",{\"1\":{\"1184\":1}}],[\"是一个相对冷门一些的知识点\",{\"1\":{\"1177\":1}}],[\"是一个典型的分布式系统\",{\"1\":{\"1085\":1}}],[\"是一个会根据需要创建新线程的线程池\",{\"1\":{\"957\":1}}],[\"是一个可重入的读写锁\",{\"1\":{\"865\":1}}],[\"是一个可重入且独占式的锁\",{\"1\":{\"857\":1}}],[\"是一个不错的选择\",{\"1\":{\"862\":1}}],[\"是一个原子操作\",{\"1\":{\"841\":1,\"990\":1}}],[\"是一个支持优先级的无界阻塞队列\",{\"1\":{\"799\":1,\"897\":1}}],[\"是一个虚拟的双向队列\",{\"1\":{\"742\":1}}],[\"是一个特殊的值\",{\"1\":{\"693\":1}}],[\"是一个特殊字符串头\",{\"1\":{\"17\":1}}],[\"是一个链表结构的元素\",{\"1\":{\"690\":1}}],[\"是一个接口\",{\"1\":{\"670\":1,\"796\":1}}],[\"是一个标记接口\",{\"1\":{\"655\":1,\"726\":1}}],[\"是一个列表\",{\"1\":{\"651\":1}}],[\"是一个后进先出的栈\",{\"1\":{\"651\":1}}],[\"是一个类似于\",{\"1\":{\"569\":1}}],[\"是一个常见的误区\",{\"1\":{\"480\":1}}],[\"是一个抽象类\",{\"1\":{\"351\":1}}],[\"是一个有歧义的名字\",{\"1\":{\"233\":1}}],[\"是一个很好的选择\",{\"1\":{\"188\":1}}],[\"是一个\",{\"1\":{\"184\":1,\"561\":1,\"765\":1,\"1276\":1,\"1367\":1}}],[\"是一个6字节的列\",{\"1\":{\"106\":1}}],[\"是一个开源的分布式应用程序协调服务器\",{\"1\":{\"1367\":1}}],[\"是一个开源的分布式协调服务\",{\"1\":{\"1344\":1}}],[\"是一个开源的分布式实时计算系统\",{\"1\":{\"1181\":1}}],[\"是一个开源的高性能内存队列\",{\"1\":{\"1178\":1}}],[\"是一个开源的\",{\"1\":{\"49\":1}}],[\"是一个自增的序列\",{\"1\":{\"22\":1}}],[\"是一个基于双向链表实现的集合类\",{\"1\":{\"724\":1}}],[\"是一个基于\",{\"1\":{\"6\":1,\"242\":1}}],[\"是\",{\"1\":{\"4\":1,\"6\":1,\"23\":1,\"35\":1,\"37\":1,\"38\":1,\"53\":1,\"55\":1,\"89\":2,\"176\":1,\"242\":1,\"254\":1,\"353\":1,\"417\":1,\"445\":1,\"446\":1,\"498\":1,\"524\":1,\"541\":1,\"542\":1,\"543\":1,\"550\":2,\"597\":1,\"643\":1,\"650\":2,\"672\":1,\"678\":1,\"684\":1,\"702\":1,\"715\":1,\"748\":1,\"752\":1,\"797\":1,\"825\":1,\"847\":1,\"861\":1,\"871\":1,\"935\":1,\"1016\":1,\"1018\":1,\"1052\":1,\"1073\":1,\"1079\":1,\"1097\":1,\"1099\":1,\"1112\":1,\"1129\":1,\"1155\":2,\"1160\":1,\"1170\":1,\"1171\":1,\"1182\":1,\"1183\":1,\"1206\":1,\"1211\":1,\"1213\":1,\"1226\":1,\"1231\":2,\"1235\":1,\"1299\":1,\"1332\":1,\"1341\":1,\"1352\":1,\"1382\":1,\"1385\":1}}],[\"n1\",{\"1\":{\"1380\":4}}],[\"n=6\",{\"1\":{\"841\":1,\"990\":1}}],[\"n=toindex\",{\"1\":{\"634\":1}}],[\"n>5\",{\"1\":{\"747\":1,\"905\":1}}],[\"ns\",{\"1\":{\"687\":8}}],[\"npe\",{\"1\":{\"630\":1,\"1005\":1}}],[\"ntainer\",{\"1\":{\"1209\":3}}],[\"nthreads\",{\"1\":{\"889\":3,\"937\":3,\"949\":8}}],[\"nt\",{\"1\":{\"576\":2}}],[\"nice\",{\"1\":{\"779\":6,\"781\":2}}],[\"nio\",{\"1\":{\"265\":1,\"353\":1,\"499\":1}}],[\"nil\",{\"1\":{\"177\":1,\"280\":2,\"777\":1}}],[\"numchildre\",{\"1\":{\"1382\":1}}],[\"numchildren\",{\"1\":{\"1327\":1,\"1329\":2,\"1330\":1,\"1349\":3}}],[\"nums\",{\"1\":{\"766\":3}}],[\"numnew\",{\"1\":{\"553\":11}}],[\"nummoved\",{\"1\":{\"553\":11,\"591\":3}}],[\"num\",{\"1\":{\"268\":1,\"679\":4,\"713\":6,\"1062\":4}}],[\"numkeys\",{\"1\":{\"193\":4}}],[\"numberofgclogfiles=14\",{\"1\":{\"483\":1}}],[\"number\",{\"0\":{\"326\":1},\"1\":{\"177\":5,\"302\":1,\"326\":1,\"618\":1,\"682\":1,\"918\":2}}],[\"nullable\",{\"1\":{\"1210\":2}}],[\"null说明当前遍历的entry是一个过期数据\",{\"1\":{\"1036\":1}}],[\"null证明只新建线程而不执行任务\",{\"1\":{\"941\":1}}],[\"nulls\",{\"1\":{\"693\":1}}],[\"nullpointerexception\",{\"1\":{\"524\":1,\"555\":1,\"571\":2,\"577\":1,\"630\":1,\"677\":1,\"890\":1,\"900\":1,\"936\":1,\"941\":1,\"1043\":1}}],[\"null操作\",{\"1\":{\"118\":1}}],[\"null或者is\",{\"1\":{\"118\":1}}],[\"null\",{\"0\":{\"551\":1,\"652\":1,\"693\":1,\"1030\":1},\"1\":{\"33\":2,\"34\":5,\"49\":2,\"56\":6,\"104\":2,\"120\":2,\"251\":1,\"256\":4,\"307\":2,\"342\":1,\"353\":5,\"357\":4,\"390\":3,\"531\":2,\"535\":2,\"536\":6,\"537\":2,\"538\":1,\"539\":3,\"541\":1,\"551\":5,\"553\":11,\"571\":21,\"572\":3,\"573\":4,\"576\":2,\"577\":13,\"578\":8,\"599\":1,\"601\":1,\"603\":1,\"604\":8,\"616\":3,\"618\":1,\"619\":1,\"621\":1,\"622\":13,\"623\":9,\"624\":16,\"629\":2,\"630\":5,\"632\":1,\"649\":2,\"652\":5,\"668\":1,\"669\":1,\"671\":1,\"677\":7,\"680\":1,\"682\":1,\"683\":11,\"686\":3,\"693\":15,\"706\":2,\"710\":7,\"711\":6,\"712\":6,\"713\":5,\"729\":5,\"730\":2,\"731\":19,\"732\":5,\"756\":2,\"767\":1,\"777\":2,\"779\":5,\"780\":2,\"781\":2,\"798\":1,\"799\":1,\"834\":2,\"883\":4,\"884\":2,\"890\":3,\"900\":1,\"911\":2,\"936\":3,\"941\":7,\"1011\":8,\"1012\":3,\"1013\":5,\"1014\":14,\"1015\":1,\"1030\":3,\"1031\":1,\"1033\":3,\"1036\":12,\"1037\":13,\"1038\":6,\"1041\":4,\"1042\":2,\"1043\":4,\"1047\":1,\"1204\":1,\"1210\":3,\"1212\":1,\"1299\":1,\"1349\":1}}],[\"n2\",{\"1\":{\"96\":2}}],[\"n+1\",{\"1\":{\"89\":1,\"895\":1,\"922\":1}}],[\"n\",{\"0\":{\"157\":1},\"1\":{\"89\":1,\"96\":3,\"97\":3,\"98\":1,\"157\":14,\"176\":1,\"256\":1,\"301\":14,\"302\":1,\"319\":5,\"407\":1,\"552\":3,\"558\":2,\"564\":5,\"570\":2,\"572\":2,\"576\":6,\"577\":3,\"578\":3,\"588\":4,\"618\":2,\"622\":5,\"623\":3,\"629\":4,\"632\":3,\"653\":7,\"654\":2,\"656\":4,\"658\":1,\"677\":14,\"682\":2,\"683\":3,\"684\":3,\"686\":2,\"691\":2,\"724\":1,\"725\":2,\"729\":2,\"742\":4,\"747\":2,\"753\":5,\"772\":1,\"841\":2,\"894\":1,\"895\":5,\"904\":4,\"905\":2,\"919\":2,\"920\":1,\"922\":5,\"990\":2,\"1042\":3,\"1062\":1,\"1111\":1,\"1209\":2,\"1213\":3,\"1348\":1,\"1357\":3,\"1373\":3}}],[\"nack\",{\"1\":{\"1256\":1}}],[\"nacos\",{\"1\":{\"72\":4,\"896\":1,\"923\":1,\"1068\":1,\"1069\":2,\"1157\":1}}],[\"nancy\",{\"1\":{\"1066\":1}}],[\"nanoseconds\",{\"1\":{\"604\":2,\"889\":1,\"937\":1,\"958\":2,\"961\":1}}],[\"nanos\",{\"1\":{\"537\":8,\"756\":5,\"911\":5}}],[\"nanotime\",{\"1\":{\"357\":2}}],[\"namingthreadfactory\",{\"1\":{\"894\":2,\"920\":2}}],[\"namenode\",{\"1\":{\"1344\":1}}],[\"nameserver\",{\"1\":{\"1281\":14,\"1316\":1}}],[\"namespace\",{\"1\":{\"37\":2}}],[\"named\",{\"1\":{\"449\":1}}],[\"nameandtype\",{\"1\":{\"328\":1}}],[\"name=\",{\"1\":{\"135\":1,\"882\":22,\"928\":1}}],[\"name=zipkin\",{\"1\":{\"7\":1}}],[\"name\",{\"1\":{\"106\":1,\"117\":5,\"125\":4,\"141\":1,\"185\":6,\"331\":1,\"351\":4,\"354\":6,\"357\":6,\"367\":2,\"630\":1,\"663\":8,\"767\":8,\"768\":8,\"894\":5,\"920\":5,\"1043\":3,\"1141\":1,\"1142\":1,\"1321\":1}}],[\"navigablemap\",{\"1\":{\"679\":1}}],[\"navigableset等抽象类以及其他的一些辅助类\",{\"1\":{\"639\":1}}],[\"native\",{\"1\":{\"332\":1,\"391\":2,\"412\":1,\"435\":3,\"445\":1,\"486\":1,\"493\":1,\"494\":1,\"499\":2,\"561\":2,\"765\":1,\"767\":2,\"808\":1,\"811\":1,\"812\":1,\"834\":3,\"841\":3,\"990\":3}}],[\"nx\",{\"1\":{\"48\":2}}],[\"nov\",{\"1\":{\"1349\":2}}],[\"node<>\",{\"1\":{\"729\":2}}],[\"node<e>\",{\"1\":{\"727\":5,\"729\":5,\"730\":5,\"731\":8,\"732\":3,\"798\":1}}],[\"node<\",{\"1\":{\"576\":1}}],[\"node<k\",{\"1\":{\"576\":4,\"577\":7,\"578\":2,\"619\":5,\"622\":3,\"623\":4,\"624\":8,\"683\":2,\"688\":1,\"708\":2,\"711\":3}}],[\"nodeindex\",{\"1\":{\"572\":3}}],[\"nodes\",{\"1\":{\"572\":1,\"708\":3}}],[\"node\",{\"0\":{\"708\":1},\"1\":{\"571\":14,\"572\":7,\"575\":1,\"577\":1,\"579\":2,\"619\":2,\"623\":1,\"624\":1,\"688\":3,\"691\":2,\"692\":2,\"708\":7,\"710\":3,\"711\":9,\"713\":4,\"727\":2,\"729\":1,\"730\":3,\"731\":1,\"742\":1,\"748\":1,\"792\":1,\"904\":1,\"906\":1,\"1005\":3,\"1008\":1,\"1011\":36,\"1012\":23,\"1013\":29,\"1014\":26,\"1015\":7}}],[\"node1\",{\"1\":{\"54\":2,\"1325\":9,\"1326\":2,\"1327\":3,\"1328\":4,\"1329\":1,\"1330\":2,\"1331\":2,\"1335\":11,\"1336\":2,\"1337\":3,\"1338\":1,\"1349\":2}}],[\"noretries\",{\"1\":{\"1210\":1}}],[\"nor\",{\"1\":{\"571\":1}}],[\"nonfairtryacquire\",{\"1\":{\"1007\":1,\"1018\":1}}],[\"nonfairtryacquireshared\",{\"1\":{\"748\":2}}],[\"nonfairsync\",{\"1\":{\"747\":2,\"748\":3,\"857\":2,\"865\":1,\"905\":2,\"1002\":2,\"1008\":1}}],[\"nonvolatile\",{\"1\":{\"571\":1}}],[\"non\",{\"1\":{\"499\":1,\"553\":1,\"669\":1,\"693\":2}}],[\"none\",{\"1\":{\"341\":1,\"680\":1}}],[\"nosuchfieldexception\",{\"1\":{\"1030\":1}}],[\"nosuchfielderror\",{\"1\":{\"341\":1}}],[\"nosuchelementexception\",{\"1\":{\"536\":2,\"539\":1,\"713\":2,\"730\":2,\"731\":2,\"732\":3}}],[\"nosuchmethoderror\",{\"1\":{\"341\":1}}],[\"nosql\",{\"0\":{\"35\":1},\"1\":{\"35\":1,\"242\":1,\"1085\":1}}],[\"no\",{\"1\":{\"41\":1,\"161\":1,\"231\":1,\"273\":1,\"282\":2,\"302\":1,\"351\":1,\"571\":1,\"577\":1,\"1371\":3,\"1374\":1}}],[\"nothing\",{\"1\":{\"1236\":1}}],[\"notify等方法\",{\"1\":{\"851\":1}}],[\"notify等方法也依赖于monitor对象\",{\"1\":{\"851\":1}}],[\"notify\",{\"1\":{\"820\":1,\"825\":1}}],[\"notifyall\",{\"1\":{\"55\":1,\"544\":1,\"825\":1,\"862\":2}}],[\"notfull\",{\"1\":{\"534\":2,\"535\":4,\"537\":1,\"544\":2}}],[\"notfoundexception\",{\"1\":{\"524\":1}}],[\"notempty\",{\"1\":{\"534\":2,\"535\":5,\"537\":1,\"544\":2}}],[\"note\",{\"0\":{\"1394\":1},\"1\":{\"256\":1,\"298\":1,\"302\":1}}],[\"not\",{\"1\":{\"11\":1,\"13\":2,\"24\":1,\"33\":2,\"34\":5,\"43\":1,\"45\":1,\"47\":1,\"57\":1,\"59\":1,\"63\":1,\"65\":2,\"78\":1,\"118\":1,\"147\":1,\"150\":2,\"153\":2,\"171\":1,\"196\":1,\"201\":1,\"202\":1,\"213\":1,\"221\":1,\"237\":1,\"240\":1,\"274\":1,\"277\":1,\"293\":1,\"298\":3,\"320\":1,\"334\":1,\"345\":1,\"351\":1,\"356\":1,\"360\":1,\"377\":1,\"409\":1,\"412\":1,\"472\":1,\"480\":1,\"486\":1,\"489\":1,\"511\":1,\"545\":1,\"548\":1,\"553\":2,\"555\":1,\"564\":2,\"571\":1,\"579\":1,\"587\":1,\"593\":1,\"612\":1,\"615\":1,\"625\":1,\"634\":1,\"637\":1,\"672\":1,\"675\":1,\"680\":1,\"698\":1,\"720\":1,\"723\":1,\"733\":1,\"736\":2,\"756\":1,\"758\":1,\"767\":2,\"769\":1,\"788\":1,\"798\":1,\"801\":1,\"804\":1,\"827\":1,\"830\":1,\"876\":1,\"879\":1,\"911\":1,\"913\":1,\"929\":1,\"964\":1,\"982\":1,\"996\":1,\"1022\":1,\"1048\":1,\"1079\":1,\"1092\":1,\"1100\":1,\"1117\":1,\"1147\":1,\"1161\":1,\"1174\":1,\"1185\":1,\"1214\":1,\"1241\":1,\"1264\":1,\"1316\":1,\"1338\":1,\"1363\":1,\"1391\":1}}],[\"ndbusiness\",{\"1\":{\"24\":1}}],[\"necessary\",{\"1\":{\"941\":1}}],[\"nextbackoff\",{\"1\":{\"1210\":8}}],[\"nextthreadid\",{\"1\":{\"1043\":1}}],[\"nexthashcode\",{\"1\":{\"1032\":5}}],[\"nextoffset\",{\"1\":{\"1011\":1}}],[\"nextwaiter\",{\"1\":{\"1005\":1}}],[\"nextgeneration\",{\"1\":{\"756\":1,\"911\":1}}],[\"nextc\",{\"1\":{\"752\":3,\"1007\":3,\"1018\":6}}],[\"nextindex++\",{\"1\":{\"732\":1}}],[\"nextindex\",{\"1\":{\"732\":5,\"1036\":4,\"1037\":4,\"1038\":1,\"1041\":1,\"1042\":1,\"1112\":4}}],[\"nextint\",{\"1\":{\"713\":4,\"782\":2,\"882\":2,\"1141\":2,\"1142\":2}}],[\"next直接当前节点的after指针快速定位到下一个节点\",{\"1\":{\"713\":1}}],[\"nextnode\",{\"1\":{\"713\":5}}],[\"next组合\",{\"1\":{\"622\":1}}],[\"next\",{\"1\":{\"571\":2,\"572\":7,\"573\":1,\"577\":2,\"578\":1,\"619\":7,\"622\":3,\"623\":2,\"624\":9,\"634\":1,\"657\":2,\"683\":4,\"708\":2,\"711\":3,\"713\":10,\"727\":4,\"729\":2,\"730\":1,\"731\":15,\"732\":15,\"742\":1,\"748\":3,\"871\":6,\"904\":1,\"1005\":1,\"1011\":9,\"1012\":2,\"1013\":8,\"1014\":5,\"1015\":1}}],[\"neither\",{\"1\":{\"571\":1}}],[\"nested\",{\"1\":{\"553\":1}}],[\"negative\",{\"1\":{\"302\":1,\"571\":1,\"629\":1}}],[\"never\",{\"1\":{\"256\":1}}],[\"near\",{\"1\":{\"86\":2}}],[\"newbuilder\",{\"1\":{\"1293\":1}}],[\"newvirtualthreadpertaskexecutor\",{\"0\":{\"1061\":1},\"1\":{\"1061\":1,\"1062\":1}}],[\"newval\",{\"1\":{\"697\":1}}],[\"newvalue\",{\"1\":{\"619\":2,\"630\":4,\"763\":2,\"766\":3}}],[\"newupdater\",{\"1\":{\"768\":2}}],[\"newmark1\",{\"1\":{\"767\":3}}],[\"newreference1\",{\"1\":{\"767\":4}}],[\"newreference\",{\"1\":{\"767\":4,\"843\":3,\"992\":3}}],[\"newratio=1\",{\"1\":{\"479\":1}}],[\"newratio=<int>\",{\"1\":{\"479\":1}}],[\"newratio=4\",{\"1\":{\"449\":1,\"452\":1}}],[\"newratio\",{\"1\":{\"449\":1,\"452\":1}}],[\"newfixedthreadpool\",{\"1\":{\"749\":1,\"753\":1,\"757\":2,\"835\":1,\"889\":1,\"909\":1,\"937\":1,\"944\":2,\"949\":2,\"1062\":1}}],[\"news\",{\"1\":{\"1237\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"889\":1,\"937\":1,\"961\":1,\"1062\":1}}],[\"newsimpleconsumerbuilder\",{\"1\":{\"1293\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"889\":1,\"937\":1,\"953\":2}}],[\"newsize=256m\",{\"1\":{\"479\":1}}],[\"newsize=<young\",{\"1\":{\"479\":1}}],[\"newsize和\",{\"1\":{\"479\":1}}],[\"newsize\",{\"1\":{\"449\":1,\"454\":1,\"479\":1,\"553\":3}}],[\"newstamp\",{\"1\":{\"767\":3,\"843\":3,\"992\":3}}],[\"newstate\",{\"1\":{\"742\":2,\"904\":2,\"1006\":1}}],[\"newarraylist\",{\"1\":{\"634\":3,\"1028\":1}}],[\"newnode\",{\"1\":{\"622\":2,\"683\":1,\"686\":1,\"729\":8}}],[\"newelements\",{\"1\":{\"588\":3,\"591\":4}}],[\"newtab\",{\"1\":{\"624\":7,\"1038\":4}}],[\"newtable\",{\"1\":{\"572\":8}}],[\"newthread\",{\"1\":{\"894\":2,\"920\":2,\"1060\":1}}],[\"newthr\",{\"1\":{\"624\":6}}],[\"newtimeout\",{\"1\":{\"49\":1}}],[\"newlen\",{\"1\":{\"1038\":5}}],[\"newlength\",{\"1\":{\"562\":3}}],[\"newlockdata\",{\"1\":{\"56\":2}}],[\"newcachedthreadpool\",{\"1\":{\"889\":1,\"937\":1,\"957\":2}}],[\"newcap\",{\"1\":{\"621\":2,\"624\":8}}],[\"newcapacity\",{\"1\":{\"553\":6,\"558\":10,\"572\":4}}],[\"newcapacity为新容量\",{\"1\":{\"553\":1,\"558\":1}}],[\"newcondition\",{\"1\":{\"534\":2,\"601\":1}}],[\"newconcurrentmap\",{\"1\":{\"56\":1}}],[\"newinstance\",{\"1\":{\"344\":1}}],[\"new\",{\"0\":{\"777\":1},\"1\":{\"49\":1,\"53\":4,\"56\":3,\"344\":3,\"352\":1,\"353\":1,\"370\":4,\"384\":7,\"390\":2,\"425\":1,\"433\":1,\"444\":1,\"449\":1,\"451\":2,\"490\":1,\"499\":1,\"502\":1,\"506\":1,\"511\":1,\"531\":7,\"533\":2,\"534\":4,\"536\":2,\"551\":1,\"553\":10,\"555\":3,\"559\":1,\"561\":1,\"562\":2,\"564\":2,\"570\":5,\"571\":5,\"572\":3,\"576\":1,\"577\":3,\"587\":1,\"591\":1,\"593\":1,\"599\":4,\"601\":2,\"621\":2,\"624\":1,\"625\":1,\"630\":5,\"631\":1,\"632\":4,\"633\":4,\"634\":6,\"649\":2,\"652\":1,\"662\":2,\"663\":5,\"677\":2,\"679\":7,\"693\":1,\"704\":1,\"705\":1,\"706\":1,\"713\":6,\"729\":2,\"730\":2,\"731\":2,\"732\":5,\"733\":1,\"747\":4,\"748\":4,\"749\":1,\"752\":3,\"753\":3,\"756\":6,\"757\":2,\"763\":1,\"764\":1,\"765\":1,\"766\":1,\"767\":7,\"768\":1,\"776\":1,\"777\":4,\"780\":4,\"782\":1,\"784\":2,\"797\":1,\"798\":2,\"820\":2,\"823\":4,\"824\":1,\"827\":1,\"834\":2,\"835\":3,\"837\":1,\"838\":1,\"841\":1,\"857\":2,\"865\":4,\"882\":8,\"889\":9,\"890\":2,\"894\":3,\"900\":3,\"905\":4,\"906\":1,\"909\":2,\"911\":6,\"918\":1,\"920\":3,\"927\":3,\"928\":1,\"936\":2,\"937\":9,\"940\":6,\"941\":6,\"949\":4,\"953\":6,\"957\":4,\"961\":2,\"986\":1,\"987\":1,\"990\":1,\"1001\":1,\"1007\":1,\"1008\":1,\"1011\":6,\"1014\":2,\"1018\":2,\"1020\":5,\"1028\":1,\"1030\":5,\"1031\":1,\"1032\":3,\"1036\":3,\"1038\":1,\"1043\":5,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1,\"1141\":1,\"1142\":5,\"1209\":1,\"1210\":3,\"1211\":3,\"1213\":1,\"1293\":1,\"1299\":2,\"1310\":1,\"1333\":1}}],[\"needcontinue\",{\"1\":{\"353\":3}}],[\"needed\",{\"1\":{\"293\":1,\"298\":1,\"619\":1}}],[\"need\",{\"1\":{\"11\":1}}],[\"netbeans\",{\"1\":{\"377\":1}}],[\"net\",{\"1\":{\"237\":2,\"334\":1,\"360\":1,\"409\":1,\"522\":1,\"612\":2,\"633\":1,\"1030\":1,\"1185\":1,\"1245\":1}}],[\"netty+kyro+zookeeper\",{\"1\":{\"1173\":1}}],[\"nettyserver\",{\"1\":{\"365\":2,\"370\":1}}],[\"nettyclient2\",{\"1\":{\"365\":2,\"370\":1}}],[\"netty\",{\"1\":{\"4\":1,\"5\":1,\"68\":1,\"265\":1,\"1130\":1,\"1166\":1,\"1178\":1}}],[\"netflix\",{\"0\":{\"4\":1},\"1\":{\"4\":4,\"53\":1,\"1332\":1}}],[\"ngx\",{\"1\":{\"6\":1}}],[\"nginx\",{\"1\":{\"1\":3,\"6\":9,\"7\":5,\"8\":2}}],[\"有比自己更小的节点\",{\"1\":{\"1388\":1}}],[\"有选举权和被选举权\",{\"1\":{\"1378\":1}}],[\"有临时节点的概念\",{\"1\":{\"1362\":1}}],[\"有意思的是在同样高并发的\",{\"1\":{\"1315\":1}}],[\"有三种模式\",{\"1\":{\"1263\":1}}],[\"有三种方式来初始化\",{\"1\":{\"555\":1}}],[\"有优先级队列实现\",{\"1\":{\"1258\":1}}],[\"有阿里巴巴的实际业务场景的实战考验\",{\"1\":{\"1240\":1}}],[\"有很好的管理控制台\",{\"1\":{\"1263\":1}}],[\"有很高的灵活性\",{\"1\":{\"1212\":1}}],[\"有很多种实现方式\",{\"1\":{\"1161\":1}}],[\"有很多的优点\",{\"1\":{\"895\":1,\"922\":1}}],[\"有很多基于\",{\"1\":{\"38\":1}}],[\"有界\",{\"1\":{\"1179\":2}}],[\"有界队列\",{\"1\":{\"798\":1}}],[\"有能力的公司甚至会基于\",{\"1\":{\"1171\":1}}],[\"有区别\",{\"1\":{\"1152\":1}}],[\"有效地进行流量削峰\",{\"1\":{\"1218\":1,\"1232\":1}}],[\"有效避免了消息丢失的风险\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"有效均衡各个节点的请求量\",{\"1\":{\"1143\":1}}],[\"有效的数据又少\",{\"1\":{\"19\":1}}],[\"有时被称为插件架构模式\",{\"1\":{\"1132\":1}}],[\"有时候也会全表扫描\",{\"1\":{\"157\":1,\"301\":1}}],[\"有时候可能也不是最优\",{\"1\":{\"87\":1}}],[\"有趣的案例\",{\"1\":{\"1071\":1}}],[\"有段时间\",{\"1\":{\"1062\":1}}],[\"有机会升级到\",{\"1\":{\"1062\":1}}],[\"有问题出现就会有解决问题的方案\",{\"1\":{\"1043\":1}}],[\"有过hash冲突数据的entry位置会更靠近正确位置\",{\"1\":{\"1037\":1}}],[\"有下面几个枚举值\",{\"1\":{\"1005\":1}}],[\"有以下两种可能\",{\"1\":{\"1002\":1}}],[\"有何区别\",{\"0\":{\"973\":1}}],[\"有没有感觉到来自兰伯特大佬满满地嘲讽的味道\",{\"1\":{\"1096\":1}}],[\"有没有感觉布隆过滤器就是我们想要找的那个\",{\"1\":{\"307\":1}}],[\"有没有可以改进的地方呢\",{\"1\":{\"909\":1}}],[\"有利于我们定位问题\",{\"1\":{\"894\":1,\"920\":1}}],[\"有利于定位问题\",{\"1\":{\"894\":1,\"920\":1}}],[\"有公平锁\",{\"1\":{\"857\":1}}],[\"有两个\",{\"1\":{\"1112\":2}}],[\"有两个构造函数\",{\"1\":{\"900\":1}}],[\"有两个线程\",{\"1\":{\"694\":1}}],[\"有两种类型的线程\",{\"1\":{\"819\":1}}],[\"有两种模式\",{\"1\":{\"747\":1,\"905\":1}}],[\"有兴趣的同学可以自己了解下\",{\"1\":{\"579\":1}}],[\"有兴趣可以了解一下\",{\"1\":{\"444\":1}}],[\"有深入研究的同学可以发表下意见\",{\"1\":{\"572\":1}}],[\"有冲突\",{\"1\":{\"571\":1}}],[\"有值没说明\",{\"1\":{\"571\":1}}],[\"有极客时间的\",{\"1\":{\"472\":1}}],[\"有可能会导致\",{\"1\":{\"1013\":1}}],[\"有可能会造成系统创建大量同类线程而导致消耗完内存或者\",{\"1\":{\"889\":1}}],[\"有可能会调用多个服务对请求进行处理\",{\"1\":{\"21\":1}}],[\"有可能导致下面这种情况出现\",{\"1\":{\"835\":1}}],[\"有可能存在\",{\"1\":{\"797\":1}}],[\"有可能是永久区导致的\",{\"1\":{\"456\":1}}],[\"有线程安全问题\",{\"1\":{\"424\":1}}],[\"有关垃圾回收实施的更多详细信息\",{\"1\":{\"482\":1}}],[\"有关\",{\"1\":{\"392\":1,\"1199\":1}}],[\"有几个哈希函数得到几个哈希值\",{\"1\":{\"307\":1}}],[\"有什么关系\",{\"0\":{\"900\":1}}],[\"有什么区别呢\",{\"1\":{\"781\":1}}],[\"有什么区别\",{\"0\":{\"542\":1,\"543\":1,\"672\":1,\"719\":1,\"855\":1,\"859\":1,\"1156\":1}}],[\"有什么不同呢\",{\"1\":{\"380\":1}}],[\"有什么优势\",{\"1\":{\"318\":1}}],[\"有什么用\",{\"0\":{\"847\":1,\"881\":1,\"905\":1,\"907\":1,\"910\":1},\"1\":{\"318\":1}}],[\"有什么危害\",{\"0\":{\"292\":1,\"297\":1}}],[\"有什么作用\",{\"0\":{\"138\":1}}],[\"有对应的\",{\"1\":{\"256\":1}}],[\"有主题和消费组的概念\",{\"1\":{\"249\":1}}],[\"有灾难恢复机制\",{\"1\":{\"245\":1}}],[\"有助于避免\",{\"1\":{\"934\":1}}],[\"有助于我们在做相应的技术选型的时候\",{\"1\":{\"245\":1}}],[\"有助于理解\",{\"1\":{\"161\":1}}],[\"有助于解决业务累积而导致的订单号重复的问题\",{\"1\":{\"18\":1}}],[\"有遍历的需求可以使用\",{\"1\":{\"157\":1,\"301\":1,\"319\":1}}],[\"有维护成本\",{\"1\":{\"119\":1}}],[\"有序的节点\",{\"1\":{\"1388\":1}}],[\"有序性\",{\"0\":{\"980\":1}}],[\"有序\",{\"1\":{\"643\":1}}],[\"有序集合的元素数量\",{\"1\":{\"293\":1}}],[\"有序集合\",{\"0\":{\"191\":1},\"1\":{\"174\":1,\"253\":1}}],[\"有序集合等\",{\"1\":{\"163\":1}}],[\"有序插入节点\",{\"1\":{\"97\":1}}],[\"有序递增\",{\"1\":{\"30\":1,\"33\":1,\"34\":1,\"38\":1}}],[\"有\",{\"1\":{\"90\":1,\"534\":1,\"1249\":1,\"1252\":1,\"1279\":1}}],[\"有一段这样的代码\",{\"1\":{\"1008\":1}}],[\"有一段话是如是介绍文件事件处理器的\",{\"1\":{\"265\":1}}],[\"有一条非常经典的设计原则\",{\"1\":{\"356\":1}}],[\"有一个属性叫做\",{\"1\":{\"1353\":1}}],[\"有一个同步状态\",{\"1\":{\"1018\":1}}],[\"有一个使用多线程读取多个文件处理的场景\",{\"1\":{\"909\":1}}],[\"有一个简单并且适用面比较广的公式\",{\"1\":{\"895\":1,\"922\":1}}],[\"有一个不是特别精确的参考标准\",{\"1\":{\"163\":1,\"291\":1}}],[\"有一个\",{\"1\":{\"70\":1}}],[\"有一些功能需要借助其他框架或者中间件\",{\"1\":{\"2\":1}}],[\"有点类似\",{\"1\":{\"325\":1}}],[\"有点类似于平衡树\",{\"1\":{\"800\":1}}],[\"有点类似于\",{\"1\":{\"188\":1,\"195\":1,\"259\":1}}],[\"有点像是\",{\"1\":{\"192\":1,\"195\":1}}],[\"有点像净化污水\",{\"1\":{\"69\":1}}],[\"有点文艺青年那味了\",{\"1\":{\"41\":1}}],[\"有的话直接将加锁次数加\",{\"1\":{\"56\":1}}],[\"有详细介绍到\",{\"1\":{\"51\":1,\"724\":1}}],[\"有安全性问题\",{\"1\":{\"35\":1}}],[\"有具体的业务含义\",{\"1\":{\"30\":1}}],[\"有些\",{\"1\":{\"968\":1}}],[\"有些同学可能对\",{\"1\":{\"579\":1}}],[\"有些同学可能会对最后的两个\",{\"1\":{\"572\":1}}],[\"有些情况下\",{\"1\":{\"359\":1}}],[\"有些线上线下结合的场景\",{\"1\":{\"19\":1}}],[\"有些场景适合\",{\"1\":{\"19\":1}}],[\"有些却看不出任何意义\",{\"1\":{\"16\":1}}],[\"有些单号一看就知道年月日的信息\",{\"1\":{\"16\":1}}],[\"有些只有几位数\",{\"1\":{\"16\":1}}],[\"有哪些工作模式\",{\"0\":{\"1259\":1}}],[\"有哪些常见的\",{\"0\":{\"1167\":1}}],[\"有哪些常见的网关系统\",{\"0\":{\"3\":1}}],[\"有哪些解决办法\",{\"0\":{\"307\":1,\"310\":1,\"314\":1}}],[\"有哪些亮点呢\",{\"1\":{\"42\":1}}],[\"有哪些具体的要求\",{\"1\":{\"15\":1}}],[\"有了消息队列\",{\"1\":{\"1272\":1}}],[\"有了下面两种方法\",{\"1\":{\"1202\":1}}],[\"有了对集合中的元素根据键排序的能力\",{\"1\":{\"679\":1}}],[\"有了对集合内元素的搜索的能力\",{\"1\":{\"679\":1}}],[\"有了\",{\"0\":{\"1150\":1},\"1\":{\"8\":1,\"1085\":1,\"1174\":1}}],[\"有赞技术团队\",{\"1\":{\"853\":1}}],[\"有赞\",{\"1\":{\"8\":1}}],[\"的典型应用场景\",{\"1\":{\"1391\":1}}],[\"的活性和进行重新选举\",{\"1\":{\"1387\":1}}],[\"的强一致性\",{\"1\":{\"1387\":1}}],[\"的强大之处\",{\"1\":{\"1020\":1}}],[\"的某些事件或要求则会\",{\"1\":{\"1385\":1}}],[\"的事务\",{\"1\":{\"1382\":1}}],[\"的事务和我们平时理解的关系型数据库的事务不同\",{\"1\":{\"281\":1}}],[\"的几个典型应用场景\",{\"0\":{\"1386\":1}}],[\"的几个理论知识\",{\"0\":{\"1381\":1}}],[\"的几把\",{\"1\":{\"868\":1}}],[\"的重新选举\",{\"1\":{\"1380\":1}}],[\"的重试\",{\"1\":{\"1210\":1}}],[\"的重试机制\",{\"1\":{\"1208\":1}}],[\"的例子\",{\"1\":{\"1380\":1}}],[\"的身份进入集群中\",{\"1\":{\"1380\":1}}],[\"的身份加入集群\",{\"1\":{\"1380\":1}}],[\"的身影\",{\"1\":{\"1129\":1}}],[\"的投票结果后发现比自己的合适于是更改投票为\",{\"1\":{\"1380\":1}}],[\"的投票发现没自己的合适故不变\",{\"1\":{\"1380\":1}}],[\"的投票信息后会将投票信息与自己的作比较\",{\"1\":{\"1380\":1}}],[\"的投票仅为\",{\"1\":{\"1380\":1}}],[\"的崩溃\",{\"1\":{\"1380\":1}}],[\"的崩溃会导致日志不一样\",{\"1\":{\"1112\":1}}],[\"的变化而变化的\",{\"1\":{\"1379\":1}}],[\"的变量\",{\"1\":{\"972\":1}}],[\"的变量会加\",{\"1\":{\"749\":1}}],[\"的更新\",{\"1\":{\"1379\":1}}],[\"的编号\",{\"1\":{\"1374\":1}}],[\"的批准\",{\"1\":{\"1374\":1}}],[\"的提案\",{\"1\":{\"1373\":1}}],[\"的提案中会存在一个编号最大的提案\",{\"1\":{\"1373\":1}}],[\"的提交被驳回\",{\"1\":{\"840\":1,\"989\":1}}],[\"的移除操作\",{\"1\":{\"1362\":1}}],[\"的容忍度是一样的\",{\"1\":{\"1357\":1}}],[\"的容量达到最小的树化容量即min\",{\"1\":{\"708\":1}}],[\"的容量未达到极限时\",{\"1\":{\"653\":1}}],[\"的容量进行扩容\",{\"1\":{\"619\":1}}],[\"的容量和负载因子创建一个\",{\"1\":{\"571\":1}}],[\"的容量至少是2或者2的倍数\",{\"1\":{\"570\":1}}],[\"的容量\",{\"1\":{\"570\":1}}],[\"的容量有限\",{\"1\":{\"541\":1}}],[\"的权限控制\",{\"1\":{\"1351\":1}}],[\"的权限\",{\"1\":{\"1351\":1,\"1384\":1}}],[\"的权重为\",{\"1\":{\"1141\":2,\"1144\":2}}],[\"的版本号\",{\"1\":{\"1382\":1}}],[\"的版本\",{\"1\":{\"1350\":1}}],[\"的版本默认为\",{\"1\":{\"37\":1}}],[\"的三个相关的版本\",{\"1\":{\"1350\":1}}],[\"的负载均衡等功能\",{\"1\":{\"1344\":1}}],[\"的负载均衡策略\",{\"0\":{\"1138\":1}}],[\"的注册以及多个\",{\"1\":{\"1344\":1}}],[\"的名字也就由此诞生了\",{\"1\":{\"1343\":1}}],[\"的名字就能看出了\",{\"1\":{\"584\":1,\"793\":1}}],[\"的理解仅仅是停留在了表面\",{\"1\":{\"1341\":1}}],[\"的理论知识\",{\"1\":{\"43\":1}}],[\"的认识\",{\"1\":{\"1341\":1}}],[\"的偏移\",{\"1\":{\"1315\":1}}],[\"的订阅模式\",{\"1\":{\"1315\":1}}],[\"的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动\",{\"1\":{\"1303\":1}}],[\"的订单信息\",{\"1\":{\"1303\":1}}],[\"的刷盘机制\",{\"0\":{\"1312\":1}}],[\"的拷贝次数和上下文切换次数\",{\"1\":{\"1311\":1}}],[\"的账户加上\",{\"1\":{\"1303\":1}}],[\"的积分加上\",{\"1\":{\"1303\":1}}],[\"的客户端\",{\"1\":{\"1292\":1,\"1341\":1}}],[\"的客户端之间可以通过\",{\"1\":{\"1226\":1}}],[\"的定时消息具有高并发和水平扩展的能力\",{\"1\":{\"1285\":1}}],[\"的定时消息可以简化定时调度任务的开发逻辑\",{\"1\":{\"1285\":1}}],[\"的定义\",{\"1\":{\"256\":1}}],[\"的定义用了\",{\"1\":{\"256\":1}}],[\"的定义是下面这样的\",{\"1\":{\"256\":1}}],[\"的效果\",{\"1\":{\"1281\":1}}],[\"的那篇文章\",{\"1\":{\"1281\":1}}],[\"的路由信息后\",{\"1\":{\"1281\":1}}],[\"的路由信息\",{\"1\":{\"1281\":1}}],[\"的路由表\",{\"1\":{\"1281\":1}}],[\"的路由和断言是什么关系\",{\"0\":{\"71\":1}}],[\"的压力会不会很大\",{\"1\":{\"1281\":1}}],[\"的压力\",{\"1\":{\"1281\":1}}],[\"的确\",{\"1\":{\"1277\":1,\"1280\":1}}],[\"的技术架构\",{\"1\":{\"1316\":1}}],[\"的技术架构的时候我已经向你展示了\",{\"1\":{\"1298\":1}}],[\"的技术架构起来就容易多了\",{\"1\":{\"1281\":1}}],[\"的技术架构之前\",{\"1\":{\"1277\":1}}],[\"的技术实施必要的监控和调节\",{\"1\":{\"381\":1}}],[\"的感觉了\",{\"1\":{\"1271\":1}}],[\"的完整数据\",{\"1\":{\"1263\":2}}],[\"的完成\",{\"1\":{\"444\":1}}],[\"的元数据\",{\"1\":{\"1263\":1}}],[\"的元素挪到\",{\"1\":{\"1037\":1}}],[\"的元素置空\",{\"1\":{\"731\":1}}],[\"的元素进行删除\",{\"1\":{\"731\":1}}],[\"的元素被删除\",{\"1\":{\"711\":1}}],[\"的元素被移动到了链表尾部\",{\"1\":{\"710\":1}}],[\"的元素时返回真\",{\"1\":{\"680\":1}}],[\"的元素多并不代表占用内存也多\",{\"1\":{\"293\":1}}],[\"的元素个数\",{\"1\":{\"202\":1}}],[\"的元素组成的集合\",{\"1\":{\"189\":1}}],[\"的元素\",{\"1\":{\"181\":1,\"589\":1,\"731\":1,\"733\":2}}],[\"的死信交换机\",{\"1\":{\"1257\":1}}],[\"的死循环\",{\"1\":{\"685\":1}}],[\"的模型架构是一样的\",{\"1\":{\"1253\":1}}],[\"的模型架构\",{\"1\":{\"1253\":1}}],[\"的绑定可以是多对多的关系\",{\"1\":{\"1249\":1}}],[\"的特点\",{\"1\":{\"1276\":1}}],[\"的特点其实很明显\",{\"1\":{\"1240\":1}}],[\"的特性\",{\"1\":{\"798\":1,\"1001\":1}}],[\"的社区算是比较成熟\",{\"1\":{\"1240\":1}}],[\"的单个实例原生支持多个集群\",{\"1\":{\"1238\":1}}],[\"的所在的位置\",{\"1\":{\"1205\":1}}],[\"的所有节点是没有进行\",{\"1\":{\"1281\":1}}],[\"的所有请求都是幂等的\",{\"1\":{\"1115\":1}}],[\"的所有属性和方法\",{\"1\":{\"715\":1}}],[\"的所有插入方法交由用户使用\",{\"1\":{\"712\":1}}],[\"的所有操作的方式\",{\"1\":{\"298\":1}}],[\"的所有字段和值\",{\"1\":{\"185\":1}}],[\"的retries\",{\"1\":{\"1204\":1}}],[\"的竞选\",{\"1\":{\"1197\":1}}],[\"的家伙\",{\"1\":{\"1197\":1,\"1206\":1}}],[\"的多个队列\",{\"1\":{\"1280\":1}}],[\"的多分区\",{\"1\":{\"1197\":1}}],[\"的多副本机制了解吗\",{\"0\":{\"1197\":1}}],[\"的多线程默认是禁用的\",{\"1\":{\"267\":1}}],[\"的多线程只是在网络数据的读写这类耗时操作上使用了\",{\"1\":{\"267\":1}}],[\"的消费监听器执行结果分为以下三种情况\",{\"1\":{\"1292\":1}}],[\"的消息进行数据写入\",{\"1\":{\"1315\":1}}],[\"的消息将会被丢弃或者返回给生产者\",{\"1\":{\"1252\":1}}],[\"的消息只会路由到\",{\"1\":{\"1252\":3}}],[\"的消息会同时路由到\",{\"1\":{\"1252\":1}}],[\"的消息会被分成多个分区并将其分布在多个\",{\"1\":{\"1199\":1}}],[\"的消息路由到所有与它绑定的\",{\"1\":{\"1252\":1}}],[\"的消息中间件\",{\"1\":{\"1237\":1,\"1276\":1}}],[\"的消息服务\",{\"1\":{\"1226\":1}}],[\"的消息\",{\"1\":{\"1204\":1}}],[\"的消息可以保证只发送到同一个\",{\"1\":{\"1202\":1}}],[\"的消息模型和\",{\"1\":{\"1194\":1}}],[\"的消息模型知道吗\",{\"0\":{\"1192\":1}}],[\"的消耗的存储空间比较大\",{\"1\":{\"37\":1}}],[\"的伪共享\",{\"1\":{\"1184\":1}}],[\"的预读机制\",{\"1\":{\"1184\":1}}],[\"的轻量级等待策略\",{\"1\":{\"1183\":1}}],[\"的真正核心\",{\"1\":{\"1182\":1}}],[\"的真正得到的参数就不是数组中的元素\",{\"1\":{\"634\":1}}],[\"的开源项目还是挺多的\",{\"1\":{\"1181\":1}}],[\"的延迟直方图对比\",{\"1\":{\"1179\":1}}],[\"的延伸和补充\",{\"1\":{\"1074\":1}}],[\"的通信层改进主要借鉴了\",{\"1\":{\"1170\":1}}],[\"的通信层的设计还是非常优秀的\",{\"1\":{\"1170\":1}}],[\"的协议\",{\"1\":{\"1155\":1,\"1231\":1}}],[\"的项目都可能会定义一套类似这样的协议解析标准\",{\"1\":{\"1152\":1}}],[\"的序列化模块实现的不满足自己要求\",{\"1\":{\"1132\":1}}],[\"的微内核架构了解吗\",{\"0\":{\"1132\":1}}],[\"的整体模型架构\",{\"1\":{\"1247\":1}}],[\"的整体模型架构如下\",{\"1\":{\"1247\":1}}],[\"的整体设计\",{\"1\":{\"1130\":1}}],[\"的整个架构比较臃肿\",{\"1\":{\"7\":1}}],[\"的要求之一就是安全性不依赖于时间\",{\"1\":{\"1116\":1}}],[\"的信息\",{\"1\":{\"1114\":1,\"1281\":2,\"1371\":1}}],[\"的不同\",{\"1\":{\"1199\":1}}],[\"的不一致\",{\"1\":{\"1112\":1}}],[\"的不断发展\",{\"1\":{\"529\":1}}],[\"的日志就一致了\",{\"1\":{\"1112\":1}}],[\"的日志条目\",{\"1\":{\"1112\":1}}],[\"的日志和\",{\"1\":{\"1112\":1}}],[\"的日志和自己的日志一致\",{\"1\":{\"1112\":1}}],[\"的日志保持一致\",{\"1\":{\"1112\":1}}],[\"的日志中\",{\"1\":{\"23\":1}}],[\"的心跳信息就会触发新一轮的选主\",{\"1\":{\"1115\":1}}],[\"的心跳\",{\"1\":{\"1111\":1}}],[\"的心跳和日志同步数据\",{\"1\":{\"1108\":1}}],[\"的状态会持续到以下情况发生\",{\"1\":{\"1111\":1}}],[\"的状态标记为\",{\"1\":{\"1013\":1}}],[\"的有效信息\",{\"1\":{\"1111\":1}}],[\"的有序性可以提升数据库写入速度\",{\"1\":{\"30\":1}}],[\"的选举过程\",{\"1\":{\"1355\":1}}],[\"的选举\",{\"1\":{\"1111\":1,\"1380\":1}}],[\"的选择\",{\"1\":{\"1068\":1}}],[\"的请求\",{\"1\":{\"1108\":1,\"1380\":1}}],[\"的请求超出了\",{\"1\":{\"297\":1}}],[\"的回复\",{\"1\":{\"1105\":1}}],[\"的回答\",{\"1\":{\"511\":1,\"820\":1}}],[\"的论文来简化对\",{\"1\":{\"1096\":1}}],[\"的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统\",{\"1\":{\"1096\":1}}],[\"的两种清理方式\",{\"1\":{\"1042\":1}}],[\"的两种典型用法\",{\"1\":{\"753\":1}}],[\"的希腊城邦来更形象化地介绍\",{\"1\":{\"1096\":1}}],[\"的示意图\",{\"1\":{\"1085\":1}}],[\"的示例\",{\"1\":{\"37\":2,\"1182\":2}}],[\"的示例是这样的\",{\"1\":{\"37\":1}}],[\"的架构和设计原理\",{\"1\":{\"1312\":1}}],[\"的架构基本和\",{\"1\":{\"1298\":1}}],[\"的架构\",{\"1\":{\"1200\":1,\"1235\":1,\"1344\":1}}],[\"的架构师\",{\"1\":{\"1072\":1}}],[\"的架构图\",{\"0\":{\"1281\":1},\"1\":{\"1069\":1}}],[\"的民间解读有很多\",{\"1\":{\"1067\":1}}],[\"的pr\",{\"1\":{\"1051\":1}}],[\"的启发式清理流程\",{\"0\":{\"1042\":1}}],[\"的槽位中\",{\"1\":{\"1037\":1}}],[\"的槽位才会停止查找\",{\"1\":{\"1033\":1}}],[\"的探测式清理流程\",{\"0\":{\"1037\":1}}],[\"的探索与实践\",{\"1\":{\"408\":1}}],[\"的灰色块数据\",{\"1\":{\"1033\":1}}],[\"的key是弱引用\",{\"1\":{\"1030\":1}}],[\"的key是否与插入的key一样\",{\"1\":{\"622\":1}}],[\"的清理机制\",{\"1\":{\"1026\":1}}],[\"的静态代码块可以看出\",{\"1\":{\"1011\":1}}],[\"的解耦思想是类似的\",{\"1\":{\"1131\":1}}],[\"的解锁方法\",{\"1\":{\"1007\":1}}],[\"的解决方案\",{\"1\":{\"35\":1}}],[\"的后续逻辑\",{\"1\":{\"1007\":1}}],[\"的后继的前驱指向待删除节点的前驱\",{\"1\":{\"731\":1}}],[\"的后继节点\",{\"1\":{\"731\":1,\"1013\":4}}],[\"的后继指针设置为\",{\"1\":{\"710\":1}}],[\"的加锁方法\",{\"1\":{\"1007\":1}}],[\"的加载路径下\",{\"1\":{\"359\":1}}],[\"的同步状态\",{\"1\":{\"1006\":1}}],[\"的同步策略\",{\"1\":{\"485\":1}}],[\"的父类\",{\"1\":{\"1002\":1}}],[\"的父加载器\",{\"1\":{\"359\":2}}],[\"的第二阶段差不多\",{\"1\":{\"1371\":1}}],[\"的第二种情况\",{\"1\":{\"1002\":1}}],[\"的第一次交互是主线程等待其他线程\",{\"1\":{\"753\":1}}],[\"的部分\",{\"1\":{\"999\":1}}],[\"的部分源码如下\",{\"1\":{\"256\":1}}],[\"的关键特性如下\",{\"1\":{\"1238\":1}}],[\"的关键在于当前的业务场景\",{\"1\":{\"1068\":1}}],[\"的关联做详细介绍\",{\"1\":{\"1002\":1}}],[\"的关联比较明显\",{\"1\":{\"1002\":1}}],[\"的关联\",{\"0\":{\"1002\":1,\"1007\":1},\"1\":{\"999\":1,\"1019\":1}}],[\"的关系用\",{\"1\":{\"976\":1}}],[\"的关系\",{\"1\":{\"6\":1,\"286\":1,\"287\":1,\"976\":1}}],[\"的人\",{\"1\":{\"985\":1}}],[\"的人而已\",{\"1\":{\"356\":1}}],[\"的规则就\",{\"1\":{\"975\":1}}],[\"的corepoolsize\",{\"1\":{\"957\":1}}],[\"的countdownlatch对象\",{\"1\":{\"909\":1}}],[\"的运行示意图\",{\"1\":{\"954\":1}}],[\"的队列就称之为死信队列\",{\"1\":{\"1256\":1}}],[\"的队列\",{\"1\":{\"896\":1,\"923\":1}}],[\"的弱引用\",{\"1\":{\"884\":1}}],[\"的键值对\",{\"1\":{\"883\":1}}],[\"的格式\",{\"1\":{\"882\":1}}],[\"的知识\",{\"1\":{\"882\":1}}],[\"的知识点\",{\"1\":{\"450\":1}}],[\"的乐观读允许一个写线程获取写锁\",{\"1\":{\"872\":1}}],[\"的乐观锁策略\",{\"1\":{\"840\":1,\"989\":1}}],[\"的获取\",{\"1\":{\"853\":1}}],[\"的持有权\",{\"1\":{\"851\":1}}],[\"的具体特点可以概括为以下几点\",{\"1\":{\"1237\":1}}],[\"的具体原理是这样的\",{\"1\":{\"1131\":1}}],[\"的具体实现和操作系统以及\",{\"1\":{\"841\":1,\"990\":1}}],[\"的具体细节之前\",{\"1\":{\"533\":1}}],[\"的思想\",{\"1\":{\"1097\":1,\"1099\":1,\"1169\":1}}],[\"的思想很简单\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"的思想是什么\",{\"0\":{\"585\":1}}],[\"的旧数据修改的结果覆盖操作员\",{\"1\":{\"840\":1,\"989\":1}}],[\"的指令重排序\",{\"1\":{\"834\":1}}],[\"的指定位置插入元素\",{\"1\":{\"588\":1}}],[\"的角度来说一下线程和进程之间的关系\",{\"1\":{\"810\":1}}],[\"的进程\",{\"1\":{\"806\":1}}],[\"的另外一个不同之处是\",{\"1\":{\"800\":1}}],[\"的另一个大优势\",{\"1\":{\"407\":1}}],[\"的详细介绍\",{\"1\":{\"792\":1,\"793\":1,\"1085\":1}}],[\"的详细介绍请看这篇文章\",{\"1\":{\"254\":1}}],[\"的诞生\",{\"1\":{\"792\":1}}],[\"的诞生主要是为了解决美团各个业务线生成分布式\",{\"1\":{\"41\":1}}],[\"的异步化\",{\"1\":{\"788\":1}}],[\"的异步任务\",{\"1\":{\"784\":1}}],[\"的异步版本\",{\"1\":{\"266\":1}}],[\"的函数式能力就是这个接口赋予的\",{\"1\":{\"774\":1,\"901\":1}}],[\"的这些缺陷\",{\"1\":{\"774\":1,\"901\":1}}],[\"的高可用模式\",{\"1\":{\"1263\":1}}],[\"的高可用性怎么实现\",{\"1\":{\"1263\":1}}],[\"的高开销\",{\"1\":{\"765\":1}}],[\"的高性能\",{\"1\":{\"6\":1,\"7\":1,\"8\":1}}],[\"的屏障\",{\"1\":{\"755\":1,\"910\":1}}],[\"的为例\",{\"1\":{\"748\":1}}],[\"的遍历的核心就是它的迭代器的实现\",{\"1\":{\"732\":1}}],[\"的next\",{\"1\":{\"729\":1}}],[\"的迭代器则是直接使用通过\",{\"1\":{\"713\":1}}],[\"的迭代器\",{\"1\":{\"713\":1}}],[\"的迭代顺序是和访问顺序一致的\",{\"1\":{\"705\":1}}],[\"的迭代顺序是和插入顺序一致的\",{\"1\":{\"704\":1}}],[\"的双向链表断开\",{\"1\":{\"712\":1}}],[\"的插入性能可能会比\",{\"1\":{\"719\":1}}],[\"的插入操作核心方法\",{\"1\":{\"712\":1}}],[\"的插入操作会将新节点追加至链表末尾\",{\"1\":{\"712\":1}}],[\"的插件\",{\"1\":{\"8\":1}}],[\"的前驱的后继指向待删除节点的后继\",{\"1\":{\"731\":1}}],[\"的前驱和后继节点\",{\"1\":{\"731\":1}}],[\"的前驱节点\",{\"1\":{\"711\":1,\"731\":1}}],[\"的前提是\",{\"1\":{\"684\":1}}],[\"的末尾\",{\"1\":{\"710\":1}}],[\"的链表访问有序性\",{\"1\":{\"710\":1}}],[\"的执行效率\",{\"1\":{\"844\":1,\"993\":1}}],[\"的执行结果\",{\"1\":{\"781\":1}}],[\"的执行步骤非常简单\",{\"1\":{\"710\":1}}],[\"的执行顺序是这样\",{\"1\":{\"694\":1}}],[\"的构造吗\",{\"1\":{\"1276\":1}}],[\"的构造方法即可看出\",{\"1\":{\"752\":1}}],[\"的构造方法完成初始化\",{\"1\":{\"709\":1}}],[\"的构造函数源码就可以看出\",{\"1\":{\"936\":1}}],[\"的构造函数来声明\",{\"1\":{\"917\":1}}],[\"的构造函数有一个\",{\"1\":{\"897\":1}}],[\"的构造函数创建线程池的时候\",{\"1\":{\"891\":1,\"936\":1}}],[\"的构造函数\",{\"1\":{\"621\":3}}],[\"的构造函数说起\",{\"0\":{\"555\":1}}],[\"的节点监听节点的状态\",{\"1\":{\"1387\":1}}],[\"的节点之间会相互发送多种\",{\"1\":{\"1085\":1}}],[\"的节点呢\",{\"1\":{\"1014\":1}}],[\"的节点类\",{\"1\":{\"708\":1}}],[\"的节点\",{\"1\":{\"708\":2,\"1013\":1}}],[\"的节点内部类\",{\"1\":{\"708\":1}}],[\"的树节点\",{\"1\":{\"708\":2}}],[\"的初衷\",{\"1\":{\"694\":1}}],[\"的初始化\",{\"1\":{\"621\":1}}],[\"的初始化是通过自旋和\",{\"1\":{\"576\":1}}],[\"的初始化逻辑\",{\"1\":{\"570\":1}}],[\"的初始化流程\",{\"1\":{\"570\":1}}],[\"的初始\",{\"1\":{\"496\":1}}],[\"的初始容量都是\",{\"1\":{\"480\":1}}],[\"的初始容量并不是\",{\"1\":{\"480\":1}}],[\"的初始大小\",{\"1\":{\"480\":1}}],[\"的初始值为\",{\"1\":{\"742\":1,\"756\":1,\"911\":1}}],[\"的初始值\",{\"1\":{\"19\":1}}],[\"的写锁\",{\"1\":{\"871\":1}}],[\"的写入是可以并发执行的\",{\"1\":{\"690\":1}}],[\"的写性能非常高\",{\"1\":{\"147\":1}}],[\"的并发编程相关\",{\"1\":{\"973\":1}}],[\"的并发写入会被阻塞\",{\"1\":{\"690\":1}}],[\"的并发控制采用可重入锁\",{\"1\":{\"541\":1}}],[\"的锁\",{\"1\":{\"690\":1,\"848\":2,\"852\":1}}],[\"的锁升级\",{\"1\":{\"579\":1}}],[\"的概念\",{\"1\":{\"688\":1,\"792\":1,\"1271\":1,\"1278\":1}}],[\"的形式\",{\"1\":{\"688\":1}}],[\"的长度为什么是\",{\"0\":{\"684\":1},\"1\":{\"684\":2}}],[\"的长度获取直接读取\",{\"1\":{\"256\":1}}],[\"的逻辑\",{\"1\":{\"683\":1,\"897\":1}}],[\"的逻辑架构图\",{\"1\":{\"81\":1}}],[\"的升序排序\",{\"1\":{\"679\":1}}],[\"的支持\",{\"1\":{\"677\":1}}],[\"的扩容机制吧\",{\"0\":{\"659\":1}}],[\"的扩容只会扩容到原来的两倍\",{\"1\":{\"572\":1}}],[\"的作用就是\",{\"1\":{\"909\":1}}],[\"的作用\",{\"1\":{\"765\":1}}],[\"的作用并不仅仅是为了获取\",{\"1\":{\"368\":1}}],[\"的作者约书亚\",{\"1\":{\"656\":1,\"724\":1}}],[\"的子类\",{\"1\":{\"643\":1}}],[\"的简单实现\",{\"1\":{\"1008\":1}}],[\"的简单入门\",{\"1\":{\"772\":1}}],[\"的简单正则匹配\",{\"1\":{\"251\":1}}],[\"的简易源码\",{\"1\":{\"634\":1}}],[\"的空闲时间\",{\"1\":{\"895\":1,\"922\":1}}],[\"的空实现方法\",{\"1\":{\"711\":1}}],[\"的空数组\",{\"1\":{\"633\":1}}],[\"的空间花费则体现在它的每一个元素都需要消耗比\",{\"1\":{\"552\":1,\"656\":1}}],[\"的空间浪费主要体现在在\",{\"1\":{\"552\":1,\"656\":1}}],[\"的空间大小更大\",{\"1\":{\"485\":1}}],[\"的空间\",{\"1\":{\"205\":1}}],[\"的空间就能存储接近2^64个不同元素\",{\"1\":{\"205\":1,\"212\":1}}],[\"的集合类\",{\"1\":{\"631\":1}}],[\"的描述如下\",{\"1\":{\"629\":1,\"630\":1,\"631\":1,\"632\":1,\"633\":1,\"634\":1}}],[\"的描述字样\",{\"1\":{\"377\":1}}],[\"的幂次则等价于与其除数减一的与\",{\"1\":{\"684\":1}}],[\"的幂次方\",{\"0\":{\"684\":1},\"1\":{\"677\":1,\"684\":2}}],[\"的幂次方大小\",{\"1\":{\"621\":1,\"677\":1}}],[\"的幂次方值\",{\"1\":{\"570\":1}}],[\"的幂作为哈希表的大小\",{\"1\":{\"616\":1,\"677\":2}}],[\"的源码非常简单\",{\"1\":{\"1141\":1}}],[\"的源码非常非常少\",{\"1\":{\"678\":1}}],[\"的源码我们就知道\",{\"1\":{\"727\":1}}],[\"的源码\",{\"1\":{\"604\":1,\"999\":1}}],[\"的成员变量\",{\"1\":{\"601\":1}}],[\"的成本远高于\",{\"1\":{\"479\":1}}],[\"的读请求都能得到一致性的结果\",{\"1\":{\"1069\":1}}],[\"的读锁\",{\"1\":{\"871\":1}}],[\"的读取操作是基于内部数组\",{\"1\":{\"589\":1}}],[\"的读写操作\",{\"1\":{\"1263\":1}}],[\"的读写\",{\"1\":{\"147\":1,\"691\":1}}],[\"的尾部\",{\"1\":{\"588\":1}}],[\"的尾部插入元素\",{\"1\":{\"588\":1,\"729\":1}}],[\"的策略\",{\"1\":{\"584\":1,\"588\":1,\"793\":1}}],[\"的机器\",{\"1\":{\"1355\":1}}],[\"的机器的\",{\"1\":{\"22\":1}}],[\"的机制\",{\"1\":{\"579\":1}}],[\"的位置的值\",{\"1\":{\"693\":1}}],[\"的位置\",{\"1\":{\"571\":1,\"1037\":1}}],[\"的位的数量\",{\"1\":{\"202\":1}}],[\"的无锁实现起来比较复杂\",{\"1\":{\"1184\":1}}],[\"的无参构造探寻\",{\"1\":{\"570\":1}}],[\"的无限的可能性\",{\"1\":{\"377\":1}}],[\"的个数\",{\"1\":{\"692\":1}}],[\"的个数一但初始化就不能改变\",{\"1\":{\"579\":1}}],[\"的个数一旦初始化就不能改变\",{\"1\":{\"569\":1,\"690\":1}}],[\"的个数一旦设置\",{\"1\":{\"267\":1}}],[\"的个数是\",{\"1\":{\"569\":1}}],[\"的列表迭代器\",{\"1\":{\"553\":1}}],[\"的古老实现类\",{\"1\":{\"550\":1,\"650\":1}}],[\"的主题\",{\"1\":{\"1286\":1}}],[\"的主题内使用\",{\"1\":{\"1285\":1}}],[\"的主题并且它有两个分区\",{\"1\":{\"1199\":1}}],[\"的主键等天然的幂等功能\",{\"1\":{\"1207\":1}}],[\"的主要区别在于底层数据结构不同\",{\"1\":{\"665\":1}}],[\"的主要实现类\",{\"1\":{\"550\":1,\"650\":1}}],[\"的主体\",{\"1\":{\"616\":1,\"645\":2,\"688\":1}}],[\"的主程序入口\",{\"1\":{\"425\":1}}],[\"的底层原理了解吗\",{\"0\":{\"874\":1}}],[\"的底层就是由\",{\"1\":{\"857\":1,\"1002\":1}}],[\"的底层数据结构类似都是采用\",{\"1\":{\"688\":1}}],[\"的底层数据结构是链表和哈希表\",{\"1\":{\"665\":1}}],[\"的底层数据结构是哈希表\",{\"1\":{\"665\":1}}],[\"的底层核心源码\",{\"1\":{\"586\":1,\"600\":1,\"727\":1}}],[\"的底层源码\",{\"1\":{\"553\":1}}],[\"的底层是数组队列\",{\"1\":{\"549\":1}}],[\"的底层实现\",{\"0\":{\"681\":1}}],[\"的底层实现是什么\",{\"0\":{\"256\":1}}],[\"的底层实现变为\",{\"1\":{\"174\":1}}],[\"的存在\",{\"1\":{\"1368\":1}}],[\"的存储机制和刷盘策略\",{\"1\":{\"1316\":1}}],[\"的存储架构还有些模糊\",{\"1\":{\"1315\":1}}],[\"的存储\",{\"1\":{\"690\":1}}],[\"的存储结构如上图\",{\"1\":{\"569\":1}}],[\"的存储结构做了优化\",{\"1\":{\"205\":1}}],[\"的存放位置\",{\"1\":{\"573\":2}}],[\"的存和取的\",{\"1\":{\"535\":1}}],[\"的步骤大致类似\",{\"1\":{\"535\":1}}],[\"的细节前\",{\"1\":{\"534\":1}}],[\"的细节交由其子类即我们的\",{\"1\":{\"533\":1}}],[\"的分析就结束了\",{\"1\":{\"533\":1}}],[\"的分布式高性能\",{\"1\":{\"244\":1}}],[\"的分布式可重入锁\",{\"1\":{\"49\":1}}],[\"的抽象类\",{\"1\":{\"533\":1}}],[\"的工作负载分布\",{\"1\":{\"1139\":1}}],[\"的工作原理了解么\",{\"0\":{\"1130\":1}}],[\"的工作方式\",{\"1\":{\"968\":1}}],[\"的工作机制了\",{\"1\":{\"532\":1}}],[\"的工作流程如下图所示\",{\"1\":{\"69\":1}}],[\"的工作流程\",{\"0\":{\"69\":1},\"1\":{\"69\":1,\"604\":1,\"712\":1}}],[\"的缘故\",{\"1\":{\"531\":1}}],[\"的阻塞队列\",{\"1\":{\"531\":1}}],[\"的阻塞点\",{\"1\":{\"166\":1}}],[\"的操刀之下已将阻塞队列的细节屏蔽\",{\"1\":{\"530\":1}}],[\"的操作已经和系统\",{\"1\":{\"1304\":1}}],[\"的操作结果的可能\",{\"1\":{\"840\":1,\"989\":1}}],[\"的操作来减少\",{\"1\":{\"752\":1,\"908\":1}}],[\"的操作添加元素\",{\"1\":{\"653\":1}}],[\"的操作将原数组复制到新的更大的数组中\",{\"1\":{\"653\":1}}],[\"的操作\",{\"1\":{\"444\":1,\"1308\":1,\"1310\":1}}],[\"的映射关系\",{\"1\":{\"498\":1}}],[\"的映射表\",{\"1\":{\"184\":1,\"195\":1}}],[\"的实际应用\",{\"1\":{\"1069\":1}}],[\"的实例\",{\"1\":{\"658\":1}}],[\"的实例来减少不必要的内存使用\",{\"1\":{\"485\":1}}],[\"的实现方法\",{\"1\":{\"949\":1}}],[\"的实现来使用\",{\"1\":{\"796\":1}}],[\"的实现看\",{\"1\":{\"742\":1,\"758\":1}}],[\"的实现是基于\",{\"1\":{\"755\":1,\"910\":1}}],[\"的实现是线程安全的\",{\"1\":{\"608\":1}}],[\"的实现是否线程安全\",{\"0\":{\"608\":1}}],[\"的实现没有进行重大变化\",{\"1\":{\"598\":1}}],[\"的实现进行了一些微小的改进\",{\"1\":{\"598\":1}}],[\"的实现进行了进一步的优化\",{\"1\":{\"598\":1}}],[\"的实现进行了优化\",{\"1\":{\"598\":1}}],[\"的实现类有下面这些\",{\"1\":{\"1140\":1}}],[\"的实现类有哪些\",{\"0\":{\"671\":1}}],[\"的实现类提交给\",{\"1\":{\"934\":1}}],[\"的实现类\",{\"1\":{\"597\":1,\"671\":1,\"796\":2,\"900\":1}}],[\"的实现类的\",{\"1\":{\"359\":1}}],[\"的实现原理\",{\"1\":{\"941\":1}}],[\"的实现原理主要分为以下几点\",{\"1\":{\"544\":1}}],[\"的实现原理是什么\",{\"0\":{\"544\":1,\"607\":1}}],[\"的实现\",{\"1\":{\"359\":2,\"387\":1,\"533\":1,\"953\":1,\"957\":1,\"1131\":1,\"1253\":1,\"1292\":1}}],[\"的实现为一个双向链表\",{\"1\":{\"195\":1}}],[\"的实现为一个\",{\"1\":{\"180\":1}}],[\"的阈值是size\",{\"1\":{\"1038\":1}}],[\"的阈值\",{\"1\":{\"480\":1}}],[\"的误解\",{\"1\":{\"480\":1}}],[\"的默认重试机制文章很多\",{\"1\":{\"1208\":1}}],[\"的默认值即为\",{\"1\":{\"1206\":1}}],[\"的默认值为\",{\"1\":{\"619\":1,\"1206\":1}}],[\"的默认大小取决于平台\",{\"1\":{\"480\":1}}],[\"的默认占比为\",{\"1\":{\"443\":1}}],[\"的堆内存大小\",{\"1\":{\"478\":1}}],[\"的栈参数调优\",{\"0\":{\"457\":1}}],[\"的最主要原因\",{\"1\":{\"1159\":1}}],[\"的最大线程数是\",{\"1\":{\"892\":1,\"938\":1}}],[\"的最大大小\",{\"1\":{\"480\":1,\"496\":1}}],[\"的最大限制\",{\"1\":{\"449\":1,\"451\":1}}],[\"的最小大小为\",{\"1\":{\"479\":1}}],[\"的最小限制\",{\"1\":{\"449\":1,\"451\":1}}],[\"的占比为\",{\"1\":{\"454\":1}}],[\"的占\",{\"1\":{\"444\":3}}],[\"的代码实现被修改重建了好几次\",{\"1\":{\"1144\":1}}],[\"的代码修改成下面这样就不会产生死锁了\",{\"1\":{\"824\":1}}],[\"的代码时\",{\"1\":{\"496\":1}}],[\"的代码\",{\"1\":{\"433\":1}}],[\"的引用保存在字符串常量池中\",{\"1\":{\"498\":1}}],[\"的引用找到\",{\"1\":{\"425\":1}}],[\"的引用\",{\"1\":{\"425\":1,\"498\":1}}],[\"的类型为\",{\"1\":{\"779\":1,\"780\":1}}],[\"的类定义如下\",{\"1\":{\"586\":1,\"600\":1,\"727\":1}}],[\"的类图\",{\"1\":{\"533\":1}}],[\"的类信息加载到运行时数据区的方法区内\",{\"1\":{\"425\":1}}],[\"的类加载委托机制\",{\"1\":{\"359\":1}}],[\"的类加载器\",{\"1\":{\"359\":1}}],[\"的类加载器的层次结构\",{\"1\":{\"359\":1}}],[\"的类加载器的层次结构如下\",{\"1\":{\"359\":1}}],[\"的调优主要就是围绕堆\",{\"1\":{\"424\":1}}],[\"的相关\",{\"1\":{\"918\":1}}],[\"的相关内容推荐阅读\",{\"1\":{\"857\":1}}],[\"的相关实现类\",{\"1\":{\"796\":1}}],[\"的相关知识点\",{\"1\":{\"412\":1}}],[\"的相关信息\",{\"1\":{\"366\":1}}],[\"的由来\",{\"1\":{\"407\":1,\"1343\":1}}],[\"的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作\",{\"1\":{\"401\":1}}],[\"的标记位设置为\",{\"1\":{\"396\":1}}],[\"的条件则相对苛刻许多\",{\"1\":{\"394\":1}}],[\"的对应关系也都是由\",{\"1\":{\"1199\":1}}],[\"的对象分为以下几种\",{\"1\":{\"445\":1}}],[\"的对象什么时候垃圾回收呢\",{\"1\":{\"444\":1}}],[\"的对象\",{\"1\":{\"396\":1,\"669\":1}}],[\"的对象作为起点\",{\"1\":{\"391\":1}}],[\"的对象就是不可能再被使用的\",{\"1\":{\"390\":1}}],[\"的对比\",{\"1\":{\"244\":1}}],[\"的区域\",{\"0\":{\"387\":1},\"1\":{\"435\":1}}],[\"的区别主要体现在实现线程安全的方式上不同\",{\"1\":{\"688\":1}}],[\"的区别在于元素出队顺序是与优先级相关的\",{\"1\":{\"669\":1}}],[\"的区别\",{\"0\":{\"550\":1,\"649\":1,\"650\":1,\"651\":1,\"661\":1,\"667\":1,\"668\":1,\"677\":1,\"688\":1}}],[\"的区别和共同点\",{\"0\":{\"245\":1},\"1\":{\"245\":1}}],[\"的区别是什么\",{\"0\":{\"611\":1}}],[\"的区别是\",{\"1\":{\"117\":1}}],[\"的官网阅读相关的虚拟机参数\",{\"1\":{\"386\":1}}],[\"的官方文档中也指出\",{\"1\":{\"1359\":1}}],[\"的官方集群解决方案\",{\"1\":{\"1085\":2}}],[\"的官方\",{\"1\":{\"42\":1}}],[\"的官方介绍\",{\"1\":{\"40\":1}}],[\"的永久代\",{\"1\":{\"384\":1,\"480\":1,\"496\":1}}],[\"的自动内存管理主要是针对对象内存的回收和对象内存的分配\",{\"1\":{\"382\":1}}],[\"的使用吧\",{\"1\":{\"1332\":1}}],[\"的使用以及开源\",{\"1\":{\"1331\":1}}],[\"的使用简单\",{\"1\":{\"747\":1,\"905\":1}}],[\"的使用概率不算很大\",{\"1\":{\"708\":1}}],[\"的使用场景有哪些\",{\"0\":{\"609\":1}}],[\"的使用\",{\"1\":{\"377\":1,\"531\":1,\"1331\":1}}],[\"的使用非常简单\",{\"1\":{\"205\":1}}],[\"的软件说明中写上了\",{\"1\":{\"377\":1}}],[\"的图形用户界面中\",{\"1\":{\"377\":1}}],[\"的慢\",{\"1\":{\"375\":1}}],[\"的速度一般会比\",{\"1\":{\"375\":1}}],[\"的速度比较慢\",{\"1\":{\"42\":2}}],[\"的可靠性保证会频繁触发消息重试机制造成大量重复消息\",{\"1\":{\"1292\":1}}],[\"的可重入性的应用\",{\"1\":{\"1019\":1}}],[\"的可重入性是\",{\"1\":{\"1018\":1}}],[\"的可重入应用\",{\"0\":{\"1018\":1}}],[\"的可视化监视\",{\"1\":{\"372\":1}}],[\"的可扩展\",{\"1\":{\"9\":1}}],[\"的监视器锁的占用\",{\"1\":{\"824\":1}}],[\"的监视器锁\",{\"1\":{\"370\":2,\"823\":2,\"824\":2}}],[\"的参数非常之多\",{\"1\":{\"449\":1}}],[\"的参数\",{\"1\":{\"367\":2,\"451\":1,\"485\":1,\"1313\":1}}],[\"的业务类\",{\"1\":{\"359\":1}}],[\"的接口的类加载器\",{\"1\":{\"359\":1}}],[\"的接口\",{\"1\":{\"359\":1,\"667\":2}}],[\"的共享和隔离\",{\"1\":{\"359\":1}}],[\"的核心特性\",{\"1\":{\"1236\":1}}],[\"的核心概念和比较常用的一些\",{\"1\":{\"788\":1}}],[\"的核心原理图\",{\"1\":{\"742\":1,\"904\":1}}],[\"的核心逻辑\",{\"1\":{\"533\":1}}],[\"的核心\",{\"1\":{\"358\":1}}],[\"的小\",{\"1\":{\"939\":1}}],[\"的小案例\",{\"1\":{\"353\":1}}],[\"的小版本号\",{\"1\":{\"325\":1,\"327\":1}}],[\"的需要\",{\"1\":{\"351\":1}}],[\"的全部数据的意思\",{\"1\":{\"1263\":1}}],[\"的全部约束要求\",{\"1\":{\"341\":1}}],[\"的全称是\",{\"1\":{\"841\":1,\"990\":1,\"995\":1}}],[\"的全称为\",{\"1\":{\"740\":1,\"903\":1}}],[\"的全局唯一性肯定是首先要满足的\",{\"1\":{\"30\":1}}],[\"的取值\",{\"1\":{\"331\":2}}],[\"的常用参数\",{\"0\":{\"449\":1}}],[\"的常量值等\",{\"1\":{\"328\":1}}],[\"的常见同步工具类\",{\"1\":{\"745\":1}}],[\"的常见操作后\",{\"1\":{\"533\":1}}],[\"的常见处理以及优化办法如下\",{\"1\":{\"294\":1,\"299\":1}}],[\"的常见应用场景如下\",{\"1\":{\"254\":1,\"259\":1}}],[\"的文件结构\",{\"1\":{\"334\":1}}],[\"的文件\",{\"1\":{\"324\":1}}],[\"的生产者是可以重复利用的底层资源\",{\"1\":{\"1290\":1}}],[\"的生产者和主题是多对多的关系\",{\"1\":{\"1289\":1}}],[\"的生产者生产消息并最终投递到队列中\",{\"1\":{\"1250\":1}}],[\"的生态系统\",{\"1\":{\"1172\":1}}],[\"的生命周期\",{\"1\":{\"319\":1}}],[\"的生成规则是不同的\",{\"1\":{\"37\":1}}],[\"的生成速度要快\",{\"1\":{\"30\":1}}],[\"的生成本质\",{\"1\":{\"23\":1}}],[\"的应用程序中尤其地明显\",{\"1\":{\"1362\":1}}],[\"的应用程序中尤其地高性能\",{\"1\":{\"1344\":1}}],[\"的应用场景\",{\"1\":{\"1019\":1}}],[\"的应用场景是什么\",{\"0\":{\"259\":1}}],[\"的应用场景有哪些\",{\"0\":{\"254\":1}}],[\"的应该分布到哪个哈希槽中\",{\"1\":{\"318\":1}}],[\"的哈希槽是\",{\"1\":{\"318\":1}}],[\"的访问标记\",{\"1\":{\"325\":1,\"329\":1}}],[\"的访问情况进行记录分析\",{\"1\":{\"298\":1}}],[\"的访问次数比较多且明显多于其他\",{\"1\":{\"296\":1}}],[\"的出现就是为了让你调用远程方法像调用本地方法一样简单\",{\"1\":{\"1165\":1}}],[\"的出现让上述问题得到了解决\",{\"1\":{\"1123\":1}}],[\"的出现\",{\"1\":{\"298\":1,\"1122\":1,\"1168\":1}}],[\"的处理方式\",{\"1\":{\"1368\":2}}],[\"的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置\",{\"1\":{\"444\":1}}],[\"的处理\",{\"1\":{\"298\":1,\"1370\":1}}],[\"的处理能力\",{\"1\":{\"297\":1}}],[\"的发音为\",{\"1\":{\"727\":1}}],[\"的发现与处理\",{\"1\":{\"320\":1}}],[\"的发现\",{\"1\":{\"298\":1}}],[\"的发展史主要是通过优化其实现方式和提高其性能和可靠性\",{\"1\":{\"598\":1}}],[\"的发展\",{\"1\":{\"244\":1}}],[\"的被访问次数\",{\"1\":{\"298\":1}}],[\"的每秒访问量就高达\",{\"1\":{\"296\":1}}],[\"的影响\",{\"1\":{\"293\":1}}],[\"的是有区别的\",{\"1\":{\"287\":1}}],[\"的顺序节点生成全局唯一\",{\"1\":{\"1346\":1}}],[\"的顺序不是遵守严格的时间顺序\",{\"1\":{\"797\":1}}],[\"的顺序一致\",{\"1\":{\"286\":1}}],[\"的顺序执行\",{\"1\":{\"280\":1}}],[\"的命令\",{\"1\":{\"280\":1}}],[\"的瓶颈主要受限于内存和网络\",{\"1\":{\"267\":1}}],[\"的基本使用\",{\"1\":{\"1319\":1}}],[\"的基本概念我们就介绍完毕了\",{\"1\":{\"1251\":1}}],[\"的基本特性和\",{\"1\":{\"999\":1}}],[\"的基本介绍\",{\"0\":{\"417\":1}}],[\"的基础重写了\",{\"1\":{\"715\":1}}],[\"的基础上做了优化\",{\"1\":{\"1161\":1}}],[\"的基础上\",{\"1\":{\"708\":1}}],[\"的基础上为\",{\"1\":{\"708\":1}}],[\"的基础之上做了一层封装的应用\",{\"1\":{\"7\":1}}],[\"的基石\",{\"1\":{\"265\":1}}],[\"的一系列语义消息\",{\"1\":{\"1314\":1}}],[\"的一部分\",{\"1\":{\"1196\":1}}],[\"的一些概念\",{\"1\":{\"1341\":1}}],[\"的一些基础概念\",{\"1\":{\"1341\":1}}],[\"的一些配置信息\",{\"1\":{\"1263\":1}}],[\"的一些高级性能\",{\"1\":{\"873\":1}}],[\"的一些常见问题分析与解决办法\",{\"1\":{\"412\":1}}],[\"的一个顶级项目\",{\"1\":{\"1276\":1}}],[\"的一个完整镜像\",{\"1\":{\"1263\":1}}],[\"的一个变种\",{\"1\":{\"1097\":1,\"1099\":1}}],[\"的一个子类\",{\"1\":{\"715\":1}}],[\"的一个内部类\",{\"1\":{\"634\":1}}],[\"的一个即时编译器\",{\"1\":{\"6\":1}}],[\"的一种\",{\"1\":{\"597\":1}}],[\"的一半大小来确定从链表头还是尾开始遍历\",{\"1\":{\"730\":1}}],[\"的一半\",{\"1\":{\"255\":1,\"730\":1}}],[\"的缓存\",{\"1\":{\"254\":1,\"1184\":1}}],[\"的都是阻塞式\",{\"1\":{\"251\":1}}],[\"的热门站点列表\",{\"1\":{\"242\":1}}],[\"的优势在哪里\",{\"0\":{\"1191\":1}}],[\"的优化\",{\"1\":{\"854\":1}}],[\"的优点\",{\"1\":{\"235\":1}}],[\"的优缺点这里就不分析了\",{\"1\":{\"42\":1}}],[\"的优缺点\",{\"1\":{\"37\":1,\"236\":1}}],[\"的过半机制导致不可能产生\",{\"1\":{\"1358\":1}}],[\"的过程给大家说一下\",{\"1\":{\"1166\":1}}],[\"的过程\",{\"1\":{\"430\":1,\"969\":1}}],[\"的过程中搞丢\",{\"1\":{\"1261\":1}}],[\"的过程中\",{\"1\":{\"319\":1}}],[\"的过期时间设置短一点比如\",{\"1\":{\"307\":1}}],[\"的过去与未来\",{\"1\":{\"233\":1}}],[\"的过滤器有哪些\",{\"0\":{\"73\":1}}],[\"的过滤器再次做处理\",{\"1\":{\"69\":1}}],[\"的比值\",{\"1\":{\"233\":1,\"452\":1,\"453\":1}}],[\"的很重要一点就是\",{\"1\":{\"224\":1,\"282\":1}}],[\"的情况等等都会有不同的处理\",{\"1\":{\"1033\":1}}],[\"的情况下\",{\"1\":{\"448\":1,\"449\":1,\"452\":1,\"503\":1,\"619\":1,\"622\":1,\"710\":1,\"1070\":1}}],[\"的情况会更少\",{\"1\":{\"408\":1}}],[\"的情况\",{\"1\":{\"219\":1,\"246\":1,\"272\":1,\"1014\":1,\"1213\":1,\"1358\":1}}],[\"的数量\",{\"1\":{\"319\":1,\"442\":1}}],[\"的数字来验证\",{\"1\":{\"234\":1}}],[\"的数据都是放在一个节点里的\",{\"1\":{\"1263\":1}}],[\"的数据还有一些没有被\",{\"1\":{\"1206\":1}}],[\"的数据结构形式加入到双端队列里\",{\"1\":{\"1012\":1}}],[\"的数据结构\",{\"0\":{\"1029\":1},\"1\":{\"688\":1,\"792\":1,\"892\":1,\"938\":1,\"961\":1,\"1350\":1}}],[\"的数据要放入的\",{\"1\":{\"571\":1}}],[\"的数据就写一个到\",{\"1\":{\"307\":1}}],[\"的数据\",{\"1\":{\"273\":1}}],[\"的数据库\",{\"1\":{\"266\":1}}],[\"的数据类型经常被用在各种排行榜的场景\",{\"1\":{\"258\":1}}],[\"的数据是保存在内存中的\",{\"1\":{\"242\":1}}],[\"的数据安全性不如\",{\"1\":{\"236\":1}}],[\"的数据可靠性\",{\"1\":{\"233\":1}}],[\"的数据需要使用大于\",{\"1\":{\"219\":1}}],[\"的数组\",{\"1\":{\"201\":1,\"212\":1,\"261\":1}}],[\"的物理内存空间大小\",{\"1\":{\"219\":1}}],[\"的计数器初始化为\",{\"1\":{\"753\":1}}],[\"的计数场景\",{\"1\":{\"207\":1}}],[\"的计数结果并不是一个精确值\",{\"1\":{\"205\":1,\"212\":1}}],[\"的场景下\",{\"1\":{\"1062\":1}}],[\"的场景几乎都可以使用\",{\"1\":{\"656\":1,\"724\":1}}],[\"的场景\",{\"1\":{\"203\":1,\"665\":1,\"1062\":1}}],[\"的场景比较多的话\",{\"1\":{\"30\":1}}],[\"的范围来获取元素的列表\",{\"1\":{\"192\":1,\"195\":1}}],[\"的原因之外\",{\"1\":{\"917\":1}}],[\"的原因应该是为了避免创建过多线程吧\",{\"1\":{\"895\":1,\"922\":1}}],[\"的原子指令\",{\"1\":{\"841\":1,\"990\":1}}],[\"的原子类都存放在java\",{\"1\":{\"762\":1}}],[\"的原生字符串\",{\"1\":{\"176\":1}}],[\"的原理是什么\",{\"0\":{\"904\":1,\"906\":1,\"908\":1,\"911\":1,\"1166\":1}}],[\"的原理是拿期望的值和原本的一个值作比较\",{\"1\":{\"765\":1}}],[\"的原理和\",{\"1\":{\"874\":1,\"1021\":1}}],[\"的原理及应用\",{\"1\":{\"742\":1,\"758\":1}}],[\"的原理以及在\",{\"1\":{\"205\":1}}],[\"的原理\",{\"1\":{\"67\":1,\"1166\":2}}],[\"的原理就能知道\",{\"1\":{\"42\":1}}],[\"的原理比较简单\",{\"1\":{\"42\":1}}],[\"的字段\",{\"1\":{\"1006\":1}}],[\"的字面意思是可循环使用\",{\"1\":{\"755\":1,\"910\":1}}],[\"的字节数据\",{\"1\":{\"451\":1}}],[\"的字节码地址\",{\"1\":{\"425\":1}}],[\"的字节码在\",{\"1\":{\"8\":1}}],[\"的字符串表示\",{\"1\":{\"176\":1}}],[\"的结果对操作\",{\"1\":{\"974\":1}}],[\"的结果应该比较大\",{\"1\":{\"895\":1,\"922\":1}}],[\"的结果就是异常的话\",{\"1\":{\"780\":1}}],[\"的结果为准\",{\"1\":{\"145\":1}}],[\"的结构类似\",{\"1\":{\"691\":1}}],[\"的结构和\",{\"1\":{\"690\":1}}],[\"的结构一样\",{\"1\":{\"688\":1}}],[\"的结构\",{\"1\":{\"331\":1,\"569\":1,\"579\":1,\"1281\":1}}],[\"的结构如下\",{\"1\":{\"325\":1}}],[\"的结合体\",{\"1\":{\"192\":1,\"195\":1}}],[\"的结合\",{\"1\":{\"174\":1}}],[\"的噩梦\",{\"1\":{\"171\":1}}],[\"的利用率等信息\",{\"1\":{\"169\":1}}],[\"的吞吐量\",{\"1\":{\"169\":1,\"1240\":1}}],[\"的检查方法如下\",{\"1\":{\"168\":1}}],[\"的内部构造\",{\"1\":{\"1276\":1}}],[\"的内部对象\",{\"1\":{\"1255\":1}}],[\"的内部元素并不是按照放入的时间排序\",{\"1\":{\"892\":1,\"938\":1,\"961\":1}}],[\"的内部类\",{\"1\":{\"748\":2,\"752\":3}}],[\"的内部结构\",{\"1\":{\"688\":1}}],[\"的内部数据\",{\"1\":{\"584\":1,\"793\":1}}],[\"的内部可以进行扩容\",{\"1\":{\"569\":1}}],[\"的内置类加载器本身没有父类加载器\",{\"1\":{\"356\":1}}],[\"的内存模型实现总是从\",{\"1\":{\"972\":1}}],[\"的内存地址\",{\"1\":{\"765\":1}}],[\"的内存已用尽时\",{\"1\":{\"503\":1}}],[\"的内存区域\",{\"1\":{\"492\":1}}],[\"的内存我们的参数应该这样来写\",{\"1\":{\"479\":1}}],[\"的内存空间又变回\",{\"1\":{\"451\":1}}],[\"的内存\",{\"1\":{\"219\":1,\"479\":2,\"492\":1}}],[\"的内存使用过大\",{\"1\":{\"167\":1}}],[\"的内容为<term\",{\"1\":{\"1110\":1}}],[\"的内容时\",{\"1\":{\"585\":1,\"793\":1}}],[\"的内容写到\",{\"1\":{\"235\":1}}],[\"的内容\",{\"1\":{\"86\":1,\"325\":1}}],[\"的流量\",{\"1\":{\"163\":1,\"292\":1}}],[\"的大了\",{\"1\":{\"1380\":1}}],[\"的大小\",{\"1\":{\"480\":1}}],[\"的大小是\",{\"1\":{\"163\":1,\"292\":1}}],[\"的大版本号\",{\"1\":{\"325\":1,\"327\":1}}],[\"的大多数核心服务功能\",{\"1\":{\"82\":1}}],[\"的性能和吞吐量\",{\"1\":{\"1313\":1}}],[\"的性能比较差\",{\"1\":{\"1240\":1}}],[\"的性能最差\",{\"1\":{\"1240\":1}}],[\"的性能为什么更好\",{\"0\":{\"872\":1}}],[\"的性能更好\",{\"1\":{\"838\":1,\"987\":1}}],[\"的性能才是最高的\",{\"1\":{\"687\":1}}],[\"的性能是最低的\",{\"1\":{\"687\":1}}],[\"的性能存在疑问\",{\"1\":{\"579\":1}}],[\"的性能分析功能甚至比起\",{\"1\":{\"377\":1}}],[\"的性能有一点影响\",{\"1\":{\"293\":1}}],[\"的性能瓶颈不在\",{\"1\":{\"266\":1}}],[\"的性能产生影响\",{\"1\":{\"220\":1}}],[\"的性能\",{\"1\":{\"161\":1,\"231\":1,\"391\":1}}],[\"的性能要优于\",{\"1\":{\"10\":1}}],[\"的配置来决定何时将系统内核缓存区的数据同步到硬盘中的\",{\"1\":{\"229\":1}}],[\"的配置文件中存在三种不同的\",{\"1\":{\"161\":1,\"231\":1,\"282\":1}}],[\"的配置在配置文件中靠前\",{\"1\":{\"71\":1}}],[\"的增大\",{\"1\":{\"157\":1,\"301\":1}}],[\"的交集\",{\"1\":{\"157\":1,\"301\":1}}],[\"的功能更全面\",{\"1\":{\"1240\":1}}],[\"的功能点\",{\"1\":{\"1132\":1}}],[\"的功能\",{\"1\":{\"146\":1}}],[\"的问题\",{\"1\":{\"145\":1,\"146\":1,\"889\":1,\"1177\":1}}],[\"的缺陷\",{\"1\":{\"145\":1}}],[\"的话我们在上面伪代码中加入\",{\"1\":{\"1275\":1}}],[\"的话才需要清理内存碎片\",{\"1\":{\"219\":1}}],[\"的话\",{\"1\":{\"145\":1,\"147\":1,\"289\":1,\"296\":1,\"654\":1,\"693\":1,\"748\":2,\"752\":1,\"767\":1,\"781\":1,\"906\":2,\"1070\":2,\"1074\":2,\"1123\":1,\"1144\":1,\"1155\":1,\"1157\":1,\"1177\":1,\"1202\":1,\"1206\":1,\"1380\":1,\"1388\":1}}],[\"的记录进行删除增加修改\",{\"1\":{\"1275\":1}}],[\"的记录\",{\"1\":{\"117\":1,\"884\":1}}],[\"的记录一条条取出来回表\",{\"1\":{\"117\":1}}],[\"的叶子节点中只存了索引列和主键的信息\",{\"1\":{\"114\":1}}],[\"的查询复杂度\",{\"1\":{\"97\":1}}],[\"的行\",{\"1\":{\"89\":1}}],[\"的能力\",{\"1\":{\"89\":1,\"816\":1}}],[\"的错误提醒\",{\"1\":{\"86\":1}}],[\"的语法\",{\"1\":{\"86\":1}}],[\"的适配模块\",{\"1\":{\"76\":1}}],[\"的时机由操作系统决定\",{\"1\":{\"161\":1,\"231\":1}}],[\"的时候突然挂了\",{\"1\":{\"1380\":1}}],[\"的时候介绍到\",{\"1\":{\"1249\":1}}],[\"的时候会介绍到\",{\"1\":{\"1237\":1}}],[\"的时候做数据兜底\",{\"1\":{\"1207\":1}}],[\"的时候都会分配一个特定的偏移量\",{\"1\":{\"1202\":1,\"1205\":1}}],[\"的时候都会采用尾加法\",{\"1\":{\"1202\":1}}],[\"的时候就已经默认它是一个非常优秀的消息队列了\",{\"1\":{\"1191\":1}}],[\"的时候就会走到这里\",{\"1\":{\"941\":1}}],[\"的时候可以再次获取这个对象的锁\",{\"1\":{\"860\":1}}],[\"的时候恢复现场\",{\"1\":{\"821\":1}}],[\"的时候原来需要遍历\",{\"1\":{\"800\":1}}],[\"的时候才会被执行\",{\"1\":{\"498\":1}}],[\"的时候才对数据进行过期检查\",{\"1\":{\"272\":1}}],[\"的时候和该数组的元素类型的\",{\"1\":{\"340\":1,\"351\":1}}],[\"的时候开始清理\",{\"1\":{\"220\":2}}],[\"的时候应该格外注意\",{\"1\":{\"156\":1}}],[\"的时候不存在线程安全问题\",{\"1\":{\"145\":1}}],[\"的时候同样更新\",{\"1\":{\"145\":2}}],[\"的时候却一脸懵逼\",{\"1\":{\"144\":1}}],[\"的时候\",{\"1\":{\"72\":1,\"144\":1,\"327\":1,\"408\":1,\"412\":1,\"444\":1,\"480\":1,\"496\":1,\"683\":1,\"688\":2,\"694\":1,\"747\":1,\"749\":1,\"752\":1,\"792\":2,\"816\":1,\"890\":1,\"905\":1,\"936\":1,\"1013\":1,\"1015\":1,\"1026\":1,\"1030\":1,\"1068\":1,\"1152\":1,\"1263\":2,\"1335\":1,\"1341\":1}}],[\"的时间段内不会占用\",{\"1\":{\"895\":1,\"922\":1}}],[\"的时间片分配\",{\"1\":{\"819\":1}}],[\"的时间复杂度内插入元素和删除堆顶元素\",{\"1\":{\"669\":1}}],[\"的时间复杂度更小\",{\"1\":{\"157\":2,\"301\":2}}],[\"的时间\",{\"1\":{\"22\":1,\"98\":1,\"820\":1}}],[\"的断言\",{\"1\":{\"71\":1}}],[\"的断言是什么\",{\"0\":{\"70\":1}}],[\"的封装更加完善\",{\"1\":{\"53\":1,\"1332\":1}}],[\"的激烈辩论\",{\"1\":{\"51\":1}}],[\"的值又是多少呢\",{\"1\":{\"1210\":1}}],[\"的值调用\",{\"1\":{\"1210\":1}}],[\"的值不同\",{\"1\":{\"1015\":1}}],[\"的值不正确\",{\"1\":{\"686\":1}}],[\"的值比\",{\"1\":{\"949\":1}}],[\"的值写回内存\",{\"1\":{\"835\":3}}],[\"的值应该是\",{\"1\":{\"835\":1}}],[\"的值时\",{\"1\":{\"756\":1,\"911\":1}}],[\"的值没办法等于\",{\"1\":{\"753\":1}}],[\"的值等于\",{\"1\":{\"753\":1,\"841\":1,\"990\":1}}],[\"的值理解为许可证的数量\",{\"1\":{\"748\":1,\"906\":1}}],[\"的值变为\",{\"1\":{\"742\":1}}],[\"的值减少\",{\"1\":{\"742\":1}}],[\"的值回到\",{\"1\":{\"742\":1}}],[\"的值加\",{\"1\":{\"742\":1}}],[\"的值只增加了\",{\"1\":{\"686\":1}}],[\"的值更新为\",{\"1\":{\"686\":2}}],[\"的值也为\",{\"1\":{\"686\":1}}],[\"的值为\",{\"1\":{\"686\":1,\"767\":1,\"841\":1,\"990\":1,\"1011\":1,\"1210\":1}}],[\"的值维持在最小堆内存大小\",{\"1\":{\"451\":1}}],[\"的值就为\",{\"1\":{\"756\":1,\"911\":1}}],[\"的值就被赋值为\",{\"1\":{\"342\":1}}],[\"的值就是\",{\"1\":{\"89\":2}}],[\"的值被客户端2修改了\",{\"1\":{\"280\":1}}],[\"的值越大代表内存碎片率越严重\",{\"1\":{\"219\":1}}],[\"的值并不是递增的\",{\"1\":{\"96\":1}}],[\"的值是否为\",{\"1\":{\"752\":1}}],[\"的值是\",{\"1\":{\"89\":3,\"1210\":1}}],[\"的值和过期时间是一个原子操作\",{\"1\":{\"48\":1}}],[\"的值\",{\"1\":{\"47\":1,\"117\":2,\"157\":1,\"177\":5,\"280\":1,\"286\":2,\"301\":1,\"319\":1,\"535\":1,\"748\":3,\"752\":1,\"835\":1,\"841\":1,\"882\":1,\"906\":3,\"990\":1,\"1006\":2,\"1011\":1}}],[\"的值都是\",{\"1\":{\"23\":1}}],[\"的设计初衷\",{\"1\":{\"1202\":1}}],[\"的设计导致其几乎没有服务治理能力\",{\"1\":{\"1170\":1}}],[\"的设计更加精简\",{\"1\":{\"1169\":1}}],[\"的设计就是一个比较棘手的问题\",{\"1\":{\"708\":1}}],[\"的设计和实现\",{\"1\":{\"231\":1}}],[\"的设计也非常有帮助\",{\"1\":{\"43\":1}}],[\"的设计\",{\"0\":{\"708\":1},\"1\":{\"43\":1,\"708\":1}}],[\"的设计与实现\",{\"1\":{\"2\":1}}],[\"的线程被中断\",{\"1\":{\"908\":1}}],[\"的线程是映射到操作系统的原生线程之上的\",{\"1\":{\"847\":1}}],[\"的线程上下文\",{\"1\":{\"821\":1}}],[\"的线程安全版本\",{\"1\":{\"792\":1,\"799\":1}}],[\"的线程就会被唤醒\",{\"1\":{\"753\":1}}],[\"的线程模型也基于\",{\"1\":{\"265\":1}}],[\"的线程\",{\"1\":{\"41\":1}}],[\"的组成不太一样\",{\"1\":{\"40\":1}}],[\"的唯一元素就是这个数组\",{\"1\":{\"634\":1}}],[\"的唯一计数\",{\"1\":{\"206\":1,\"262\":1}}],[\"的唯一\",{\"1\":{\"40\":1}}],[\"的二进制文件\",{\"1\":{\"425\":1}}],[\"的二进制被分成了几部分\",{\"1\":{\"38\":1}}],[\"的二进制数字组成\",{\"1\":{\"38\":1}}],[\"的算法会造成\",{\"1\":{\"37\":1}}],[\"的介绍中有提到\",{\"1\":{\"285\":1}}],[\"的介绍\",{\"1\":{\"37\":1,\"585\":1,\"1096\":1}}],[\"的方案已经不能在第二阶段被批准了\",{\"1\":{\"1375\":1}}],[\"的方法去向每个队列中生产数据以达到\",{\"1\":{\"1281\":1}}],[\"的方法用于实现不同的效果\",{\"1\":{\"781\":1}}],[\"的方法的参数是\",{\"1\":{\"779\":1}}],[\"的方法是的参数是\",{\"1\":{\"779\":1}}],[\"的方法上\",{\"1\":{\"533\":1}}],[\"的方法并实现后\",{\"1\":{\"533\":1}}],[\"的方法多种多样以及不可靠的问题\",{\"1\":{\"41\":1}}],[\"的方法\",{\"1\":{\"37\":1,\"446\":1,\"1011\":1,\"1305\":1}}],[\"的方式来禁止特定类型的处理器重排序\",{\"1\":{\"969\":1}}],[\"的方式来禁止指令重排序\",{\"1\":{\"834\":1}}],[\"的方式来说\",{\"1\":{\"713\":1}}],[\"的方式在本地内存上分配的\",{\"1\":{\"499\":1}}],[\"的方式\",{\"1\":{\"7\":1,\"629\":1,\"887\":1,\"1286\":1}}],[\"的缩写\",{\"1\":{\"37\":1,\"417\":1,\"1371\":1}}],[\"的混合持久化\",{\"1\":{\"35\":1,\"224\":1,\"235\":1,\"263\":1,\"282\":1}}],[\"的\",{\"0\":{\"692\":1,\"1131\":1},\"1\":{\"35\":1,\"37\":2,\"38\":1,\"56\":1,\"89\":2,\"105\":1,\"147\":1,\"163\":1,\"164\":2,\"176\":2,\"180\":1,\"184\":1,\"194\":1,\"195\":1,\"210\":1,\"231\":1,\"236\":1,\"256\":2,\"258\":1,\"291\":1,\"293\":2,\"298\":1,\"307\":1,\"353\":1,\"357\":1,\"359\":1,\"364\":1,\"365\":1,\"366\":1,\"391\":1,\"407\":1,\"421\":1,\"423\":1,\"443\":1,\"450\":1,\"497\":1,\"498\":1,\"499\":1,\"531\":3,\"533\":3,\"549\":1,\"555\":1,\"558\":1,\"570\":1,\"571\":4,\"573\":2,\"575\":1,\"586\":1,\"588\":3,\"601\":2,\"603\":1,\"605\":1,\"607\":1,\"616\":1,\"618\":8,\"629\":2,\"631\":3,\"632\":4,\"634\":2,\"656\":1,\"657\":1,\"677\":1,\"679\":1,\"682\":8,\"684\":1,\"686\":1,\"687\":1,\"688\":4,\"693\":2,\"708\":3,\"710\":1,\"711\":1,\"712\":4,\"724\":1,\"729\":1,\"732\":1,\"740\":1,\"748\":1,\"749\":1,\"752\":1,\"753\":1,\"755\":2,\"772\":1,\"777\":1,\"782\":1,\"884\":1,\"892\":1,\"894\":1,\"900\":1,\"903\":1,\"906\":1,\"908\":1,\"909\":1,\"910\":2,\"920\":1,\"934\":1,\"938\":1,\"944\":1,\"949\":2,\"950\":1,\"951\":1,\"953\":1,\"955\":1,\"958\":1,\"1004\":1,\"1007\":4,\"1011\":3,\"1016\":1,\"1019\":1,\"1078\":2,\"1083\":1,\"1096\":1,\"1111\":2,\"1112\":1,\"1122\":1,\"1152\":1,\"1159\":1,\"1166\":1,\"1182\":1,\"1199\":1,\"1207\":1,\"1212\":1,\"1231\":1,\"1237\":1,\"1238\":1,\"1249\":1,\"1271\":1,\"1281\":2,\"1299\":1,\"1303\":1,\"1314\":1,\"1315\":3,\"1322\":1,\"1350\":1,\"1353\":1,\"1358\":1,\"1380\":1,\"1381\":1}}],[\"的递增规律就能推算出每天的订单量\",{\"1\":{\"33\":1,\"34\":1}}],[\"的视图\",{\"1\":{\"21\":1}}],[\"的灵魂了\",{\"1\":{\"1359\":1}}],[\"的灵魂\",{\"1\":{\"9\":1}}],[\"的替代项目\",{\"1\":{\"8\":1}}],[\"的服务端将消息投递给消费者消费时\",{\"1\":{\"1297\":1}}],[\"的服务端负载均衡\",{\"1\":{\"1\":1}}],[\"的服务节点\",{\"1\":{\"1255\":1}}],[\"的服务可以和业务相关的服务解耦\",{\"1\":{\"30\":1}}],[\"的服务要保证可用性无限接近于\",{\"1\":{\"30\":1}}],[\"的服务器\",{\"1\":{\"7\":1}}],[\"的入门以及网关安全实战推荐阅读这篇文章\",{\"1\":{\"6\":1}}],[\"的差别不大\",{\"1\":{\"5\":1,\"68\":1}}],[\"降低系统耦合性\",{\"0\":{\"1222\":1},\"1\":{\"1219\":1}}],[\"降低系统使用\",{\"1\":{\"168\":1}}],[\"降低资源消耗\",{\"1\":{\"887\":1,\"933\":1}}],[\"降低性能\",{\"1\":{\"553\":1}}],[\"降低停顿时间是\",{\"1\":{\"407\":1}}],[\"降低了可用性\",{\"1\":{\"1314\":1}}],[\"降低了读写延迟\",{\"1\":{\"1313\":1}}],[\"降低了系统的可用性\",{\"1\":{\"1275\":1}}],[\"降低了效率\",{\"1\":{\"819\":1}}],[\"降低了资源的消耗\",{\"1\":{\"265\":1}}],[\"降低了证书更换时的复杂度\",{\"1\":{\"2\":1}}],[\"降级熔断\",{\"1\":{\"1\":1}}],[\"由来\",{\"0\":{\"1343\":1}}],[\"由客户端\",{\"1\":{\"1292\":1}}],[\"由阿里巴巴团队开发\",{\"1\":{\"1276\":1}}],[\"由交换器将消息路由到一个或者多个队列中\",{\"1\":{\"1255\":1}}],[\"由轻量级的\",{\"1\":{\"1238\":1}}],[\"由通过高性能\",{\"1\":{\"1235\":1}}],[\"由甲骨文公司主办\",{\"1\":{\"1178\":1}}],[\"由英国外汇交易公司\",{\"1\":{\"1178\":1}}],[\"由加州大学伯克利分校的\",{\"1\":{\"1066\":1}}],[\"由各个自定义同步器实现\",{\"1\":{\"1016\":1}}],[\"由inheritablethreadlocal类维护\",{\"1\":{\"883\":1}}],[\"由threadlocal类维护\",{\"1\":{\"883\":1}}],[\"由objectmonitor实现的\",{\"1\":{\"851\":1}}],[\"由上图可以看出\",{\"1\":{\"820\":1}}],[\"由操作系统内核管理和调度的线程\",{\"1\":{\"808\":1}}],[\"由操作系统内核进行线程的调度和管理\",{\"1\":{\"808\":1}}],[\"由用户空间程序管理和调度的线程\",{\"1\":{\"808\":1}}],[\"由子类实现\",{\"1\":{\"744\":1}}],[\"由comparator控制排序逻辑\",{\"1\":{\"696\":1}}],[\"由数组+链表组成的\",{\"1\":{\"645\":1}}],[\"由很多个\",{\"1\":{\"569\":1}}],[\"由此我们就能实现一个\",{\"1\":{\"718\":1}}],[\"由此我们便知道了上文中\",{\"1\":{\"533\":1}}],[\"由此\",{\"1\":{\"533\":1}}],[\"由此可见\",{\"1\":{\"246\":1,\"1341\":1}}],[\"由编译器检查发现语法错误\",{\"1\":{\"524\":1}}],[\"由默认初始化的\",{\"1\":{\"430\":1}}],[\"由bootstrapclassloader\",{\"1\":{\"359\":1}}],[\"由vm调用\",{\"1\":{\"352\":1}}],[\"由这个类加载器加载的类\",{\"1\":{\"352\":1}}],[\"由远到近\",{\"1\":{\"210\":1}}],[\"由近到远\",{\"1\":{\"210\":1}}],[\"由后台线程\",{\"1\":{\"161\":1,\"231\":1}}],[\"由\",{\"1\":{\"38\":1,\"345\":1,\"353\":2,\"616\":1,\"1052\":1,\"1072\":1,\"1108\":1,\"1110\":1,\"1349\":1,\"1367\":1}}],[\"由于协议是\",{\"1\":{\"1379\":1}}],[\"由于rocketmq\",{\"1\":{\"1315\":1}}],[\"由于业务上需求需要重新消费\",{\"1\":{\"1306\":1}}],[\"由于消费组未订阅该主题\",{\"1\":{\"1304\":1}}],[\"由于消息分布在各个\",{\"1\":{\"1281\":1}}],[\"由于消息传播的随机性\",{\"1\":{\"1090\":1}}],[\"由于服务端处理业务时间长或者网络链接等等原因让\",{\"1\":{\"1207\":1}}],[\"由于其跨语言特性和出色的性能\",{\"1\":{\"1171\":1}}],[\"由于其是\",{\"1\":{\"359\":1}}],[\"由于连接池有利于提升网络请求性能\",{\"1\":{\"1158\":1}}],[\"由于broadcasttime和mtbf是由系统决定的属性\",{\"1\":{\"1116\":1}}],[\"由于可能同一时刻出现多个\",{\"1\":{\"1111\":1}}],[\"由于状态机是确定性的\",{\"1\":{\"1106\":1}}],[\"由于兰伯特提到的\",{\"1\":{\"1099\":1}}],[\"由于拜占庭将军问题\",{\"1\":{\"1090\":1}}],[\"由于index=4桶已经有了数据\",{\"1\":{\"1037\":1}}],[\"由于极端情况下入队的非原子操作和\",{\"1\":{\"1014\":1}}],[\"由于是双向链表\",{\"1\":{\"1011\":1}}],[\"由于本篇文章不讲述\",{\"1\":{\"1005\":1}}],[\"由于篇幅原因\",{\"1\":{\"999\":1,\"1021\":1}}],[\"由于指令重排序问题\",{\"1\":{\"980\":1}}],[\"由于早期内存模型存在一些缺陷\",{\"1\":{\"971\":1}}],[\"由于内存的处理速度远远高于外存\",{\"1\":{\"968\":1}}],[\"由于内存与硬盘的读写速度差几个数量级\",{\"1\":{\"168\":1}}],[\"由于使用无界队列时\",{\"1\":{\"951\":1}}],[\"由于使用不断扩容到\",{\"1\":{\"480\":1}}],[\"由于线程池中的任务可能会被取消或抛出异常\",{\"1\":{\"924\":1}}],[\"由于线程被无限期地阻塞\",{\"1\":{\"823\":1}}],[\"由于父任务把线程池核心线程资源用完\",{\"1\":{\"919\":1}}],[\"由于需要对队列中的元素进行排序操作以及保证线程安全\",{\"1\":{\"897\":1}}],[\"由于需要将所有元素依次向前移动一个位置\",{\"1\":{\"653\":1}}],[\"由于需要将所有元素都依次向后移动一个位置\",{\"1\":{\"653\":1}}],[\"由于队列\",{\"1\":{\"1218\":1}}],[\"由于队列永远不会被放满\",{\"1\":{\"897\":1}}],[\"由于队列已满\",{\"1\":{\"531\":1}}],[\"由于该对象的锁已被当前线程所持有且无法释放\",{\"1\":{\"860\":1}}],[\"由于该命令对\",{\"1\":{\"298\":1}}],[\"由于绿色线程和原生线程比起来在使用时有一些限制\",{\"1\":{\"808\":1}}],[\"由于方法众多\",{\"1\":{\"774\":1}}],[\"由于缓存容量为\",{\"1\":{\"706\":1}}],[\"由于之前已经进行过\",{\"1\":{\"686\":1}}],[\"由于时间片耗尽挂起\",{\"1\":{\"686\":2}}],[\"由于底层调用了系统级别的拷贝指令\",{\"1\":{\"588\":1}}],[\"由于读取操作不会对原有数据进行修改\",{\"1\":{\"584\":1,\"793\":1}}],[\"由于dequeue\",{\"1\":{\"535\":1}}],[\"由于执行顺序缘故\",{\"1\":{\"430\":1}}],[\"由于多了整理这一步\",{\"1\":{\"398\":1}}],[\"由于垃圾回收器是一个优先级很低的线程\",{\"1\":{\"392\":1,\"884\":1}}],[\"由于现在收集器基本都采用分代垃圾收集算法\",{\"1\":{\"382\":1,\"495\":1}}],[\"由于字节码并不针对一种特定的机器\",{\"1\":{\"324\":1}}],[\"由于字符串是二进制安全的块\",{\"1\":{\"201\":1}}],[\"由于慢查询日志会占用一定内存空间\",{\"1\":{\"302\":1}}],[\"由于文件事件处理器\",{\"1\":{\"265\":1}}],[\"由于购物车中的商品频繁修改和变动\",{\"1\":{\"257\":1}}],[\"由于这部分内容较为重要\",{\"1\":{\"1208\":1}}],[\"由于这个数组中的所有元素在初始化时一次性全部创建\",{\"1\":{\"1184\":1}}],[\"由于这个\",{\"1\":{\"353\":1}}],[\"由于这个语句的\",{\"1\":{\"89\":1}}],[\"由于这种方式的定义存在问题\",{\"1\":{\"256\":1}}],[\"由于这些命令时间复杂度是\",{\"1\":{\"157\":1,\"301\":1}}],[\"由于在可重复读隔离级别下\",{\"1\":{\"141\":1}}],[\"由于undo版本连上的事务200和100都在\",{\"1\":{\"141\":1}}],[\"由于第二个事务的修改\",{\"1\":{\"128\":1}}],[\"由于我们前面说过的\",{\"1\":{\"89\":1}}],[\"由于订单服务位于不同的\",{\"1\":{\"60\":1}}],[\"由于默认使用\",{\"1\":{\"7\":1}}],[\"由于\",{\"1\":{\"6\":1,\"51\":1,\"89\":2,\"163\":1,\"233\":1,\"235\":1,\"292\":1,\"330\":1,\"479\":1,\"571\":1,\"621\":1,\"633\":1,\"655\":1,\"726\":1,\"860\":1,\"866\":1,\"934\":1,\"951\":1,\"1007\":2,\"1014\":1,\"1069\":1,\"1097\":1,\"1115\":1,\"1123\":1,\"1157\":1,\"1231\":1,\"1260\":1,\"1353\":1}}],[\"由于引入网关之后\",{\"1\":{\"1\":1}}],[\"由一个统一的入口管理接口\",{\"1\":{\"2\":1}}],[\"s3\",{\"1\":{\"1238\":1}}],[\"sz\",{\"1\":{\"1036\":3,\"1038\":2}}],[\"sbits\",{\"1\":{\"871\":1}}],[\"sbase\",{\"1\":{\"570\":1,\"571\":2,\"573\":1}}],[\"s2\",{\"1\":{\"781\":2,\"1141\":3,\"1144\":3}}],[\"s=list\",{\"1\":{\"633\":1}}],[\"s=\",{\"1\":{\"633\":1}}],[\"s=ft\",{\"1\":{\"621\":1}}],[\"s为m的实际元素个数\",{\"1\":{\"621\":1}}],[\"s1\",{\"1\":{\"382\":1,\"386\":1,\"444\":2,\"495\":2,\"781\":2,\"1141\":3,\"1144\":4}}],[\"s0\",{\"1\":{\"382\":1,\"386\":1,\"444\":3,\"495\":2,\"570\":2}}],[\"sweep这两个词可以看出\",{\"1\":{\"406\":1}}],[\"sweep\",{\"1\":{\"396\":2,\"406\":2}}],[\"switching\",{\"1\":{\"298\":1}}],[\"swappiness\",{\"1\":{\"168\":1}}],[\"swap\",{\"0\":{\"168\":1},\"1\":{\"168\":13,\"696\":1,\"742\":1,\"765\":1,\"841\":1,\"904\":1,\"978\":1,\"990\":1,\"995\":1}}],[\"swagger\",{\"1\":{\"2\":1}}],[\"slave\",{\"1\":{\"1281\":2,\"1354\":2,\"1355\":1}}],[\"slf4j\",{\"1\":{\"1045\":1,\"1046\":2,\"1212\":1}}],[\"slice\",{\"1\":{\"820\":1}}],[\"slow\",{\"1\":{\"302\":3}}],[\"slower\",{\"1\":{\"302\":5}}],[\"slowlog\",{\"1\":{\"302\":14}}],[\"slot位置中的entry\",{\"1\":{\"1040\":1}}],[\"slottoexpunge表示开始探测式清理过期数据的开始下标\",{\"1\":{\"1036\":1}}],[\"slottoexpunge\",{\"1\":{\"1035\":2,\"1036\":19}}],[\"slot\",{\"1\":{\"286\":4,\"287\":2,\"288\":1,\"442\":5,\"572\":1}}],[\"sleepingwaitstrategy三个中的一个\",{\"1\":{\"1183\":1}}],[\"sleepingwaitstrategy\",{\"1\":{\"1183\":1}}],[\"sleep\",{\"0\":{\"825\":1},\"1\":{\"293\":1,\"298\":1,\"370\":3,\"687\":1,\"749\":2,\"753\":2,\"757\":2,\"781\":3,\"782\":2,\"785\":1,\"820\":1,\"821\":1,\"823\":3,\"824\":1,\"825\":4,\"826\":2,\"835\":1,\"882\":2,\"940\":1,\"944\":2,\"1062\":1,\"1333\":3}}],[\"srcpos\",{\"1\":{\"561\":2}}],[\"src\",{\"1\":{\"256\":1,\"268\":1,\"498\":1,\"561\":2,\"1096\":1,\"1131\":1}}],[\"srandmember\",{\"1\":{\"189\":1,\"190\":1,\"260\":1}}],[\"si\",{\"1\":{\"625\":7}}],[\"signifies\",{\"1\":{\"624\":1}}],[\"signal\",{\"1\":{\"535\":3,\"544\":2,\"601\":1,\"603\":1,\"604\":1,\"607\":1,\"807\":1,\"1005\":1,\"1012\":2,\"1013\":2}}],[\"simplify\",{\"1\":{\"553\":1}}],[\"simpleconsumer\",{\"0\":{\"1293\":1},\"1\":{\"1293\":11}}],[\"simpledateformat\",{\"1\":{\"882\":6}}],[\"simple\",{\"1\":{\"176\":1,\"256\":1,\"1096\":3}}],[\"sizing\",{\"1\":{\"386\":1}}],[\"sizectl\",{\"1\":{\"576\":6}}],[\"sizemask\",{\"1\":{\"572\":5}}],[\"size作为新数组的大小\",{\"1\":{\"559\":1}}],[\"size大\",{\"1\":{\"559\":1}}],[\"size进行比较\",{\"1\":{\"559\":1}}],[\"size++\",{\"1\":{\"553\":2,\"557\":1,\"561\":1,\"729\":2}}],[\"size+prefix\",{\"1\":{\"218\":2}}],[\"size>threshold的时候\",{\"1\":{\"619\":1}}],[\"size>\",{\"1\":{\"478\":2,\"479\":3}}],[\"sizes数组是每个年龄段对象大小\",{\"1\":{\"386\":1,\"495\":1}}],[\"sizes\",{\"1\":{\"293\":1,\"298\":1,\"386\":1,\"495\":1,\"570\":1}}],[\"size\",{\"1\":{\"218\":12,\"233\":3,\"293\":6,\"386\":7,\"459\":1,\"478\":1,\"480\":1,\"495\":8,\"553\":57,\"555\":2,\"557\":1,\"558\":11,\"559\":6,\"561\":3,\"562\":2,\"564\":2,\"576\":1,\"590\":1,\"593\":2,\"619\":1,\"621\":2,\"625\":2,\"629\":4,\"632\":3,\"634\":3,\"658\":1,\"677\":1,\"686\":6,\"706\":1,\"708\":1,\"711\":1,\"712\":2,\"729\":1,\"730\":4,\"731\":1,\"732\":1,\"733\":3,\"909\":1,\"918\":2,\"940\":4,\"941\":1,\"1028\":3,\"1032\":1,\"1037\":3,\"1038\":2,\"1141\":1,\"1142\":1,\"1310\":1,\"1315\":1}}],[\"sismember\",{\"1\":{\"189\":2}}],[\"since\",{\"1\":{\"201\":1,\"480\":1}}],[\"sinterstore\",{\"1\":{\"189\":2,\"190\":1}}],[\"sinter\",{\"1\":{\"157\":1,\"189\":1,\"190\":1,\"301\":1,\"319\":1}}],[\"singleproducersequencer\",{\"1\":{\"1182\":1}}],[\"singlethreadexector只能创建一个线程\",{\"1\":{\"892\":1,\"938\":1}}],[\"singlethreadexector\",{\"1\":{\"892\":1,\"938\":1}}],[\"singlethreadexecutor的运行示意图\",{\"1\":{\"954\":1}}],[\"singlethreadexecutor\",{\"0\":{\"952\":1,\"955\":1},\"1\":{\"888\":1,\"889\":1,\"917\":1,\"937\":2,\"953\":2,\"954\":1,\"955\":2}}],[\"singlethreadscheduledexecutor\",{\"1\":{\"889\":1,\"892\":1,\"917\":1,\"937\":1,\"938\":1}}],[\"singletonmap\",{\"1\":{\"1293\":1}}],[\"singleton\",{\"1\":{\"834\":7}}],[\"singletonlist\",{\"1\":{\"49\":1}}],[\"single\",{\"1\":{\"120\":2,\"274\":2,\"572\":1}}],[\"skipping\",{\"1\":{\"1209\":1}}],[\"skips\",{\"1\":{\"553\":1}}],[\"skiplist\",{\"1\":{\"174\":2}}],[\"sketch\",{\"1\":{\"205\":1}}],[\"skywalking\",{\"1\":{\"8\":1}}],[\"sdk\",{\"1\":{\"1168\":1,\"1292\":4,\"1293\":1}}],[\"sdshdr\",{\"1\":{\"256\":1}}],[\"sdshdr64\",{\"1\":{\"256\":2}}],[\"sdshdr32\",{\"1\":{\"256\":2}}],[\"sdshdr16\",{\"1\":{\"256\":2}}],[\"sdshdr8\",{\"1\":{\"256\":2}}],[\"sdshdr5\",{\"1\":{\"256\":3}}],[\"sds\",{\"1\":{\"174\":2,\"176\":3,\"256\":22}}],[\"sdiff等\",{\"1\":{\"319\":1}}],[\"sdiffstore\",{\"1\":{\"189\":1,\"190\":1}}],[\"sdiff\",{\"1\":{\"157\":1,\"189\":2,\"190\":1,\"301\":1}}],[\"smtp\",{\"1\":{\"1245\":1}}],[\"small\",{\"1\":{\"218\":1,\"708\":1}}],[\"smaps\",{\"1\":{\"168\":1}}],[\"smembers\",{\"1\":{\"157\":1,\"189\":3,\"298\":7,\"301\":1,\"319\":1}}],[\"science\",{\"1\":{\"1022\":1}}],[\"scheduler\",{\"1\":{\"964\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"918\":1,\"1062\":1}}],[\"scheduledthreadexecutor\",{\"1\":{\"961\":1,\"962\":1}}],[\"scheduledthreadpoolexecutor不是\",{\"1\":{\"962\":1}}],[\"scheduledthreadpoolexecutor\",{\"0\":{\"962\":1},\"1\":{\"889\":2,\"918\":1,\"934\":7,\"937\":2,\"961\":5,\"962\":1,\"964\":2}}],[\"scheduledthreadpool\",{\"0\":{\"960\":1},\"1\":{\"888\":1,\"889\":1,\"892\":1,\"917\":1,\"937\":2,\"938\":1,\"961\":2}}],[\"scheduledexecutorservice继承executorservice接口\",{\"1\":{\"934\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"889\":1,\"918\":3,\"934\":3,\"937\":1,\"961\":2,\"964\":1,\"1062\":3}}],[\"screenexecutor\",{\"1\":{\"779\":4,\"780\":1,\"781\":1}}],[\"sc\",{\"1\":{\"576\":7}}],[\"scavengegc\",{\"1\":{\"449\":1}}],[\"scavenge\",{\"0\":{\"403\":1},\"1\":{\"385\":1,\"400\":1,\"403\":5,\"404\":1,\"405\":2,\"448\":2}}],[\"scala\",{\"1\":{\"324\":1,\"1191\":1}}],[\"scard\",{\"1\":{\"189\":2,\"190\":1,\"293\":1}}],[\"scanandlockforput\",{\"1\":{\"571\":5}}],[\"scanning\",{\"1\":{\"293\":1,\"298\":1}}],[\"scan\",{\"1\":{\"164\":1,\"293\":4,\"294\":1,\"298\":1,\"571\":1,\"1036\":1,\"1042\":1}}],[\"score2\",{\"1\":{\"193\":1}}],[\"score1\",{\"1\":{\"193\":1}}],[\"score\",{\"1\":{\"157\":1,\"192\":3,\"193\":5,\"195\":3,\"210\":1,\"301\":1,\"687\":2}}],[\"sofatracer\",{\"1\":{\"1181\":2}}],[\"soft\",{\"1\":{\"1073\":1}}],[\"softreflrupolicymspermb\",{\"1\":{\"468\":1}}],[\"softreference\",{\"1\":{\"392\":1,\"1030\":2}}],[\"sock\",{\"1\":{\"1151\":1}}],[\"socket\",{\"1\":{\"265\":3,\"285\":2,\"1151\":4,\"1166\":1,\"1308\":2,\"1310\":1,\"1311\":1}}],[\"soa\",{\"1\":{\"1125\":1}}],[\"solaris\",{\"1\":{\"808\":3,\"1053\":2}}],[\"solution\",{\"1\":{\"720\":1}}],[\"song\",{\"1\":{\"661\":1}}],[\"sort\",{\"1\":{\"634\":1,\"661\":1,\"662\":5,\"696\":2}}],[\"sorted\",{\"0\":{\"191\":1},\"1\":{\"157\":2,\"192\":2,\"193\":1,\"194\":1,\"195\":1,\"209\":1,\"210\":4,\"212\":1,\"242\":1,\"249\":2,\"258\":2,\"291\":1,\"293\":1,\"301\":2}}],[\"source\",{\"1\":{\"370\":2,\"697\":1,\"1140\":1,\"1143\":1}}],[\"sourcekey2\",{\"1\":{\"206\":1}}],[\"sourcekey1\",{\"1\":{\"206\":1}}],[\"so\",{\"1\":{\"243\":2,\"293\":2,\"302\":1,\"553\":1,\"558\":1,\"756\":1,\"767\":2,\"911\":1}}],[\"sobyte\",{\"1\":{\"237\":1}}],[\"some\",{\"1\":{\"120\":2,\"206\":3,\"298\":1,\"1042\":1}}],[\"ss\",{\"1\":{\"570\":3,\"571\":6}}],[\"ssize\",{\"1\":{\"570\":9}}],[\"sshift\",{\"1\":{\"570\":3,\"571\":2,\"573\":1}}],[\"sscan\",{\"1\":{\"157\":1,\"301\":1,\"319\":1}}],[\"ssl=false\",{\"1\":{\"373\":1}}],[\"ssl\",{\"1\":{\"2\":1,\"267\":1}}],[\"sult\",{\"1\":{\"1204\":1}}],[\"success\",{\"1\":{\"1292\":1}}],[\"succ不为\",{\"1\":{\"729\":1}}],[\"succ\",{\"1\":{\"729\":8}}],[\"supplier\",{\"1\":{\"778\":2,\"882\":1}}],[\"supplier<t>\",{\"1\":{\"778\":1}}],[\"supplier<u>\",{\"1\":{\"778\":3}}],[\"supplier<m>\",{\"1\":{\"630\":1}}],[\"supplyasync\",{\"1\":{\"776\":1,\"778\":5,\"779\":1,\"780\":2,\"781\":7,\"782\":4,\"785\":1,\"909\":2}}],[\"supposed\",{\"1\":{\"553\":1,\"564\":1}}],[\"suppresswarnings\",{\"1\":{\"535\":1,\"536\":1,\"553\":2,\"570\":1,\"571\":1,\"576\":1,\"624\":1}}],[\"super\",{\"0\":{\"330\":1},\"1\":{\"325\":1,\"330\":1,\"533\":2,\"536\":1,\"553\":1,\"619\":1,\"630\":4,\"634\":2,\"658\":1,\"663\":1,\"706\":1,\"708\":1,\"709\":4,\"767\":1,\"768\":1,\"779\":18,\"780\":3,\"781\":5,\"884\":1,\"889\":1,\"937\":1,\"961\":1,\"1047\":1,\"1212\":2}}],[\"survivorratio=6\",{\"1\":{\"485\":1}}],[\"survivorratio\",{\"1\":{\"449\":1,\"453\":1,\"485\":1}}],[\"survivor1\",{\"1\":{\"444\":1}}],[\"survivor0\",{\"1\":{\"444\":6}}],[\"survivor\",{\"0\":{\"453\":1},\"1\":{\"375\":1,\"382\":1,\"384\":1,\"386\":9,\"443\":2,\"444\":3,\"449\":5,\"452\":1,\"453\":3,\"454\":1,\"485\":2,\"495\":8}}],[\"sun\",{\"1\":{\"353\":2,\"357\":3,\"365\":1,\"373\":3,\"449\":1,\"450\":1,\"841\":1,\"940\":20,\"990\":1,\"1327\":2,\"1329\":2,\"1330\":2}}],[\"sunionstore\",{\"1\":{\"189\":1,\"190\":1}}],[\"sunion\",{\"1\":{\"157\":1,\"189\":2,\"190\":1,\"301\":1,\"319\":1}}],[\"submit\",{\"0\":{\"944\":1},\"1\":{\"900\":3,\"934\":6,\"944\":7,\"1061\":1,\"1062\":1}}],[\"subsequent\",{\"1\":{\"756\":1,\"911\":1}}],[\"subscriber\",{\"1\":{\"251\":1,\"1279\":1}}],[\"subclasses\",{\"1\":{\"354\":1}}],[\"sub\",{\"0\":{\"1229\":1},\"1\":{\"251\":6,\"1194\":1,\"1218\":1,\"1229\":2,\"1231\":2,\"1259\":1}}],[\"subquery是一个索引查找函数\",{\"1\":{\"120\":1}}],[\"subquery\",{\"1\":{\"120\":5}}],[\"suitable\",{\"1\":{\"201\":1}}],[\"sumcount\",{\"1\":{\"629\":3}}],[\"summary\",{\"1\":{\"293\":1}}],[\"sum\",{\"1\":{\"193\":1,\"629\":3,\"838\":2,\"987\":1}}],[\"salve\",{\"1\":{\"1281\":1}}],[\"san\",{\"1\":{\"625\":2}}],[\"sayname\",{\"1\":{\"425\":3}}],[\"sat\",{\"1\":{\"369\":1}}],[\"sameweight\",{\"1\":{\"1141\":4,\"1142\":5}}],[\"same\",{\"1\":{\"351\":1,\"572\":1}}],[\"sampled\",{\"1\":{\"293\":1}}],[\"sample\",{\"1\":{\"7\":1}}],[\"sadd\",{\"1\":{\"189\":4,\"260\":1,\"286\":1}}],[\"save\",{\"0\":{\"158\":1},\"1\":{\"158\":2,\"226\":3,\"227\":1}}],[\"safepoint\",{\"1\":{\"483\":1}}],[\"safe\",{\"1\":{\"89\":3,\"201\":1,\"631\":2}}],[\"sqlexception\",{\"1\":{\"524\":1}}],[\"sql语句\",{\"1\":{\"120\":1}}],[\"sql\",{\"1\":{\"83\":1,\"86\":5,\"89\":1,\"117\":1,\"353\":1,\"359\":1,\"412\":4}}],[\"symbolic\",{\"1\":{\"497\":1}}],[\"syscall\",{\"1\":{\"230\":1,\"268\":1}}],[\"sys\",{\"1\":{\"168\":1,\"1304\":2}}],[\"systems\",{\"1\":{\"1096\":1}}],[\"system\",{\"0\":{\"560\":1,\"561\":1},\"1\":{\"53\":6,\"120\":2,\"351\":1,\"353\":1,\"357\":2,\"370\":6,\"433\":1,\"449\":1,\"451\":15,\"498\":1,\"531\":11,\"551\":1,\"553\":8,\"561\":3,\"562\":2,\"563\":1,\"564\":6,\"591\":2,\"593\":10,\"599\":5,\"625\":20,\"631\":1,\"634\":6,\"649\":5,\"652\":1,\"662\":8,\"663\":1,\"679\":1,\"704\":1,\"705\":1,\"706\":1,\"713\":13,\"732\":2,\"733\":8,\"749\":2,\"753\":2,\"757\":6,\"763\":3,\"766\":4,\"767\":14,\"768\":2,\"778\":1,\"779\":3,\"780\":1,\"781\":11,\"782\":5,\"785\":1,\"807\":1,\"823\":6,\"824\":3,\"835\":1,\"851\":1,\"852\":1,\"860\":2,\"882\":2,\"909\":2,\"924\":1,\"940\":3,\"944\":2,\"974\":1,\"1020\":1,\"1028\":2,\"1030\":3,\"1043\":2,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":4,\"1132\":1,\"1213\":1,\"1252\":1,\"1293\":1}}],[\"sync\",{\"1\":{\"747\":2,\"748\":12,\"752\":10,\"857\":5,\"865\":1,\"905\":2,\"906\":2,\"999\":1,\"1002\":2,\"1007\":4,\"1008\":1,\"1014\":3,\"1018\":1,\"1020\":6,\"1313\":1}}],[\"synchronization\",{\"1\":{\"1356\":1}}],[\"synchronizer\",{\"1\":{\"807\":1,\"1022\":1}}],[\"synchronized的使用方式\",{\"1\":{\"1001\":1}}],[\"synchronized关键字与wait\",{\"1\":{\"862\":1}}],[\"synchronized关键字原理\",{\"1\":{\"851\":1,\"852\":1}}],[\"synchronized锁是可重入的\",{\"1\":{\"860\":1}}],[\"synchronizeddemo2\",{\"1\":{\"852\":1}}],[\"synchronizeddemo\",{\"1\":{\"851\":4,\"860\":1}}],[\"synchronizedset\",{\"1\":{\"698\":1}}],[\"synchronizedmap\",{\"1\":{\"698\":1,\"792\":1}}],[\"synchronizedlist\",{\"1\":{\"698\":1}}],[\"synchronizedcollection\",{\"1\":{\"698\":1}}],[\"synchronized\",{\"0\":{\"846\":1,\"847\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"854\":1,\"855\":1,\"859\":1,\"861\":1,\"862\":1},\"1\":{\"50\":1,\"60\":1,\"357\":1,\"370\":5,\"577\":3,\"579\":4,\"583\":1,\"651\":1,\"688\":3,\"691\":2,\"692\":2,\"747\":1,\"764\":1,\"765\":1,\"792\":2,\"793\":1,\"820\":2,\"823\":5,\"824\":2,\"833\":1,\"834\":1,\"835\":3,\"837\":1,\"847\":6,\"848\":16,\"849\":1,\"850\":1,\"851\":3,\"852\":5,\"853\":3,\"854\":1,\"855\":4,\"857\":1,\"860\":4,\"861\":2,\"863\":1,\"905\":1,\"971\":1,\"978\":1,\"986\":1,\"1001\":5}}],[\"synchronousqueue<runnable>\",{\"1\":{\"889\":1,\"937\":1,\"957\":2}}],[\"synchronousqueue等等皆是基于\",{\"1\":{\"740\":1,\"903\":1}}],[\"synchronousqueue通常用于线程之间的直接传递数据\",{\"1\":{\"671\":1}}],[\"synchronousqueue\",{\"1\":{\"529\":1,\"671\":1,\"889\":2,\"892\":2,\"913\":1,\"917\":1,\"937\":2,\"938\":2,\"958\":3,\"959\":1}}],[\"syntax\",{\"1\":{\"86\":3}}],[\"s\",{\"1\":{\"41\":1,\"86\":1,\"156\":1,\"171\":2,\"320\":3,\"356\":1,\"553\":1,\"564\":1,\"567\":1,\"571\":6,\"573\":3,\"621\":4,\"633\":1,\"634\":2,\"698\":1,\"779\":16,\"781\":4,\"851\":1,\"871\":11,\"876\":1,\"940\":2,\"941\":3,\"944\":4,\"1011\":9,\"1014\":7,\"1030\":5,\"1062\":1,\"1066\":1,\"1076\":1,\"1155\":6,\"1161\":4,\"1178\":3,\"1209\":2,\"1241\":1,\"1327\":1}}],[\"snapshot\",{\"1\":{\"369\":2}}],[\"snapshotting\",{\"1\":{\"35\":1,\"224\":1,\"282\":1}}],[\"snailclimb>jstack\",{\"1\":{\"370\":1}}],[\"snailclimb>jhat\",{\"1\":{\"369\":1}}],[\"snailclimb>jmap\",{\"1\":{\"368\":1}}],[\"snailclimb>jinfo\",{\"1\":{\"367\":5}}],[\"snailclimb>jps\",{\"1\":{\"365\":2,\"370\":1}}],[\"snailclimb\",{\"1\":{\"329\":1,\"368\":2,\"369\":2,\"767\":1,\"1103\":1}}],[\"snowflake\",{\"0\":{\"38\":1},\"1\":{\"38\":10,\"40\":3,\"41\":1}}],[\"sendfile\",{\"0\":{\"1311\":1},\"1\":{\"1311\":4}}],[\"sendre\",{\"1\":{\"1204\":1}}],[\"sendresult\",{\"1\":{\"1204\":3,\"1299\":2}}],[\"sendresult<string\",{\"1\":{\"1204\":1}}],[\"send\",{\"1\":{\"1204\":3,\"1209\":1,\"1290\":1,\"1299\":1}}],[\"sentinel\",{\"1\":{\"49\":1,\"76\":3,\"242\":1,\"318\":8,\"1085\":2}}],[\"selfinterrupt\",{\"1\":{\"1008\":1,\"1012\":1,\"1015\":2}}],[\"selection\",{\"1\":{\"480\":1}}],[\"selected\",{\"1\":{\"298\":1}}],[\"selector\",{\"1\":{\"265\":1}}],[\"select的查询序列号\",{\"1\":{\"120\":1}}],[\"select\",{\"1\":{\"33\":1,\"34\":4,\"81\":1,\"86\":3,\"117\":1,\"120\":4,\"125\":2,\"135\":1,\"141\":1,\"266\":2,\"1131\":1,\"1140\":1,\"1299\":1}}],[\"semaphoreexample\",{\"1\":{\"749\":1}}],[\"semaphore\",{\"0\":{\"746\":1,\"905\":1,\"906\":1},\"1\":{\"740\":1,\"747\":13,\"748\":1,\"749\":10,\"903\":1,\"905\":13,\"906\":1,\"999\":1,\"1019\":1}}],[\"seg\",{\"1\":{\"571\":6}}],[\"segment<k\",{\"1\":{\"570\":4,\"571\":11,\"573\":2,\"690\":1}}],[\"segmentmask=15\",{\"1\":{\"571\":1}}],[\"segmentmask\",{\"1\":{\"570\":2,\"571\":1,\"573\":1}}],[\"segmentshift\",{\"1\":{\"570\":2,\"571\":1,\"573\":1}}],[\"segments\",{\"1\":{\"570\":8,\"571\":2,\"573\":1}}],[\"segmentfault\",{\"1\":{\"196\":1,\"1092\":1}}],[\"segment\",{\"1\":{\"74\":1,\"75\":1,\"141\":2,\"569\":4,\"570\":5,\"571\":27,\"575\":1,\"579\":4,\"688\":6,\"690\":13,\"691\":1,\"692\":4,\"792\":3}}],[\"seekutils\",{\"1\":{\"1210\":2}}],[\"seeking\",{\"1\":{\"1209\":2}}],[\"seek\",{\"1\":{\"1209\":1}}],[\"see\",{\"1\":{\"555\":1,\"587\":1,\"708\":1}}],[\"se\",{\"1\":{\"353\":1,\"403\":1,\"876\":1}}],[\"se8\",{\"1\":{\"334\":1,\"345\":1,\"409\":1,\"511\":1}}],[\"sej7d9tpdaobccmdydmiya\",{\"1\":{\"320\":1}}],[\"serialize\",{\"1\":{\"1130\":1}}],[\"serializable\",{\"1\":{\"125\":1,\"132\":2,\"549\":3,\"553\":1,\"586\":2,\"619\":1,\"634\":1,\"690\":1,\"727\":2,\"740\":1,\"797\":1,\"857\":1,\"865\":1,\"871\":1,\"903\":1}}],[\"serialversionuid\",{\"1\":{\"553\":1,\"619\":1}}],[\"serial\",{\"0\":{\"401\":1,\"404\":1},\"1\":{\"401\":5,\"402\":3,\"404\":2,\"503\":1,\"772\":1}}],[\"serve\",{\"1\":{\"356\":1}}],[\"server3\",{\"1\":{\"1380\":10}}],[\"server2\",{\"1\":{\"1380\":9}}],[\"server1也会\",{\"1\":{\"1380\":1}}],[\"server1\",{\"1\":{\"1380\":17}}],[\"serverless\",{\"1\":{\"1238\":2}}],[\"server层包括连接器\",{\"1\":{\"82\":1}}],[\"serverwebexchange\",{\"1\":{\"77\":1}}],[\"server\",{\"0\":{\"82\":1},\"1\":{\"7\":1,\"42\":1,\"72\":1,\"81\":1,\"86\":1,\"89\":1,\"90\":2,\"161\":1,\"168\":1,\"229\":1,\"242\":1,\"273\":5,\"298\":2,\"359\":1,\"369\":2,\"373\":1,\"402\":1,\"403\":1,\"485\":2,\"929\":1,\"1155\":4,\"1304\":1,\"1322\":1,\"1333\":2,\"1354\":1,\"1380\":7}}],[\"serviceloader\",{\"1\":{\"1132\":1}}],[\"serviceproxy\",{\"1\":{\"1130\":1}}],[\"serviceconfig\",{\"1\":{\"1130\":1}}],[\"service\",{\"1\":{\"7\":1,\"1131\":1,\"1226\":2}}],[\"services\",{\"1\":{\"7\":1}}],[\"sec\",{\"1\":{\"125\":2,\"293\":1,\"298\":1}}],[\"second\",{\"1\":{\"246\":1,\"302\":1}}],[\"secondary\",{\"1\":{\"111\":1}}],[\"seconds\",{\"1\":{\"49\":1,\"53\":1,\"177\":1,\"757\":1,\"785\":1,\"889\":1,\"918\":1,\"927\":1,\"937\":1,\"940\":2,\"944\":1,\"957\":2}}],[\"search\",{\"1\":{\"97\":2,\"356\":2}}],[\"sequential\",{\"1\":{\"54\":2,\"1335\":2,\"1349\":2}}],[\"sequencer\",{\"1\":{\"1182\":2}}],[\"sequence\",{\"1\":{\"33\":1,\"34\":1,\"35\":3,\"572\":1,\"1182\":1}}],[\"sessiontimeout\",{\"1\":{\"1353\":2}}],[\"sessionid是\",{\"1\":{\"1353\":1}}],[\"sessionid\",{\"1\":{\"1349\":1,\"1353\":3,\"1382\":1}}],[\"session\",{\"0\":{\"1353\":1},\"1\":{\"54\":1,\"178\":1,\"249\":2,\"254\":1,\"280\":2,\"1253\":1,\"1335\":1,\"1349\":1,\"1353\":2,\"1383\":3}}],[\"setdata\",{\"1\":{\"1337\":1}}],[\"setdaemon\",{\"1\":{\"894\":1,\"920\":1,\"928\":1}}],[\"setretrytimeswhensendfailed\",{\"1\":{\"1301\":1}}],[\"setclientconfiguration\",{\"1\":{\"1293\":1}}],[\"setconsumergroup\",{\"1\":{\"1293\":1}}],[\"setconsumerfactory\",{\"1\":{\"1211\":1}}],[\"setcontextmap\",{\"1\":{\"1047\":1}}],[\"setcontextclassloader\",{\"1\":{\"359\":1}}],[\"setcommonerrorhandler\",{\"1\":{\"1211\":2}}],[\"setcorepoolsize\",{\"1\":{\"896\":1,\"923\":1,\"928\":1}}],[\"seth\",{\"1\":{\"1066\":1}}],[\"sethead\",{\"1\":{\"1012\":3,\"1015\":1}}],[\"setkeepaliveseconds\",{\"1\":{\"928\":1}}],[\"setqueuecapacity\",{\"1\":{\"928\":1}}],[\"setmaxpoolsize\",{\"1\":{\"928\":1}}],[\"set或get方法时才创建它们\",{\"1\":{\"883\":1}}],[\"setup\",{\"1\":{\"765\":1}}],[\"setawaitduration\",{\"1\":{\"1293\":1}}],[\"setaccessible\",{\"1\":{\"1030\":4}}],[\"setage\",{\"1\":{\"663\":1,\"767\":1,\"768\":1}}],[\"setarray\",{\"1\":{\"587\":3,\"588\":1,\"591\":2}}],[\"setthreshold\",{\"1\":{\"1032\":1,\"1038\":1}}],[\"setthreadnameprefix\",{\"1\":{\"928\":1}}],[\"setthreadpriority\",{\"1\":{\"928\":1}}],[\"setters\",{\"1\":{\"630\":1}}],[\"setting\",{\"1\":{\"218\":1,\"688\":1}}],[\"settimeout\",{\"1\":{\"49\":1}}],[\"set<person>\",{\"1\":{\"663\":1}}],[\"set<t>\",{\"1\":{\"632\":1,\"698\":1}}],[\"set<java\",{\"1\":{\"625\":1}}],[\"set<string>\",{\"1\":{\"625\":2}}],[\"set<map\",{\"1\":{\"619\":1}}],[\"setvalue\",{\"1\":{\"619\":1}}],[\"setendpoints\",{\"1\":{\"1293\":1}}],[\"setentryat\",{\"1\":{\"571\":1}}],[\"setexclusiveownerthread\",{\"1\":{\"1002\":1,\"1007\":1,\"1008\":1,\"1014\":1,\"1018\":2}}],[\"setex\",{\"1\":{\"177\":1,\"270\":3}}],[\"setnameformat\",{\"1\":{\"894\":1,\"920\":1}}],[\"setname\",{\"1\":{\"663\":1,\"767\":1,\"768\":1,\"894\":1,\"920\":1}}],[\"setnext\",{\"1\":{\"571\":1,\"572\":1}}],[\"setnx\",{\"1\":{\"47\":5,\"177\":1,\"178\":1,\"254\":1}}],[\"setsendlatencyfaultenable\",{\"1\":{\"1299\":1}}],[\"setsubscriptionexpressions\",{\"1\":{\"1293\":1}}],[\"setstate\",{\"1\":{\"742\":2,\"752\":1,\"904\":2,\"1006\":1,\"1007\":1,\"1014\":1,\"1018\":2,\"1020\":1}}],[\"sets\",{\"1\":{\"293\":1,\"386\":1}}],[\"setbit\",{\"1\":{\"202\":6,\"203\":1,\"261\":3}}],[\"setlockwatchdogtimeout\",{\"1\":{\"49\":1}}],[\"setifabsent\",{\"1\":{\"47\":1}}],[\"set\",{\"0\":{\"187\":1,\"191\":1,\"259\":1,\"260\":1,\"640\":1,\"643\":1,\"660\":1,\"1031\":1,\"1034\":1,\"1035\":1,\"1036\":1,\"1326\":1},\"1\":{\"34\":1,\"35\":1,\"47\":1,\"48\":2,\"89\":1,\"125\":2,\"135\":2,\"157\":4,\"174\":2,\"177\":3,\"178\":2,\"188\":6,\"189\":1,\"192\":4,\"193\":2,\"194\":1,\"195\":3,\"201\":2,\"209\":1,\"210\":4,\"212\":1,\"220\":6,\"242\":1,\"245\":1,\"249\":2,\"253\":1,\"257\":1,\"258\":2,\"259\":2,\"260\":1,\"270\":1,\"280\":11,\"291\":2,\"293\":2,\"301\":4,\"302\":2,\"307\":2,\"480\":1,\"553\":1,\"585\":1,\"589\":1,\"593\":2,\"625\":1,\"632\":3,\"634\":1,\"639\":1,\"640\":1,\"646\":1,\"649\":1,\"665\":1,\"678\":2,\"680\":2,\"688\":2,\"698\":2,\"733\":1,\"767\":7,\"793\":1,\"881\":1,\"882\":1,\"883\":3,\"884\":1,\"1026\":1,\"1030\":2,\"1031\":2,\"1036\":2,\"1037\":1,\"1038\":1,\"1043\":2,\"1207\":1,\"1210\":1,\"1326\":2,\"1327\":3}}],[\"sh\",{\"1\":{\"1322\":1}}],[\"shuwdown\",{\"1\":{\"924\":1}}],[\"shuffle\",{\"1\":{\"696\":1}}],[\"shuang\",{\"1\":{\"679\":1,\"940\":1}}],[\"shutdownnow\",{\"0\":{\"945\":1},\"1\":{\"924\":2,\"945\":1,\"951\":1}}],[\"shutdown\",{\"0\":{\"945\":1},\"1\":{\"484\":1,\"749\":1,\"753\":1,\"757\":2,\"835\":1,\"909\":1,\"924\":3,\"940\":2,\"941\":6,\"944\":2,\"945\":2,\"946\":2,\"951\":1,\"1290\":1}}],[\"shipilev\",{\"1\":{\"633\":1}}],[\"shinerio\",{\"1\":{\"221\":1}}],[\"short\",{\"1\":{\"493\":1}}],[\"shouldparkafterfailedacquire\",{\"1\":{\"1012\":4,\"1013\":3,\"1015\":1}}],[\"should\",{\"1\":{\"351\":1}}],[\"shr\",{\"1\":{\"412\":1}}],[\"share\",{\"1\":{\"498\":1}}],[\"sharedclassloader\",{\"1\":{\"359\":9}}],[\"sharedclassloader对应\",{\"1\":{\"359\":1}}],[\"shared\",{\"1\":{\"140\":1,\"359\":1,\"1005\":2,\"1236\":1}}],[\"sharing\",{\"1\":{\"274\":1,\"820\":1,\"1117\":1,\"1184\":1}}],[\"sharding\",{\"1\":{\"29\":1}}],[\"shenyu\",{\"0\":{\"9\":1},\"1\":{\"9\":7}}],[\"shepherd\",{\"1\":{\"2\":1}}],[\"spuriously\",{\"1\":{\"767\":2}}],[\"spground\",{\"1\":{\"720\":1}}],[\"spread\",{\"1\":{\"577\":1,\"578\":1}}],[\"spring默认动态代理\",{\"1\":{\"523\":1}}],[\"springboot\",{\"1\":{\"77\":1,\"918\":1}}],[\"springcloud\",{\"1\":{\"5\":3}}],[\"springframework\",{\"1\":{\"4\":1}}],[\"spring\",{\"0\":{\"5\":1,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":1,\"928\":1},\"1\":{\"4\":1,\"5\":11,\"10\":6,\"11\":1,\"67\":1,\"68\":14,\"69\":5,\"70\":1,\"72\":6,\"75\":1,\"76\":3,\"77\":2,\"78\":6,\"359\":9,\"523\":1,\"891\":1,\"928\":1,\"936\":1,\"1123\":1,\"1130\":1,\"1132\":1,\"1172\":1,\"1178\":2,\"1204\":1,\"1208\":2,\"1212\":1,\"1213\":1,\"1275\":1,\"1281\":2}}],[\"space\",{\"1\":{\"449\":1,\"495\":1}}],[\"spanid\",{\"0\":{\"23\":1},\"1\":{\"21\":1,\"22\":1,\"23\":7}}],[\"span\",{\"1\":{\"21\":3,\"23\":1}}],[\"spans\",{\"1\":{\"7\":1}}],[\"spi\",{\"0\":{\"1131\":1},\"1\":{\"359\":6,\"896\":1,\"923\":1,\"1131\":4,\"1132\":1,\"1140\":1,\"1237\":1}}],[\"spin\",{\"1\":{\"50\":1,\"576\":1}}],[\"split\",{\"1\":{\"353\":3,\"624\":1}}],[\"speculatively\",{\"1\":{\"571\":1}}],[\"specified\",{\"1\":{\"571\":5,\"680\":1}}],[\"specification\",{\"1\":{\"334\":1,\"339\":1,\"345\":1,\"971\":1}}],[\"specify\",{\"1\":{\"480\":1}}],[\"specs\",{\"1\":{\"334\":1,\"345\":1,\"409\":1,\"511\":1}}],[\"spop\",{\"1\":{\"189\":1,\"190\":1,\"260\":1}}],[\"style\",{\"1\":{\"1173\":1}}],[\"st\",{\"1\":{\"895\":5,\"922\":5}}],[\"stw\",{\"1\":{\"483\":1}}],[\"student\",{\"1\":{\"425\":17}}],[\"stub\",{\"1\":{\"33\":4,\"561\":1,\"1166\":12}}],[\"stomp2\",{\"1\":{\"1253\":1}}],[\"stomp\",{\"1\":{\"1237\":1,\"1245\":2,\"1246\":1}}],[\"stop\",{\"1\":{\"401\":2,\"407\":1,\"408\":1,\"924\":1,\"945\":1,\"1210\":5}}],[\"storm\",{\"1\":{\"1181\":3}}],[\"storage\",{\"1\":{\"307\":1}}],[\"storagevalue\",{\"1\":{\"307\":4}}],[\"storefence\",{\"1\":{\"834\":1}}],[\"store\",{\"1\":{\"218\":1,\"972\":3,\"1315\":1}}],[\"standardopenoption\",{\"1\":{\"1311\":2}}],[\"stanford\",{\"1\":{\"1117\":1}}],[\"star\",{\"1\":{\"1122\":1}}],[\"startvirtualthread\",{\"0\":{\"1058\":1},\"1\":{\"1057\":1,\"1058\":1}}],[\"startable\",{\"1\":{\"941\":1}}],[\"starttime1\",{\"1\":{\"564\":2}}],[\"starttime\",{\"1\":{\"564\":2}}],[\"start0\",{\"1\":{\"435\":1}}],[\"started\",{\"1\":{\"369\":1}}],[\"starter\",{\"1\":{\"4\":1}}],[\"start\",{\"1\":{\"53\":1,\"125\":1,\"135\":1,\"181\":2,\"193\":4,\"202\":2,\"370\":2,\"531\":2,\"713\":9,\"820\":3,\"823\":2,\"824\":1,\"827\":3,\"882\":1,\"934\":1,\"940\":11,\"941\":2,\"975\":1,\"1020\":2,\"1030\":2,\"1043\":1,\"1059\":2,\"1060\":1,\"1062\":2,\"1333\":2}}],[\"stake\",{\"1\":{\"1097\":1}}],[\"stale\",{\"1\":{\"1042\":1}}],[\"staleslot说明\",{\"1\":{\"1036\":1}}],[\"staleslot位置为过期元素\",{\"1\":{\"1035\":1}}],[\"staleslot\",{\"1\":{\"1035\":1,\"1036\":21,\"1037\":5}}],[\"stableslot\",{\"1\":{\"1035\":1}}],[\"stampedlock\",{\"0\":{\"870\":1,\"871\":1,\"872\":1,\"873\":1,\"874\":1},\"1\":{\"864\":1,\"870\":1,\"871\":6,\"872\":1,\"873\":4,\"874\":5,\"876\":1}}],[\"stamp\",{\"1\":{\"767\":4,\"843\":2,\"871\":3,\"992\":2}}],[\"stacksize\",{\"1\":{\"1043\":3}}],[\"stackoverflow\",{\"1\":{\"511\":1}}],[\"stackoverflowerror\",{\"1\":{\"439\":1,\"493\":4,\"494\":1}}],[\"stack\",{\"0\":{\"651\":1},\"1\":{\"364\":1,\"370\":2,\"459\":1,\"651\":3}}],[\"state>=0\",{\"1\":{\"906\":1}}],[\"state<0\",{\"1\":{\"906\":1}}],[\"state=0\",{\"1\":{\"904\":2}}],[\"state=state+1\",{\"1\":{\"748\":1,\"906\":1}}],[\"state=state\",{\"1\":{\"748\":2,\"906\":2}}],[\"state+1\",{\"1\":{\"904\":1}}],[\"states\",{\"1\":{\"820\":1}}],[\"stateoffset\",{\"1\":{\"742\":1,\"904\":1,\"1011\":1}}],[\"state\",{\"0\":{\"1006\":1},\"1\":{\"742\":14,\"748\":8,\"749\":4,\"752\":14,\"871\":5,\"874\":1,\"900\":2,\"904\":11,\"906\":5,\"908\":5,\"1002\":2,\"1004\":1,\"1006\":7,\"1007\":2,\"1011\":1,\"1018\":5,\"1073\":1,\"1112\":1}}],[\"status\",{\"1\":{\"364\":1,\"365\":1,\"918\":1}}],[\"statistics\",{\"1\":{\"293\":1,\"298\":1,\"364\":1,\"366\":1,\"1130\":1,\"1142\":2}}],[\"static修饰方法\",{\"1\":{\"521\":1}}],[\"static修饰属性\",{\"1\":{\"521\":1}}],[\"static修饰符\",{\"1\":{\"331\":1}}],[\"static和final关键字\",{\"0\":{\"521\":1}}],[\"static\",{\"1\":{\"56\":1,\"342\":3,\"353\":1,\"370\":3,\"384\":2,\"390\":1,\"429\":2,\"430\":2,\"433\":1,\"520\":1,\"521\":1,\"531\":3,\"553\":7,\"555\":2,\"557\":1,\"558\":1,\"559\":1,\"561\":2,\"562\":2,\"564\":2,\"570\":3,\"618\":2,\"619\":9,\"625\":1,\"630\":2,\"632\":2,\"634\":3,\"658\":1,\"663\":1,\"677\":1,\"679\":1,\"682\":2,\"688\":4,\"690\":1,\"693\":1,\"708\":2,\"727\":1,\"748\":3,\"749\":3,\"752\":1,\"753\":3,\"757\":8,\"763\":1,\"765\":3,\"766\":1,\"767\":3,\"768\":1,\"777\":1,\"778\":4,\"797\":1,\"807\":1,\"823\":3,\"834\":2,\"835\":2,\"848\":2,\"882\":3,\"884\":1,\"889\":4,\"891\":1,\"909\":2,\"918\":1,\"937\":4,\"940\":5,\"941\":3,\"949\":2,\"953\":2,\"957\":2,\"961\":1,\"1002\":2,\"1008\":1,\"1011\":1,\"1012\":1,\"1015\":1,\"1020\":4,\"1028\":4,\"1030\":2,\"1032\":4,\"1036\":2,\"1043\":1,\"1058\":2,\"1059\":2,\"1060\":2,\"1061\":2,\"1062\":3,\"1140\":1,\"1141\":1,\"1142\":3,\"1210\":2,\"1333\":2}}],[\"stat\",{\"0\":{\"1329\":1},\"1\":{\"218\":2,\"1329\":2,\"1330\":2,\"1349\":3,\"1350\":2,\"1382\":1}}],[\"stat获取当前\",{\"1\":{\"169\":1}}],[\"str\",{\"1\":{\"634\":1}}],[\"strongreference\",{\"1\":{\"392\":1}}],[\"strategy\",{\"1\":{\"351\":1,\"1333\":1}}],[\"structure\",{\"1\":{\"511\":1}}],[\"structures\",{\"1\":{\"174\":1,\"196\":2,\"213\":2}}],[\"struct\",{\"1\":{\"256\":6,\"271\":1}}],[\"strlen\",{\"1\":{\"177\":2,\"293\":2}}],[\"stringutils\",{\"1\":{\"1046\":2}}],[\"stringlist\",{\"1\":{\"649\":7}}],[\"stringarr\",{\"1\":{\"649\":9}}],[\"string>>\",{\"1\":{\"625\":1}}],[\"string>\",{\"1\":{\"625\":3,\"663\":2,\"679\":2,\"705\":2,\"1047\":2,\"1211\":1}}],[\"stringtablesize\",{\"1\":{\"498\":2}}],[\"stringtable\",{\"1\":{\"498\":2}}],[\"stringbuilder\",{\"1\":{\"353\":2}}],[\"strings\",{\"1\":{\"201\":1,\"256\":1,\"293\":1}}],[\"string\",{\"0\":{\"175\":1,\"254\":1,\"255\":1,\"256\":1,\"257\":1},\"1\":{\"56\":3,\"163\":1,\"174\":2,\"176\":3,\"177\":1,\"184\":1,\"195\":2,\"196\":1,\"201\":2,\"242\":1,\"249\":1,\"253\":1,\"254\":3,\"255\":5,\"256\":3,\"291\":1,\"292\":1,\"293\":4,\"294\":1,\"328\":1,\"353\":1,\"354\":5,\"357\":1,\"370\":1,\"384\":2,\"390\":1,\"393\":1,\"433\":4,\"485\":4,\"498\":3,\"511\":1,\"523\":1,\"531\":3,\"553\":1,\"561\":1,\"562\":1,\"564\":2,\"619\":1,\"625\":4,\"630\":2,\"633\":5,\"634\":3,\"649\":4,\"663\":5,\"679\":1,\"704\":4,\"706\":1,\"732\":2,\"733\":1,\"749\":1,\"753\":1,\"757\":2,\"763\":1,\"766\":1,\"767\":7,\"768\":5,\"785\":1,\"807\":1,\"823\":1,\"835\":1,\"848\":1,\"882\":1,\"894\":2,\"909\":1,\"920\":2,\"927\":1,\"940\":4,\"944\":2,\"1020\":1,\"1028\":2,\"1030\":3,\"1043\":2,\"1046\":2,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1,\"1141\":1,\"1142\":3,\"1209\":2,\"1213\":1,\"1293\":1}}],[\"streammessage\",{\"1\":{\"1226\":1}}],[\"streams\",{\"1\":{\"293\":1}}],[\"stream\",{\"1\":{\"6\":1,\"182\":1,\"249\":1,\"251\":4,\"630\":3,\"634\":3,\"679\":1,\"909\":1,\"1151\":2}}],[\"step5\",{\"0\":{\"506\":1}}],[\"step4\",{\"0\":{\"505\":1}}],[\"step3\",{\"0\":{\"504\":1}}],[\"step2\",{\"0\":{\"503\":1}}],[\"step1\",{\"0\":{\"502\":1}}],[\"step\",{\"1\":{\"34\":2}}],[\"将写请求\",{\"1\":{\"1379\":1}}],[\"将这条消息本身在\",{\"1\":{\"1315\":1}}],[\"将这个\",{\"1\":{\"609\":1}}],[\"将内核缓冲区的数据拷贝到\",{\"1\":{\"1310\":1}}],[\"将内核缓存区的数据拷贝到用户缓冲区\",{\"1\":{\"1308\":1}}],[\"将用户缓冲区的数据拷贝到\",{\"1\":{\"1308\":1}}],[\"将用户的请求数据存储到消息队列之后就立即返回结果\",{\"1\":{\"1220\":1}}],[\"将磁盘数据通过\",{\"1\":{\"1308\":1}}],[\"将备份原消息的主题与消息消费队列\",{\"1\":{\"1304\":1}}],[\"将丢失的那批数据\",{\"1\":{\"1264\":1}}],[\"将消息从物理文件中删除\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"将消息存储在\",{\"1\":{\"1250\":1}}],[\"将消息继续发送出去\",{\"1\":{\"1222\":1}}],[\"将消息发送到特定的主题\",{\"1\":{\"1196\":1}}],[\"将生产者发布的消息发送到\",{\"1\":{\"1196\":1}}],[\"将连续的几个页预读到内存里\",{\"1\":{\"1184\":1}}],[\"将相邻的事件对象一起加载到缓存中\",{\"1\":{\"1184\":1}}],[\"将要发送给该追随者的下一条日志条目的索引\",{\"1\":{\"1112\":1}}],[\"将军\",{\"1\":{\"1105\":1}}],[\"将军们如何达成是否要进攻的一致性决定\",{\"1\":{\"1105\":1}}],[\"将traceid写入到请求的header中\",{\"1\":{\"1045\":1}}],[\"将tail的后继节点设置为null\",{\"1\":{\"1013\":1}}],[\"将takeindex置空\",{\"1\":{\"535\":1}}],[\"将此字符串放入当前线程的threadlocal中\",{\"1\":{\"1045\":1}}],[\"将此值设置为\",{\"1\":{\"233\":1}}],[\"将过期数据的entry设置为null\",{\"1\":{\"1037\":1}}],[\"将找到的\",{\"1\":{\"1013\":1}}],[\"将从后往前的第一个非取消状态的节点设置为尾节点\",{\"1\":{\"1013\":1}}],[\"将无效节点过滤\",{\"1\":{\"1013\":1}}],[\"将无用对象从内存中卸载\",{\"1\":{\"431\":1}}],[\"将暂时获取不到锁的线程加入到队列中\",{\"1\":{\"1004\":1}}],[\"将共享资源设置为锁定状态\",{\"1\":{\"1004\":1}}],[\"将他标记为一个线程独享变量\",{\"1\":{\"972\":1}}],[\"将他们合并起来\",{\"1\":{\"909\":1}}],[\"将主内存的值写入高速缓存\",{\"1\":{\"969\":1}}],[\"将各种硬件资源虚拟化\",{\"1\":{\"968\":1}}],[\"将失败\",{\"1\":{\"958\":1}}],[\"将没有线程执行\",{\"1\":{\"958\":1}}],[\"将任务加入\",{\"1\":{\"954\":1}}],[\"将任何后续元素向左移动\",{\"1\":{\"591\":1}}],[\"将任何后续元素移动到左侧\",{\"1\":{\"553\":2}}],[\"将是一个无效参数\",{\"1\":{\"951\":2}}],[\"将返回线程池进行复用\",{\"1\":{\"937\":1}}],[\"将返回一个实现future接口的对象\",{\"1\":{\"934\":1}}],[\"将抛出\",{\"1\":{\"891\":1,\"936\":1}}],[\"将需要存储的值放入到这个哈希表中\",{\"1\":{\"883\":1}}],[\"将锁计数器设为\",{\"1\":{\"851\":1}}],[\"将锁的超时时间设置为\",{\"1\":{\"49\":1}}],[\"将线程挡住了\",{\"1\":{\"756\":1,\"911\":1}}],[\"将同步状态值设置为给定值update如果当前同步状态的值等于expect\",{\"1\":{\"742\":1,\"904\":1}}],[\"将每条请求共享资源的线程封装成一个\",{\"1\":{\"742\":1}}],[\"将上次返回的节点引用置为\",{\"1\":{\"732\":1}}],[\"将待删除节点\",{\"1\":{\"731\":3}}],[\"将下一个节点的\",{\"1\":{\"731\":1}}],[\"将前一个节点的\",{\"1\":{\"731\":1}}],[\"将first赋值为新节点\",{\"1\":{\"729\":1}}],[\"将最后一个元素赋值\",{\"1\":{\"729\":1}}],[\"将最近最少访问的元素移除\",{\"1\":{\"706\":1}}],[\"将next指向bucket中下一个不为空的node\",{\"1\":{\"713\":1}}],[\"将p的前驱和后继指针都设置为null\",{\"1\":{\"711\":1}}],[\"将putindex位置的值设置为我们传入的x\",{\"1\":{\"535\":1}}],[\"将当前元素放入此槽位中\",{\"1\":{\"1033\":1}}],[\"将当前元素添加到链表末尾\",{\"1\":{\"710\":1}}],[\"将当前独占锁所有线程设置为null\",{\"1\":{\"1014\":1}}],[\"将当前\",{\"1\":{\"1013\":1}}],[\"将当前线程获锁结果设置为失败\",{\"1\":{\"1002\":1}}],[\"将当前线程和对应的\",{\"1\":{\"56\":1}}],[\"将当前节点元素置为\",{\"1\":{\"731\":1}}],[\"将当前节点的\",{\"1\":{\"731\":2}}],[\"将当前节点的后继节点指针指向空\",{\"1\":{\"710\":1}}],[\"将当前节点\",{\"1\":{\"710\":1}}],[\"将当前访问的元素移到链表的末尾\",{\"1\":{\"710\":1}}],[\"将list后distance个元素整体移到前面\",{\"1\":{\"696\":1}}],[\"将leader设置为空\",{\"1\":{\"603\":1}}],[\"将红黑树拆分成2棵子树\",{\"1\":{\"624\":1}}],[\"将m中的所有元素添加至hashmap中\",{\"1\":{\"621\":1}}],[\"将max\",{\"1\":{\"559\":1}}],[\"将链表和数组相结合\",{\"1\":{\"618\":1,\"682\":1}}],[\"将链表转换为红黑树\",{\"1\":{\"692\":1}}],[\"将链表转换成红黑树前会判断\",{\"1\":{\"616\":1,\"645\":1,\"677\":1,\"683\":2}}],[\"将链表转化为红黑树\",{\"1\":{\"616\":1,\"645\":1,\"677\":1,\"683\":1}}],[\"将底层aqs的state设置为1\",{\"1\":{\"604\":1}}],[\"将新的数据添加到table\",{\"1\":{\"1036\":1}}],[\"将新节点赋值给l\",{\"1\":{\"729\":1}}],[\"将新数组赋值给array引用\",{\"1\":{\"591\":1}}],[\"将新对象预留在新生代\",{\"1\":{\"479\":1}}],[\"将index=i\",{\"1\":{\"766\":1}}],[\"将index前的元素和index+1后的元素复制到新数组\",{\"1\":{\"591\":1}}],[\"将integer\",{\"1\":{\"559\":1}}],[\"将原数组拷贝到你自己定义的数组里或者原数组\",{\"1\":{\"563\":1}}],[\"将原来不是object类型的elementdata数组的内容\",{\"1\":{\"553\":1}}],[\"将源数组中的数据进行拷贝\",{\"1\":{\"562\":1}}],[\"将element插入index位置\",{\"1\":{\"553\":1,\"561\":1}}],[\"将为指定数组的运行时类型和此列表的大小分配一个新数组\",{\"1\":{\"553\":1}}],[\"将oldcapacity\",{\"1\":{\"553\":1,\"558\":1}}],[\"将元素节点插入到链表尾部\",{\"1\":{\"729\":1}}],[\"将元素从\",{\"1\":{\"712\":1}}],[\"将元素添加进入\",{\"1\":{\"622\":1}}],[\"将元素返回出去\",{\"1\":{\"605\":1}}],[\"将元素插入队列尾部\",{\"1\":{\"536\":2}}],[\"将元素插入队列中\",{\"1\":{\"535\":1}}],[\"将元素存到\",{\"1\":{\"535\":1}}],[\"将队列中的元素全部存到指定的集合中\",{\"1\":{\"533\":1}}],[\"将字符串常量池放到堆中\",{\"1\":{\"498\":1}}],[\"将字符串对象\",{\"1\":{\"498\":1}}],[\"将字节流所代表的静态存储结构转换为方法区的运行时数据结构\",{\"1\":{\"340\":1,\"349\":1}}],[\"将根据运行时的应用程序需求动态地重新调整大小\",{\"1\":{\"496\":1}}],[\"将会开启另一个任期\",{\"1\":{\"1109\":1}}],[\"将会清空工作内存中此变量的值\",{\"1\":{\"972\":1}}],[\"将会使用默认值\",{\"1\":{\"495\":1}}],[\"将会减小年老代大小\",{\"1\":{\"449\":1,\"450\":1}}],[\"将附加到文件名中\",{\"1\":{\"484\":1}}],[\"将它复制到\",{\"1\":{\"444\":1}}],[\"将静态数据结构转化成方法区中运行时的数据结构\",{\"1\":{\"428\":1}}],[\"将引用分为强引用\",{\"1\":{\"392\":1}}],[\"将尝试进行一次\",{\"1\":{\"388\":1}}],[\"将被移动到\",{\"1\":{\"386\":1}}],[\"将被查询的字段\",{\"1\":{\"115\":1}}],[\"将指定集合中的所有元素插入到此列表中\",{\"1\":{\"553\":1}}],[\"将指定集合转换为数组\",{\"1\":{\"553\":1}}],[\"将指定的元素追加到此列表的末尾\",{\"1\":{\"553\":1,\"557\":1}}],[\"将指定应用程序的堆快照输出到桌面\",{\"1\":{\"368\":1}}],[\"将指定列表索引\",{\"1\":{\"181\":1}}],[\"将搜索类或资源的任务委托给其父类加载器\",{\"1\":{\"356\":2}}],[\"将符号引用转化为直接引用的时候\",{\"1\":{\"341\":1}}],[\"将结果输出到\",{\"1\":{\"328\":1}}],[\"将第\",{\"1\":{\"328\":1}}],[\"将热点数据分散存储在多个\",{\"1\":{\"299\":1}}],[\"将该操作交给单独的子线程处理\",{\"1\":{\"289\":1,\"294\":1}}],[\"将一直保存在\",{\"1\":{\"1362\":1}}],[\"将一系列的\",{\"1\":{\"445\":1}}],[\"将一个含有上万字段数量的\",{\"1\":{\"294\":1}}],[\"将一个\",{\"1\":{\"294\":1}}],[\"将一批\",{\"1\":{\"287\":1}}],[\"将一些常用的\",{\"1\":{\"6\":1}}],[\"将不工作\",{\"1\":{\"267\":1}}],[\"将访问指定页面的每个用户\",{\"1\":{\"262\":1}}],[\"将禁用自动\",{\"1\":{\"233\":1}}],[\"将触发\",{\"1\":{\"233\":1}}],[\"将阻塞直到写入磁盘完成后返回\",{\"1\":{\"230\":1}}],[\"将多个线程放到起点\",{\"1\":{\"753\":1}}],[\"将多个\",{\"1\":{\"206\":1}}],[\"将多个锁作为一个整体\",{\"1\":{\"53\":1}}],[\"将多个锁作为单个实体管理的容器\",{\"1\":{\"53\":1}}],[\"将其计数器初始化为\",{\"1\":{\"753\":1}}],[\"将其放到链表末端\",{\"1\":{\"712\":1}}],[\"将其扩容到与\",{\"1\":{\"621\":1}}],[\"将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期\",{\"1\":{\"310\":1}}],[\"将其划分为了现在的\",{\"1\":{\"256\":1}}],[\"将其视为位向量\",{\"1\":{\"201\":1}}],[\"将其所有粉丝存在一个集合\",{\"1\":{\"188\":1}}],[\"将给定所有有序集合的交集存储在\",{\"1\":{\"193\":1}}],[\"将给定所有集合的差集存储在\",{\"1\":{\"189\":1}}],[\"将给定所有集合的并集存储在\",{\"1\":{\"189\":1}}],[\"将给定所有集合的交集存储在\",{\"1\":{\"189\":1}}],[\"将严重影响\",{\"1\":{\"169\":1}}],[\"将缓冲区中新数据写到新文件的过程中会产生阻塞\",{\"1\":{\"162\":1}}],[\"将数据保存在内存中\",{\"1\":{\"1344\":1,\"1362\":1}}],[\"将数据从热存储卸载到冷\",{\"1\":{\"1238\":1}}],[\"将数据版本号\",{\"1\":{\"840\":1,\"989\":1}}],[\"将数据写入\",{\"1\":{\"146\":1}}],[\"将数据\",{\"1\":{\"145\":1}}],[\"将undo日志版本连的每一条数跟生成的read\",{\"1\":{\"141\":1}}],[\"将跳转路径中包含的api替换成空\",{\"1\":{\"75\":1}}],[\"将跳转路径中包含的\",{\"1\":{\"74\":1}}],[\"将库存数量减少\",{\"1\":{\"60\":2}}],[\"将加锁次数加\",{\"1\":{\"56\":1}}],[\"将\",{\"1\":{\"2\":1,\"96\":1,\"177\":4,\"181\":1,\"230\":1,\"233\":1,\"265\":1,\"299\":1,\"425\":1,\"426\":1,\"428\":1,\"533\":1,\"694\":2,\"696\":1,\"718\":1,\"729\":2,\"732\":3,\"744\":1,\"753\":1,\"756\":1,\"834\":1,\"835\":1,\"882\":1,\"911\":1,\"1011\":1,\"1013\":1,\"1207\":1,\"1249\":1,\"1308\":1}}],[\"将请求\",{\"1\":{\"1379\":1}}],[\"将请求转发到注册中心注册的\",{\"1\":{\"75\":1}}],[\"将请求转发到目标微服务\",{\"1\":{\"2\":1}}],[\"将请求动态分流到不同的服务版本\",{\"1\":{\"2\":1}}],[\"等功能\",{\"1\":{\"1344\":1}}],[\"等协议\",{\"1\":{\"1253\":1}}],[\"等复杂的消息类型\",{\"1\":{\"1231\":1}}],[\"等消息真正被消费者服务器处理后才删除消息\",{\"1\":{\"1222\":1}}],[\"等技术实现的\",{\"1\":{\"1184\":1}}],[\"等项目\",{\"1\":{\"1178\":1}}],[\"等项目应用\",{\"1\":{\"1091\":1}}],[\"等特性\",{\"1\":{\"1168\":1}}],[\"等分布式中间件不太一样\",{\"1\":{\"1097\":1}}],[\"等共识算法\",{\"1\":{\"1097\":1}}],[\"等知名项目都用到了\",{\"1\":{\"1085\":1}}],[\"等同步器的\",{\"1\":{\"1021\":1}}],[\"等主流操作系统中\",{\"1\":{\"808\":1,\"1053\":1}}],[\"等能力\",{\"1\":{\"774\":1,\"901\":1}}],[\"等我们的事情干完后\",{\"1\":{\"773\":1,\"899\":1}}],[\"等其他方法\",{\"1\":{\"667\":1}}],[\"等到我们的牛肉面上了我们就可以吃了\",{\"1\":{\"1271\":1}}],[\"等到所有子线程都执行完后\",{\"1\":{\"904\":1}}],[\"等到有线程释放了共享资源\",{\"1\":{\"747\":1,\"905\":1}}],[\"等到\",{\"1\":{\"604\":1}}],[\"等到这个线程执行完毕后\",{\"1\":{\"441\":1}}],[\"等修改方法时\",{\"1\":{\"589\":1}}],[\"等操作\",{\"1\":{\"585\":1,\"793\":1}}],[\"等操作取出一个元素之后\",{\"1\":{\"535\":1}}],[\"等操作时\",{\"1\":{\"265\":1}}],[\"等于队列长度\",{\"1\":{\"535\":1}}],[\"等方式管理插件生命周期\",{\"1\":{\"1132\":1}}],[\"等方式来授权\",{\"1\":{\"2\":1}}],[\"等方法来组合多个异步任务\",{\"1\":{\"787\":1}}],[\"等方法内部都调用了该方法来获取对应的节点\",{\"1\":{\"730\":1}}],[\"等方法导致阻塞的线程来争抢元素\",{\"1\":{\"603\":1}}],[\"等方法中都用到了该方法\",{\"1\":{\"560\":1}}],[\"等方法获取值了\",{\"1\":{\"535\":1}}],[\"等类\",{\"1\":{\"523\":1}}],[\"等空间\",{\"1\":{\"495\":1}}],[\"等它剩余大小小于\",{\"1\":{\"451\":1}}],[\"等都是靠这招去判定对象是否存活的\",{\"1\":{\"445\":1}}],[\"等垃圾收集器的关注点更多的是用户线程的停顿时间\",{\"1\":{\"403\":1}}],[\"等问题的产生\",{\"1\":{\"392\":1}}],[\"等问题依然没有一个比较好的解决办法\",{\"1\":{\"251\":1}}],[\"等信息建立一个快照\",{\"1\":{\"377\":1}}],[\"等工具无法与之媲美的\",{\"1\":{\"377\":1}}],[\"等工具分析该堆文件\",{\"1\":{\"368\":1}}],[\"等专业且收费的\",{\"1\":{\"377\":1}}],[\"等语言都是运行在\",{\"1\":{\"324\":1}}],[\"等语言开发插件\",{\"1\":{\"7\":1}}],[\"等缓存服务可用之后\",{\"1\":{\"316\":1}}],[\"等待所有前面的操作完成\",{\"1\":{\"1388\":1}}],[\"等待所有请求执行结束\",{\"1\":{\"286\":1}}],[\"等待定时时刻到达\",{\"1\":{\"1285\":1}}],[\"等待消费者消费的状态\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"等待消费者连接到这个队列将其取走\",{\"1\":{\"1250\":1}}],[\"等待其他消息接受者订阅该消息\",{\"1\":{\"1222\":1}}],[\"等待策略有哪些\",{\"0\":{\"1183\":1}}],[\"等待策略\",{\"1\":{\"1182\":1,\"1183\":2,\"1185\":2}}],[\"等待选票的时候\",{\"1\":{\"1111\":1}}],[\"等待时间的单位为\",{\"1\":{\"940\":1}}],[\"等待时间为\",{\"1\":{\"940\":1}}],[\"等待线程池关闭\",{\"1\":{\"924\":1}}],[\"等待线程结束\",{\"1\":{\"531\":1}}],[\"等待可中断\",{\"1\":{\"862\":1}}],[\"等待1\",{\"1\":{\"835\":1}}],[\"等待状态\",{\"1\":{\"820\":1}}],[\"等待运行的状态\",{\"1\":{\"820\":1}}],[\"等待任务执行完成并获取运算结果\",{\"1\":{\"774\":1}}],[\"等待任务到期时\",{\"1\":{\"604\":1}}],[\"等待60秒\",{\"1\":{\"757\":1}}],[\"等待发令枪响\",{\"1\":{\"753\":1}}],[\"等待队列中线程出队列时机\",{\"0\":{\"1012\":1}}],[\"等待队列正在有线程进行初始化\",{\"1\":{\"1011\":1}}],[\"等待队列容量为\",{\"1\":{\"941\":1}}],[\"等待队列\",{\"1\":{\"742\":1}}],[\"等待队列非满时插入\",{\"1\":{\"535\":1,\"544\":1}}],[\"等待队列非满时继续存放元素\",{\"1\":{\"530\":1}}],[\"等待队列非空时消费\",{\"1\":{\"544\":1}}],[\"等待队列非空时获取并移除元素\",{\"1\":{\"535\":1}}],[\"等待队列非空再继续消费\",{\"1\":{\"531\":1}}],[\"等待队列非空\",{\"1\":{\"530\":1}}],[\"等待gc回收\",{\"1\":{\"712\":1}}],[\"等待\",{\"1\":{\"711\":1,\"712\":2,\"752\":1,\"820\":1}}],[\"等待非满\",{\"1\":{\"535\":1,\"537\":1}}],[\"等待后续使用\",{\"1\":{\"256\":1}}],[\"等命令来实现事务\",{\"1\":{\"280\":1}}],[\"等过程中产生的临时文件资源\",{\"1\":{\"268\":1}}],[\"等异步命令\",{\"1\":{\"266\":1}}],[\"等数据结构的存储\",{\"1\":{\"245\":1}}],[\"等参数\",{\"1\":{\"210\":1}}],[\"等场景\",{\"1\":{\"190\":1}}],[\"等值查询非常快\",{\"1\":{\"103\":1}}],[\"等多种消息\",{\"1\":{\"1246\":1}}],[\"等多种消息中间件协议\",{\"1\":{\"1237\":1}}],[\"等多种语言\",{\"1\":{\"1168\":1}}],[\"等多种部署架构\",{\"1\":{\"49\":1}}],[\"等多个存储引擎\",{\"1\":{\"83\":1}}],[\"等多个线程同时进入抢购方法\",{\"1\":{\"60\":1}}],[\"等等\",{\"1\":{\"8\":1,\"259\":1,\"329\":1,\"344\":1,\"1146\":1,\"1316\":1,\"1329\":1,\"1349\":1,\"1381\":1,\"1382\":1}}],[\"等\",{\"1\":{\"6\":1,\"8\":1,\"90\":1,\"291\":1,\"342\":1,\"420\":1,\"421\":1,\"436\":1,\"523\":1,\"530\":1,\"649\":2,\"651\":1,\"821\":1,\"999\":1,\"1132\":1,\"1237\":1,\"1245\":1,\"1246\":1,\"1248\":1,\"1388\":1}}],[\"等组件配合使用\",{\"1\":{\"4\":1}}],[\"等不同风格和实现技术的微服务\",{\"1\":{\"2\":1}}],[\"ajax\",{\"1\":{\"1245\":1}}],[\"a036405f989c\",{\"1\":{\"1199\":1}}],[\"a会生成一个类似uuid的traceid字符串\",{\"1\":{\"1045\":1}}],[\"a时\",{\"1\":{\"1045\":1}}],[\"ah\",{\"1\":{\"882\":10}}],[\"ahwzboztt53zffzmssnmsw\",{\"1\":{\"567\":1}}],[\"af\",{\"1\":{\"1151\":1}}],[\"afterwarmup\",{\"1\":{\"1142\":6}}],[\"aftercompletion\",{\"1\":{\"1046\":1}}],[\"afterexecute\",{\"1\":{\"962\":1}}],[\"after\",{\"1\":{\"625\":7,\"708\":4,\"710\":4,\"711\":3,\"713\":2,\"779\":6}}],[\"afternoderemoval\",{\"0\":{\"711\":1},\"1\":{\"711\":6,\"712\":1,\"715\":1}}],[\"afternodeinsertion\",{\"0\":{\"712\":1},\"1\":{\"622\":1,\"686\":1,\"712\":5,\"715\":1}}],[\"afternodeaccess\",{\"1\":{\"622\":1,\"710\":5,\"712\":3,\"715\":1}}],[\"af01\",{\"1\":{\"293\":2}}],[\"aqs\",{\"0\":{\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"743\":1,\"902\":1,\"903\":1,\"904\":1,\"1002\":1,\"1003\":1,\"1005\":1,\"1007\":1,\"1008\":1,\"1017\":1},\"1\":{\"604\":4,\"740\":5,\"741\":1,\"742\":10,\"743\":2,\"744\":4,\"745\":1,\"748\":1,\"749\":1,\"752\":1,\"755\":2,\"758\":3,\"857\":4,\"865\":1,\"871\":1,\"874\":4,\"903\":5,\"904\":6,\"906\":1,\"908\":1,\"910\":2,\"913\":2,\"999\":8,\"1002\":9,\"1003\":5,\"1004\":4,\"1005\":1,\"1006\":3,\"1007\":10,\"1008\":1,\"1011\":1,\"1016\":1,\"1018\":1,\"1019\":8,\"1020\":3,\"1021\":2}}],[\"award\",{\"1\":{\"1178\":1}}],[\"awards\",{\"1\":{\"1178\":3}}],[\"aware\",{\"1\":{\"302\":1}}],[\"awaittermination\",{\"1\":{\"924\":4}}],[\"await方法为例\",{\"1\":{\"752\":1}}],[\"awaitnanos\",{\"1\":{\"537\":2,\"604\":1,\"756\":1,\"911\":1}}],[\"await\",{\"1\":{\"531\":1,\"535\":2,\"544\":2,\"604\":4,\"607\":1,\"742\":1,\"752\":6,\"753\":6,\"756\":6,\"757\":3,\"904\":1,\"908\":4,\"909\":2,\"911\":6,\"1019\":1}}],[\"aa==bb\",{\"1\":{\"498\":1}}],[\"aa\",{\"1\":{\"498\":1}}],[\"a1\",{\"1\":{\"441\":3}}],[\"abits\",{\"1\":{\"871\":2}}],[\"aba\",{\"0\":{\"843\":1,\"992\":1},\"1\":{\"762\":3,\"767\":2,\"841\":1,\"842\":1,\"843\":3,\"990\":1,\"991\":1,\"992\":3,\"995\":1}}],[\"ab\",{\"1\":{\"498\":5}}],[\"abort\",{\"1\":{\"1371\":1}}],[\"abortpolicy\",{\"1\":{\"891\":2,\"936\":2}}],[\"about\",{\"1\":{\"480\":1,\"708\":1,\"756\":1,\"911\":1}}],[\"above\",{\"1\":{\"370\":1}}],[\"abc\",{\"1\":{\"393\":3,\"782\":2,\"944\":3,\"1030\":2}}],[\"abcdefghijklmnopqrstuvwxyzabcdefghjklmnpqrstuvwxzy0123456789\",{\"1\":{\"19\":1}}],[\"abstractloadbalance\",{\"1\":{\"1131\":1,\"1140\":3,\"1141\":1,\"1142\":1}}],[\"abstractlist的\",{\"1\":{\"634\":1}}],[\"abstractlist<e>\",{\"1\":{\"549\":1,\"553\":1,\"634\":1}}],[\"abstractlist\",{\"1\":{\"549\":1,\"727\":2}}],[\"abstractexecutorservice\",{\"1\":{\"934\":1}}],[\"abstractexecutorservice实现了executorservice接口\",{\"1\":{\"934\":1}}],[\"abstractownablesynchronizer\",{\"1\":{\"740\":1,\"903\":1}}],[\"abstractsequentiallist\",{\"1\":{\"727\":2}}],[\"abstractsequentiallist<e>\",{\"1\":{\"727\":1}}],[\"abstractmap<k\",{\"1\":{\"619\":1}}],[\"abstractcollection<e>\",{\"1\":{\"533\":1}}],[\"abstractcollection\",{\"1\":{\"533\":3}}],[\"abstractqueuedsynchronizer中的默认实现仅仅抛出\",{\"1\":{\"748\":1,\"752\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"740\":2,\"742\":1,\"744\":1,\"748\":4,\"752\":4,\"857\":1,\"903\":2,\"904\":1,\"999\":1,\"1002\":1,\"1006\":1,\"1008\":2,\"1011\":7,\"1012\":5,\"1013\":2,\"1014\":4,\"1015\":3,\"1018\":1,\"1020\":1}}],[\"abstractqueue的offer来自下层的arrayblockingqueue从blockingqueue继承并实现的offer方法\",{\"1\":{\"533\":1}}],[\"abstractqueue<e>\",{\"1\":{\"533\":1,\"600\":1,\"797\":1}}],[\"abstractqueue\",{\"1\":{\"533\":8,\"600\":1}}],[\"abstract修饰抽象方法\",{\"1\":{\"520\":1}}],[\"abstract修饰的抽象方法\",{\"1\":{\"520\":1}}],[\"abstract等关键字修饰方法\",{\"1\":{\"332\":1}}],[\"abstract\",{\"1\":{\"329\":1,\"351\":1,\"352\":1,\"353\":1,\"356\":1,\"533\":1,\"740\":1,\"778\":1,\"903\":1,\"943\":1,\"1140\":2}}],[\"author\",{\"1\":{\"679\":1,\"835\":1,\"940\":1}}],[\"authenticate=false\",{\"1\":{\"373\":1}}],[\"auth\",{\"1\":{\"293\":2,\"1351\":1}}],[\"automatically\",{\"1\":{\"351\":1}}],[\"auto\",{\"1\":{\"33\":1,\"233\":2,\"561\":1,\"749\":1,\"757\":4,\"1207\":1}}],[\"aversion\",{\"1\":{\"1382\":1}}],[\"average\",{\"1\":{\"293\":1,\"298\":1}}],[\"availability\",{\"1\":{\"1067\":3,\"1368\":1}}],[\"availableprocessors\",{\"1\":{\"928\":1}}],[\"available\",{\"1\":{\"601\":5,\"603\":1,\"604\":4,\"748\":3,\"1073\":1}}],[\"avoid\",{\"1\":{\"480\":1}}],[\"avgt\",{\"1\":{\"687\":8}}],[\"avg\",{\"1\":{\"293\":7}}],[\"avl树得名于它的发明者g\",{\"1\":{\"98\":1}}],[\"avl树是最先发明的自平衡二叉查找树\",{\"1\":{\"98\":1}}],[\"avl\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"asr\",{\"1\":{\"767\":16}}],[\"assign\",{\"1\":{\"972\":5}}],[\"asserttrue\",{\"1\":{\"782\":1}}],[\"assertnull\",{\"1\":{\"779\":1}}],[\"assertequals\",{\"1\":{\"777\":1,\"778\":1,\"779\":4,\"780\":2,\"781\":2}}],[\"assert\",{\"1\":{\"729\":1,\"730\":1,\"731\":1}}],[\"associated\",{\"1\":{\"356\":1,\"571\":3,\"884\":1}}],[\"astringarray\",{\"1\":{\"634\":2}}],[\"asynctool\",{\"1\":{\"787\":2,\"788\":1}}],[\"asyncpool\",{\"1\":{\"781\":1}}],[\"async\",{\"1\":{\"266\":2,\"1313\":1}}],[\"as\",{\"1\":{\"218\":2,\"293\":2,\"298\":2,\"351\":3,\"356\":1,\"571\":1,\"629\":4}}],[\"ascii\",{\"1\":{\"485\":1}}],[\"asc\",{\"1\":{\"210\":1}}],[\"aside\",{\"0\":{\"145\":1},\"1\":{\"145\":3,\"146\":3,\"316\":2}}],[\"aslist\",{\"1\":{\"53\":1,\"633\":1,\"634\":12,\"649\":1,\"909\":1}}],[\"amr\",{\"1\":{\"767\":16}}],[\"ambiguities\",{\"1\":{\"693\":1}}],[\"amount\",{\"1\":{\"135\":2,\"480\":1}}],[\"amount=400\",{\"1\":{\"135\":1}}],[\"amqp\",{\"0\":{\"1225\":1,\"1230\":1,\"1231\":1,\"1253\":1},\"1\":{\"2\":1,\"1192\":1,\"1222\":1,\"1230\":2,\"1231\":5,\"1237\":2,\"1245\":2,\"1246\":1,\"1252\":1,\"1253\":6,\"1257\":1}}],[\"a向b转账\",{\"1\":{\"125\":1}}],[\"acl\",{\"0\":{\"1351\":1,\"1384\":1},\"1\":{\"1349\":2,\"1350\":1,\"1351\":2,\"1381\":1,\"1382\":1,\"1384\":2,\"1391\":1}}],[\"aclversion\",{\"1\":{\"1327\":1,\"1329\":2,\"1330\":1,\"1349\":2,\"1350\":1}}],[\"acm\",{\"1\":{\"1072\":1,\"1084\":1}}],[\"accurate\",{\"1\":{\"1011\":1}}],[\"accumulator\",{\"1\":{\"630\":2}}],[\"acc\",{\"1\":{\"852\":2,\"853\":1,\"1043\":1}}],[\"accommodated\",{\"1\":{\"693\":1}}],[\"account\",{\"1\":{\"141\":1}}],[\"acceptor表决者\",{\"1\":{\"1372\":1,\"1373\":1}}],[\"acceptor\",{\"1\":{\"1098\":2,\"1374\":8,\"1375\":3}}],[\"accepteitherasync\",{\"1\":{\"781\":2}}],[\"accepteither\",{\"1\":{\"781\":2,\"787\":1}}],[\"accept\",{\"0\":{\"1374\":1},\"1\":{\"265\":1,\"779\":6,\"1372\":1,\"1373\":3,\"1374\":3}}],[\"accesscontrollists\",{\"1\":{\"1351\":1}}],[\"accesscontrolcontext\",{\"1\":{\"1043\":1}}],[\"accessorder\",{\"1\":{\"705\":3,\"706\":1,\"709\":8,\"710\":5,\"717\":2,\"718\":1}}],[\"access\",{\"0\":{\"329\":1},\"1\":{\"256\":1,\"298\":1,\"325\":1,\"329\":1,\"331\":3,\"332\":2,\"553\":2,\"573\":1,\"1384\":1}}],[\"acks\",{\"1\":{\"1206\":5}}],[\"ack\",{\"1\":{\"249\":1,\"1293\":3,\"1313\":1}}],[\"actuator\",{\"1\":{\"918\":1}}],[\"actual\",{\"1\":{\"201\":1}}],[\"actionscript\",{\"1\":{\"1245\":1}}],[\"action\",{\"1\":{\"634\":1,\"779\":18,\"781\":4}}],[\"activemq\",{\"0\":{\"1239\":1},\"1\":{\"1226\":1,\"1240\":6}}],[\"active\",{\"1\":{\"220\":4,\"918\":1,\"1142\":6}}],[\"activedefrag\",{\"1\":{\"220\":2}}],[\"acid只是个概念\",{\"1\":{\"133\":1}}],[\"acid\",{\"1\":{\"125\":1,\"1079\":1}}],[\"acquirequeued\",{\"1\":{\"1008\":1,\"1012\":6,\"1013\":2,\"1014\":1,\"1015\":3}}],[\"acquireread\",{\"1\":{\"871\":2}}],[\"acquirewrite\",{\"1\":{\"871\":2}}],[\"acquireshared\",{\"1\":{\"1019\":1}}],[\"acquiresharedinterruptibly方法是\",{\"1\":{\"748\":1,\"752\":1}}],[\"acquiresharedinterruptibly\",{\"1\":{\"748\":3,\"752\":2,\"906\":2}}],[\"acquires\",{\"1\":{\"748\":4,\"752\":1,\"1007\":3,\"1018\":4}}],[\"acquire方法获取锁的时候\",{\"1\":{\"56\":1}}],[\"acquire\",{\"1\":{\"53\":1,\"56\":2,\"747\":2,\"748\":4,\"749\":5,\"905\":2,\"906\":2,\"1002\":7,\"1007\":2,\"1008\":3,\"1010\":1,\"1012\":1,\"1016\":2,\"1019\":1,\"1020\":1}}],[\"algorithm\",{\"1\":{\"1096\":1}}],[\"algorithms\",{\"1\":{\"1084\":1}}],[\"alive\",{\"1\":{\"940\":2,\"1158\":1}}],[\"alibabacloud\",{\"1\":{\"293\":1,\"298\":1}}],[\"alibaba\",{\"1\":{\"72\":3,\"929\":1,\"1172\":1}}],[\"alternative\",{\"1\":{\"767\":2}}],[\"already\",{\"1\":{\"553\":1,\"564\":1,\"571\":1,\"680\":1}}],[\"always\",{\"1\":{\"161\":1,\"231\":1,\"282\":2,\"623\":1}}],[\"allfutures\",{\"1\":{\"909\":1}}],[\"allof\",{\"1\":{\"782\":5,\"786\":1,\"787\":1,\"909\":2}}],[\"allowed\",{\"1\":{\"693\":1}}],[\"alloc\",{\"1\":{\"218\":2,\"256\":6}}],[\"allocated\",{\"1\":{\"480\":1}}],[\"allocates\",{\"1\":{\"218\":1}}],[\"allocation\",{\"1\":{\"451\":1}}],[\"allocation5\",{\"1\":{\"384\":2}}],[\"allocation4\",{\"1\":{\"384\":2}}],[\"allocation3\",{\"1\":{\"384\":2}}],[\"allocation2\",{\"1\":{\"384\":6}}],[\"allocation1\",{\"1\":{\"384\":6}}],[\"allocations\",{\"1\":{\"218\":1}}],[\"allkeys\",{\"1\":{\"273\":3,\"298\":3}}],[\"all\",{\"1\":{\"120\":2,\"377\":2,\"621\":1,\"782\":3,\"909\":1,\"940\":2,\"1206\":3}}],[\"age++\",{\"1\":{\"386\":1,\"495\":1}}],[\"agetable\",{\"1\":{\"386\":1,\"495\":1}}],[\"age=10\",{\"1\":{\"117\":1}}],[\"age\",{\"1\":{\"117\":6,\"185\":4,\"386\":6,\"495\":5,\"663\":10,\"679\":6,\"767\":8,\"768\":9}}],[\"agent\",{\"1\":{\"17\":1,\"377\":1}}],[\"advanced\",{\"1\":{\"1230\":1,\"1237\":1,\"1245\":1}}],[\"adaptive\",{\"1\":{\"386\":1}}],[\"addwaiter\",{\"1\":{\"1008\":1,\"1010\":1,\"1011\":3,\"1012\":2,\"1014\":2}}],[\"addworkerfailed\",{\"1\":{\"941\":1}}],[\"addworker\",{\"1\":{\"941\":6}}],[\"add方法\",{\"1\":{\"631\":1}}],[\"add方法内部用到了\",{\"1\":{\"588\":1}}],[\"addentry\",{\"1\":{\"622\":1}}],[\"addelapsedtimefrom\",{\"1\":{\"357\":1}}],[\"addelement\",{\"1\":{\"352\":1}}],[\"addifabsent\",{\"1\":{\"588\":1}}],[\"adding\",{\"1\":{\"577\":1}}],[\"addcallback\",{\"1\":{\"1204\":1}}],[\"addcount\",{\"1\":{\"577\":1}}],[\"addclass\",{\"1\":{\"352\":1}}],[\"add和addall使用的rangecheck的一个版本\",{\"1\":{\"553\":1}}],[\"addall\",{\"1\":{\"553\":2,\"602\":2,\"634\":1,\"728\":1}}],[\"addlast\",{\"1\":{\"552\":1,\"656\":1,\"667\":1}}],[\"addfirst\",{\"1\":{\"552\":1,\"656\":1,\"667\":1}}],[\"add\",{\"0\":{\"557\":1},\"1\":{\"531\":5,\"533\":6,\"536\":6,\"539\":1,\"551\":2,\"552\":3,\"553\":2,\"557\":3,\"558\":4,\"561\":1,\"564\":2,\"572\":1,\"585\":1,\"588\":4,\"593\":5,\"599\":3,\"603\":1,\"604\":1,\"630\":2,\"631\":4,\"632\":1,\"634\":8,\"649\":2,\"652\":2,\"656\":3,\"662\":8,\"667\":1,\"678\":1,\"680\":2,\"729\":5,\"732\":6,\"733\":4,\"793\":1,\"941\":1,\"1028\":3,\"1062\":2}}],[\"addtime\",{\"1\":{\"357\":1}}],[\"adjust\",{\"1\":{\"298\":1}}],[\"adelson\",{\"1\":{\"98\":1}}],[\"admin\",{\"1\":{\"7\":1,\"1351\":1,\"1384\":1}}],[\"atomic包下面的原子变量类\",{\"1\":{\"838\":2,\"987\":2}}],[\"atomicstampedreference<>\",{\"1\":{\"767\":1}}],[\"atomicstampedreference<integer>\",{\"1\":{\"767\":1}}],[\"atomicstampedreferencedemo\",{\"1\":{\"767\":1}}],[\"atomicstampedreference\",{\"1\":{\"762\":1,\"767\":3,\"843\":1,\"992\":1}}],[\"atomicmarkablereference<>\",{\"1\":{\"767\":1}}],[\"atomicmarkablereference<boolean>\",{\"1\":{\"767\":1}}],[\"atomicmarkablereferencedemo\",{\"1\":{\"767\":1}}],[\"atomicmarkablereference\",{\"1\":{\"762\":2,\"767\":3}}],[\"atomicreferencetest\",{\"1\":{\"767\":1}}],[\"atomicreferencefieldupdater\",{\"1\":{\"762\":1,\"768\":1}}],[\"atomicreference\",{\"1\":{\"762\":1,\"767\":7}}],[\"atomicreferencearray\",{\"1\":{\"762\":1,\"766\":1}}],[\"atomicboolean\",{\"1\":{\"762\":1,\"763\":1}}],[\"atomiclongfieldupdater\",{\"1\":{\"762\":1,\"768\":1}}],[\"atomiclongarray\",{\"1\":{\"762\":1,\"766\":1}}],[\"atomiclong\",{\"1\":{\"762\":1,\"763\":1,\"838\":1,\"987\":1}}],[\"atomic下\",{\"1\":{\"762\":1}}],[\"atomic\",{\"0\":{\"761\":1,\"762\":1,\"875\":1},\"1\":{\"762\":2,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"875\":2,\"894\":1,\"920\":1,\"1354\":1,\"1360\":1,\"1377\":1}}],[\"atomicity\",{\"1\":{\"125\":1,\"281\":1}}],[\"atomicintegertest\",{\"1\":{\"763\":1}}],[\"atomicintegerfieldupdater<user>\",{\"1\":{\"768\":1}}],[\"atomicintegerfieldupdatertest\",{\"1\":{\"768\":1}}],[\"atomicintegerfieldupdater为例子来介绍\",{\"1\":{\"768\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"762\":1,\"768\":4}}],[\"atomicintegerarraytest\",{\"1\":{\"766\":1}}],[\"atomicintegerarray\",{\"1\":{\"762\":1,\"766\":7}}],[\"atomicinteger\",{\"0\":{\"765\":1},\"1\":{\"56\":2,\"762\":1,\"763\":7,\"764\":2,\"765\":3,\"767\":1,\"835\":3,\"838\":1,\"894\":3,\"920\":3,\"941\":2,\"987\":1,\"1032\":2}}],[\"attribution\",{\"1\":{\"1003\":1}}],[\"attributes\",{\"0\":{\"333\":1},\"1\":{\"325\":3,\"331\":4,\"333\":3}}],[\"attribute\",{\"1\":{\"256\":5,\"325\":1,\"333\":1}}],[\"attach\",{\"1\":{\"807\":1}}],[\"attempts\",{\"1\":{\"1213\":1}}],[\"attemptstamp\",{\"1\":{\"767\":1}}],[\"attemptstampresult=true\",{\"1\":{\"767\":1}}],[\"attemptstampresult=\",{\"1\":{\"767\":1}}],[\"attemptstampresult\",{\"1\":{\"767\":2}}],[\"attemptrecovery\",{\"1\":{\"1210\":2}}],[\"attemptmark\",{\"1\":{\"767\":1}}],[\"attemptmarkresult=true\",{\"1\":{\"767\":1}}],[\"attemptmarkresult=\",{\"1\":{\"767\":1}}],[\"attemptmarkresult\",{\"1\":{\"767\":2}}],[\"attempting\",{\"1\":{\"356\":1}}],[\"attempt\",{\"1\":{\"351\":1}}],[\"attemptlock\",{\"1\":{\"56\":1}}],[\"at\",{\"1\":{\"86\":1,\"218\":1,\"298\":1,\"370\":6,\"553\":1,\"564\":1,\"572\":1,\"618\":2,\"682\":2,\"944\":1}}],[\"architecture\",{\"1\":{\"1106\":1,\"1178\":1}}],[\"archive\",{\"1\":{\"913\":1}}],[\"archives\",{\"1\":{\"511\":1}}],[\"arr\",{\"1\":{\"767\":6,\"1030\":2}}],[\"arraydeque\",{\"0\":{\"668\":1},\"1\":{\"644\":1,\"668\":7}}],[\"arraytolist\",{\"1\":{\"634\":2}}],[\"array指向新数组\",{\"1\":{\"588\":1}}],[\"arraycopytest\",{\"1\":{\"561\":1}}],[\"arraycopy\",{\"0\":{\"560\":1,\"561\":1},\"1\":{\"553\":9,\"561\":5,\"562\":2,\"563\":2,\"591\":2}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"534\":1,\"634\":1}}],[\"arrayblockingqueue中的锁是没有分离的\",{\"1\":{\"542\":1,\"672\":1}}],[\"arrayblockingqueue<e>\",{\"1\":{\"797\":1}}],[\"arrayblockingqueue<string>\",{\"1\":{\"531\":1}}],[\"arrayblockingqueue<>\",{\"1\":{\"531\":3,\"927\":1,\"940\":1}}],[\"arrayblockingqueue<integer>\",{\"1\":{\"531\":2,\"797\":2}}],[\"arrayblockingqueue\",{\"0\":{\"527\":1,\"531\":1,\"532\":1,\"539\":1,\"540\":1,\"541\":1,\"542\":1,\"543\":1,\"544\":1,\"672\":1,\"797\":1},\"1\":{\"529\":3,\"531\":6,\"532\":1,\"533\":12,\"534\":6,\"535\":9,\"536\":1,\"538\":1,\"539\":1,\"541\":4,\"542\":5,\"543\":4,\"544\":2,\"545\":2,\"671\":1,\"672\":5,\"796\":1,\"797\":8,\"798\":1,\"799\":1,\"940\":2,\"1179\":2}}],[\"arraylist的底层数组大小为10\",{\"1\":{\"653\":1}}],[\"arraylist的扩容机制提高了性能\",{\"1\":{\"553\":1}}],[\"arraylist创建时不需要指定大小\",{\"1\":{\"649\":1}}],[\"arraylist会根据实际存储的元素动态地扩容或缩容\",{\"1\":{\"649\":1}}],[\"arraylist扩容的核心方法\",{\"1\":{\"553\":1,\"558\":1}}],[\"arraylist<integer>\",{\"1\":{\"662\":2}}],[\"arraylist<t>\",{\"1\":{\"634\":1}}],[\"arraylist<object>\",{\"1\":{\"564\":4}}],[\"arraylist<\",{\"1\":{\"553\":2}}],[\"arraylist<string>\",{\"1\":{\"551\":1,\"634\":1,\"649\":1,\"652\":1}}],[\"arraylist<e>\",{\"1\":{\"549\":1,\"553\":1,\"634\":1}}],[\"arraylist<>\",{\"1\":{\"531\":1,\"551\":1,\"630\":1,\"631\":1,\"632\":2,\"634\":2,\"649\":1,\"652\":1,\"1062\":1}}],[\"arraylist\",{\"0\":{\"548\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":1,\"649\":1,\"650\":1,\"652\":1,\"653\":1,\"656\":1,\"659\":1},\"1\":{\"429\":1,\"549\":5,\"550\":1,\"551\":1,\"552\":7,\"553\":5,\"555\":7,\"556\":1,\"557\":1,\"558\":1,\"560\":1,\"564\":6,\"588\":1,\"632\":2,\"634\":3,\"642\":2,\"646\":1,\"649\":9,\"650\":1,\"652\":1,\"653\":1,\"656\":8,\"658\":4,\"659\":1,\"662\":20,\"698\":1,\"724\":2,\"727\":3}}],[\"array\",{\"0\":{\"649\":1},\"1\":{\"351\":3,\"553\":8,\"555\":1,\"558\":6,\"559\":9,\"589\":5,\"633\":2,\"634\":9,\"649\":6}}],[\"arrays$arraylist\",{\"1\":{\"634\":2}}],[\"arrayscopyoftest\",{\"1\":{\"562\":1}}],[\"arrays\",{\"0\":{\"560\":1,\"562\":1},\"1\":{\"53\":1,\"553\":7,\"555\":1,\"558\":1,\"562\":3,\"587\":2,\"588\":3,\"591\":1,\"633\":2,\"634\":14,\"649\":3,\"909\":1}}],[\"ar\",{\"1\":{\"767\":7}}],[\"art\",{\"1\":{\"511\":1}}],[\"articles\",{\"1\":{\"334\":1,\"511\":1}}],[\"article\",{\"1\":{\"11\":2,\"221\":1,\"237\":1,\"334\":1,\"360\":1,\"522\":1,\"612\":2,\"720\":1,\"876\":1,\"982\":1,\"1030\":1,\"1185\":1}}],[\"artifactid>\",{\"1\":{\"4\":2,\"1332\":2}}],[\"arg0\",{\"1\":{\"1046\":2}}],[\"arg为获取许可证个数\",{\"1\":{\"748\":1,\"906\":1}}],[\"arg\",{\"1\":{\"748\":5,\"752\":5,\"906\":5,\"1007\":8,\"1008\":4,\"1012\":5,\"1013\":2,\"1014\":4,\"1015\":2,\"1020\":2,\"1299\":1}}],[\"arguments\",{\"1\":{\"570\":1}}],[\"args\",{\"1\":{\"353\":1,\"370\":1,\"384\":2,\"390\":1,\"433\":1,\"484\":3,\"531\":3,\"561\":1,\"562\":1,\"564\":2,\"625\":1,\"663\":1,\"679\":1,\"749\":1,\"753\":1,\"757\":2,\"763\":1,\"766\":1,\"767\":3,\"768\":1,\"807\":1,\"823\":1,\"835\":1,\"882\":1,\"909\":1,\"940\":1,\"1020\":1,\"1028\":1,\"1030\":1,\"1043\":1,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1,\"1062\":1}}],[\"arg3\",{\"1\":{\"268\":1,\"1046\":2}}],[\"arg2\",{\"1\":{\"268\":1,\"1046\":2}}],[\"arg1\",{\"1\":{\"268\":1,\"1046\":2}}],[\"argv\",{\"1\":{\"47\":1,\"49\":2}}],[\"arethe\",{\"1\":{\"1178\":1}}],[\"aren\",{\"1\":{\"693\":1}}],[\"areas\",{\"1\":{\"511\":1}}],[\"area\",{\"1\":{\"498\":2,\"511\":1}}],[\"are\",{\"1\":{\"41\":1,\"201\":3,\"218\":1,\"351\":2,\"354\":1,\"708\":3}}],[\"aofrw\",{\"1\":{\"231\":3}}],[\"aof\",{\"0\":{\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"236\":1},\"1\":{\"35\":3,\"160\":5,\"161\":13,\"162\":9,\"224\":2,\"229\":8,\"230\":10,\"231\":22,\"232\":5,\"233\":42,\"234\":6,\"235\":8,\"236\":22,\"237\":5,\"251\":1,\"263\":2,\"268\":5,\"282\":5}}],[\"aop\",{\"1\":{\"4\":1,\"523\":1}}],[\"a\",{\"1\":{\"19\":2,\"23\":4,\"69\":1,\"78\":2,\"125\":1,\"141\":1,\"145\":11,\"189\":1,\"196\":1,\"201\":2,\"205\":1,\"302\":2,\"351\":10,\"356\":5,\"370\":9,\"429\":1,\"430\":1,\"438\":1,\"441\":1,\"449\":1,\"480\":2,\"531\":2,\"553\":14,\"558\":1,\"561\":10,\"562\":5,\"570\":2,\"571\":1,\"589\":2,\"618\":1,\"629\":3,\"633\":2,\"634\":3,\"677\":1,\"682\":1,\"693\":2,\"694\":7,\"704\":2,\"708\":1,\"710\":9,\"711\":11,\"742\":6,\"768\":3,\"778\":2,\"798\":3,\"823\":4,\"840\":5,\"841\":1,\"843\":3,\"848\":2,\"904\":3,\"974\":1,\"975\":2,\"989\":5,\"990\":1,\"992\":3,\"1016\":5,\"1068\":5,\"1069\":1,\"1070\":1,\"1073\":1,\"1074\":1,\"1085\":2,\"1087\":6,\"1092\":1,\"1105\":5,\"1151\":1,\"1165\":2,\"1209\":1,\"1304\":3,\"1314\":3,\"1321\":1,\"1322\":1,\"1333\":1,\"1335\":1,\"1336\":1,\"1379\":3}}],[\"anti\",{\"0\":{\"1087\":1},\"1\":{\"1086\":1,\"1089\":1}}],[\"antirez\",{\"1\":{\"51\":2,\"218\":1}}],[\"anothervalue\",{\"1\":{\"694\":5}}],[\"anotherlistorcollection\",{\"1\":{\"634\":1}}],[\"ancients\",{\"1\":{\"633\":1}}],[\"anyof\",{\"1\":{\"782\":3,\"787\":1}}],[\"any\",{\"1\":{\"553\":1,\"564\":1}}],[\"answer\",{\"1\":{\"511\":2,\"1218\":1}}],[\"analyzer\",{\"1\":{\"412\":2}}],[\"analyze\",{\"1\":{\"237\":1}}],[\"andthen\",{\"1\":{\"779\":2}}],[\"and\",{\"1\":{\"34\":1,\"117\":2,\"201\":1,\"202\":1,\"237\":3,\"256\":5,\"261\":1,\"298\":1,\"339\":1,\"345\":1,\"351\":1,\"356\":1,\"386\":1,\"396\":1,\"398\":1,\"480\":2,\"511\":1,\"553\":1,\"570\":2,\"571\":1,\"577\":1,\"630\":1,\"708\":1,\"742\":2,\"758\":1,\"765\":1,\"767\":6,\"820\":1,\"841\":1,\"904\":2,\"971\":1,\"974\":1,\"978\":1,\"990\":1,\"995\":1,\"999\":1,\"1004\":1,\"1011\":1,\"1178\":1,\"1333\":1}}],[\"an\",{\"1\":{\"11\":1,\"86\":2,\"201\":1,\"298\":1,\"351\":3,\"356\":1,\"480\":1,\"767\":2}}],[\"ap\",{\"1\":{\"1068\":4,\"1069\":2,\"1070\":2,\"1071\":1,\"1074\":3,\"1079\":1,\"1368\":1}}],[\"apr\",{\"1\":{\"940\":20}}],[\"apollo\",{\"1\":{\"896\":1,\"923\":1}}],[\"apsaradb\",{\"1\":{\"293\":1,\"298\":1}}],[\"appropriate\",{\"1\":{\"767\":2}}],[\"approximately\",{\"1\":{\"618\":1,\"682\":1}}],[\"apple\",{\"1\":{\"634\":2,\"732\":2,\"733\":2,\"1209\":2,\"1213\":1}}],[\"applet\",{\"1\":{\"351\":1}}],[\"apply\",{\"1\":{\"630\":3,\"758\":1,\"999\":1,\"1046\":1}}],[\"application\",{\"1\":{\"480\":2}}],[\"appclassloader的父\",{\"1\":{\"353\":1}}],[\"appclassloader\",{\"1\":{\"345\":1,\"353\":1,\"358\":1}}],[\"app0000000002\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"app0000000001\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"appendentriesrpc\",{\"1\":{\"1115\":1}}],[\"appendentries\",{\"1\":{\"1112\":5}}],[\"appendonly\",{\"1\":{\"229\":3}}],[\"appendfsync\",{\"1\":{\"161\":4,\"231\":4,\"282\":3}}],[\"append\",{\"1\":{\"35\":1,\"224\":1,\"229\":1,\"230\":1,\"282\":1}}],[\"app\",{\"1\":{\"17\":2,\"19\":1,\"425\":7,\"432\":1,\"433\":1,\"1303\":1}}],[\"apache\",{\"1\":{\"7\":2,\"8\":5,\"9\":3,\"10\":1,\"11\":1,\"634\":1,\"1085\":1,\"1091\":1,\"1122\":2,\"1131\":7,\"1140\":1,\"1143\":1,\"1168\":4,\"1171\":3,\"1214\":1,\"1235\":3,\"1236\":4,\"1238\":5,\"1241\":1,\"1276\":2,\"1285\":1,\"1289\":1,\"1290\":1,\"1297\":2,\"1322\":1,\"1332\":2,\"1341\":1,\"1367\":2}}],[\"apisix\",{\"0\":{\"8\":1},\"1\":{\"8\":17,\"10\":10,\"11\":1}}],[\"api\",{\"0\":{\"861\":1},\"1\":{\"2\":6,\"7\":4,\"8\":3,\"10\":1,\"11\":3,\"17\":1,\"53\":1,\"70\":1,\"74\":3,\"75\":3,\"76\":1,\"176\":1,\"205\":1,\"256\":1,\"268\":1,\"351\":1,\"354\":1,\"358\":1,\"360\":1,\"530\":1,\"649\":1,\"772\":1,\"788\":2,\"861\":1,\"876\":1,\"918\":1,\"1003\":2,\"1006\":1,\"1007\":1,\"1226\":1,\"1231\":2,\"1238\":1,\"1311\":2,\"1331\":1,\"1332\":1}}],[\"api网关基础知识总结\",{\"0\":{\"0\":1}}],[\"rw\",{\"1\":{\"1310\":1}}],[\"rmq\",{\"1\":{\"1304\":2}}],[\"rmi\",{\"1\":{\"366\":1,\"373\":1,\"1123\":1}}],[\"rl\",{\"1\":{\"1210\":2}}],[\"rlock\",{\"1\":{\"49\":2}}],[\"rsm\",{\"1\":{\"1106\":1}}],[\"rs=shutdown\",{\"1\":{\"941\":1}}],[\"rs\",{\"1\":{\"941\":8}}],[\"rss\",{\"1\":{\"219\":2}}],[\"rfull\",{\"1\":{\"871\":1}}],[\"rfc\",{\"1\":{\"37\":1}}],[\"r\",{\"1\":{\"387\":2,\"484\":1,\"619\":4,\"704\":2,\"779\":3,\"808\":1,\"891\":2,\"894\":2,\"920\":2,\"1053\":1}}],[\"rt\",{\"1\":{\"353\":4,\"432\":1,\"433\":2}}],[\"rtt\",{\"1\":{\"285\":3}}],[\"ruby\",{\"1\":{\"1237\":1,\"1245\":1,\"1246\":1}}],[\"ruby等\",{\"1\":{\"1171\":1}}],[\"rumor\",{\"0\":{\"1088\":1},\"1\":{\"1086\":1,\"1087\":1,\"1088\":1,\"1089\":2,\"1091\":1}}],[\"rustguide\",{\"1\":{\"280\":1}}],[\"runworker\",{\"1\":{\"1015\":1}}],[\"runstateof\",{\"1\":{\"941\":4}}],[\"runstate\",{\"1\":{\"941\":1}}],[\"runit\",{\"1\":{\"871\":1}}],[\"runasync\",{\"1\":{\"776\":1,\"778\":5,\"784\":1}}],[\"running\",{\"1\":{\"820\":4,\"941\":4}}],[\"runnable自\",{\"1\":{\"943\":1}}],[\"runnable接口\",{\"1\":{\"934\":1}}],[\"runnable\",{\"0\":{\"943\":1},\"1\":{\"599\":2,\"756\":2,\"757\":1,\"778\":6,\"779\":4,\"820\":5,\"882\":1,\"883\":1,\"891\":1,\"894\":1,\"900\":7,\"911\":2,\"920\":1,\"934\":9,\"940\":3,\"941\":2,\"943\":7,\"958\":1,\"1020\":5,\"1043\":2,\"1047\":6,\"1058\":1,\"1059\":1,\"1060\":1,\"1061\":1}}],[\"runner\",{\"1\":{\"8\":1}}],[\"runtimeexception\",{\"1\":{\"524\":2,\"780\":3,\"1209\":1,\"1213\":1}}],[\"runtime\",{\"1\":{\"298\":1,\"351\":1,\"353\":1,\"403\":1,\"451\":12,\"511\":1,\"516\":1,\"928\":1}}],[\"run\",{\"0\":{\"827\":1},\"1\":{\"49\":1,\"370\":4,\"599\":1,\"756\":1,\"778\":1,\"820\":1,\"827\":4,\"882\":1,\"891\":2,\"911\":1,\"936\":1,\"940\":1,\"943\":1,\"1020\":1,\"1043\":1,\"1047\":3,\"1058\":2,\"1059\":2,\"1060\":2,\"1061\":2,\"1321\":1}}],[\"rc3\",{\"1\":{\"220\":1}}],[\"rpop这样的方式存在性能问题\",{\"1\":{\"251\":1}}],[\"rpop即可实现简易版消息队列\",{\"1\":{\"251\":1}}],[\"rpop或者lpush\",{\"1\":{\"181\":1}}],[\"rpop实现队列\",{\"1\":{\"181\":1}}],[\"rpop\",{\"1\":{\"181\":3,\"251\":1}}],[\"rpush\",{\"1\":{\"181\":8,\"251\":4}}],[\"rpcrequest\",{\"1\":{\"1166\":2}}],[\"rpcresponse\",{\"1\":{\"777\":2,\"1166\":2}}],[\"rpcresponse<object>\",{\"1\":{\"777\":1}}],[\"rpc基础知识总结\",{\"0\":{\"1164\":1}}],[\"rpc原理图\",{\"1\":{\"1166\":1}}],[\"rpc原理\",{\"1\":{\"1159\":1}}],[\"rpc可以像调用本地方法那样调用远端方法\",{\"1\":{\"1154\":1}}],[\"rpcstatus>\",{\"1\":{\"1142\":1}}],[\"rpcstatus>>\",{\"1\":{\"1142\":2}}],[\"rpcstatus\",{\"1\":{\"1142\":5}}],[\"rpcexception\",{\"1\":{\"1131\":2}}],[\"rpc\",{\"0\":{\"1150\":1,\"1153\":1,\"1154\":1,\"1155\":1,\"1156\":1,\"1160\":1,\"1165\":1,\"1166\":1,\"1167\":1,\"1173\":1,\"1174\":1,\"1232\":1,\"1396\":1},\"1\":{\"8\":1,\"23\":1,\"41\":1,\"777\":1,\"1112\":2,\"1122\":2,\"1129\":1,\"1130\":2,\"1131\":7,\"1150\":2,\"1152\":1,\"1154\":4,\"1155\":6,\"1156\":1,\"1157\":1,\"1158\":2,\"1159\":3,\"1160\":1,\"1161\":10,\"1164\":1,\"1165\":7,\"1166\":7,\"1167\":2,\"1168\":2,\"1169\":3,\"1170\":1,\"1171\":1,\"1172\":4,\"1173\":2,\"1174\":1,\"1218\":1,\"1232\":8,\"1271\":1,\"1303\":1},\"2\":{\"1149\":1,\"1163\":1,\"1176\":1}}],[\"robin\",{\"1\":{\"820\":1,\"1250\":1}}],[\"rotate\",{\"1\":{\"696\":1}}],[\"root\",{\"1\":{\"406\":1,\"619\":1,\"688\":1,\"1322\":1}}],[\"roots\",{\"1\":{\"391\":4,\"445\":3,\"446\":1}}],[\"routingkey\",{\"1\":{\"1249\":4,\"1252\":5}}],[\"routing\",{\"1\":{\"1245\":1,\"1248\":1,\"1259\":1,\"1281\":1}}],[\"routes\",{\"1\":{\"75\":1}}],[\"route4\",{\"1\":{\"71\":1}}],[\"route3\",{\"1\":{\"71\":3}}],[\"route2\",{\"1\":{\"71\":2}}],[\"route1\",{\"1\":{\"71\":1}}],[\"route\",{\"1\":{\"70\":1,\"71\":1,\"75\":1,\"76\":1}}],[\"router\",{\"1\":{\"42\":1}}],[\"roundrobinloadbalance\",{\"0\":{\"1144\":1},\"1\":{\"1144\":2}}],[\"round\",{\"1\":{\"285\":1,\"820\":1,\"1250\":1}}],[\"roll\",{\"1\":{\"281\":1}}],[\"rollback\",{\"1\":{\"125\":2,\"1370\":1}}],[\"rockemq\",{\"1\":{\"1315\":2}}],[\"rocketmq常见问题总结\",{\"0\":{\"1267\":1}}],[\"rocketmq\",{\"0\":{\"1236\":1,\"1276\":1,\"1280\":1,\"1281\":1,\"1282\":1,\"1304\":1,\"1307\":1,\"1312\":1},\"1\":{\"251\":1,\"788\":4,\"1178\":1,\"1191\":1,\"1194\":1,\"1217\":1,\"1223\":1,\"1236\":9,\"1240\":7,\"1267\":1,\"1276\":6,\"1277\":2,\"1280\":4,\"1281\":5,\"1284\":5,\"1285\":5,\"1289\":1,\"1290\":1,\"1292\":4,\"1296\":1,\"1297\":4,\"1298\":5,\"1299\":4,\"1301\":1,\"1302\":1,\"1304\":4,\"1305\":1,\"1306\":1,\"1311\":2,\"1312\":1,\"1314\":2,\"1315\":5,\"1316\":3},\"2\":{\"1318\":1}}],[\"rocksdb\",{\"1\":{\"244\":1}}],[\"rows\",{\"1\":{\"120\":1,\"125\":2}}],[\"ringbuffer\",{\"1\":{\"1182\":2,\"1184\":6}}],[\"right\",{\"1\":{\"86\":1,\"619\":1}}],[\"ribbon\",{\"1\":{\"4\":1}}],[\"rdb\",{\"0\":{\"158\":1,\"225\":1,\"226\":1,\"227\":1,\"236\":1},\"1\":{\"35\":3,\"158\":2,\"164\":6,\"224\":3,\"227\":1,\"229\":1,\"234\":2,\"235\":6,\"236\":17,\"237\":4,\"251\":1,\"263\":2,\"268\":1,\"282\":3,\"293\":7}}],[\"raghuramakrishnan\",{\"1\":{\"1343\":1}}],[\"rabbtimq\",{\"1\":{\"1264\":1}}],[\"rabbitmq常见问题总结\",{\"0\":{\"1244\":1}}],[\"rabbitmq\",{\"0\":{\"1237\":1,\"1245\":1,\"1246\":1,\"1247\":1,\"1257\":1,\"1259\":1,\"1260\":1,\"1262\":1,\"1263\":1},\"1\":{\"1191\":1,\"1217\":1,\"1230\":1,\"1237\":17,\"1240\":7,\"1245\":2,\"1246\":7,\"1247\":5,\"1248\":2,\"1249\":5,\"1250\":3,\"1251\":8,\"1252\":5,\"1253\":5,\"1254\":1,\"1255\":3,\"1257\":6,\"1258\":1,\"1260\":4,\"1261\":4,\"1263\":9,\"1264\":1,\"1280\":1}}],[\"rarely\",{\"1\":{\"708\":1,\"767\":2}}],[\"race\",{\"1\":{\"576\":1}}],[\"rawtypes\",{\"1\":{\"624\":1}}],[\"raw\",{\"1\":{\"571\":1}}],[\"radius\",{\"1\":{\"210\":2}}],[\"rand\",{\"1\":{\"782\":3}}],[\"randomloadbalance\",{\"0\":{\"1141\":1},\"1\":{\"1141\":4,\"1142\":2,\"1144\":1}}],[\"randomaccessfile\",{\"1\":{\"1310\":1}}],[\"randomaccess\",{\"0\":{\"655\":1,\"658\":1,\"726\":1},\"1\":{\"549\":3,\"552\":1,\"553\":1,\"586\":2,\"634\":1,\"655\":2,\"656\":1,\"658\":9,\"726\":2}}],[\"random\",{\"1\":{\"273\":2,\"708\":1,\"782\":2,\"882\":3,\"1140\":1,\"1141\":1}}],[\"randomuuid\",{\"1\":{\"37\":3,\"1046\":1}}],[\"ranaction\",{\"1\":{\"756\":3,\"911\":3}}],[\"rangecheckforadd\",{\"1\":{\"553\":4,\"561\":2}}],[\"rangecheck\",{\"1\":{\"553\":4}}],[\"ranges\",{\"1\":{\"480\":1}}],[\"range\",{\"1\":{\"120\":2}}],[\"raft\",{\"0\":{\"1103\":1},\"1\":{\"8\":1,\"1097\":4,\"1099\":2,\"1108\":1,\"1109\":2,\"1111\":2,\"1112\":1,\"1115\":1,\"1116\":1,\"1117\":4,\"1200\":2,\"1235\":2,\"1344\":1,\"1361\":1}}],[\"rather\",{\"1\":{\"354\":1}}],[\"ratio\",{\"1\":{\"219\":5}}],[\"ratio=0\",{\"1\":{\"7\":1}}],[\"ratelimiter\",{\"1\":{\"76\":2}}],[\"ratelimit<\",{\"1\":{\"4\":1}}],[\"ratelimit\",{\"1\":{\"4\":1}}],[\"rebalance\",{\"1\":{\"1207\":1}}],[\"req\",{\"1\":{\"1154\":2}}],[\"requeue\",{\"1\":{\"1256\":1}}],[\"requestvoterpc\",{\"1\":{\"1111\":1,\"1114\":1,\"1115\":1}}],[\"request\",{\"1\":{\"1046\":3,\"1130\":1}}],[\"requestid\",{\"0\":{\"1047\":1},\"1\":{\"1046\":11}}],[\"requestinterceptor\",{\"1\":{\"1046\":1}}],[\"requesttemplate\",{\"1\":{\"1046\":1}}],[\"requested\",{\"1\":{\"356\":1}}],[\"requirenonnull\",{\"1\":{\"553\":2,\"630\":4,\"779\":2}}],[\"required\",{\"1\":{\"351\":1}}],[\"requiredargsconstructor\",{\"1\":{\"77\":1}}],[\"relation\",{\"1\":{\"1128\":1}}],[\"releases\",{\"1\":{\"748\":2,\"752\":1,\"1014\":2,\"1236\":1,\"1238\":1}}],[\"releaseshared方法是\",{\"1\":{\"748\":1,\"752\":1}}],[\"releaseshared\",{\"1\":{\"748\":3,\"752\":2,\"906\":2}}],[\"release\",{\"1\":{\"53\":1,\"747\":1,\"748\":4,\"749\":5,\"905\":1,\"906\":2,\"1007\":2,\"1014\":3,\"1020\":1}}],[\"release<\",{\"1\":{\"4\":1}}],[\"reordering\",{\"1\":{\"982\":1}}],[\"reject\",{\"1\":{\"941\":2,\"1256\":1}}],[\"rejectedexecution\",{\"1\":{\"891\":1,\"893\":1,\"941\":1}}],[\"rejectedexecutionexception\",{\"1\":{\"891\":1,\"936\":1}}],[\"rejectedexecutionexception来拒绝新任务的处理\",{\"1\":{\"891\":1,\"936\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"530\":1,\"890\":1,\"891\":2,\"936\":2}}],[\"registry\",{\"1\":{\"1069\":1,\"1128\":1,\"1130\":1}}],[\"regionserver\",{\"1\":{\"1344\":1}}],[\"region\",{\"1\":{\"407\":2}}],[\"regular\",{\"1\":{\"708\":1}}],[\"reverse\",{\"1\":{\"633\":1,\"662\":4,\"696\":1,\"1011\":1}}],[\"reuse\",{\"1\":{\"572\":1}}],[\"re\",{\"1\":{\"571\":1,\"756\":1,\"911\":1}}],[\"rehash\",{\"0\":{\"572\":1},\"1\":{\"571\":1,\"572\":1,\"619\":1,\"1036\":2,\"1038\":2}}],[\"retrypolicy\",{\"1\":{\"1333\":5}}],[\"retryabletopic\",{\"1\":{\"1213\":2}}],[\"retrylisteners\",{\"1\":{\"1210\":1}}],[\"retry\",{\"1\":{\"941\":4,\"1333\":2}}],[\"retries\",{\"1\":{\"571\":7,\"1333\":3}}],[\"retrieved\",{\"1\":{\"571\":1}}],[\"retain\",{\"1\":{\"604\":1}}],[\"retainall\",{\"1\":{\"553\":1}}],[\"returns\",{\"1\":{\"571\":1,\"677\":1,\"680\":2,\"693\":1}}],[\"returned\",{\"1\":{\"351\":1}}],[\"return\",{\"1\":{\"47\":2,\"49\":6,\"56\":3,\"218\":2,\"307\":2,\"357\":1,\"493\":1,\"533\":2,\"535\":2,\"536\":8,\"537\":4,\"538\":3,\"553\":33,\"555\":1,\"557\":3,\"558\":2,\"559\":1,\"562\":2,\"571\":6,\"573\":2,\"576\":1,\"577\":3,\"578\":4,\"587\":1,\"588\":1,\"589\":3,\"590\":1,\"591\":1,\"592\":3,\"599\":4,\"603\":1,\"604\":3,\"605\":1,\"618\":2,\"619\":9,\"622\":6,\"623\":5,\"624\":2,\"629\":3,\"630\":3,\"632\":9,\"634\":3,\"658\":2,\"662\":1,\"663\":5,\"677\":1,\"679\":3,\"680\":1,\"682\":2,\"686\":3,\"706\":1,\"710\":2,\"711\":2,\"712\":3,\"713\":4,\"729\":1,\"730\":5,\"731\":7,\"732\":4,\"742\":2,\"748\":5,\"752\":6,\"756\":3,\"764\":2,\"767\":2,\"768\":2,\"777\":2,\"778\":1,\"779\":14,\"780\":7,\"781\":7,\"782\":2,\"785\":1,\"834\":1,\"841\":1,\"843\":1,\"871\":3,\"882\":1,\"883\":1,\"889\":4,\"894\":1,\"904\":2,\"906\":2,\"911\":3,\"920\":1,\"927\":1,\"928\":1,\"937\":4,\"940\":1,\"941\":8,\"943\":1,\"944\":2,\"949\":2,\"953\":2,\"957\":2,\"961\":1,\"990\":1,\"992\":1,\"1007\":3,\"1011\":6,\"1012\":4,\"1013\":1,\"1014\":7,\"1015\":3,\"1018\":4,\"1020\":3,\"1028\":1,\"1032\":1,\"1036\":6,\"1037\":1,\"1041\":4,\"1042\":1,\"1046\":1,\"1141\":2,\"1142\":5,\"1210\":5,\"1211\":1,\"1299\":1}}],[\"recipes<\",{\"1\":{\"1332\":1}}],[\"receive\",{\"1\":{\"1293\":2}}],[\"recently\",{\"1\":{\"273\":2,\"706\":1}}],[\"recovered\",{\"1\":{\"1210\":2}}],[\"records\",{\"1\":{\"1212\":2}}],[\"record\",{\"1\":{\"1210\":7}}],[\"recordaccess\",{\"1\":{\"622\":1}}],[\"recorded\",{\"1\":{\"576\":1}}],[\"recording\",{\"1\":{\"571\":1}}],[\"recv\",{\"1\":{\"1151\":1}}],[\"recheck\",{\"1\":{\"571\":3,\"941\":3}}],[\"reclaim\",{\"1\":{\"302\":1}}],[\"remappingfunction\",{\"1\":{\"630\":3}}],[\"remaining\",{\"1\":{\"572\":1,\"748\":4}}],[\"remainingcapacity\",{\"1\":{\"533\":1}}],[\"removal\",{\"1\":{\"391\":1,\"708\":1}}],[\"removetreenode\",{\"1\":{\"711\":1}}],[\"removenode\",{\"1\":{\"711\":2,\"712\":4}}],[\"removeeldestentry\",{\"1\":{\"706\":1,\"712\":6,\"718\":2}}],[\"removeif\",{\"1\":{\"631\":2,\"732\":2}}],[\"removeall\",{\"1\":{\"553\":1,\"591\":1,\"593\":2}}],[\"removerange\",{\"1\":{\"553\":1,\"634\":2}}],[\"removeduplicatebylist\",{\"1\":{\"632\":1}}],[\"removeduplicatebyset\",{\"1\":{\"632\":1}}],[\"removed\",{\"1\":{\"553\":1,\"1042\":3}}],[\"removelast\",{\"1\":{\"552\":1,\"656\":1,\"667\":1,\"731\":2}}],[\"removefirst\",{\"1\":{\"552\":1,\"656\":1,\"667\":1,\"731\":2}}],[\"remove\",{\"0\":{\"711\":1},\"1\":{\"49\":1,\"533\":1,\"536\":3,\"539\":1,\"552\":2,\"553\":3,\"585\":1,\"589\":1,\"591\":3,\"593\":2,\"625\":2,\"630\":1,\"631\":5,\"634\":6,\"649\":2,\"656\":2,\"667\":1,\"694\":1,\"711\":3,\"712\":1,\"730\":1,\"731\":4,\"732\":1,\"733\":2,\"793\":1,\"884\":1,\"941\":1,\"1028\":1,\"1046\":1,\"1047\":1,\"1210\":2}}],[\"remotefunc\",{\"1\":{\"1154\":1}}],[\"remote\",{\"1\":{\"242\":1,\"1123\":1,\"1154\":1,\"1165\":1}}],[\"remcarpediem\",{\"1\":{\"237\":1}}],[\"rewrite\",{\"1\":{\"230\":1,\"233\":3}}],[\"rewritepath=\",{\"1\":{\"74\":1,\"75\":1}}],[\"reids\",{\"1\":{\"168\":1}}],[\"replicas>\",{\"1\":{\"1206\":1}}],[\"replicas\",{\"1\":{\"1206\":4}}],[\"replicate\",{\"1\":{\"1281\":1}}],[\"replicated\",{\"1\":{\"1084\":1,\"1112\":1}}],[\"replication\",{\"1\":{\"1206\":4}}],[\"replica\",{\"1\":{\"1197\":3,\"1206\":1}}],[\"replacestaleentry\",{\"1\":{\"1036\":4}}],[\"replacementtreenode\",{\"1\":{\"683\":1}}],[\"replaceall\",{\"1\":{\"634\":1,\"697\":1}}],[\"replace\",{\"1\":{\"33\":3,\"555\":1,\"625\":2,\"1046\":1}}],[\"repair\",{\"1\":{\"1078\":1}}],[\"repeatable\",{\"1\":{\"125\":1,\"132\":2}}],[\"referent\",{\"1\":{\"1030\":1}}],[\"referenceconfig\",{\"1\":{\"1130\":1}}],[\"referencecountinggc\",{\"1\":{\"390\":5}}],[\"referencefield\",{\"1\":{\"1030\":3}}],[\"referencequeue\",{\"1\":{\"392\":3,\"884\":1}}],[\"references\",{\"1\":{\"369\":2}}],[\"reference\",{\"1\":{\"78\":1,\"351\":1,\"392\":1,\"393\":1,\"493\":1,\"497\":1,\"508\":1,\"509\":1,\"510\":3,\"807\":2,\"843\":2,\"992\":2}}],[\"reflect\",{\"1\":{\"344\":1,\"882\":1}}],[\"refresh\",{\"1\":{\"293\":2}}],[\"ref\",{\"1\":{\"120\":7,\"446\":1,\"604\":1,\"1030\":1}}],[\"reetrantlock\",{\"1\":{\"60\":1}}],[\"reentrantreadwritelock的替代品\",{\"1\":{\"873\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"864\":1,\"865\":1,\"866\":1},\"1\":{\"584\":1,\"740\":1,\"793\":1,\"864\":1,\"865\":6,\"866\":2,\"871\":2,\"873\":1,\"903\":1,\"1007\":1,\"1019\":1}}],[\"reentrant\",{\"1\":{\"50\":1}}],[\"reentrantlock+condition\",{\"1\":{\"1183\":1}}],[\"reentrantlock的使用方式\",{\"1\":{\"1001\":1}}],[\"reentrantlock类当然也可以实现\",{\"1\":{\"862\":1}}],[\"reentrantlock类的reentrantlock\",{\"1\":{\"862\":1}}],[\"reentrantlock默认情况是非公平的\",{\"1\":{\"862\":1}}],[\"reentrantlock可以指定是公平锁还是非公平锁\",{\"1\":{\"862\":1}}],[\"reentrantlock提供了一种能够中断等待锁的线程的机制\",{\"1\":{\"862\":1}}],[\"reentrantlock增加了一些高级功能\",{\"1\":{\"862\":1}}],[\"reentrantlock\",{\"0\":{\"856\":1,\"857\":1,\"859\":1,\"861\":1,\"862\":1,\"1000\":1,\"1001\":1,\"1002\":1,\"1007\":1,\"1008\":1,\"1018\":1},\"1\":{\"50\":1,\"534\":2,\"535\":2,\"536\":3,\"537\":2,\"538\":1,\"541\":1,\"544\":1,\"571\":2,\"588\":2,\"591\":1,\"598\":1,\"601\":3,\"603\":1,\"604\":2,\"605\":1,\"607\":1,\"608\":1,\"690\":2,\"692\":1,\"740\":1,\"742\":2,\"747\":1,\"755\":2,\"756\":1,\"758\":1,\"797\":1,\"799\":1,\"835\":2,\"837\":1,\"857\":7,\"861\":1,\"862\":1,\"863\":1,\"865\":1,\"873\":1,\"897\":1,\"903\":1,\"904\":1,\"905\":1,\"910\":2,\"911\":1,\"941\":3,\"986\":1,\"999\":5,\"1001\":5,\"1002\":7,\"1007\":11,\"1008\":3,\"1011\":1,\"1014\":4,\"1018\":5,\"1019\":3,\"1021\":2,\"1179\":2}}],[\"redspider\",{\"1\":{\"982\":2}}],[\"red\",{\"1\":{\"619\":1}}],[\"reduce\",{\"1\":{\"573\":1}}],[\"rednaxelafx\",{\"1\":{\"498\":1,\"511\":1}}],[\"redolog\",{\"1\":{\"90\":1}}],[\"redo\",{\"0\":{\"134\":1,\"136\":1},\"1\":{\"89\":17,\"90\":1,\"133\":1,\"135\":3,\"136\":1,\"1370\":1,\"1371\":1}}],[\"redlock\",{\"1\":{\"50\":1,\"51\":7}}],[\"redisdb\",{\"1\":{\"271\":3}}],[\"redis过期字典\",{\"1\":{\"271\":1}}],[\"redis6\",{\"0\":{\"266\":1,\"267\":1},\"1\":{\"266\":1,\"267\":3}}],[\"redis常见面试题总结\",{\"0\":{\"240\":1,\"277\":1}}],[\"redis常见阻塞原因总结\",{\"0\":{\"156\":1}}],[\"redis7\",{\"1\":{\"233\":1,\"256\":1}}],[\"redis就会自动触发bgsave命令创建快照\",{\"1\":{\"226\":3}}],[\"redis持久化机制详解\",{\"0\":{\"224\":1}}],[\"redis4\",{\"1\":{\"220\":1,\"244\":1,\"266\":1}}],[\"redis内存碎片详解\",{\"0\":{\"216\":1}}],[\"redis集群详解\",{\"0\":{\"153\":1}}],[\"redisratelimiter\",{\"1\":{\"76\":1}}],[\"rediscommands\",{\"1\":{\"49\":1}}],[\"redisson\",{\"1\":{\"49\":10,\"50\":1,\"249\":3}}],[\"redis\",{\"0\":{\"46\":1,\"47\":1,\"51\":1,\"174\":1,\"199\":1,\"218\":1,\"219\":1,\"220\":1,\"235\":1,\"241\":1,\"242\":1,\"243\":1,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"258\":1,\"263\":1,\"264\":1,\"265\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":1,\"290\":1,\"295\":1,\"303\":1,\"304\":1,\"317\":1,\"318\":1,\"319\":1},\"1\":{\"24\":1,\"35\":15,\"45\":3,\"47\":6,\"49\":10,\"51\":16,\"52\":1,\"54\":1,\"57\":2,\"62\":2,\"63\":1,\"76\":1,\"144\":1,\"146\":1,\"153\":1,\"156\":3,\"157\":1,\"158\":4,\"160\":3,\"161\":5,\"162\":2,\"163\":2,\"164\":5,\"165\":2,\"166\":1,\"167\":3,\"168\":8,\"169\":3,\"170\":1,\"171\":3,\"174\":11,\"176\":5,\"177\":3,\"180\":3,\"181\":3,\"182\":1,\"184\":2,\"185\":3,\"188\":1,\"189\":3,\"193\":3,\"195\":1,\"196\":8,\"199\":1,\"201\":1,\"205\":9,\"210\":2,\"212\":1,\"213\":4,\"217\":2,\"218\":13,\"219\":9,\"220\":4,\"221\":6,\"224\":5,\"226\":6,\"227\":6,\"229\":4,\"230\":1,\"231\":9,\"232\":3,\"233\":11,\"234\":4,\"235\":2,\"236\":6,\"237\":8,\"242\":18,\"243\":7,\"244\":8,\"245\":14,\"246\":3,\"249\":8,\"250\":1,\"251\":15,\"252\":4,\"253\":1,\"254\":2,\"256\":11,\"258\":2,\"259\":1,\"263\":3,\"264\":3,\"265\":10,\"266\":7,\"267\":9,\"268\":6,\"270\":2,\"271\":2,\"272\":4,\"273\":3,\"274\":6,\"279\":5,\"280\":6,\"281\":10,\"282\":5,\"283\":9,\"284\":2,\"285\":2,\"286\":9,\"287\":9,\"288\":2,\"289\":4,\"292\":4,\"293\":16,\"294\":4,\"296\":1,\"297\":3,\"298\":16,\"299\":4,\"301\":4,\"302\":3,\"303\":3,\"307\":2,\"314\":2,\"317\":2,\"318\":9,\"319\":5,\"320\":8,\"747\":1,\"905\":1,\"968\":1,\"1085\":23,\"1091\":1,\"1092\":2,\"1157\":1,\"1207\":1,\"1303\":2,\"1388\":2},\"2\":{\"149\":1,\"152\":1,\"155\":1,\"173\":1,\"198\":1,\"215\":1,\"223\":1,\"239\":1,\"276\":1,\"322\":1}}],[\"renewal\",{\"1\":{\"49\":1}}],[\"renewexpirationasync\",{\"1\":{\"49\":4}}],[\"renewexpiration\",{\"1\":{\"49\":3}}],[\"research\",{\"1\":{\"1096\":1}}],[\"reset\",{\"1\":{\"84\":1,\"302\":2}}],[\"response\",{\"1\":{\"1046\":1,\"1130\":1,\"1370\":1}}],[\"responsible\",{\"1\":{\"351\":1}}],[\"resizablecapacitylinkedblockingqueue\",{\"1\":{\"896\":1,\"923\":1}}],[\"resizing\",{\"1\":{\"708\":1}}],[\"resize\",{\"0\":{\"624\":1},\"1\":{\"619\":1,\"621\":2,\"622\":2,\"624\":3,\"683\":1,\"686\":1,\"712\":1,\"1038\":2}}],[\"resultfuture\",{\"1\":{\"777\":4}}],[\"result\",{\"1\":{\"386\":1,\"495\":1,\"593\":4,\"632\":4,\"777\":1,\"778\":2,\"785\":2,\"900\":2,\"943\":1,\"1130\":1,\"1204\":3,\"1272\":1}}],[\"resolving\",{\"1\":{\"369\":2}}],[\"resolved\",{\"1\":{\"369\":1}}],[\"resolveclass\",{\"1\":{\"354\":1,\"357\":1}}],[\"resolve\",{\"1\":{\"354\":3,\"357\":2}}],[\"resolution\",{\"1\":{\"338\":1}}],[\"resource2\",{\"1\":{\"370\":9,\"823\":9,\"824\":9}}],[\"resource1\",{\"1\":{\"370\":10,\"823\":10,\"824\":6}}],[\"resources\",{\"1\":{\"353\":1,\"356\":1,\"1131\":1}}],[\"resource\",{\"1\":{\"53\":1,\"356\":3}}],[\"res\",{\"1\":{\"49\":2,\"412\":2,\"779\":3,\"780\":4,\"781\":2,\"1154\":2}}],[\"restcontrolleradvice和\",{\"1\":{\"77\":1}}],[\"restful\",{\"1\":{\"7\":1}}],[\"rest\",{\"1\":{\"2\":1}}],[\"reason\",{\"1\":{\"693\":1}}],[\"real\",{\"1\":{\"293\":1,\"298\":1}}],[\"readlock\",{\"1\":{\"865\":3,\"871\":1}}],[\"readerlock\",{\"1\":{\"865\":1}}],[\"reader\",{\"1\":{\"688\":1}}],[\"readobject\",{\"1\":{\"678\":1}}],[\"ready\",{\"1\":{\"369\":1,\"757\":22,\"820\":3,\"1200\":1}}],[\"reading\",{\"1\":{\"369\":1}}],[\"reads\",{\"1\":{\"267\":2}}],[\"readview其实就是一张存储事务id的表\",{\"1\":{\"141\":1}}],[\"read\",{\"0\":{\"146\":1},\"1\":{\"125\":3,\"132\":6,\"141\":2,\"146\":5,\"147\":2,\"265\":1,\"351\":1,\"369\":1,\"688\":1,\"972\":2,\"1011\":1,\"1078\":1,\"1308\":3,\"1310\":2,\"1351\":1,\"1384\":1}}],[\"readwritelock接口\",{\"1\":{\"871\":1,\"874\":1}}],[\"readwritelock\",{\"1\":{\"50\":1,\"865\":3,\"872\":1,\"876\":1}}],[\"readme\",{\"1\":{\"41\":1,\"787\":1}}],[\"reactor\",{\"1\":{\"5\":1,\"68\":1,\"243\":1,\"265\":4,\"1062\":1}}],[\"rbac\",{\"1\":{\"2\":1}}],[\"或比自己小的节点都是读请求\",{\"1\":{\"1388\":1}}],[\"或是当\",{\"1\":{\"1361\":1}}],[\"或是在各个线程之间作切换工作时\",{\"1\":{\"807\":1}}],[\"或时间区间来查询消息的方法\",{\"1\":{\"1315\":1}}],[\"或返回给生产者或直接丢弃\",{\"1\":{\"1255\":1}}],[\"或许会被直接丢弃掉\",{\"1\":{\"1249\":1}}],[\"或许会返回给\",{\"1\":{\"1249\":1}}],[\"或许是你的首选\",{\"1\":{\"1240\":1}}],[\"或其他序列化协议去保存结构体数据\",{\"1\":{\"1159\":1}}],[\"或有时叫做内存栅栏\",{\"1\":{\"969\":2}}],[\"或在无法这样做时抛出异常\",{\"1\":{\"943\":1}}],[\"或用户可以引用的对象\",{\"1\":{\"396\":1}}],[\"或调用一个类的静态方法时\",{\"1\":{\"344\":1}}],[\"或调用它没有权限访问的方法时\",{\"1\":{\"341\":1}}],[\"或者那个客户端主动释放了锁\",{\"1\":{\"1388\":1}}],[\"或者打印一下日志查看是否是哪一个线程卡死\",{\"1\":{\"1305\":1}}],[\"或者可以称为\",{\"1\":{\"1279\":1}}],[\"或者我们直接监听节点的状态\",{\"1\":{\"1387\":1}}],[\"或者我们直接通过\",{\"1\":{\"891\":1,\"936\":1}}],[\"或者我消费端处理失败了\",{\"1\":{\"1275\":1}}],[\"或者当我们取消某些业务\",{\"1\":{\"1272\":1}}],[\"或者当前\",{\"1\":{\"1011\":1}}],[\"或者就一个\",{\"1\":{\"1262\":1}}],[\"或者数据持久化都有很好的支持\",{\"1\":{\"1245\":1}}],[\"或者超过一定的重试次数仍无法被成功处理\",{\"1\":{\"1213\":1}}],[\"或者性能以及封装更加优秀的\",{\"1\":{\"1166\":1}}],[\"或者一致性\",{\"1\":{\"1068\":1}}],[\"或者往后遍历过程中\",{\"1\":{\"1035\":1}}],[\"或者上述条件不满足\",{\"1\":{\"1013\":1}}],[\"或者是p不为头结点\",{\"1\":{\"1012\":1}}],[\"或者是为了做数据同步\",{\"1\":{\"224\":1}}],[\"或者也可以把\",{\"1\":{\"934\":1}}],[\"或者也可以使用\",{\"1\":{\"825\":1}}],[\"或者调用await\",{\"1\":{\"908\":1}}],[\"或者其他手段来解决\",{\"1\":{\"968\":1}}],[\"或者其他要测试\",{\"1\":{\"483\":1}}],[\"或者其它原因导致的任务暂停而带来的影响\",{\"1\":{\"895\":1,\"922\":1}}],[\"或者大量任务堆积在任务队列导致\",{\"1\":{\"895\":1,\"922\":1}}],[\"或者初始化时通过构造器参数\",{\"1\":{\"799\":1}}],[\"或者手动实现线程安全的方法来提供安全的多线程操作支持\",{\"1\":{\"651\":1}}],[\"或者扩容前的旧容量小于16\",{\"1\":{\"624\":1}}],[\"或者元素未到期\",{\"1\":{\"604\":2}}],[\"或者链表表里完毕没有相同的\",{\"1\":{\"571\":1}}],[\"或者更快地分配内存\",{\"1\":{\"495\":1}}],[\"或者在一定时间内没有收到所有参与者的响应\",{\"1\":{\"1371\":1}}],[\"或者在一定时间内没有收到协调者的请求\",{\"1\":{\"1371\":1}}],[\"或者在等待些什么资源\",{\"1\":{\"370\":1}}],[\"或者在父类加载器返回之后\",{\"1\":{\"359\":1}}],[\"或者使用\",{\"1\":{\"298\":1}}],[\"或者做运算皆可\",{\"1\":{\"257\":1}}],[\"或者通过\",{\"1\":{\"242\":1}}],[\"或者个别的是\",{\"1\":{\"168\":1}}],[\"或者说我这扣钱明明失败了\",{\"1\":{\"1275\":1}}],[\"或者说是标签\",{\"1\":{\"1248\":1}}],[\"或者说是监听多个\",{\"1\":{\"265\":1}}],[\"或者说压根不知道这回事\",{\"1\":{\"144\":1}}],[\"或者说多个读请求可以共享一把锁读数据\",{\"1\":{\"140\":1}}],[\"或者采用反过来的顺序\",{\"1\":{\"89\":1}}],[\"或者\",{\"1\":{\"45\":1,\"62\":1,\"174\":1,\"181\":1,\"249\":1,\"251\":2,\"329\":1,\"386\":1,\"388\":1,\"407\":1,\"417\":1,\"422\":1,\"455\":1,\"495\":1,\"535\":1,\"694\":1,\"779\":1,\"825\":1,\"900\":1,\"934\":1,\"958\":1,\"1015\":1,\"1068\":1,\"1070\":1,\"1084\":1,\"1109\":1,\"1111\":1,\"1154\":1,\"1251\":1,\"1252\":1,\"1313\":1,\"1371\":1}}],[\"或者退货时客服查询\",{\"1\":{\"18\":1}}],[\"或\",{\"1\":{\"2\":1,\"251\":1,\"344\":1,\"391\":1,\"399\":1,\"646\":2,\"730\":1,\"732\":1,\"934\":5,\"943\":1,\"951\":1,\"972\":2,\"985\":1,\"1071\":1,\"1213\":1}}],[\"如今比较常见的分布式事务实现有\",{\"1\":{\"1304\":1}}],[\"如今例如\",{\"1\":{\"1277\":1}}],[\"如持久化\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"如图\",{\"1\":{\"1109\":1,\"1311\":1}}],[\"如图所示\",{\"1\":{\"1030\":1}}],[\"如图2\",{\"1\":{\"141\":1}}],[\"如网络请求\",{\"1\":{\"925\":1}}],[\"如偏向锁\",{\"1\":{\"854\":1}}],[\"如读写文件\",{\"1\":{\"819\":1}}],[\"如此\",{\"1\":{\"749\":1}}],[\"如此往复\",{\"1\":{\"535\":1}}],[\"如reentrantreadwritelock\",{\"1\":{\"743\":1}}],[\"如reentrantlock\",{\"1\":{\"743\":1}}],[\"如semaphore\",{\"1\":{\"743\":1}}],[\"如put\",{\"1\":{\"694\":1}}],[\"如使用\",{\"1\":{\"688\":1}}],[\"如想深入了解\",{\"1\":{\"639\":1}}],[\"如内存或磁盘上的数据存储\",{\"1\":{\"585\":1}}],[\"如有必要\",{\"1\":{\"553\":1,\"564\":1}}],[\"如list等类型\",{\"1\":{\"522\":1}}],[\"如是否启用偏向锁等\",{\"1\":{\"505\":1}}],[\"如是写道\",{\"1\":{\"387\":1}}],[\"如例子中的年龄\",{\"1\":{\"444\":1}}],[\"如对象年龄\",{\"1\":{\"444\":1}}],[\"如性能分析\",{\"1\":{\"377\":1}}],[\"如线程间死锁\",{\"1\":{\"370\":1}}],[\"如线下收款\",{\"1\":{\"18\":1}}],[\"如空间使用率\",{\"1\":{\"368\":1}}],[\"如com\",{\"1\":{\"359\":1}}],[\"如一部分字节码文件格式验证动作\",{\"1\":{\"340\":1}}],[\"如文本字符串\",{\"1\":{\"328\":1}}],[\"如重大的热搜事件\",{\"1\":{\"296\":1}}],[\"如下代码所示\",{\"1\":{\"536\":1}}],[\"如下所示\",{\"1\":{\"531\":1,\"704\":1,\"1045\":1,\"1349\":1}}],[\"如下面代码所示\",{\"1\":{\"390\":1}}],[\"如下\",{\"1\":{\"280\":1,\"366\":1,\"694\":1,\"757\":2,\"904\":1}}],[\"如下图\",{\"1\":{\"141\":1,\"1035\":1,\"1280\":2}}],[\"如下图所示\",{\"1\":{\"1\":1,\"375\":1,\"762\":1,\"772\":1,\"806\":1,\"823\":1,\"934\":1,\"1030\":1,\"1035\":2,\"1040\":1,\"1088\":1,\"1196\":1,\"1221\":1,\"1249\":1,\"1355\":1}}],[\"如需开启需要设置\",{\"1\":{\"267\":1}}],[\"如echo\",{\"1\":{\"168\":1}}],[\"如\",{\"1\":{\"160\":1,\"232\":1,\"342\":1,\"359\":2,\"492\":1,\"524\":1,\"598\":1,\"631\":1,\"649\":1,\"694\":1,\"811\":1,\"1007\":1,\"1238\":1,\"1252\":1}}],[\"如日期\",{\"1\":{\"82\":1}}],[\"如上图\",{\"1\":{\"1037\":2}}],[\"如上图所示\",{\"1\":{\"71\":1,\"800\":1,\"1033\":1,\"1037\":1,\"1202\":1,\"1313\":1}}],[\"如上图中路由\",{\"1\":{\"71\":2}}],[\"如何给一个对象设置\",{\"1\":{\"1389\":1}}],[\"如何给线程池命名\",{\"0\":{\"894\":1}}],[\"如何去配置整个分布式系统等等\",{\"1\":{\"1367\":1}}],[\"如何去解决这个问题呢\",{\"1\":{\"1304\":1}}],[\"如何减少各个系统之间的耦合度\",{\"1\":{\"1367\":1}}],[\"如何做到写入消息但是对用户不可见呢\",{\"1\":{\"1304\":1}}],[\"如何导致的\",{\"0\":{\"1256\":1}}],[\"如何重新消费这些重试失败的数据呢\",{\"1\":{\"1213\":1}}],[\"如何在重试失败后进行告警\",{\"0\":{\"1212\":1}}],[\"如何自定义重试次数以及时间间隔\",{\"0\":{\"1211\":1}}],[\"如何自定义全局异常处理\",{\"0\":{\"77\":1}}],[\"如何正确选择处理该请求的服务器就很关键\",{\"1\":{\"1139\":1}}],[\"如何扩展\",{\"0\":{\"1131\":1}}],[\"如何出队列\",{\"1\":{\"1012\":1}}],[\"如何加入队列\",{\"0\":{\"1011\":1}}],[\"如何设计并实现一个\",{\"0\":{\"1173\":1}}],[\"如何设计一个能够根据任务的优先级来执行的线程池\",{\"0\":{\"897\":1}}],[\"如何设定线程池的大小\",{\"0\":{\"895\":1}}],[\"如何支持参数动态配置\",{\"1\":{\"896\":1,\"923\":1}}],[\"如何动态修改线程池的参数\",{\"0\":{\"896\":1}}],[\"如何解锁\",{\"0\":{\"1014\":1}}],[\"如何解释分布式事务呢\",{\"1\":{\"1304\":1}}],[\"如何解释\",{\"0\":{\"890\":1}}],[\"如何解决顺序消费和重复消费\",{\"0\":{\"1298\":1}}],[\"如何解决消息堆积问题\",{\"0\":{\"1305\":1}}],[\"如何解决消息的顺序消费问题\",{\"1\":{\"1275\":1}}],[\"如何解决消息队列的延时以及过期失效问题\",{\"0\":{\"1264\":1}}],[\"如何解决重复消费消息的问题\",{\"1\":{\"1275\":1}}],[\"如何解决这个问题呢\",{\"1\":{\"359\":1}}],[\"如何解决呢\",{\"1\":{\"289\":1}}],[\"如何解决\",{\"0\":{\"283\":1,\"299\":1}}],[\"如何解决集群情况下分布式锁的可靠性\",{\"0\":{\"51\":1}}],[\"如何创建线程池\",{\"0\":{\"888\":1}}],[\"如何禁止指令重排序\",{\"0\":{\"834\":1}}],[\"如何预防死锁\",{\"1\":{\"824\":1}}],[\"如何预防和避免线程死锁\",{\"0\":{\"824\":1}}],[\"如何避免死锁\",{\"0\":{\"822\":1},\"1\":{\"824\":1}}],[\"如何理解线程安全和不安全\",{\"0\":{\"818\":1}}],[\"如何按照访问顺序迭代元素\",{\"0\":{\"717\":1}}],[\"如何按照插入顺序迭代元素\",{\"0\":{\"716\":1}}],[\"如何检查重复\",{\"0\":{\"680\":1}}],[\"如何检测节点是否下线\",{\"1\":{\"318\":1}}],[\"如何选用集合\",{\"0\":{\"646\":1}}],[\"如何选择出新的\",{\"1\":{\"318\":1}}],[\"如何选择\",{\"0\":{\"10\":1,\"236\":1,\"1240\":1}}],[\"如何得到class的实例\",{\"1\":{\"523\":1}}],[\"如何才能找到类的元数据信息\",{\"1\":{\"505\":1}}],[\"如何才能实现共享资源的互斥访问呢\",{\"1\":{\"60\":1}}],[\"如何宣告一个对象的真正死亡\",{\"0\":{\"446\":1}}],[\"如何判断是\",{\"1\":{\"895\":1,\"922\":1}}],[\"如何判断一个对象需要被干掉\",{\"0\":{\"445\":1}}],[\"如何判断一个类是无用的类\",{\"0\":{\"394\":1},\"1\":{\"380\":1}}],[\"如何判断一个常量是废弃常量\",{\"0\":{\"393\":1},\"1\":{\"380\":1}}],[\"如何判断对象是否死亡\",{\"1\":{\"380\":1}}],[\"如何确定给定\",{\"1\":{\"318\":1}}],[\"如何从工作内存同步到主内存之间的实现细节\",{\"1\":{\"972\":1}}],[\"如何从\",{\"1\":{\"318\":1}}],[\"如何找到慢查询命令\",{\"0\":{\"302\":1}}],[\"如何处理\",{\"0\":{\"294\":1}}],[\"如何发现\",{\"0\":{\"293\":1,\"298\":1}}],[\"如何使用\",{\"0\":{\"280\":1,\"848\":1,\"882\":1}}],[\"如何保证高性能读写\",{\"0\":{\"1307\":1}}],[\"如何保证消息的可靠性\",{\"0\":{\"1261\":1}}],[\"如何保证消息的消费顺序\",{\"0\":{\"1202\":1}}],[\"如何保证消息不重复消费\",{\"0\":{\"1207\":1}}],[\"如何保证消息不丢失这里\",{\"1\":{\"1208\":1}}],[\"如何保证消息不丢失\",{\"0\":{\"1203\":1}}],[\"如何保证变量的可见性\",{\"0\":{\"833\":1}}],[\"如何保证缓存和数据库数据的一致性\",{\"0\":{\"316\":1}}],[\"如何保证\",{\"0\":{\"1262\":1,\"1263\":1},\"1\":{\"273\":1}}],[\"如何清理\",{\"0\":{\"220\":1},\"1\":{\"303\":1}}],[\"如何查看\",{\"0\":{\"219\":1}}],[\"如何分析sql使用索引情况\",{\"0\":{\"120\":1}}],[\"如何实现呢\",{\"1\":{\"1388\":1}}],[\"如何实现分布式事务\",{\"0\":{\"1304\":1}}],[\"如何实现乐观锁\",{\"0\":{\"839\":1,\"988\":1}}],[\"如何实现\",{\"0\":{\"718\":1}}],[\"如何实现动态路由\",{\"0\":{\"72\":1}}],[\"如何实现可重入锁\",{\"0\":{\"50\":1,\"56\":1}}],[\"如何实现锁的优雅续期\",{\"0\":{\"49\":1}}],[\"如何基于\",{\"0\":{\"47\":1,\"53\":1,\"250\":1}}],[\"如时间\",{\"1\":{\"18\":1}}],[\"如果忘了可以回去看看再次理解一下\",{\"1\":{\"1391\":1}}],[\"如果只是\",{\"1\":{\"1380\":1}}],[\"如果只有一个订阅者\",{\"1\":{\"1194\":1}}],[\"如果只有一个\",{\"1\":{\"1142\":1}}],[\"如果只有在作者全部完成编写后编辑人员才可以读取文档\",{\"1\":{\"128\":1}}],[\"如果超过半数以上的同意那么就进行\",{\"1\":{\"1379\":1}}],[\"如果协调者收到了所有参与者在\",{\"1\":{\"1371\":1}}],[\"如果协调者挂了那么整个系统都处于不可用的状态了\",{\"1\":{\"1370\":1}}],[\"如果可以则返回\",{\"1\":{\"1371\":1}}],[\"如果可以获取成功的话\",{\"1\":{\"748\":1}}],[\"如果能执行我发的事务内容那么就先执行但不提交\",{\"1\":{\"1370\":1}}],[\"如果能有具体的业务含义\",{\"1\":{\"30\":1}}],[\"如果回答你不知道\",{\"1\":{\"1368\":1}}],[\"如果剩下的\",{\"1\":{\"1357\":1}}],[\"如果剩余大小大于\",{\"1\":{\"451\":1}}],[\"如果别人\",{\"1\":{\"1341\":1}}],[\"如果文章有任何需要改善和完善的地方\",{\"1\":{\"1319\":1,\"1341\":1}}],[\"如果文件内容发生了变化\",{\"1\":{\"234\":1}}],[\"如果消费者消费过慢的话\",{\"1\":{\"1305\":1}}],[\"如果消息是\",{\"1\":{\"1304\":1}}],[\"如果消息处理时长无法预估\",{\"1\":{\"1293\":1}}],[\"如果消息队列挂了怎么办呢\",{\"1\":{\"1275\":1}}],[\"如果消息在\",{\"1\":{\"1264\":1}}],[\"如果消息发送失败的话\",{\"1\":{\"1204\":1}}],[\"如果还不是很理解的话\",{\"1\":{\"1281\":1}}],[\"如果还没来的同步的时候宕机或断电了怎么办\",{\"1\":{\"136\":1}}],[\"如果整个系统仅仅靠着一个\",{\"1\":{\"1281\":1}}],[\"如果该节点为持久节点\",{\"1\":{\"1382\":1}}],[\"如果该提案编号\",{\"1\":{\"1374\":1}}],[\"如果该记录涉及到金额的话是不是会出大事情\",{\"1\":{\"1275\":1}}],[\"如果该方法返回了\",{\"1\":{\"1008\":1}}],[\"如果完全匹配则消息会路由到该队列\",{\"1\":{\"1252\":1}}],[\"如果以其他的路由键发送消息\",{\"1\":{\"1252\":1}}],[\"如果以上都没有\",{\"1\":{\"106\":1}}],[\"如果发送消息的时候设置路由键为\",{\"1\":{\"1252\":1}}],[\"如果发现自己的更新\",{\"1\":{\"1114\":1}}],[\"如果发现该线程被中断过\",{\"1\":{\"1015\":1}}],[\"如果发现当前的读锁被占用\",{\"1\":{\"868\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"392\":1}}],[\"如果发现文件有问题\",{\"1\":{\"234\":1}}],[\"如果路由不到\",{\"1\":{\"1249\":1}}],[\"如果业务场景对并发量要求不是太高\",{\"1\":{\"1240\":1}}],[\"如果仍然无法成功处理消息\",{\"1\":{\"1213\":1}}],[\"如果处理失败\",{\"1\":{\"1213\":1}}],[\"如果处于排队等候机制中的线程一直无法获取锁\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"如果数组已满\",{\"1\":{\"1184\":1}}],[\"如果数量大于\",{\"1\":{\"577\":1}}],[\"如果通信协议都用\",{\"1\":{\"1155\":1}}],[\"如果通过where\",{\"1\":{\"106\":2}}],[\"如果现在这不是个本地方法\",{\"1\":{\"1154\":1}}],[\"如果现在有一个需求\",{\"1\":{\"117\":1}}],[\"如果调用的是其他语言开发的服务的时候就不支持了\",{\"1\":{\"1147\":1}}],[\"如果崩溃恢复后\",{\"1\":{\"1115\":1}}],[\"如果写失败\",{\"1\":{\"1078\":1}}],[\"如果检测到不同节点的副本数据不一致\",{\"1\":{\"1078\":1}}],[\"如果网络分区正常的话\",{\"1\":{\"1068\":1}}],[\"如果出现网路波动第\",{\"1\":{\"1304\":1}}],[\"如果出现hash冲突则往后寻找最近的entry为null的槽位\",{\"1\":{\"1038\":1}}],[\"如果出现了这样的错误\",{\"1\":{\"524\":1}}],[\"如果遇到系统流控等原因造成拉取失败\",{\"1\":{\"1293\":1}}],[\"如果遇到k==null的过期数据\",{\"1\":{\"1037\":1}}],[\"如果遇到了key过期的entry数据\",{\"1\":{\"1033\":1}}],[\"如果被偏移\",{\"1\":{\"1037\":1}}],[\"如果被请求的共享资源被占用\",{\"1\":{\"742\":1,\"904\":1}}],[\"如果被请求的共享资源空闲\",{\"1\":{\"742\":1,\"904\":1,\"1004\":1}}],[\"如果定位的位置已经有了数据\",{\"1\":{\"1037\":1}}],[\"如果定位到的数组位置有元素\",{\"1\":{\"622\":1}}],[\"如果定位到的数组位置有元素就和要插入的\",{\"1\":{\"622\":1}}],[\"如果定位到的数组位置没有元素\",{\"1\":{\"622\":2}}],[\"如果条件成立\",{\"1\":{\"1036\":1}}],[\"如果slottoexpunge\",{\"1\":{\"1036\":1}}],[\"如果迭代过程中\",{\"1\":{\"1036\":1}}],[\"如果向前找到了过期数据\",{\"1\":{\"1036\":1}}],[\"如果向任务队列投放任务失败\",{\"1\":{\"893\":1,\"941\":1}}],[\"如果清理工作完成后\",{\"1\":{\"1036\":1}}],[\"如果key没有过期\",{\"1\":{\"1037\":1}}],[\"如果key\",{\"1\":{\"1036\":1}}],[\"如果key值对应的桶中entry数据不为空\",{\"1\":{\"1036\":1}}],[\"如果k\",{\"1\":{\"1036\":1}}],[\"如果找到了相同\",{\"1\":{\"1035\":1}}],[\"如果找到了过期的数据\",{\"1\":{\"1035\":1}}],[\"如果找到entry为null的槽位\",{\"1\":{\"1035\":1}}],[\"如果改动一下代码\",{\"1\":{\"1030\":1}}],[\"如果下一次需要访问相同的数据\",{\"1\":{\"1184\":1}}],[\"如果下一个节点不为空\",{\"1\":{\"731\":1}}],[\"如果下一个节点为空\",{\"1\":{\"731\":1}}],[\"如果下个节点是null或者下个节点被cancelled\",{\"1\":{\"1014\":1}}],[\"如果持有线程全部释放\",{\"1\":{\"1014\":1}}],[\"如果1和2中有一个为true\",{\"1\":{\"1013\":1}}],[\"如果更新成功\",{\"1\":{\"1013\":1}}],[\"如果更新数据库成功\",{\"1\":{\"316\":1}}],[\"如果p是头结点\",{\"1\":{\"1012\":1}}],[\"如果putindex等于数组长度\",{\"1\":{\"535\":1}}],[\"如果再有其他数据set到map中\",{\"1\":{\"1037\":1}}],[\"如果再有线程要获取锁\",{\"1\":{\"1011\":1}}],[\"如果再来新任务的话\",{\"1\":{\"950\":2}}],[\"如果经历了初始化或者并发导致队列中有元素\",{\"1\":{\"1011\":1}}],[\"如果释放后允许唤醒后续等待结点返回\",{\"1\":{\"1007\":1}}],[\"如果共享资源被占用\",{\"1\":{\"1004\":1}}],[\"如果重排序之后的执行结果\",{\"1\":{\"974\":1}}],[\"如果直接复用操作系统层面的内存模型\",{\"1\":{\"971\":1}}],[\"如果两个日志的\",{\"1\":{\"1114\":1}}],[\"如果两个操作不满足上述任意一个\",{\"1\":{\"975\":1}}],[\"如果两个线程同时执行的话\",{\"1\":{\"968\":1}}],[\"如果两者相同\",{\"1\":{\"680\":1}}],[\"如果addworker\",{\"1\":{\"941\":1}}],[\"如果accessorder\",{\"1\":{\"710\":1}}],[\"如果等待超时\",{\"1\":{\"924\":1}}],[\"如果等于数组长度则更新为0\",{\"1\":{\"535\":1}}],[\"如果同一时间有大量任务\",{\"1\":{\"895\":1,\"922\":1}}],[\"如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话\",{\"1\":{\"891\":1,\"936\":1}}],[\"如果达到的话\",{\"1\":{\"890\":1,\"892\":1,\"896\":1,\"923\":1,\"936\":1,\"938\":1}}],[\"如果无限制的创建\",{\"1\":{\"887\":1,\"933\":1}}],[\"如果无法计算结果\",{\"1\":{\"943\":1}}],[\"如果无法满足此时间\",{\"1\":{\"449\":1}}],[\"如果无法通过符号引用验证\",{\"1\":{\"341\":1}}],[\"如果己经有线程持有写锁\",{\"1\":{\"871\":1}}],[\"如果锁的计数器为\",{\"1\":{\"851\":1}}],[\"如果锁的超时时间设置过长\",{\"1\":{\"48\":1}}],[\"如果长时间不成功\",{\"1\":{\"844\":1,\"993\":1}}],[\"如果全部相等\",{\"1\":{\"843\":1,\"992\":1}}],[\"如果相等\",{\"1\":{\"841\":1,\"990\":1}}],[\"如果相同那么就\",{\"1\":{\"1380\":1}}],[\"如果相同则比较\",{\"1\":{\"1380\":1}}],[\"如果相同则更新成新的值\",{\"1\":{\"765\":1}}],[\"如果相同的话\",{\"1\":{\"618\":1,\"682\":1}}],[\"如果乐观锁解决了频繁失败和重试这个问题的话\",{\"1\":{\"838\":1,\"987\":1}}],[\"如果冲突频繁发生\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"如果申请不到\",{\"1\":{\"824\":1}}],[\"如果频繁切换就会造成整体效率低下\",{\"1\":{\"821\":1}}],[\"如果空间不够的话会自动扩容\",{\"1\":{\"799\":1}}],[\"如果空间还不够\",{\"1\":{\"456\":1}}],[\"如果未指定\",{\"1\":{\"798\":1}}],[\"如果保证不了分布式事务的话\",{\"1\":{\"1304\":1}}],[\"如果保证公平性\",{\"1\":{\"797\":1}}],[\"如果保存的数据要求安全性比较高的话\",{\"1\":{\"236\":1}}],[\"如果必须要使用的话\",{\"1\":{\"785\":1}}],[\"如果任务不需要返回结果或抛出异常推荐使用\",{\"1\":{\"943\":1}}],[\"如果任务为null\",{\"1\":{\"941\":1}}],[\"如果任务数量过多且执行速度较慢\",{\"1\":{\"889\":1}}],[\"如果任务是\",{\"1\":{\"819\":2}}],[\"如果任务\",{\"1\":{\"781\":1}}],[\"如果输入的数值等于预期值\",{\"1\":{\"763\":1,\"766\":1}}],[\"如果失败了\",{\"1\":{\"742\":1}}],[\"如果上面参与者返回的都是\",{\"1\":{\"1371\":1}}],[\"如果上面没看懂的读者一定要认真看下面的流程分析\",{\"1\":{\"1315\":1}}],[\"如果上述条件都满足\",{\"1\":{\"1013\":1}}],[\"如果上次返回的节点为空\",{\"1\":{\"732\":1}}],[\"如果上锁成功\",{\"1\":{\"603\":2}}],[\"如果索引值小于\",{\"1\":{\"730\":1}}],[\"如果索引列上使用了函数\",{\"1\":{\"118\":1}}],[\"如果索引列和查询条件的数据类型不匹配\",{\"1\":{\"118\":1}}],[\"如果index小于size的二分之一\",{\"1\":{\"730\":1}}],[\"如果越界就抛异常\",{\"1\":{\"730\":1,\"731\":1}}],[\"如果evict为true且队首元素不为空以及removeeldestentry返回true\",{\"1\":{\"712\":1}}],[\"如果elementdata不是object类型数据\",{\"1\":{\"553\":1}}],[\"如果elementdata数组的长度不为0\",{\"1\":{\"553\":1}}],[\"如果链表长度超过一定数量则会转化成红黑树\",{\"1\":{\"1033\":1}}],[\"如果链表末端为空\",{\"1\":{\"710\":1}}],[\"如果链表元素个数大于等于treeify\",{\"1\":{\"683\":1}}],[\"如果last为空\",{\"1\":{\"710\":1}}],[\"如果leader不为空且q有元素\",{\"1\":{\"604\":1}}],[\"如果后继节点为空\",{\"1\":{\"710\":1,\"711\":1}}],[\"如果后继节点不为空\",{\"1\":{\"710\":2}}],[\"如果前一个节点不为空\",{\"1\":{\"731\":1}}],[\"如果前一个节点为空\",{\"1\":{\"731\":1}}],[\"如果前驱节点的状态是\",{\"1\":{\"1013\":1}}],[\"如果前驱节点b不为空\",{\"1\":{\"711\":1}}],[\"如果前驱节点为空\",{\"1\":{\"710\":1,\"711\":1}}],[\"如果前端请求路径包含\",{\"1\":{\"75\":1}}],[\"如果线程间需要通信\",{\"1\":{\"972\":1}}],[\"如果线程池状态小于stop\",{\"1\":{\"941\":1}}],[\"如果线程池状态依然为running\",{\"1\":{\"941\":1}}],[\"如果线程池状态不是\",{\"1\":{\"941\":1}}],[\"如果线程的状态改变了就再次执行上述操作\",{\"1\":{\"941\":1}}],[\"如果线程是\",{\"1\":{\"819\":2}}],[\"如果线程中断了\",{\"1\":{\"756\":1,\"911\":1}}],[\"如果线程\",{\"1\":{\"694\":1}}],[\"如果线程请求的栈的深度大于虚拟机栈的最大深度\",{\"1\":{\"439\":1}}],[\"如果传入\",{\"1\":{\"693\":1}}],[\"如果传入的参数等于0\",{\"1\":{\"553\":1}}],[\"如果传入的参数大于0\",{\"1\":{\"553\":1}}],[\"如果插入位置没有元素返回null\",{\"1\":{\"680\":1}}],[\"如果并发操作\",{\"1\":{\"631\":1}}],[\"如果既要遍历key又要value\",{\"1\":{\"625\":1}}],[\"如果子节点列表有变动\",{\"1\":{\"1390\":1}}],[\"如果子节点个数变了就代表\",{\"1\":{\"1387\":1}}],[\"如果子树节点数大于\",{\"1\":{\"624\":1}}],[\"如果子树节点数小于等于\",{\"1\":{\"624\":1}}],[\"如果子类覆盖了父类的方法\",{\"1\":{\"519\":1}}],[\"如果子类加载器也无法加载这个类\",{\"1\":{\"357\":1}}],[\"如果table未初始化\",{\"1\":{\"621\":1}}],[\"如果添加s个元素所\",{\"1\":{\"621\":1}}],[\"如果某个\",{\"1\":{\"1281\":2}}],[\"如果某个消费者挂掉\",{\"1\":{\"1280\":1}}],[\"如果某个任务执行时间过长\",{\"1\":{\"611\":1}}],[\"如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上\",{\"1\":{\"1125\":1}}],[\"如果某些方法中的对象引用没有被返回或者未被外面使用\",{\"1\":{\"495\":1}}],[\"如果元素未到期\",{\"1\":{\"604\":1}}],[\"如果元素到期\",{\"1\":{\"604\":1}}],[\"如果元素不为空\",{\"1\":{\"604\":1}}],[\"如果元素为空\",{\"1\":{\"604\":1}}],[\"如果删除的是最后一个元素\",{\"1\":{\"591\":1}}],[\"如果成功添加工作线程\",{\"1\":{\"941\":1}}],[\"如果成功添加元素则返回\",{\"1\":{\"588\":1}}],[\"如果成功了\",{\"1\":{\"742\":1}}],[\"如果成功返回true\",{\"1\":{\"533\":1}}],[\"如果头节点\",{\"1\":{\"578\":1}}],[\"如果头节点就是要找的\",{\"1\":{\"578\":1}}],[\"如果都不满足\",{\"1\":{\"577\":1}}],[\"如果要遍历\",{\"1\":{\"1315\":1}}],[\"如果要使用\",{\"1\":{\"1200\":1,\"1235\":1}}],[\"如果要同步等待线程池彻底关闭后才继续往下执行\",{\"1\":{\"924\":1}}],[\"如果要挂起或者唤醒一个线程\",{\"1\":{\"847\":1}}],[\"如果要插入的位置之前已经存在\",{\"1\":{\"571\":1}}],[\"如果要把\",{\"1\":{\"30\":1}}],[\"如果查找到的\",{\"1\":{\"571\":1}}],[\"如果查询是基于分区表的话\",{\"1\":{\"120\":1}}],[\"如果查询条件中使用了隐式类型转换\",{\"1\":{\"118\":1}}],[\"如果查询条件中使用了表达式操作\",{\"1\":{\"118\":1}}],[\"如果查询条件中使用了is\",{\"1\":{\"118\":1}}],[\"如果查询条件中使用了函数操作\",{\"1\":{\"118\":1}}],[\"如果mincapacity大于最大容量\",{\"1\":{\"558\":1}}],[\"如果mincapacity大于max\",{\"1\":{\"553\":1}}],[\"如果新容量大于\",{\"1\":{\"558\":1,\"559\":1}}],[\"如果指定元素为\",{\"1\":{\"731\":1}}],[\"如果指定元素不存在\",{\"1\":{\"588\":1}}],[\"如果指定位置元素存在\",{\"1\":{\"578\":1}}],[\"如果指定位置的\",{\"1\":{\"571\":1}}],[\"如果指定的集合为null\",{\"1\":{\"555\":1}}],[\"如果指定了\",{\"1\":{\"403\":1}}],[\"如果列表不包含该元素\",{\"1\":{\"553\":1}}],[\"如果列表适用于指定的数组\",{\"1\":{\"553\":1}}],[\"如果列表适合指定的数组\",{\"1\":{\"553\":1}}],[\"如果此时协调者挂了\",{\"1\":{\"1370\":1}}],[\"如果此时集群中已经存在一个\",{\"1\":{\"1361\":1}}],[\"如果此时我们主节点\",{\"1\":{\"1314\":1}}],[\"如果此时有多个消费者组\",{\"1\":{\"1280\":1}}],[\"如果此时有大量用户请求购票整个系统会变成什么样\",{\"1\":{\"1273\":1}}],[\"如果此时修改\",{\"1\":{\"1013\":1}}],[\"如果此时\",{\"1\":{\"1011\":1}}],[\"如果此时对象还没成功逃脱\",{\"1\":{\"446\":1}}],[\"如果此列表被修改则返回true\",{\"1\":{\"553\":1}}],[\"如果此列表不包含此元素\",{\"1\":{\"553\":2}}],[\"如果此列表不包含元素\",{\"1\":{\"553\":2}}],[\"如果此列表包含指定的元素\",{\"1\":{\"553\":2}}],[\"如果最小容量大于已有的最大容量\",{\"1\":{\"553\":1}}],[\"如果每次只扩充一个\",{\"1\":{\"553\":1}}],[\"如果每个主题中只存在一个队列\",{\"1\":{\"1280\":1}}],[\"如果每个\",{\"1\":{\"22\":1}}],[\"如果规定时间内还不能存放元素则直接返回\",{\"1\":{\"537\":1}}],[\"如果返回的数据戳为\",{\"1\":{\"871\":1}}],[\"如果返回值大于等于0\",{\"1\":{\"592\":1}}],[\"如果返回\",{\"1\":{\"536\":1,\"941\":1,\"1011\":2}}],[\"如果入队失败则直接抛异常\",{\"1\":{\"536\":1}}],[\"如果count等数组长度则说明队列已满\",{\"1\":{\"535\":1}}],[\"如果队列满了\",{\"1\":{\"891\":1}}],[\"如果队列非空\",{\"1\":{\"538\":1}}],[\"如果队列不为空则调用dequeue获取元素\",{\"1\":{\"535\":1}}],[\"如果队列中元素个数为0\",{\"1\":{\"535\":1}}],[\"如果队列中有元素\",{\"1\":{\"531\":1}}],[\"如果队列可以存放元素\",{\"1\":{\"535\":1}}],[\"如果队列为空直接返回null\",{\"1\":{\"536\":1}}],[\"如果队列为空则会抛出\",{\"1\":{\"536\":1}}],[\"如果队列为空则阻塞等待\",{\"1\":{\"531\":1,\"533\":1}}],[\"如果队列为空\",{\"1\":{\"535\":1,\"536\":2}}],[\"如果队列已满则会抛出\",{\"1\":{\"536\":1}}],[\"如果队列已满则阻塞等待\",{\"1\":{\"531\":1}}],[\"如果队列已满\",{\"1\":{\"535\":1,\"536\":1}}],[\"如果队列已满元素不可入队则将线程阻塞\",{\"1\":{\"533\":1}}],[\"如果因为冲突失败就重试\",{\"1\":{\"503\":1}}],[\"如果栈的内存大小可以动态扩展\",{\"1\":{\"493\":1}}],[\"如果栈不是很深\",{\"1\":{\"449\":1}}],[\"如果虚拟机在动态扩展栈时无法申请到足够的内存空间\",{\"1\":{\"493\":2}}],[\"如果函数调用陷入无限循环的话\",{\"1\":{\"493\":1}}],[\"如果系统发生\",{\"1\":{\"1070\":1,\"1074\":1}}],[\"如果系统没有发生\",{\"1\":{\"1070\":2,\"1074\":2}}],[\"如果系统支持\",{\"1\":{\"485\":1}}],[\"如果系统对性能和资源消耗非常敏感的话\",{\"1\":{\"255\":1}}],[\"如果将大量定时消息的定时时间设置为同一时刻\",{\"1\":{\"1285\":1}}],[\"如果将军\",{\"1\":{\"1105\":1}}],[\"如果将悲观锁\",{\"1\":{\"985\":1}}],[\"如果将耗时任务提交到线程池中执行\",{\"1\":{\"925\":1}}],[\"如果将此值设置为一个较大值\",{\"1\":{\"464\":1}}],[\"如果将超时时间设置为\",{\"1\":{\"251\":1}}],[\"如果设置的队列大小小于0\",{\"1\":{\"534\":1}}],[\"如果设置为0的话\",{\"1\":{\"464\":1}}],[\"如果设置最大记录条数过大\",{\"1\":{\"302\":1}}],[\"如果堆空间没有用完也抛出了\",{\"1\":{\"456\":1}}],[\"如果确定对象已经死亡\",{\"1\":{\"446\":1}}],[\"如果执行完启发式清理工作后\",{\"1\":{\"1038\":1}}],[\"如果执行\",{\"1\":{\"934\":1}}],[\"如果执行程序已关闭\",{\"1\":{\"891\":1,\"936\":1}}],[\"如果执行notifyall\",{\"1\":{\"544\":1,\"862\":1}}],[\"如果执行的是\",{\"1\":{\"435\":1,\"811\":1}}],[\"如果执行flushall命令意外地刷新了所有内容后\",{\"1\":{\"236\":1}}],[\"如果监测到没有where条件的全表查询应该默认增加一个合适的limit作为限制\",{\"1\":{\"412\":1}}],[\"如果按照前者的理解\",{\"1\":{\"396\":1}}],[\"如果这时没有新的任务提交\",{\"1\":{\"890\":1,\"936\":1}}],[\"如果这时发生内存回收的话而且有必要的话\",{\"1\":{\"393\":1}}],[\"如果这里线程池的线程数量给太少的话你会发现执行的很慢\",{\"1\":{\"749\":1,\"753\":1}}],[\"如果这个互斥锁被释放了\",{\"1\":{\"1388\":1}}],[\"如果这个\",{\"1\":{\"1387\":1}}],[\"如果这个时候获取锁成功\",{\"1\":{\"1015\":1}}],[\"如果这个时候执行了\",{\"1\":{\"1014\":1}}],[\"如果这个时间段没有元素则直接返回null\",{\"1\":{\"533\":1}}],[\"如果这个位置上的\",{\"1\":{\"571\":2}}],[\"如果这个条件成立\",{\"1\":{\"388\":1}}],[\"如果这个类本身是接口的话则是extends\",{\"1\":{\"330\":1}}],[\"如果弱引用所引用的对象被垃圾回收\",{\"1\":{\"392\":1,\"884\":1}}],[\"如果软引用所引用的对象被垃圾回收\",{\"1\":{\"392\":1}}],[\"如果内存空间不足了\",{\"1\":{\"392\":1}}],[\"如果内存空间足够\",{\"1\":{\"392\":1}}],[\"如果小于的话\",{\"1\":{\"941\":1}}],[\"如果小于0则说明已到期直接返回出去\",{\"1\":{\"604\":1}}],[\"如果小于\",{\"1\":{\"388\":1}}],[\"如果大于的话就会回收工作线程\",{\"1\":{\"896\":1,\"923\":1}}],[\"如果大于0则说明任务还没到期\",{\"1\":{\"604\":1}}],[\"如果大于最大值\",{\"1\":{\"570\":1}}],[\"如果大于\",{\"1\":{\"388\":1}}],[\"如果允许\",{\"1\":{\"388\":1}}],[\"如果进程执行的是\",{\"1\":{\"365\":1}}],[\"如果其父类还未初始化\",{\"1\":{\"344\":1}}],[\"如果类没初始化\",{\"1\":{\"344\":1}}],[\"如果程序运行的全部代码\",{\"1\":{\"341\":1}}],[\"如果读取的文件不是以这个魔数开头\",{\"1\":{\"326\":1}}],[\"如果多数节点同时挂掉他也是无法保证可用性的\",{\"1\":{\"1314\":1}}],[\"如果多次重试还是失败的话\",{\"1\":{\"316\":1}}],[\"如果多个\",{\"1\":{\"60\":1,\"63\":1}}],[\"如果多个线程同时访问共享资源\",{\"1\":{\"60\":1}}],[\"如果为临时节点为\",{\"1\":{\"1382\":1}}],[\"如果为了保证\",{\"1\":{\"1068\":1}}],[\"如果为了短时间的不一致性问题\",{\"1\":{\"316\":1}}],[\"如果为空表示当前位置可以写入数据\",{\"1\":{\"577\":1}}],[\"如果为\",{\"1\":{\"354\":1}}],[\"如果为真则做这件事\",{\"1\":{\"70\":1}}],[\"如果值都为\",{\"1\":{\"307\":1}}],[\"如果存活对象数量比较大\",{\"1\":{\"397\":1}}],[\"如果存在则写入自己线程的threadlocal中\",{\"1\":{\"1045\":1}}],[\"如果存在\",{\"1\":{\"553\":1,\"571\":1}}],[\"如果存在一个值不为\",{\"1\":{\"307\":1}}],[\"如果存在主键\",{\"1\":{\"106\":1}}],[\"如果存储数据为空\",{\"1\":{\"307\":1}}],[\"如果用\",{\"1\":{\"307\":1,\"1275\":1}}],[\"如果非要用这种方式来解决穿透问题的话\",{\"1\":{\"307\":1}}],[\"如果黑客恶意攻击\",{\"1\":{\"307\":1}}],[\"如果缓存和数据库都查不到某个\",{\"1\":{\"307\":1}}],[\"如果缓存中的所有数据都是一直保存的话\",{\"1\":{\"270\":1}}],[\"如果突然访问\",{\"1\":{\"297\":1}}],[\"如果突然遇到大量过期\",{\"1\":{\"289\":1}}],[\"如果假设你设置了一批\",{\"1\":{\"272\":1}}],[\"如果需要跨多种语言调用的话\",{\"1\":{\"1172\":1}}],[\"如果需要和\",{\"1\":{\"1167\":1}}],[\"如果需要获得公平性的\",{\"1\":{\"797\":1}}],[\"如果需要原子更新某个类里的某个字段时\",{\"1\":{\"768\":1}}],[\"如果需要原子更新多个变量\",{\"1\":{\"767\":1}}],[\"如果需要自定义同步器一般的方式是这样\",{\"1\":{\"744\":1}}],[\"如果需要删除或插入元素\",{\"1\":{\"732\":1}}],[\"如果需要使用\",{\"1\":{\"373\":1}}],[\"如果需要开启多线程\",{\"1\":{\"267\":1}}],[\"如果需要用这个\",{\"1\":{\"89\":1}}],[\"如果需要用到分布式\",{\"1\":{\"30\":1}}],[\"如果当日活跃过就设置为\",{\"1\":{\"261\":1}}],[\"如果当前执行次数大于最大执行次数则返回\",{\"1\":{\"1210\":1}}],[\"如果当前执行的任务数量大于等于\",{\"1\":{\"941\":1}}],[\"如果当前节点为持久节点\",{\"1\":{\"1349\":1}}],[\"如果当前节点的下个节点不为空\",{\"1\":{\"1014\":1}}],[\"如果当前节点是head的后继节点\",{\"1\":{\"1013\":1}}],[\"如果当前节点是尾节点\",{\"1\":{\"1013\":1}}],[\"如果当前节点不是head的后继节点\",{\"1\":{\"1013\":1}}],[\"如果当前工作线程数量为0\",{\"1\":{\"941\":1}}],[\"如果当前运行的线程数少于\",{\"1\":{\"954\":1}}],[\"如果当前运行的线程数小于\",{\"1\":{\"950\":1}}],[\"如果当前运行的线程数小于核心线程数\",{\"1\":{\"893\":1,\"941\":1}}],[\"如果当前运行的线程数已经等同于最大线程数了\",{\"1\":{\"893\":1,\"941\":1}}],[\"如果当前运行的线程数等于或大于核心线程数\",{\"1\":{\"893\":1,\"941\":1}}],[\"如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时\",{\"1\":{\"891\":1,\"936\":1}}],[\"如果当前线程池中没有线程可用\",{\"1\":{\"888\":1}}],[\"如果当前的key在map中存在\",{\"1\":{\"712\":1}}],[\"如果当前被插入的\",{\"1\":{\"712\":1}}],[\"如果当前数组的长度小于\",{\"1\":{\"616\":1,\"645\":1,\"677\":1,\"683\":3}}],[\"如果当前数组元素为空数组\",{\"1\":{\"553\":1,\"557\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"618\":1,\"682\":1}}],[\"如果当前位置的\",{\"1\":{\"577\":1}}],[\"如果当前位置还不是链表\",{\"1\":{\"572\":1}}],[\"如果当前容量大于扩容阀值\",{\"1\":{\"571\":2}}],[\"如果当前队列为空则阻塞等待timeout且单位为unit的时长\",{\"1\":{\"533\":1}}],[\"如果当前没有任何\",{\"1\":{\"393\":1}}],[\"如果当前\",{\"1\":{\"233\":1,\"958\":1}}],[\"如果有疑问和建议欢迎提出\",{\"1\":{\"1391\":1}}],[\"如果有需要发送消息到多个主题的场景\",{\"1\":{\"1289\":1}}],[\"如果有广播消费的需求\",{\"1\":{\"1250\":1}}],[\"如果有跨语言需求的话可以考虑使用\",{\"1\":{\"1147\":1}}],[\"如果有多个\",{\"1\":{\"1142\":2}}],[\"如果有多个服务提供者的活跃数相等怎么办\",{\"1\":{\"1142\":1}}],[\"如果有多个调用者\",{\"1\":{\"585\":1}}],[\"如果有服务器发现自己的\",{\"1\":{\"1109\":1}}],[\"如果有超过半数接受者就某个提议达成了共识\",{\"1\":{\"1098\":1}}],[\"如果有则更新slottoexpunge值\",{\"1\":{\"1035\":1}}],[\"如果有空闲线程\",{\"1\":{\"892\":1,\"938\":1}}],[\"如果有其他线程要写这棵红黑树就会发生线程不安全问题\",{\"1\":{\"688\":1}}],[\"如果有一种四海之内\",{\"1\":{\"400\":1}}],[\"如果有这个接口的实现类发生了初始化\",{\"1\":{\"344\":1}}],[\"如果有数据立刻返回\",{\"1\":{\"251\":1}}],[\"如果有权限\",{\"1\":{\"88\":1}}],[\"如果说收集算法是内存回收的方法论\",{\"1\":{\"400\":1}}],[\"如果说\",{\"1\":{\"246\":1,\"1281\":1}}],[\"如果把这两个人比作线程的话\",{\"1\":{\"881\":1}}],[\"如果把混合持久化打开\",{\"1\":{\"235\":1}}],[\"如果把一次调用中所有的\",{\"1\":{\"23\":1}}],[\"如果至少有10000个key发生变化\",{\"1\":{\"226\":1}}],[\"如果至少有10个key发生变化\",{\"1\":{\"226\":1}}],[\"如果至少有1个key发生变化\",{\"1\":{\"226\":1}}],[\"如果想实现每一个线程都有自己的专属本地变量该如何解决呢\",{\"1\":{\"881\":1}}],[\"如果想看这个泛型有多少个元素\",{\"1\":{\"558\":1}}],[\"如果想看这个字符串的长度则用到\",{\"1\":{\"558\":1}}],[\"如果想了解的话可以看\",{\"1\":{\"377\":1}}],[\"如果想打破双亲委派模型则需要重写\",{\"1\":{\"354\":1,\"359\":1}}],[\"如果想要调用服务\",{\"1\":{\"1165\":1}}],[\"如果想要保证上面的代码运行正确也非常简单\",{\"1\":{\"835\":1}}],[\"如果想要深入学习的话\",{\"1\":{\"788\":1}}],[\"如果想要详细了解\",{\"1\":{\"685\":1}}],[\"如果想要解决这个多次网络传输的问题\",{\"1\":{\"286\":1}}],[\"如果想要让\",{\"1\":{\"283\":1}}],[\"如果想要使用并发安全的\",{\"1\":{\"583\":1,\"793\":1}}],[\"如果想要使用的话\",{\"1\":{\"287\":1}}],[\"如果想要使用\",{\"1\":{\"251\":1,\"260\":1,\"261\":1}}],[\"如果想要快速查看内存碎片率的话\",{\"1\":{\"219\":1}}],[\"如果想在\",{\"1\":{\"6\":1}}],[\"如果交换量都是\",{\"1\":{\"168\":1}}],[\"如果操作系统把\",{\"1\":{\"168\":1}}],[\"如果操作共享资源的线程还未执行完成的话\",{\"1\":{\"49\":1}}],[\"如果操作共享资源的操作还未完成\",{\"1\":{\"48\":1}}],[\"如果操作共享资源的时间大于过期时间\",{\"1\":{\"48\":1}}],[\"如果主线程发生了阻塞\",{\"1\":{\"165\":1}}],[\"如果主键或唯一索引字段出现重复数据错误而插入失败时\",{\"1\":{\"33\":1}}],[\"如果一定时间后没有收到消费者的响应\",{\"1\":{\"1284\":1,\"1285\":1}}],[\"如果一台服务器能够收到来自\",{\"1\":{\"1111\":1}}],[\"如果一台服务器收到的请求的\",{\"1\":{\"1109\":1}}],[\"如果一段时间还没收到将军\",{\"1\":{\"1105\":1}}],[\"如果一下子释放了大量内存\",{\"1\":{\"165\":1}}],[\"如果一个秒杀系统将服务拆分成了下订单和加积分服务\",{\"1\":{\"1369\":1}}],[\"如果一个主节点挂掉了\",{\"1\":{\"1314\":1}}],[\"如果一个操作\",{\"1\":{\"974\":1}}],[\"如果一个线程\",{\"1\":{\"848\":1}}],[\"如果一个变量事先没有被\",{\"1\":{\"972\":1}}],[\"如果一个变量\",{\"1\":{\"843\":1,\"992\":1}}],[\"如果一个对象仅持有虚引用\",{\"1\":{\"392\":1}}],[\"如果一个对象只具有弱引用\",{\"1\":{\"392\":1,\"884\":1}}],[\"如果一个对象只具有软引用\",{\"1\":{\"392\":1}}],[\"如果一个对象具有强引用\",{\"1\":{\"392\":1}}],[\"如果一个被\",{\"1\":{\"280\":1}}],[\"如果一个\",{\"1\":{\"163\":2,\"291\":1,\"292\":1,\"296\":1,\"1109\":2,\"1111\":1,\"1112\":1}}],[\"如果一个请求可以匹配多个路由\",{\"1\":{\"71\":1}}],[\"如果一个路由规则中有多个断言\",{\"1\":{\"71\":1}}],[\"如果刚执行完命令\",{\"1\":{\"160\":1,\"232\":1}}],[\"如果手动使用\",{\"1\":{\"158\":1}}],[\"如果row的trx\",{\"1\":{\"141\":3}}],[\"如果银行这么整\",{\"1\":{\"124\":1}}],[\"如果从索引的第二列开始查找\",{\"1\":{\"116\":1}}],[\"如果表中的数据量太大\",{\"1\":{\"118\":1}}],[\"如果表没有定义主键\",{\"1\":{\"113\":1}}],[\"如果表定义了主键\",{\"1\":{\"113\":1}}],[\"如果没有收到超过半数的\",{\"1\":{\"1374\":1}}],[\"如果没有学过\",{\"1\":{\"1341\":1}}],[\"如果没有从第\",{\"1\":{\"1304\":1}}],[\"如果没有消息队列\",{\"1\":{\"1272\":1}}],[\"如果没有其他手段来重新分配选票的话\",{\"1\":{\"1111\":1}}],[\"如果没有选出\",{\"1\":{\"1109\":1}}],[\"如果没有选择索引\",{\"1\":{\"120\":1}}],[\"如果没有找到相同\",{\"1\":{\"1035\":1}}],[\"如果没有过多思考\",{\"1\":{\"1030\":1}}],[\"如果没有被初始化\",{\"1\":{\"1011\":1}}],[\"如果没有前一个节点\",{\"1\":{\"732\":1}}],[\"如果没有则抛出\",{\"1\":{\"732\":1}}],[\"如果没有相符的\",{\"1\":{\"680\":1}}],[\"如果没有\",{\"1\":{\"502\":1}}],[\"如果没有特殊说明\",{\"1\":{\"380\":1,\"489\":1}}],[\"如果没有通过setcontextclassloader\",{\"1\":{\"359\":1}}],[\"如果没有使用双亲委派模型\",{\"1\":{\"358\":1}}],[\"如果没有主键\",{\"1\":{\"106\":1}}],[\"如果没有权限\",{\"1\":{\"88\":1}}],[\"如果我们增加一个收回复的过程\",{\"1\":{\"1370\":1}}],[\"如果我们仅仅是发送一个消息也不收回复\",{\"1\":{\"1370\":1}}],[\"如果我们任意节点都可以存入任何消息\",{\"1\":{\"1314\":1}}],[\"如果我们此时的消息需要保证严格的顺序性怎么办呢\",{\"1\":{\"1275\":1}}],[\"如果我们把购买完成的信息发送到消息队列中\",{\"1\":{\"1273\":1}}],[\"如果我们又加一个需求\",{\"1\":{\"1272\":1}}],[\"如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的\",{\"1\":{\"1165\":1}}],[\"如果我们还能像调用本地方法那样去调用它\",{\"1\":{\"1154\":1}}],[\"如果我们有\",{\"1\":{\"1144\":1,\"1357\":2}}],[\"如果我们插入一个value=27的数据\",{\"1\":{\"1033\":1}}],[\"如果我们的强引用不存在的话\",{\"1\":{\"1030\":1}}],[\"如果我们的项目也想要实现这种效果的话\",{\"1\":{\"896\":1,\"923\":1}}],[\"如果我们设置线程数量太大\",{\"1\":{\"895\":1,\"922\":1}}],[\"如果我们设置的线程池数量太小的话\",{\"1\":{\"895\":1,\"922\":1}}],[\"如果我们将一个变量使用\",{\"1\":{\"833\":1}}],[\"如果我们将变量声明为\",{\"1\":{\"833\":1,\"834\":1,\"979\":1}}],[\"如果我们想要在其中查找某个数据\",{\"1\":{\"800\":1}}],[\"如果我们想要实现\",{\"1\":{\"781\":1}}],[\"如果我们想在内存不足时重启服务器\",{\"1\":{\"484\":1}}],[\"如果我们没有指定\",{\"1\":{\"480\":1}}],[\"如果我们需要指定最小和最大堆大小\",{\"1\":{\"478\":1}}],[\"如果我们需要寻找key为28的数据\",{\"1\":{\"99\":1}}],[\"如果我们要继续服务\",{\"1\":{\"1068\":1}}],[\"如果我们要让\",{\"1\":{\"709\":1}}],[\"如果我们要为\",{\"1\":{\"478\":1,\"479\":2}}],[\"如果我们要加载它\",{\"1\":{\"433\":1}}],[\"如果我们要自定义自己的类加载器\",{\"1\":{\"354\":1}}],[\"如果我们因为某些特殊需求想要打破双亲委派模型\",{\"1\":{\"356\":1}}],[\"如果我们不想打破双亲委派模型\",{\"1\":{\"354\":1,\"359\":1}}],[\"如果我们可以批量获取\",{\"1\":{\"34\":1}}],[\"如果命中缓存\",{\"1\":{\"90\":1}}],[\"如果采用\",{\"1\":{\"89\":1}}],[\"如果正在执行的查询\",{\"1\":{\"85\":1}}],[\"如果获取失败\",{\"1\":{\"1008\":1}}],[\"如果获取失败则会创建一个\",{\"1\":{\"748\":1}}],[\"如果获取成功的话\",{\"1\":{\"906\":1}}],[\"如果获取对象锁失败\",{\"1\":{\"851\":1}}],[\"如果获取到\",{\"1\":{\"353\":1}}],[\"如果获取不到锁\",{\"1\":{\"61\":1}}],[\"如果获取锁失败\",{\"1\":{\"53\":1,\"55\":1,\"1010\":1}}],[\"如果不确定消息处理耗时\",{\"1\":{\"1292\":1}}],[\"如果不存在数据依赖性\",{\"1\":{\"969\":1}}],[\"如果不存在该元素则返回\",{\"1\":{\"591\":1,\"731\":2}}],[\"如果不想丢弃任务的话\",{\"1\":{\"891\":1}}],[\"如果不相等\",{\"1\":{\"841\":1,\"990\":1}}],[\"如果不等\",{\"1\":{\"841\":1,\"990\":1}}],[\"如果不为\",{\"1\":{\"731\":1}}],[\"如果不为空\",{\"1\":{\"604\":1}}],[\"如果不指定则默认为integer\",{\"1\":{\"671\":1}}],[\"如果不指定大小的话\",{\"1\":{\"480\":1,\"496\":1}}],[\"如果不是第一次添加\",{\"1\":{\"729\":1}}],[\"如果不是则调用\",{\"1\":{\"729\":1}}],[\"如果不是\",{\"1\":{\"658\":1,\"1013\":1,\"1037\":1}}],[\"如果不是就遍历链表插入\",{\"1\":{\"622\":1}}],[\"如果不是非要实现绝对可靠的分布式锁的话\",{\"1\":{\"51\":1}}],[\"如果不了解虚拟机是怎样使用内存的\",{\"1\":{\"490\":1}}],[\"如果不成立\",{\"1\":{\"388\":1}}],[\"如果不使用线程池\",{\"1\":{\"889\":1}}],[\"如果不使用\",{\"1\":{\"368\":1}}],[\"如果不满足则不回应或者返回\",{\"1\":{\"1374\":1}}],[\"如果不满足\",{\"1\":{\"256\":1}}],[\"如果不用两阶段提交\",{\"1\":{\"89\":1}}],[\"如果不对共享资源进行互斥访问\",{\"1\":{\"60\":1}}],[\"如果对一个变量执行\",{\"1\":{\"972\":1}}],[\"如果对于收集器运作不太了解\",{\"1\":{\"403\":1}}],[\"如果对象还存活\",{\"1\":{\"495\":1}}],[\"如果对象有必要执行\",{\"1\":{\"446\":1}}],[\"如果对象进行可达性分析之后没发现与\",{\"1\":{\"446\":1}}],[\"如果对象在\",{\"1\":{\"386\":1,\"446\":1}}],[\"如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息\",{\"1\":{\"255\":1}}],[\"如果对可靠性要求比较高的话\",{\"1\":{\"57\":1}}],[\"如果对性能要求比较高的话\",{\"1\":{\"10\":1,\"57\":1}}],[\"如果已经获取过一次锁\",{\"1\":{\"56\":1}}],[\"如果客户端发送的请求满足了断言的条件\",{\"1\":{\"70\":1}}],[\"如果客户端发生异常导致没来得及释放锁也没关系\",{\"1\":{\"54\":1}}],[\"如果客户端能够和半数以上的实例成功地完成加锁操作\",{\"1\":{\"51\":1}}],[\"如果你已经接触过\",{\"1\":{\"1341\":1}}],[\"如果你已经知道计算的结果的话\",{\"1\":{\"777\":1}}],[\"如果你看到控制台成功打印出如下信息的话\",{\"1\":{\"1322\":1}}],[\"如果你看过\",{\"1\":{\"678\":1}}],[\"如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况\",{\"1\":{\"1305\":1}}],[\"如果你使用严格顺序模式\",{\"1\":{\"1299\":1}}],[\"如果你使用的公有云的\",{\"1\":{\"299\":1}}],[\"如果你感兴趣可以自己去官网上照着例子搭建属于你自己的\",{\"1\":{\"1298\":1}}],[\"如果你觉得还行\",{\"1\":{\"1272\":1}}],[\"如果你是写请求\",{\"1\":{\"1388\":1}}],[\"如果你是新手\",{\"1\":{\"1217\":1}}],[\"如果你是老手\",{\"1\":{\"1217\":1}}],[\"如果你发送消息的时候指定了\",{\"1\":{\"1202\":1}}],[\"如果你要是公司实际使用的话\",{\"1\":{\"1169\":1}}],[\"如果你要保证线程安全的话就使用\",{\"1\":{\"677\":1}}],[\"如果你写了下面这段代码的话\",{\"1\":{\"882\":1}}],[\"如果你创建了一个threadlocal变量\",{\"1\":{\"881\":1}}],[\"如果你只是准备面试的话\",{\"1\":{\"874\":1}}],[\"如果你的项目经历中用到了\",{\"1\":{\"1177\":1}}],[\"如果你的应用需要有序性\",{\"1\":{\"800\":1}}],[\"如果你的语句不对\",{\"1\":{\"86\":1}}],[\"如果你不需要从回调函数中获取返回结果\",{\"1\":{\"779\":1}}],[\"如果你确实需要在\",{\"1\":{\"693\":1}}],[\"如果你用\",{\"1\":{\"693\":2}}],[\"如果你用的是公有云的\",{\"1\":{\"293\":1,\"298\":1}}],[\"如果你还不了解\",{\"1\":{\"630\":1}}],[\"如果你需要用到\",{\"1\":{\"873\":1}}],[\"如果你需要程序开发\",{\"1\":{\"516\":1}}],[\"如果你需要运行java程序\",{\"1\":{\"516\":1}}],[\"如果你去\",{\"1\":{\"386\":1}}],[\"如果你想要解决这个问题的话\",{\"1\":{\"1170\":1}}],[\"如果你想要成功发表这篇论文的话\",{\"1\":{\"1096\":1}}],[\"如果你想要使用\",{\"1\":{\"38\":1}}],[\"如果你想\",{\"1\":{\"962\":1}}],[\"如果你想使用上述功能\",{\"1\":{\"862\":1}}],[\"如果你想让\",{\"1\":{\"780\":1}}],[\"如果你想将其描述为\",{\"1\":{\"227\":1}}],[\"如果你采用的是高可用架构的\",{\"1\":{\"220\":1}}],[\"如果你现在要找身份证号在\",{\"1\":{\"96\":1}}],[\"如果你必须要实现一个绝对可靠的分布式锁的话\",{\"1\":{\"51\":1}}],[\"如果在整个集群运行的过程中\",{\"1\":{\"1380\":1}}],[\"如果在第一阶段协调者收到了\",{\"1\":{\"1371\":1}}],[\"如果在发送消息的时候设置路由键为\",{\"1\":{\"1252\":1}}],[\"如果在面试的时候你被面试官问到这个问题的话\",{\"1\":{\"1219\":1}}],[\"如果在一段时间内\",{\"1\":{\"888\":1}}],[\"如果在等待获取锁的过程中被打断则该方法会抛出interruptedexception异常\",{\"1\":{\"535\":1}}],[\"如果在等待时长内没有入队成功则直接返回false\",{\"1\":{\"533\":1}}],[\"如果在文中用词或者理解方面出现问题\",{\"1\":{\"416\":1}}],[\"如果在重写期间有写入命令\",{\"1\":{\"233\":1,\"236\":1}}],[\"如果在\",{\"1\":{\"51\":1,\"89\":1,\"944\":1,\"1210\":1}}],[\"如果是你\",{\"1\":{\"1379\":1}}],[\"如果是写请求则要转发给\",{\"1\":{\"1378\":1}}],[\"如果是写服务则转发给\",{\"1\":{\"1355\":2}}],[\"如果是读请求则可以自己处理\",{\"1\":{\"1378\":1}}],[\"如果是读已提交隔离级别则在每次执行查询sql时都会重新生成一致性视图read\",{\"1\":{\"141\":1}}],[\"如果是集群的话\",{\"1\":{\"1280\":1}}],[\"如果是大数据领域的实时计算\",{\"1\":{\"1240\":1}}],[\"如果是从前往后找\",{\"1\":{\"1014\":1}}],[\"如果是不可重入锁的话\",{\"1\":{\"860\":1}}],[\"如果是静态方法\",{\"1\":{\"852\":1}}],[\"如果是实例方法\",{\"1\":{\"852\":1}}],[\"如果是串行\",{\"1\":{\"772\":1}}],[\"如果是则表示还有下一个元素可以遍历\",{\"1\":{\"732\":1}}],[\"如果是则说明当前这个元素是即将到期的任务\",{\"1\":{\"603\":2}}],[\"如果是第一次添加\",{\"1\":{\"729\":1}}],[\"如果是就直接调用\",{\"1\":{\"729\":1}}],[\"如果是就调用e\",{\"1\":{\"622\":1}}],[\"如果是就执行续期操作\",{\"1\":{\"49\":1}}],[\"如果是链表\",{\"1\":{\"573\":1,\"578\":1}}],[\"如果是链表了\",{\"1\":{\"572\":1}}],[\"如果是奇数的话会丢掉小数\",{\"1\":{\"558\":1}}],[\"如果是false\",{\"1\":{\"553\":1}}],[\"如果是true\",{\"1\":{\"553\":1}}],[\"如果是要在指定位置\",{\"1\":{\"552\":1,\"656\":1}}],[\"如果是引⽤类型的变量\",{\"1\":{\"521\":1}}],[\"如果是基本数据类型的变量\",{\"1\":{\"521\":1}}],[\"如果是类的话是否声明为\",{\"1\":{\"329\":1}}],[\"如果是\",{\"1\":{\"236\":1,\"658\":1,\"1144\":1,\"1172\":1}}],[\"如果是组合索引\",{\"1\":{\"104\":1}}],[\"如果是的话\",{\"1\":{\"50\":1}}],[\"如果使用直接指针访问\",{\"1\":{\"510\":1}}],[\"如果使用句柄的话\",{\"1\":{\"509\":1}}],[\"如果使用这个\",{\"1\":{\"485\":1}}],[\"如果使用传统的数据库来处理的话\",{\"1\":{\"270\":1}}],[\"如果使用二叉树来存储\",{\"1\":{\"98\":1}}],[\"如果使用\",{\"1\":{\"49\":1,\"163\":1,\"292\":1}}],[\"如果\",{\"1\":{\"23\":1,\"47\":2,\"53\":1,\"74\":1,\"89\":1,\"146\":1,\"233\":1,\"251\":1,\"280\":1,\"283\":1,\"288\":1,\"316\":1,\"357\":1,\"392\":1,\"419\":1,\"484\":1,\"533\":2,\"535\":1,\"559\":1,\"576\":3,\"622\":3,\"633\":1,\"710\":1,\"729\":1,\"731\":3,\"748\":4,\"752\":4,\"756\":1,\"767\":1,\"816\":1,\"835\":1,\"844\":1,\"884\":1,\"906\":3,\"908\":1,\"911\":1,\"975\":1,\"993\":1,\"1011\":6,\"1015\":1,\"1036\":1,\"1112\":2,\"1114\":1,\"1115\":2,\"1273\":1,\"1281\":1,\"1301\":1,\"1374\":1,\"1380\":1,\"1388\":1}}],[\"如果计划将\",{\"1\":{\"2\":1}}],[\"响应\",{\"1\":{\"1371\":1}}],[\"响应并进入预备状态\",{\"1\":{\"1371\":1}}],[\"响应客户端\",{\"1\":{\"1108\":1}}],[\"响应时间上的损失\",{\"1\":{\"1076\":1}}],[\"响应式编程来提高\",{\"1\":{\"1062\":1}}],[\"响应式网关\",{\"1\":{\"9\":1}}],[\"响应速度会比较慢\",{\"1\":{\"289\":1}}],[\"响应经过过滤处理后\",{\"1\":{\"69\":1}}],[\"响应返回\",{\"1\":{\"69\":1}}],[\"响应过滤\",{\"1\":{\"69\":1}}],[\"响应耗时上升\",{\"1\":{\"22\":1}}],[\"响应聚合\",{\"1\":{\"2\":1}}],[\"响应缓存\",{\"1\":{\"2\":1}}],[\"这无所谓\",{\"1\":{\"1380\":1}}],[\"这端\",{\"1\":{\"1379\":1}}],[\"这有很多方式\",{\"1\":{\"1374\":1}}],[\"这会极大影响性能\",{\"1\":{\"1370\":1}}],[\"这啥玩意\",{\"1\":{\"1367\":1}}],[\"这将会带来数据一致性等问题\",{\"1\":{\"1358\":1}}],[\"这将会占用\",{\"1\":{\"821\":1}}],[\"这应该是一个很简单的数学问题了\",{\"1\":{\"1357\":1}}],[\"这在高并发场景下肯定会严重影响读写性能故引入了零拷贝技术\",{\"1\":{\"1308\":1}}],[\"这在项目开发中还是挺常见的\",{\"1\":{\"772\":1}}],[\"这条回应没有发送成功\",{\"1\":{\"1303\":1}}],[\"这又扯到两个概念\",{\"1\":{\"1299\":1}}],[\"这老家伙\",{\"1\":{\"1281\":1}}],[\"这玩意其实跟选主基本一样\",{\"1\":{\"1388\":1}}],[\"这玩意一看就知道能干啥了\",{\"1\":{\"1388\":1}}],[\"这玩意好简单\",{\"1\":{\"1281\":1}}],[\"这玩意不就是存放消息的队列嘛\",{\"1\":{\"1277\":1}}],[\"这多个合在一起就是一个\",{\"1\":{\"1280\":2}}],[\"这消息队列还怎么用啊\",{\"1\":{\"1275\":1}}],[\"这东西抽象出来就是购票的处理结果呀\",{\"1\":{\"1272\":1}}],[\"这方案主要是提高吞吐量的\",{\"1\":{\"1263\":1}}],[\"这四种\",{\"1\":{\"1252\":1}}],[\"这四个自定义的类加载器对应的目录如下\",{\"1\":{\"359\":1}}],[\"这显然也提高了系统的扩展性\",{\"1\":{\"1222\":1}}],[\"这明显违反高可用性\",{\"1\":{\"1206\":1}}],[\"这正如我上面所画的图一样\",{\"1\":{\"1196\":1}}],[\"这到底是什么意思呢\",{\"1\":{\"1190\":1}}],[\"这中间这么多年有多少自定义的协议\",{\"1\":{\"1155\":1}}],[\"这么用会有问题\",{\"1\":{\"1151\":1}}],[\"这谁忍得了\",{\"1\":{\"1096\":1}}],[\"这俩大佬觉得论文还是挺不错的\",{\"1\":{\"1096\":1}}],[\"这绝不等价于系统不可用\",{\"1\":{\"1076\":1}}],[\"这说明replacestaleentry\",{\"1\":{\"1036\":1}}],[\"这说明这里是替换逻辑\",{\"1\":{\"1036\":1}}],[\"这说明散列数组这里没有数据冲突\",{\"1\":{\"1036\":1}}],[\"这块\",{\"1\":{\"1159\":1}}],[\"这块具体见下边代码分析\",{\"1\":{\"1011\":1}}],[\"这块可能会有以下思考\",{\"1\":{\"1002\":1}}],[\"这块代码的含义为\",{\"1\":{\"1002\":1}}],[\"这只是\",{\"1\":{\"971\":1}}],[\"这并不合适\",{\"1\":{\"929\":1}}],[\"这并不意味着它可以保证所有的复合操作都是原子性的\",{\"1\":{\"694\":1}}],[\"这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集\",{\"1\":{\"1240\":1}}],[\"这点性能影响是可以接受的\",{\"1\":{\"897\":1}}],[\"这点和\",{\"1\":{\"302\":1}}],[\"这存在一些风险和问题\",{\"1\":{\"897\":1}}],[\"这存在一些问题\",{\"1\":{\"256\":1}}],[\"这代表你将丢失对这个任务的处理\",{\"1\":{\"891\":1,\"936\":1}}],[\"这段代码其实是分为三步执行\",{\"1\":{\"834\":1}}],[\"这减少了线程上下文切换的开销\",{\"1\":{\"816\":1}}],[\"这表示\",{\"1\":{\"777\":1}}],[\"这表示写入的资料必须完全符合所有的预设规则\",{\"1\":{\"125\":1}}],[\"这和它在易用性\",{\"1\":{\"1237\":1}}],[\"这和我们日常接触到的\",{\"1\":{\"1097\":1}}],[\"这和我们上面讲到的\",{\"1\":{\"972\":1}}],[\"这和我们以往通过实现接口的方式有很大区别\",{\"1\":{\"744\":1}}],[\"这和关系型数据库\",{\"1\":{\"160\":1}}],[\"这几个方法都是\",{\"1\":{\"742\":1,\"904\":1,\"1006\":1}}],[\"这过程对其他的调用者都是透明的\",{\"1\":{\"585\":1}}],[\"这次调用将被忽略\",{\"1\":{\"779\":1}}],[\"这次是\",{\"1\":{\"567\":1}}],[\"这次又来了\",{\"1\":{\"567\":1}}],[\"这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度\",{\"1\":{\"553\":1}}],[\"这不过这里的\",{\"1\":{\"1380\":1}}],[\"这不多余吗\",{\"1\":{\"1281\":1}}],[\"这不也是一种空间的浪费吗\",{\"1\":{\"708\":1}}],[\"这不应该发生\",{\"1\":{\"553\":1}}],[\"这不仅包括内存碎片\",{\"1\":{\"219\":1}}],[\"这可以减少递增式再分配的数量\",{\"1\":{\"549\":1}}],[\"这可能是由于网络延迟\",{\"1\":{\"1069\":1}}],[\"这可能是最好的联接类型\",{\"1\":{\"120\":1}}],[\"这可能会释放一个阻塞的\",{\"1\":{\"749\":1}}],[\"这可能会导致一定的数据一致性问题\",{\"1\":{\"585\":1}}],[\"这可能会导致\",{\"1\":{\"485\":1}}],[\"这意味着消息在发送给客户端时先在中心队列排队\",{\"1\":{\"1245\":1}}],[\"这意味着\",{\"1\":{\"542\":1,\"672\":1}}],[\"这意味着它只受系统内存的限制\",{\"1\":{\"496\":1}}],[\"这其中虽然做面的时间没有变短\",{\"1\":{\"1271\":1}}],[\"这其中我们也就传达了一个消息\",{\"1\":{\"1271\":1}}],[\"这其中前三种都会发生线程切换\",{\"1\":{\"821\":1}}],[\"这其中自然也包含了我们这篇文章所讨论的阻塞队列\",{\"1\":{\"529\":1}}],[\"这其实就是一代理类\",{\"1\":{\"1166\":1}}],[\"这其实就是多线程中经典的\",{\"1\":{\"773\":1,\"899\":1}}],[\"这其实是最为简单的一种\",{\"1\":{\"412\":1}}],[\"这反过来又会迫使\",{\"1\":{\"485\":1}}],[\"这反过来会导致应用程序崩溃\",{\"1\":{\"484\":1}}],[\"这通过将重复\",{\"1\":{\"485\":1}}],[\"这通常比all快\",{\"1\":{\"120\":1}}],[\"这本书是这样介绍的\",{\"1\":{\"1132\":1}}],[\"这本书中的一张图就可以非常好的解释清楚\",{\"1\":{\"976\":1}}],[\"这本书中的一张\",{\"1\":{\"974\":1}}],[\"这本书\",{\"1\":{\"386\":1}}],[\"这同样是\",{\"1\":{\"288\":1}}],[\"这主要也是因为\",{\"1\":{\"287\":1}}],[\"这部分属于\",{\"1\":{\"1015\":1}}],[\"这部分内容参考和借鉴了这篇文章\",{\"1\":{\"1199\":1}}],[\"这部分内容在类加载器详解这篇文章中有详细介绍到\",{\"1\":{\"340\":1}}],[\"这部分内存不会立即被回收\",{\"1\":{\"256\":1}}],[\"这部分的内容\",{\"1\":{\"286\":1}}],[\"这篇论文就\",{\"1\":{\"1096\":1}}],[\"这篇就文章\",{\"1\":{\"268\":1}}],[\"这篇文章简单给演示一下\",{\"1\":{\"1319\":1}}],[\"这篇文章可以看作是对\",{\"1\":{\"1177\":1}}],[\"这篇文章会简单介绍一下\",{\"1\":{\"1164\":1}}],[\"这篇文章会详细总结一下可能导致\",{\"1\":{\"156\":1}}],[\"这篇文章同样耗费了不少的时间和精力才创作完成\",{\"1\":{\"1026\":1}}],[\"这篇文章中我带大家入门了\",{\"1\":{\"1391\":1}}],[\"这篇文章中我主要想大家介绍了\",{\"1\":{\"1316\":1}}],[\"这篇文章中有详细介绍到如何基于\",{\"1\":{\"1346\":1}}],[\"这篇文章中已经介绍到\",{\"1\":{\"1329\":1}}],[\"这篇文章中的消息队列主要指的是分布式消息队列\",{\"1\":{\"1217\":1}}],[\"这篇文章中介绍过\",{\"1\":{\"1192\":1}}],[\"这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法\",{\"1\":{\"896\":1,\"923\":1}}],[\"这篇文章中就说过这三个参数是\",{\"1\":{\"896\":1}}],[\"这篇文章中详细介绍了\",{\"1\":{\"286\":1}}],[\"这篇文章中详细介绍了链表这种数据结构\",{\"1\":{\"180\":1}}],[\"这篇文章介绍了\",{\"1\":{\"788\":1}}],[\"这篇文章详细介绍了\",{\"1\":{\"788\":1}}],[\"这篇文章只是简单介绍了\",{\"1\":{\"788\":1}}],[\"这篇文章是我根据官方文档以及自己平时的使用情况\",{\"1\":{\"1120\":1}}],[\"这篇文章是基于\",{\"1\":{\"1120\":1}}],[\"这篇文章是\",{\"1\":{\"772\":1}}],[\"这篇文章对于\",{\"1\":{\"687\":1}}],[\"这篇文章我会详细介绍一下线程池的基本概念以及核心原理\",{\"1\":{\"932\":1}}],[\"这篇文章我根据\",{\"1\":{\"628\":1}}],[\"这篇文章我们主要介绍了\",{\"1\":{\"63\":1}}],[\"这篇文章我们先介绍一下分布式锁的基本概念\",{\"1\":{\"59\":1}}],[\"这篇文章我们介绍了实现分布式锁的两种常见方式\",{\"1\":{\"57\":1}}],[\"这篇文章共\",{\"1\":{\"412\":1}}],[\"这篇文章\",{\"1\":{\"231\":1,\"233\":1,\"341\":1,\"382\":1,\"408\":1,\"412\":1,\"742\":1,\"857\":1,\"868\":1,\"896\":1,\"1088\":1,\"1223\":1}}],[\"这篇文章涉及对这部分知识的深入讲解\",{\"1\":{\"87\":1}}],[\"这保持了\",{\"1\":{\"265\":1}}],[\"这套事件处理模型对应的是\",{\"1\":{\"265\":1}}],[\"这类似于\",{\"1\":{\"1184\":1}}],[\"这类分布式队列\",{\"1\":{\"1178\":1}}],[\"这类框架并不能算是\",{\"1\":{\"1167\":1}}],[\"这类硬件来做负载均衡\",{\"1\":{\"1123\":1}}],[\"这类共识算法最典型的应用就是区块链\",{\"1\":{\"1097\":1}}],[\"这类任务的特点是\",{\"1\":{\"895\":1,\"922\":1}}],[\"这类的数据库的\",{\"1\":{\"246\":1}}],[\"这类中间件也可以帮助我们生成唯一\",{\"1\":{\"43\":1}}],[\"这进一步增强了\",{\"1\":{\"233\":1}}],[\"这就很好地同时实现了共享锁和独占锁\",{\"1\":{\"1388\":1}}],[\"这就涉及到如何使用\",{\"1\":{\"1381\":1}}],[\"这就会出现数据不一致性问题\",{\"1\":{\"1371\":1}}],[\"这就发生了脑裂现象\",{\"1\":{\"1358\":1}}],[\"这就有点类似于我们有一大堆书需要装上书架\",{\"1\":{\"1315\":1}}],[\"这就违背我们消息中间件的\",{\"1\":{\"1278\":1}}],[\"这就不是说数据会大量积压在\",{\"1\":{\"1264\":1}}],[\"这就类似我们平时手机订火车票和电影票\",{\"1\":{\"1220\":1}}],[\"这就意味着\",{\"1\":{\"1112\":1}}],[\"这就意味着它也具备了队列所拥有的所有行为\",{\"1\":{\"533\":1}}],[\"这就和\",{\"1\":{\"1068\":1}}],[\"这就叫\",{\"1\":{\"1067\":1}}],[\"这就叫做索引覆盖\",{\"1\":{\"115\":1}}],[\"这就叫做回表查询\",{\"1\":{\"112\":1}}],[\"这就可能造成一个线程在主存中修改了一个变量的值\",{\"1\":{\"972\":1}}],[\"这就可能会导致瞬时大量的请求直接打到了数据库上\",{\"1\":{\"309\":1}}],[\"这就指示\",{\"1\":{\"833\":2,\"979\":1}}],[\"这就解释了\",{\"1\":{\"684\":1}}],[\"这就使得不论机房的机器如何分配都不可能发生脑裂\",{\"1\":{\"1358\":1}}],[\"这就使得转为红黑树的树节点也需要具备双向链表节点的特性\",{\"1\":{\"708\":1}}],[\"这就使得\",{\"1\":{\"607\":1}}],[\"这就是著名的\",{\"1\":{\"1368\":1}}],[\"这就是\",{\"1\":{\"1020\":1,\"1375\":1}}],[\"这就是可重入的概念\",{\"1\":{\"904\":1}}],[\"这就是可重入性的体现\",{\"1\":{\"742\":1}}],[\"这就是所谓的\",{\"1\":{\"821\":1,\"1152\":2,\"1184\":1}}],[\"这就是复合操作的非原子性导致的问题\",{\"1\":{\"694\":1}}],[\"这就是单线程状态下产生的\",{\"1\":{\"631\":1}}],[\"这就是快速随机访问\",{\"1\":{\"549\":1}}],[\"这就是为什么只有在同步的块或者方法中才能调用wait\",{\"1\":{\"851\":1}}],[\"这就是为什么\",{\"1\":{\"484\":1}}],[\"这就是已经申请了一次内存的结果\",{\"1\":{\"451\":1}}],[\"这就是数学的魅力么\",{\"1\":{\"205\":1}}],[\"这就算符号引用\",{\"1\":{\"429\":1}}],[\"这就需要提到双亲委派模型了\",{\"1\":{\"356\":1}}],[\"这就好比雪崩一样\",{\"1\":{\"313\":1}}],[\"这就导致一个线程可能获取到其他线程的threadlocal\",{\"1\":{\"929\":1}}],[\"这就导致线程在执行\",{\"1\":{\"860\":1}}],[\"这就导致线程\",{\"1\":{\"686\":1}}],[\"这就导致\",{\"1\":{\"631\":1}}],[\"这就导致大量的请求直接落到数据库上\",{\"1\":{\"313\":1}}],[\"这就导致瞬时大量对该商品的请求直接落到数据库上\",{\"1\":{\"309\":1}}],[\"这就导致这些请求直接到了数据库上\",{\"1\":{\"306\":1}}],[\"这就导致客户端请求没办法被及时处理\",{\"1\":{\"289\":1}}],[\"这对于我们对有些有语意的对象的\",{\"1\":{\"1389\":1}}],[\"这对于普通千兆网卡的服务器来说是灾难性的\",{\"1\":{\"163\":1,\"292\":1}}],[\"这对客户端是透明的\",{\"1\":{\"146\":1}}],[\"这包含资料的精确度\",{\"1\":{\"125\":1}}],[\"这还不错\",{\"1\":{\"117\":1}}],[\"这时队列中的消息会被平摊\",{\"1\":{\"1255\":1}}],[\"这时队列中的消息会被平均分摊\",{\"1\":{\"1250\":1}}],[\"这时就可以将\",{\"1\":{\"895\":1,\"922\":1}}],[\"这时就要用到\",{\"1\":{\"124\":1}}],[\"这时会调用equals\",{\"1\":{\"680\":1}}],[\"这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件\",{\"1\":{\"265\":1}}],[\"这时\",{\"1\":{\"127\":1,\"523\":1,\"647\":1,\"742\":1,\"777\":1,\"1112\":1}}],[\"这时对应的哈希索引的示意图如下所示\",{\"1\":{\"96\":1}}],[\"这时候请你思考一个问题\",{\"1\":{\"1369\":1}}],[\"这时候子集群各自选主导致\",{\"1\":{\"1358\":1}}],[\"这时候接收端没发区分你是想要表达\",{\"1\":{\"1152\":1}}],[\"这时候接待你的就是连接器\",{\"1\":{\"84\":1}}],[\"这时候线程\",{\"1\":{\"824\":1}}],[\"这时候最小堆内存是顶不住的\",{\"1\":{\"451\":1}}],[\"这时候我们创建了一个\",{\"1\":{\"451\":1}}],[\"这时候申请到的内存为\",{\"1\":{\"451\":1}}],[\"这时候无需等到\",{\"1\":{\"444\":1}}],[\"这时候就是虚拟机中的堆内存不足\",{\"1\":{\"444\":1}}],[\"这时候字符串常量池还在堆\",{\"1\":{\"393\":1}}],[\"这时候它们暂时处于\",{\"1\":{\"391\":1}}],[\"这时候进行内存分配的仅包括类变量\",{\"1\":{\"342\":1}}],[\"这时候你要查\",{\"1\":{\"96\":1}}],[\"这时候\",{\"1\":{\"89\":1,\"1151\":1}}],[\"这时候有同学要问\",{\"1\":{\"89\":1}}],[\"这一原则\",{\"1\":{\"1278\":1}}],[\"这一模型来实现的\",{\"1\":{\"1277\":1}}],[\"这一层\",{\"1\":{\"1249\":1}}],[\"这一层能够做到无限想象的事情\",{\"1\":{\"7\":1}}],[\"这一章节\",{\"1\":{\"889\":1}}],[\"这一点需要注意\",{\"1\":{\"1346\":1}}],[\"这一点和\",{\"1\":{\"1250\":1}}],[\"这一点\",{\"1\":{\"1152\":1}}],[\"这一点其实就是\",{\"1\":{\"1074\":1}}],[\"这一点我们可以从两者的迭代器中得以印证\",{\"1\":{\"713\":1}}],[\"这一点我们可以在\",{\"1\":{\"712\":1}}],[\"这一点相比于\",{\"1\":{\"713\":1}}],[\"这一点是\",{\"1\":{\"704\":1}}],[\"这一点笔者会在后续的源码解析中详细说明\",{\"1\":{\"534\":1}}],[\"这一阶段的目的是确保\",{\"1\":{\"341\":1}}],[\"这一步则是将当前节点\",{\"1\":{\"710\":1}}],[\"这一步操作保证了对象的实例字段在\",{\"1\":{\"504\":1}}],[\"这一步\",{\"1\":{\"344\":1}}],[\"这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式\",{\"1\":{\"340\":1}}],[\"这一步需要调用\",{\"1\":{\"230\":1}}],[\"这一步需要调用write函数\",{\"1\":{\"230\":1}}],[\"这一过程目前还处于半自动状态\",{\"1\":{\"167\":1}}],[\"这一行所在的数据页本来就在内存中\",{\"1\":{\"89\":1}}],[\"这一行\",{\"1\":{\"89\":1}}],[\"这一行的\",{\"1\":{\"89\":1}}],[\"这一般是通过超时机制实现的\",{\"1\":{\"61\":1}}],[\"这些玩意有啥用\",{\"1\":{\"1386\":1}}],[\"这些数据可以是数字\",{\"1\":{\"1348\":1}}],[\"这些功能的实现基本都得益于\",{\"1\":{\"1346\":1}}],[\"这些功能的实现主要依赖于\",{\"1\":{\"1344\":1}}],[\"这些实现幂等的方法\",{\"1\":{\"1303\":1}}],[\"这些问题不仅仅挂钩于\",{\"1\":{\"1298\":1}}],[\"这些东西都是我在介绍消息队列带来的一些副作用的时候提到的\",{\"1\":{\"1298\":1}}],[\"这些场景大多数要求数据传输通道具有可靠传输的能力\",{\"1\":{\"1284\":1}}],[\"这些优秀的消息中间件不仅仅是通过一个\",{\"1\":{\"1277\":1}}],[\"这些优化让\",{\"1\":{\"847\":1}}],[\"这些绑定允许使用相同的\",{\"1\":{\"1249\":1}}],[\"这些属性包括\",{\"1\":{\"1248\":1}}],[\"这些分区信息及与\",{\"1\":{\"1199\":1}}],[\"这些标准实际上已经属于废弃状态\",{\"1\":{\"1192\":1}}],[\"这些标准的进化跟不上消息队列的演进速度\",{\"1\":{\"1192\":1}}],[\"这些短板都被\",{\"1\":{\"1191\":1}}],[\"这些事件对象的内存地址就能够保持连续\",{\"1\":{\"1184\":1}}],[\"这些队列要不就是加锁有界\",{\"1\":{\"1179\":1}}],[\"这些队列使用的其实都不多\",{\"1\":{\"671\":1}}],[\"这些都是跨语言的序列化方式\",{\"1\":{\"1147\":1}}],[\"这些服务器形成了一个单一的\",{\"1\":{\"1106\":1}}],[\"这些名字的特点都具有\",{\"1\":{\"1084\":1}}],[\"这些线程可以被映射到底层多个\",{\"1\":{\"816\":1}}],[\"这些线程访问共享资源是互斥的\",{\"1\":{\"60\":1}}],[\"这些任务之间没有依赖关系\",{\"1\":{\"782\":1}}],[\"这些任务都会扔到\",{\"1\":{\"530\":1}}],[\"这些元素利用该集合的迭代器按顺序返回\",{\"1\":{\"555\":1}}],[\"这些接口\",{\"1\":{\"549\":1}}],[\"这些信息存放在对象头中\",{\"1\":{\"505\":1}}],[\"这些内存直接受操作系统管理\",{\"1\":{\"499\":1}}],[\"这些内存都将在方法区中分配\",{\"1\":{\"342\":1}}],[\"这些参数将堆内存转储到一个物理文件中\",{\"1\":{\"484\":1}}],[\"这些参数都是可以通过自己编写程序去简单测试的\",{\"1\":{\"459\":1}}],[\"这些方法都可以接受一个函数作为参数\",{\"1\":{\"694\":1}}],[\"这些方法都是字节码文件中只能给\",{\"1\":{\"430\":1}}],[\"这些方法可以配合起来使用\",{\"1\":{\"294\":1,\"299\":1}}],[\"这些操作我们后面都会介绍到\",{\"1\":{\"1348\":1}}],[\"这些操作系统环境下即可\",{\"1\":{\"417\":1}}],[\"这些操作必须保证是一体的\",{\"1\":{\"124\":1}}],[\"这些命令在\",{\"1\":{\"364\":1}}],[\"这些命令并不是一定不能使用\",{\"1\":{\"157\":1,\"301\":1}}],[\"这些被实现的接口将按\",{\"1\":{\"330\":1}}],[\"这些\",{\"1\":{\"283\":1,\"287\":1,\"442\":1,\"1167\":1}}],[\"这些函数被称为\",{\"1\":{\"230\":1}}],[\"这些情况也是影响\",{\"1\":{\"156\":1}}],[\"这些过滤器逻辑上可以称作\",{\"1\":{\"69\":1}}],[\"这些过滤器可以对请求进行拦截和修改\",{\"1\":{\"69\":1}}],[\"这些独立的进程中的线程访问共享资源是互斥的\",{\"1\":{\"60\":1}}],[\"这些是在网上购物经常使用到的单号\",{\"1\":{\"16\":1}}],[\"这两者都是专门针对\",{\"1\":{\"1147\":1}}],[\"这两句用来获取线程池的状态\",{\"1\":{\"941\":1}}],[\"这两点来回答这个问题\",{\"1\":{\"246\":1}}],[\"这两条记录回表取数据判断\",{\"1\":{\"117\":1}}],[\"这两个\",{\"1\":{\"1379\":1}}],[\"这两个服务部署在不同的机器上了\",{\"1\":{\"1369\":1}}],[\"这两个概念很好的理解透\",{\"1\":{\"1367\":1}}],[\"这两个重要的概念\",{\"1\":{\"1196\":1}}],[\"这两个是和清理相关的方法\",{\"1\":{\"1036\":1}}],[\"这两个地方可以看作\",{\"1\":{\"1014\":1}}],[\"这两个关键类实现了\",{\"1\":{\"934\":1}}],[\"这两个共用一个袋子的话肯定会产生争执\",{\"1\":{\"881\":1}}],[\"这两个方法的区别在于\",{\"1\":{\"779\":1}}],[\"这两个方法可以帮助我们封装计算逻辑\",{\"1\":{\"778\":1}}],[\"这两个方法实现的关键就是在于两个条件对象\",{\"1\":{\"535\":1}}],[\"这两个构造方法\",{\"1\":{\"747\":1,\"905\":1}}],[\"这两个条件对象是如何控制\",{\"1\":{\"535\":1}}],[\"这两个会阻塞的存和取方法之后\",{\"1\":{\"531\":1}}],[\"这两个版本为例介绍\",{\"1\":{\"491\":1}}],[\"这两个名词\",{\"1\":{\"422\":1}}],[\"这两个对象之间再无任何引用\",{\"1\":{\"390\":1}}],[\"这两个都是默认关闭的\",{\"1\":{\"367\":1}}],[\"这两个都是过期时间设置\",{\"1\":{\"48\":1}}],[\"这两个图里面\",{\"1\":{\"117\":1}}],[\"这两种权限都是针对\",{\"1\":{\"1351\":1}}],[\"这两种消息模型是\",{\"1\":{\"1222\":1}}],[\"这两种序列化方式是\",{\"1\":{\"1147\":1}}],[\"这两种对象访问方式各有优势\",{\"1\":{\"510\":1}}],[\"这两种锁被称为\",{\"1\":{\"140\":1}}],[\"这两种日志有以下三点不同\",{\"1\":{\"89\":1}}],[\"这两种模式来生成分布式\",{\"1\":{\"41\":1}}],[\"这名字起得真心挺不错的\",{\"1\":{\"41\":1}}],[\"这\",{\"1\":{\"38\":1,\"174\":1,\"231\":1,\"328\":1,\"338\":1,\"344\":1,\"742\":1,\"782\":1,\"904\":1,\"909\":1,\"1202\":1}}],[\"这里为了方便随便取个数字\",{\"1\":{\"1380\":1}}],[\"这里为什么要用两个日志模块\",{\"1\":{\"89\":1}}],[\"这里我就不展开说明了\",{\"1\":{\"1314\":1}}],[\"这里我们使用\",{\"1\":{\"1045\":1}}],[\"这里我们还是以staleslot=3\",{\"1\":{\"1037\":1}}],[\"这里我们以\",{\"1\":{\"632\":1}}],[\"这里我们只需初步了解一下阻塞队列的构造即可\",{\"1\":{\"534\":1}}],[\"这里我们建议使用\",{\"1\":{\"47\":1}}],[\"这里可以将\",{\"1\":{\"1249\":1}}],[\"这里可不是b减树\",{\"1\":{\"99\":1}}],[\"这里推荐为\",{\"1\":{\"1204\":1}}],[\"这里推荐了非常多优质的\",{\"1\":{\"486\":1}}],[\"这里额外补充一点\",{\"1\":{\"1184\":1}}],[\"这里用到的就是\",{\"1\":{\"1154\":1}}],[\"这里还有一个相关的\",{\"1\":{\"1143\":1}}],[\"这里还有会有一些其他场景\",{\"1\":{\"1045\":1}}],[\"这里还画了一个entry中的key为null的数据\",{\"1\":{\"1033\":1}}],[\"这里首先是会进行探测式清理工作\",{\"1\":{\"1038\":1}}],[\"这里是\",{\"1\":{\"1371\":1}}],[\"这里是处理正常的产生hash冲突的数据\",{\"1\":{\"1037\":1}}],[\"这里是计算每个\",{\"1\":{\"570\":1}}],[\"这里会通过key来计算在散列表中的对应位置\",{\"1\":{\"1036\":1}}],[\"这里会生成\",{\"1\":{\"202\":1}}],[\"这里直接更新该槽位的数据\",{\"1\":{\"1035\":1}}],[\"这里直接将数据放到该槽位即可\",{\"1\":{\"1035\":1}}],[\"这里最关键的就是threadlocalhashcode值的计算\",{\"1\":{\"1032\":1}}],[\"这里i就是当前\",{\"1\":{\"1032\":1}}],[\"这里就是可重入的概念\",{\"1\":{\"1018\":1}}],[\"这里就不再延伸\",{\"1\":{\"1043\":1}}],[\"这里就不贴代码了\",{\"1\":{\"936\":1}}],[\"这里就不详细介绍了\",{\"1\":{\"874\":1}}],[\"这里就不详细介绍模板方法模式了\",{\"1\":{\"744\":1}}],[\"这里就不重复介绍了\",{\"1\":{\"535\":1}}],[\"这里就不重复进行介绍了\",{\"1\":{\"234\":1}}],[\"这里就不以一一列举了\",{\"1\":{\"449\":1}}],[\"这里就不具体介绍\",{\"1\":{\"377\":1}}],[\"这里就不演示了\",{\"1\":{\"251\":1}}],[\"这里就不介绍了\",{\"1\":{\"37\":1}}],[\"这里如果还没来得及入队\",{\"1\":{\"1014\":1}}],[\"这里主要阐述一下非公平锁与\",{\"1\":{\"1007\":1}}],[\"这里不做过多解释\",{\"1\":{\"1374\":1}}],[\"这里不做讨论\",{\"1\":{\"968\":1}}],[\"这里不涉及到一些细节讨论\",{\"1\":{\"1315\":1}}],[\"这里不涉及运维方面的搭建\",{\"1\":{\"1298\":1}}],[\"这里不予以描述\",{\"1\":{\"1252\":1}}],[\"这里不去细纠斐波那契具体算法\",{\"1\":{\"1032\":1}}],[\"这里不妨用反证法来进行解释\",{\"1\":{\"89\":1}}],[\"这里提了很多底层的类关系\",{\"1\":{\"934\":1}}],[\"这里选择\",{\"1\":{\"895\":1,\"922\":1}}],[\"这里借用\",{\"1\":{\"887\":1,\"933\":1}}],[\"这里需要格外注意\",{\"1\":{\"839\":1,\"988\":1,\"995\":1}}],[\"这里需要加锁以实现对检查库存操作的同步访问\",{\"1\":{\"60\":1}}],[\"这里简单举几个例子\",{\"1\":{\"1181\":1}}],[\"这里简单以\",{\"1\":{\"1069\":1}}],[\"这里简单分析一下整个流程\",{\"1\":{\"941\":1}}],[\"这里简单介绍一下\",{\"1\":{\"808\":1,\"1015\":1}}],[\"这里简单列举一个例子\",{\"1\":{\"653\":1,\"654\":1}}],[\"这里没有抛出异常所有为\",{\"1\":{\"779\":1}}],[\"这里没有提到运行时常量池\",{\"1\":{\"393\":1}}],[\"这里列举其相关的一些要点\",{\"1\":{\"669\":1}}],[\"这里再以非公平模式\",{\"1\":{\"748\":1}}],[\"这里再以\",{\"1\":{\"585\":1}}],[\"这里再详细介绍一下线程间的等待和唤醒具体的实现\",{\"1\":{\"544\":1}}],[\"这里第一个\",{\"1\":{\"572\":1}}],[\"这里补充一点比较重要\",{\"1\":{\"558\":1}}],[\"这里补充一句\",{\"1\":{\"440\":1}}],[\"这里看到arraylist添加元素的实质就相当于为数组赋值\",{\"1\":{\"553\":1,\"557\":1}}],[\"这里使用lockinterruptibly\",{\"1\":{\"535\":1}}],[\"这里笔者为了保证消费者能够在消费完\",{\"1\":{\"531\":1}}],[\"这里有几点需要注意\",{\"1\":{\"484\":1}}],[\"这里有个关键字\",{\"1\":{\"75\":1}}],[\"这里有个示例\",{\"1\":{\"74\":1}}],[\"这里碍于篇幅问题就不再提供\",{\"1\":{\"459\":1}}],[\"这里只做科普不做详细介绍\",{\"1\":{\"1315\":1}}],[\"这里只列举比较重要的几个\",{\"1\":{\"449\":1}}],[\"这里只是\",{\"1\":{\"1008\":1}}],[\"这里只是为了演示使用\",{\"1\":{\"944\":1}}],[\"这里只是以业务比较简单的购物车场景举例\",{\"1\":{\"257\":1}}],[\"这里只是举例说明\",{\"1\":{\"4\":1}}],[\"这里的服务端\",{\"1\":{\"1166\":1}}],[\"这里的处理方式就和\",{\"1\":{\"1142\":1}}],[\"这里的处理方式主要是运用线程池中基本运作单元\",{\"1\":{\"1015\":1}}],[\"这里的前提是系统发生了\",{\"1\":{\"1070\":1}}],[\"这里的判断条件为什么是\",{\"1\":{\"1014\":1}}],[\"这里的核心在于\",{\"1\":{\"730\":1,\"731\":1}}],[\"这里的\",{\"1\":{\"618\":1,\"682\":1,\"819\":1}}],[\"这里的类就可以看作是永久代和元空间\",{\"1\":{\"496\":1}}],[\"这里的存活判断是\",{\"1\":{\"444\":1}}],[\"这里的双亲更多地表达的是\",{\"1\":{\"356\":1}}],[\"这里\",{\"1\":{\"444\":1,\"451\":1,\"558\":1,\"1281\":1}}],[\"这里所设置的初始值\",{\"1\":{\"342\":1}}],[\"这里多说一嘴\",{\"1\":{\"307\":1}}],[\"这里结合自己的理解简单总结一下\",{\"1\":{\"236\":1}}],[\"这里对上面提到的一些\",{\"1\":{\"230\":1}}],[\"这里说的仅仅是\",{\"1\":{\"394\":1}}],[\"这里说\",{\"1\":{\"227\":1}}],[\"这里面的第一步中的\",{\"1\":{\"571\":1}}],[\"这里面有很多过滤器\",{\"1\":{\"69\":1}}],[\"这里面会做断言\",{\"1\":{\"69\":1}}],[\"这里被拦下了\",{\"1\":{\"56\":1}}],[\"这里以非公平锁为例进行分析\",{\"1\":{\"1008\":1}}],[\"这里以remove\",{\"1\":{\"591\":1}}],[\"这里以add\",{\"1\":{\"588\":1}}],[\"这里以无参构造函数创建的\",{\"1\":{\"556\":1}}],[\"这里以阻塞式获取和新增元素为例介绍\",{\"1\":{\"544\":1}}],[\"这里以阿里云\",{\"1\":{\"293\":1,\"298\":1,\"299\":1}}],[\"这里以\",{\"1\":{\"56\":1,\"553\":1,\"586\":1,\"600\":1,\"686\":1,\"727\":1}}],[\"这也极大地提高了消息存储的安全性\",{\"1\":{\"1197\":1}}],[\"这也和\",{\"1\":{\"1191\":1}}],[\"这也正是\",{\"1\":{\"1084\":1}}],[\"这也成了第一个逻辑时钟算法\",{\"1\":{\"974\":1}}],[\"这也意味着\",{\"1\":{\"742\":1}}],[\"这也使得阻塞队列在多线程开发中有着广泛的运用\",{\"1\":{\"530\":1}}],[\"这也就保证了\",{\"1\":{\"1362\":1}}],[\"这也就表明一个\",{\"1\":{\"1196\":1}}],[\"这也就意味着如果主线程提交任务的速度高于\",{\"1\":{\"957\":1}}],[\"这也就意味着当队列中没有数据的时消费者就会阻塞\",{\"1\":{\"531\":1}}],[\"这也就造成了\",{\"1\":{\"919\":1}}],[\"这也就导致两个线程分别对\",{\"1\":{\"835\":1}}],[\"这也就解释了\",{\"1\":{\"684\":1}}],[\"这也就解释了上面的代码\",{\"1\":{\"634\":1}}],[\"这也就证明了我们前面说的\",{\"1\":{\"588\":1}}],[\"这也就是说在查找过程中\",{\"1\":{\"800\":1}}],[\"这也就是二义性的由来\",{\"1\":{\"693\":1}}],[\"这也就是它的名字\",{\"1\":{\"407\":1}}],[\"这也就是我们说的\",{\"1\":{\"34\":1}}],[\"这也就产生了死锁\",{\"1\":{\"370\":1,\"823\":1}}],[\"这也是在公司内部微服务中抛弃\",{\"1\":{\"1159\":1}}],[\"这也是这种模式的特征\",{\"1\":{\"1132\":1}}],[\"这也是第一个被证明完备的共识算法\",{\"1\":{\"1096\":1}}],[\"这也是threadlocal变量名的由来\",{\"1\":{\"881\":1}}],[\"这也是stampedlock不可重入的原因\",{\"1\":{\"871\":1}}],[\"这也是一个函数式接口\",{\"1\":{\"778\":1}}],[\"这也是为什么我们后续的\",{\"1\":{\"531\":1}}],[\"这也是\",{\"1\":{\"124\":1,\"233\":1,\"359\":1,\"1190\":1,\"1235\":1,\"1311\":1}}],[\"这也是不允许的\",{\"1\":{\"18\":1}}],[\"这种消息中间件相反\",{\"1\":{\"1250\":1}}],[\"这种模式\",{\"1\":{\"1263\":1}}],[\"这种模式是最高级别的\",{\"1\":{\"1206\":1}}],[\"这种模式下要尽量避免传播的信息包不能太大\",{\"1\":{\"1088\":1}}],[\"这种看了\",{\"1\":{\"1150\":1}}],[\"这种支持远程调用的框架来简单地暴露和引用远程服务\",{\"1\":{\"1123\":1}}],[\"这种机制使得各个服务器能够分散开来\",{\"1\":{\"1111\":1}}],[\"这种机制下\",{\"1\":{\"589\":1}}],[\"这种思想的核心就是通过多个\",{\"1\":{\"1099\":1}}],[\"这种思路与\",{\"1\":{\"584\":1,\"793\":1}}],[\"这种版本的解读\",{\"1\":{\"1067\":1}}],[\"这种优化会提高整个散列表查询性能\",{\"1\":{\"1037\":1}}],[\"这种设计会极大降低系统的并发度\",{\"1\":{\"1002\":1}}],[\"这种任务应用起来\",{\"1\":{\"895\":1,\"922\":1}}],[\"这种任务消耗的主要是\",{\"1\":{\"895\":1,\"922\":1}}],[\"这种策略是为了提高获得锁和释放锁的效率\",{\"1\":{\"854\":1}}],[\"这种策略在我们平时开发过程中也非常非常少见\",{\"1\":{\"147\":1}}],[\"这种性能优化方式比较简单且效果还不错\",{\"1\":{\"788\":1}}],[\"这种通知机制是通过\",{\"1\":{\"753\":1}}],[\"这种插入方式需要先移动到指定位置\",{\"1\":{\"729\":1}}],[\"这种操作在执行过程中可能会被其他线程打断\",{\"1\":{\"694\":1}}],[\"这种操作实在是看不懂\",{\"1\":{\"279\":1}}],[\"这种参数类型可以用在类\",{\"1\":{\"522\":1}}],[\"这种错误经常出现在递归中\",{\"1\":{\"439\":1}}],[\"这种用\",{\"1\":{\"435\":1}}],[\"这种使用\",{\"1\":{\"407\":1}}],[\"这种算法没有什么新的思想\",{\"1\":{\"399\":1}}],[\"这种算法在短网址的技术实现上越来越多了起来\",{\"1\":{\"24\":1}}],[\"这种垃圾收集算法会带来两个明显的问题\",{\"1\":{\"396\":1}}],[\"这种解决办法对于先操作缓存后操作数据库的场景不适用\",{\"1\":{\"316\":1}}],[\"这种解决办法同样存在漏洞\",{\"1\":{\"48\":1}}],[\"这种情况\",{\"1\":{\"1193\":1}}],[\"这种情况也能加锁同步呀\",{\"1\":{\"694\":1}}],[\"这种情况时间复杂度就是\",{\"1\":{\"552\":1,\"656\":1}}],[\"这种情况下也需要将相关线程加入队列中\",{\"1\":{\"1011\":1}}],[\"这种情况下\",{\"1\":{\"297\":1,\"958\":1}}],[\"这种情况我在日常使用中还没有遇到过\",{\"1\":{\"219\":1}}],[\"这种阻塞式读取的命令\",{\"1\":{\"251\":1}}],[\"这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见\",{\"1\":{\"146\":1}}],[\"这种隔离级别很少使用\",{\"1\":{\"132\":1}}],[\"这种方法最有效\",{\"1\":{\"1207\":1}}],[\"这种方法的缺陷也很明显\",{\"1\":{\"1083\":1}}],[\"这种方法的优点是能够解决循环引用的问题\",{\"1\":{\"445\":1}}],[\"这种方案并不能从根本上解决此问题\",{\"1\":{\"307\":1}}],[\"这种方案的前提是你的\",{\"1\":{\"293\":1}}],[\"这种方案的前提是\",{\"1\":{\"164\":1}}],[\"这种方案有什么问题呢\",{\"1\":{\"42\":1}}],[\"这种方式对性能消耗比较低\",{\"1\":{\"1078\":1}}],[\"这种方式对数据一致性带来了更大的挑战\",{\"1\":{\"147\":1}}],[\"这种方式虽然能够保证同步\",{\"1\":{\"583\":1,\"793\":1}}],[\"这种方式可以解决请求的\",{\"1\":{\"307\":1}}],[\"这种方式会让业务代码的复杂性增加\",{\"1\":{\"298\":1}}],[\"这种方式只能找出每种数据结构\",{\"1\":{\"293\":1}}],[\"这种方式大量浪费了系统资源\",{\"1\":{\"251\":1}}],[\"这种方式在\",{\"1\":{\"77\":1}}],[\"这种方式实现分布式锁存在一些问题\",{\"1\":{\"47\":1}}],[\"这种方式的优缺点也比较明显\",{\"1\":{\"33\":1}}],[\"这种方式就比较简单直白了\",{\"1\":{\"33\":1}}],[\"这种值分别对应不同的含义\",{\"1\":{\"37\":1}}],[\"这种场景下\",{\"1\":{\"22\":1}}],[\"这个强大的分布式协调框架\",{\"1\":{\"1391\":1}}],[\"这个顺序体现在\",{\"1\":{\"1382\":1}}],[\"这个阶段其实和\",{\"1\":{\"1371\":1}}],[\"这个阶段的停顿时间一般会比初始标记阶段的时间稍长\",{\"1\":{\"406\":1}}],[\"这个命令很简单\",{\"1\":{\"1331\":1}}],[\"这个命令将列出绝对路径\",{\"1\":{\"1328\":1}}],[\"这个命令会返回键值对占用的内存空间\",{\"1\":{\"293\":1}}],[\"这个命令会扫描\",{\"1\":{\"293\":1}}],[\"这个消息是不可见的\",{\"1\":{\"1304\":1}}],[\"这个还是需要结合具体的业务的\",{\"1\":{\"1303\":1}}],[\"这个步骤就对应这上面的\",{\"1\":{\"1281\":1}}],[\"这个性能开销也太大了吧\",{\"1\":{\"1263\":1}}],[\"这个性能差距几乎可以忽略不计\",{\"1\":{\"564\":1}}],[\"这个策略是镜像集群模式的策略\",{\"1\":{\"1263\":1}}],[\"这个交换器就是\",{\"1\":{\"1256\":1}}],[\"这个逻辑层面\",{\"1\":{\"1250\":1}}],[\"这个会在介绍\",{\"1\":{\"1249\":1}}],[\"这个后面会在我们讲\",{\"1\":{\"1237\":1}}],[\"这个桩就不是代理类了\",{\"1\":{\"1166\":1}}],[\"这个字段都传过来\",{\"1\":{\"1159\":1}}],[\"这个字段主要的过程\",{\"1\":{\"1018\":1}}],[\"这个将结构体转为二进制数组的过程就叫\",{\"1\":{\"1159\":1}}],[\"这个将军就把自己当成大将军候选人\",{\"1\":{\"1105\":1}}],[\"这个找到服务对应的\",{\"1\":{\"1157\":1}}],[\"这个八股文我们没白背\",{\"1\":{\"1152\":1}}],[\"这个作业留给你们\",{\"1\":{\"1143\":1}}],[\"这个名字起得有点不直观\",{\"1\":{\"1142\":1}}],[\"这个两个理论已经再熟悉不过了\",{\"1\":{\"1065\":1}}],[\"这个前提是前驱节点扫描时未发现过期数据\",{\"1\":{\"1036\":1}}],[\"这个数据就没了\",{\"1\":{\"1264\":1}}],[\"这个数字\",{\"1\":{\"1032\":1}}],[\"这个数组下标的计算方法是\",{\"1\":{\"684\":1}}],[\"这个值在后面会讲解\",{\"1\":{\"1035\":1}}],[\"这个值很特殊\",{\"1\":{\"1032\":1}}],[\"这个值就会增长\",{\"1\":{\"1032\":1}}],[\"这个值为\",{\"1\":{\"570\":1}}],[\"这个threadlocal\",{\"1\":{\"1032\":1}}],[\"这个函数返回的是当前执行线程的中断状态\",{\"1\":{\"1015\":1}}],[\"这个指针不多介绍\",{\"1\":{\"1005\":1}}],[\"这个概念中\",{\"1\":{\"1202\":1}}],[\"这个概念来描述两个操作之间的内存可见性\",{\"1\":{\"974\":1,\"981\":1}}],[\"这个概念诞生的背景并不是重点\",{\"1\":{\"974\":1}}],[\"这个概念最早诞生于\",{\"1\":{\"974\":1}}],[\"这个概念了\",{\"1\":{\"124\":1}}],[\"这个缓存一致性协议指的是在\",{\"1\":{\"968\":1}}],[\"这个线程对这个共享变量的可见性\",{\"1\":{\"967\":1}}],[\"这个线程池是全局共享的\",{\"1\":{\"784\":1}}],[\"这个直接查看\",{\"1\":{\"936\":1}}],[\"这个问题刚开始看\",{\"1\":{\"1030\":1}}],[\"这个问题的解决比较简单粗暴\",{\"1\":{\"897\":1}}],[\"这个问题被称为\",{\"1\":{\"843\":1,\"992\":1}}],[\"这个状态之间的转换需要相对比较长的时间\",{\"1\":{\"847\":1}}],[\"这个变量是共享且不稳定的\",{\"1\":{\"833\":2,\"979\":1}}],[\"这个时间分片通常是很小的\",{\"1\":{\"820\":1}}],[\"这个时候重新选举的时候我们如果把\",{\"1\":{\"1380\":1}}],[\"这个时候请求处理的顺序不同就会导致数据的不同\",{\"1\":{\"1379\":1}}],[\"这个时候收到消息的参与者都会进行事务提交\",{\"1\":{\"1371\":1}}],[\"这个时候会一直占用着资源不释放\",{\"1\":{\"1370\":1}}],[\"这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了\",{\"1\":{\"1368\":1}}],[\"这个时候从节点就少了一部分消息\",{\"1\":{\"1314\":1}}],[\"这个时候单个队列即不能满足需求了\",{\"1\":{\"1278\":1}}],[\"这个时候我规定所有创建节点必须有序\",{\"1\":{\"1388\":1}}],[\"这个时候我加了多次是不是对其他用户不公平\",{\"1\":{\"1275\":1}}],[\"这个时候我们\",{\"1\":{\"1387\":1}}],[\"这个时候我们有理由相信其他系统都能进行事务的执行和提交\",{\"1\":{\"1371\":1}}],[\"这个时候我们有一个订单的处理积分的系统\",{\"1\":{\"1303\":1}}],[\"这个时候我们是不是又得改代码\",{\"1\":{\"1272\":1}}],[\"这个时候我们就可以把模型给改造了\",{\"1\":{\"1271\":1}}],[\"这个时候我们就开始写程序\",{\"1\":{\"1264\":1}}],[\"这个时候消息队列也应运而生了\",{\"1\":{\"1269\":1}}],[\"这个时候推荐你结合你自己的项目来回答\",{\"1\":{\"1219\":1}}],[\"这个时候分布式服务架构就诞生了\",{\"1\":{\"1123\":1}}],[\"这个时候\",{\"1\":{\"1070\":1,\"1074\":1,\"1087\":1,\"1374\":1,\"1375\":2,\"1380\":2}}],[\"这个时候就进行事务的提交\",{\"1\":{\"1370\":1}}],[\"这个时候就会出现积分加了但是订单没下成功\",{\"1\":{\"1370\":1}}],[\"这个时候就引申出一个概念\",{\"1\":{\"1369\":1}}],[\"这个时候就出现了系统的可用性问题\",{\"1\":{\"1368\":1}}],[\"这个时候就是\",{\"1\":{\"1367\":2}}],[\"这个时候就要判断当前node是否要被阻塞\",{\"1\":{\"1012\":1}}],[\"这个时候就可能会产生内存泄露\",{\"1\":{\"884\":1}}],[\"这个时候就需要用到\",{\"1\":{\"359\":1}}],[\"这个时候就需要优化器上场了\",{\"1\":{\"86\":1}}],[\"这个时候就需要生成分布式\",{\"1\":{\"29\":1}}],[\"这个时候线程就会进入\",{\"1\":{\"820\":1}}],[\"这个时候类变量则会随着\",{\"1\":{\"342\":1}}],[\"这个时候突然有大量的请求需要访问这些过期的数据\",{\"1\":{\"313\":1}}],[\"这个时候才允许其他事务新增数据\",{\"1\":{\"130\":1}}],[\"这个时候才允许其他事务更改刚才的数据\",{\"1\":{\"130\":1}}],[\"这个并发框架\",{\"1\":{\"788\":1}}],[\"这个静态方法来并行运行多个\",{\"1\":{\"782\":1}}],[\"这个触发时机是不确定的\",{\"1\":{\"781\":1}}],[\"这个我们之前线上也有类似的场景干过\",{\"1\":{\"1264\":1}}],[\"这个我们可以采用表\",{\"1\":{\"1202\":1}}],[\"这个我们通过\",{\"1\":{\"752\":1}}],[\"这个我们在上文的构造方法中有提到\",{\"1\":{\"535\":1}}],[\"这个机制主要用的是\",{\"1\":{\"1004\":1}}],[\"这个机制\",{\"1\":{\"742\":1,\"904\":1}}],[\"这个机制的原理其实非常简单\",{\"1\":{\"234\":1}}],[\"这个类来维护的\",{\"1\":{\"1382\":1}}],[\"这个类\",{\"1\":{\"934\":1}}],[\"这个类在我们实际使用线程池的过程中\",{\"1\":{\"934\":1}}],[\"这个类在\",{\"1\":{\"740\":1,\"903\":1}}],[\"这个类加载器通常是由应用程序或者容器\",{\"1\":{\"359\":1}}],[\"这个大部分人都会读错\",{\"1\":{\"727\":1}}],[\"这个算法应该如何设计呢\",{\"1\":{\"684\":1}}],[\"这个算法的基本思想就是通过一系列的称为\",{\"1\":{\"391\":1}}],[\"这个内部类并没有实现集合的修改方法或者说并没有重写这些方法\",{\"1\":{\"634\":1}}],[\"这个内存仅代表当前线程所执行的字节码的行号指示器\",{\"1\":{\"435\":1}}],[\"这个结点是放在数组中\",{\"1\":{\"622\":1,\"686\":1}}],[\"这个结构里的\",{\"1\":{\"271\":1}}],[\"这个的意思就是\",{\"1\":{\"619\":1}}],[\"这个队列中也维护着每个消费者组的消费位置\",{\"1\":{\"1280\":1}}],[\"这个队列中\",{\"1\":{\"604\":1}}],[\"这个节点后面的所有\",{\"1\":{\"572\":1}}],[\"这个循环可以找到\",{\"1\":{\"570\":1}}],[\"这个属性\",{\"1\":{\"558\":1}}],[\"这个实现数组之间复制的方法一定要看一下\",{\"1\":{\"553\":1}}],[\"这个功能类似于消息队列\",{\"1\":{\"1190\":1,\"1235\":1}}],[\"这个功能非常重要\",{\"1\":{\"544\":1,\"862\":1}}],[\"这个功能的呢\",{\"1\":{\"210\":1}}],[\"这个构造方法里面有两个比较核心的成员变量\",{\"1\":{\"534\":1}}],[\"这个继承关系使得\",{\"1\":{\"533\":1}}],[\"这个继承了\",{\"1\":{\"533\":1}}],[\"这个抽象类\",{\"1\":{\"533\":1}}],[\"这个接口之后\",{\"1\":{\"533\":1}}],[\"这个接口\",{\"1\":{\"533\":1}}],[\"这个文件可以使用\",{\"1\":{\"455\":1}}],[\"这个参数需要严格的测试\",{\"1\":{\"449\":1,\"463\":1}}],[\"这个选项对性能影响比较大\",{\"1\":{\"449\":1}}],[\"这个可以通过参数\",{\"1\":{\"444\":1}}],[\"这个操作我们会称作\",{\"1\":{\"444\":1}}],[\"这个闭包结构并不能保证包含当前所有的可达对象\",{\"1\":{\"406\":1}}],[\"这个方法其实就是把对应的线程以\",{\"1\":{\"1012\":1}}],[\"这个方法主要是对\",{\"1\":{\"1011\":1}}],[\"这个方法主要用来创建新的工作线程\",{\"1\":{\"941\":1}}],[\"这个方法非常重要\",{\"1\":{\"941\":1}}],[\"这个方法的话\",{\"1\":{\"896\":1,\"923\":1}}],[\"这个方法还是非常有用的\",{\"1\":{\"781\":1}}],[\"这个方法不对外暴露\",{\"1\":{\"777\":1}}],[\"这个方法最终还是调用\",{\"1\":{\"767\":2}}],[\"这个方法是用来拿到\",{\"1\":{\"765\":1}}],[\"这个方法是接口中的默认实现\",{\"1\":{\"630\":1}}],[\"这个方法负责将元素移动到链表末尾\",{\"1\":{\"710\":1}}],[\"这个方法会根据\",{\"1\":{\"619\":1,\"622\":1}}],[\"这个方法会复制整个数组\",{\"1\":{\"588\":1}}],[\"这个方法会一次性将队列中所有元素存放到列表\",{\"1\":{\"531\":1}}],[\"这个方法做的操作就是不断的自旋\",{\"1\":{\"571\":1}}],[\"这个方法\",{\"1\":{\"558\":1,\"564\":1,\"730\":1,\"731\":1}}],[\"这个方法必须分配一个新的数组\",{\"1\":{\"553\":1}}],[\"这个方法由编译器收集\",{\"1\":{\"430\":1}}],[\"这个方法实现简单\",{\"1\":{\"390\":1}}],[\"这个方法返回的是看门狗给锁续期的过期时间\",{\"1\":{\"49\":1}}],[\"这个说法的来源大部分都是\",{\"1\":{\"386\":1}}],[\"这个优点是\",{\"1\":{\"377\":1}}],[\"这个例子来说\",{\"1\":{\"359\":1}}],[\"这个\",{\"1\":{\"329\":1,\"425\":2,\"433\":1,\"690\":1,\"710\":1,\"949\":1,\"1142\":1,\"1260\":1,\"1380\":1}}],[\"这个标志用于识别一些类或者接口层次的访问信息\",{\"1\":{\"329\":1}}],[\"这个项目不光支持\",{\"1\":{\"298\":1}}],[\"这个项目的名字\",{\"1\":{\"41\":1,\"1343\":1}}],[\"这个事情发生在\",{\"1\":{\"451\":1}}],[\"这个事务是可以被执行成功的\",{\"1\":{\"280\":1}}],[\"这个事件监听器的作用是\",{\"1\":{\"55\":1}}],[\"这个应该没人使用吧\",{\"1\":{\"273\":1}}],[\"这个是由于\",{\"1\":{\"1160\":1}}],[\"这个是要区分垃圾收集器的\",{\"1\":{\"386\":1}}],[\"这个是最常用的方式\",{\"1\":{\"1078\":1}}],[\"这个是最常用的\",{\"1\":{\"273\":1}}],[\"这个是比较麻烦且耗费资源的\",{\"1\":{\"42\":1}}],[\"这个整数保存了\",{\"1\":{\"271\":1}}],[\"这个整数作为\",{\"1\":{\"210\":1}}],[\"这个处理器被称为文件事件处理器\",{\"1\":{\"265\":1}}],[\"这个也没错\",{\"1\":{\"256\":1}}],[\"这个也是\",{\"1\":{\"188\":1}}],[\"这个校验和是通过对整个\",{\"1\":{\"234\":1}}],[\"这个新的\",{\"1\":{\"233\":1}}],[\"这个在实际项目中基本不会被用到\",{\"1\":{\"961\":1}}],[\"这个在官方对\",{\"1\":{\"285\":1}}],[\"这个在\",{\"1\":{\"218\":1}}],[\"这个视图包含的内容有\",{\"1\":{\"141\":1}}],[\"这个段称为undo段\",{\"1\":{\"141\":1}}],[\"这个过程大致是这样的\",{\"1\":{\"1356\":1}}],[\"这个过程会选举产生新的\",{\"1\":{\"1356\":1}}],[\"这个过程就像调用本地方法一样简单\",{\"1\":{\"1165\":1,\"1232\":1}}],[\"这个过程就属于一次上下文切换\",{\"1\":{\"895\":1,\"922\":1}}],[\"这个过程需要移动平均\",{\"1\":{\"653\":1}}],[\"这个过程并没有加锁\",{\"1\":{\"589\":1}}],[\"这个过程成为类型擦除\",{\"1\":{\"522\":1}}],[\"这个过程便是方法覆盖的本质\",{\"1\":{\"519\":1}}],[\"这个过程也被称为\",{\"1\":{\"493\":1}}],[\"这个过程也就是求交集的过程\",{\"1\":{\"188\":1}}],[\"这个过程叫做\",{\"1\":{\"425\":1}}],[\"这个过程是这样的\",{\"1\":{\"280\":1}}],[\"这个过程是比较慢\",{\"1\":{\"246\":1}}],[\"这个过程本身需要一定时间\",{\"1\":{\"165\":1}}],[\"这个过程可以简单描述为\",{\"1\":{\"145\":2}}],[\"这个过程\",{\"1\":{\"117\":1}}],[\"这个过程中每个服务之间的通信又是单独的网络请求\",{\"1\":{\"21\":1}}],[\"这个查询可真够慢的\",{\"1\":{\"98\":1}}],[\"这个区间的所有用户\",{\"1\":{\"96\":1}}],[\"这个日志模块所有执行引擎都可以共用\",{\"1\":{\"90\":1}}],[\"这个日志\",{\"1\":{\"89\":1}}],[\"这个临时库就会少了这一次更新\",{\"1\":{\"89\":1}}],[\"这个关键字识别出来\",{\"1\":{\"86\":1}}],[\"这个词听起来极其深奥\",{\"1\":{\"70\":1}}],[\"这个路由映射后端的某个服务\",{\"1\":{\"69\":1}}],[\"这个监听器的作用是当前一个节点释放锁之后通知客户端\",{\"1\":{\"53\":1}}],[\"这个主要根据所涉及的编号对应的使用场景来\",{\"1\":{\"18\":1}}],[\"这是和三个一样的\",{\"1\":{\"1380\":1}}],[\"这是非常有用的\",{\"1\":{\"1335\":1}}],[\"这是非常耗时的\",{\"1\":{\"1315\":1}}],[\"这是官方文档的解释\",{\"1\":{\"1306\":1}}],[\"这是我们都不愿意见到的\",{\"1\":{\"1304\":1}}],[\"这是我们的代码运行空间\",{\"1\":{\"422\":1}}],[\"这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放\",{\"1\":{\"851\":1}}],[\"这是真正的多线程工作\",{\"1\":{\"827\":1}}],[\"这是真的厉害\",{\"1\":{\"205\":1}}],[\"这是另一个非常经典的\",{\"1\":{\"827\":1}}],[\"这是不可取的\",{\"1\":{\"784\":1}}],[\"这是模板方法模式很经典的一个运用\",{\"1\":{\"744\":1}}],[\"这是由于当一个桶位中有多个元素需要进行扩容时\",{\"1\":{\"685\":1}}],[\"这是由于订单号的生成规则的唯一性决定的\",{\"1\":{\"18\":1}}],[\"这是使用\",{\"1\":{\"435\":1}}],[\"这是使用最普遍的引用\",{\"1\":{\"392\":1}}],[\"这是因为的父节点node1还未创建\",{\"1\":{\"1335\":1}}],[\"这是因为并发编程下\",{\"1\":{\"971\":1}}],[\"这是因为fixedthreadpool\",{\"1\":{\"949\":1}}],[\"这是因为线程池会复用线程对象\",{\"1\":{\"929\":1}}],[\"这是因为读锁升级为写锁会引起线程的争夺\",{\"1\":{\"869\":1}}],[\"这是因为静态成员不属于任何一个实例对象\",{\"1\":{\"848\":1}}],[\"这是因为监视器锁\",{\"1\":{\"847\":1}}],[\"这是因为如果栈的内存大小可以动态扩展\",{\"1\":{\"493\":1}}],[\"这是因为在加载的时候其实是找到了\",{\"1\":{\"433\":1}}],[\"这是因为软引用可以加速\",{\"1\":{\"392\":1}}],[\"这是因为\",{\"1\":{\"358\":1,\"629\":1}}],[\"这是因为bootstrapclassloader\",{\"1\":{\"353\":1}}],[\"这是因为非主键索引叶子节点不保存行数据\",{\"1\":{\"106\":1}}],[\"这是比较浪费资源的行为\",{\"1\":{\"279\":1}}],[\"这是const联接类型的一个特例\",{\"1\":{\"120\":1}}],[\"这是\",{\"1\":{\"69\":1,\"288\":1,\"403\":1,\"407\":1,\"1141\":1}}],[\"这是一项重量级的更新\",{\"1\":{\"912\":1,\"1051\":1}}],[\"这是一种非常愚蠢的做法\",{\"1\":{\"1193\":1}}],[\"这是一种随机且带有传染性的方式将信息传播到整个网络中\",{\"1\":{\"1084\":1}}],[\"这是一种用户级线程\",{\"1\":{\"808\":1}}],[\"这是一种类似于二叉树的实现\",{\"1\":{\"445\":1}}],[\"这是一种最简易的\",{\"1\":{\"47\":1}}],[\"这是一个小问题\",{\"1\":{\"1170\":1}}],[\"这是一个比较常见的问题\",{\"1\":{\"973\":1}}],[\"这是一个简单的runnable类\",{\"1\":{\"940\":1}}],[\"这是一个常见的面试问题\",{\"1\":{\"897\":1}}],[\"这是一个\",{\"1\":{\"791\":1,\"1271\":1}}],[\"这是一个接口\",{\"1\":{\"791\":1}}],[\"这是一个非阻塞队列\",{\"1\":{\"791\":1}}],[\"这是一个非常关键的场景\",{\"1\":{\"484\":1}}],[\"这是一个函数式接口\",{\"1\":{\"778\":1}}],[\"这是一个标志接口\",{\"1\":{\"549\":1,\"586\":1}}],[\"这是一个查询语句\",{\"1\":{\"86\":1}}],[\"这是一个十六进制的数字\",{\"1\":{\"22\":1}}],[\"这是绝对不可允许\",{\"1\":{\"18\":1}}],[\"这极大减少了用户扫码支付的时间\",{\"1\":{\"17\":1}}],[\"这三个特点真的概括的\",{\"1\":{\"1152\":1}}],[\"这三个单词首字母组合\",{\"1\":{\"1067\":1}}],[\"这三个核心参数是\",{\"1\":{\"896\":1,\"923\":1}}],[\"这三个\",{\"1\":{\"10\":1}}],[\"这样每个表决者中保存的已经被\",{\"1\":{\"1373\":1}}],[\"这样能\",{\"1\":{\"1371\":1}}],[\"这样能加载的类就更多了\",{\"1\":{\"496\":1}}],[\"这样其他节点是无法代替主节点\",{\"1\":{\"1314\":1}}],[\"这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放\",{\"1\":{\"60\":1,\"837\":1,\"986\":1}}],[\"这样频繁的创建销毁会在服务端产生大量短连接请求\",{\"1\":{\"1290\":1}}],[\"这样我生产者是不是只能向一个队列发送消息\",{\"1\":{\"1280\":1}}],[\"这样我们就可以根据这个偏移量在对象内存当中找到这个属性\",{\"1\":{\"1011\":1}}],[\"这样我们就可以根据各个年代的特点选择合适的垃圾收集算法\",{\"1\":{\"399\":1}}],[\"这样我们就可以根据各个区域的特点选择合适的垃圾收集算法\",{\"1\":{\"382\":1}}],[\"这样我们就可以在异常处理中进行相应的操作\",{\"1\":{\"785\":1}}],[\"这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列\",{\"1\":{\"1278\":1}}],[\"这样改来改去是不是很麻烦\",{\"1\":{\"1272\":1}}],[\"这样是不是其他的\",{\"1\":{\"1280\":1}}],[\"这样是不是会将消息堆积在消息队列中\",{\"1\":{\"1275\":1}}],[\"这样是不是大妈打饭配菜的流程就会变长\",{\"1\":{\"1271\":1}}],[\"这样是不是更好理解一点\",{\"1\":{\"1196\":1}}],[\"这样整个系统的调用链又变长了\",{\"1\":{\"1271\":1}}],[\"这样图\",{\"1\":{\"1251\":1}}],[\"这样避免消息被重复消费\",{\"1\":{\"1250\":1}}],[\"这样系统的可扩展性无疑更好一些\",{\"1\":{\"1222\":1}}],[\"这样业务岂不是卡住了\",{\"1\":{\"1209\":1}}],[\"这样降低了消息丢失的可能性\",{\"1\":{\"1206\":1}}],[\"这样配置代表消息至少要被写入到\",{\"1\":{\"1206\":1}}],[\"这样当然可以解决问题\",{\"1\":{\"1202\":1}}],[\"这样学来的也终会忘记\",{\"1\":{\"1199\":1}}],[\"这样便能提供比较好的并发能力\",{\"1\":{\"1197\":1,\"1199\":1}}],[\"这样也就产生了事务的最终一致性\",{\"1\":{\"1304\":1}}],[\"这样也就得到了最终结果\",{\"1\":{\"1166\":1}}],[\"这样也可以做到\",{\"1\":{\"1280\":1}}],[\"这样也会产生重复的消息\",{\"1\":{\"1275\":1}}],[\"这样也带来了风险\",{\"1\":{\"160\":1,\"232\":1}}],[\"这样提升了开发效率\",{\"1\":{\"1126\":1}}],[\"这样提高了处理速度\",{\"1\":{\"968\":1}}],[\"这样提高了效率\",{\"1\":{\"558\":1}}],[\"这样节点\",{\"1\":{\"1087\":1}}],[\"这样存在\",{\"1\":{\"968\":1}}],[\"这样代码看起来会更加简洁\",{\"1\":{\"943\":1}}],[\"这样有助于我们定位问题\",{\"1\":{\"917\":1}}],[\"这样有什么好处呢\",{\"1\":{\"246\":1}}],[\"这样很明显是有问题的\",{\"1\":{\"895\":1,\"922\":1}}],[\"这样同样会非常影响性能\",{\"1\":{\"838\":1,\"987\":1,\"995\":1}}],[\"这样同样带来了网络调用消耗增加的问题\",{\"1\":{\"30\":1}}],[\"这样带来的好处是\",{\"1\":{\"800\":1}}],[\"这样效率自然就会很低\",{\"1\":{\"800\":1}}],[\"这样主线程的操作就会在这个方法上阻塞\",{\"1\":{\"753\":1}}],[\"这样在访问元素时就会把该元素移动到链表尾部\",{\"1\":{\"706\":1}}],[\"这样在下次调用时就可以直接使用缓存的字节码\",{\"1\":{\"6\":1}}],[\"这样只要集群中大部分机器是可用的\",{\"1\":{\"1354\":1,\"1362\":1}}],[\"这样只要\",{\"1\":{\"691\":1}}],[\"这样才可以使日志条目只有一个流向\",{\"1\":{\"1114\":1}}],[\"这样才可以避免\",{\"1\":{\"51\":1}}],[\"这样才能保证\",{\"1\":{\"904\":1}}],[\"这样才不会出错\",{\"1\":{\"663\":1}}],[\"这样实现的原因可能是基于概率统计\",{\"1\":{\"572\":1}}],[\"这样加载多少类的元数据就不由\",{\"1\":{\"496\":1}}],[\"这样那些不可达的对象进行清除\",{\"1\":{\"444\":1}}],[\"这样保证了一段时间内总有一个\",{\"1\":{\"444\":1}}],[\"这样保证了使用不同的类加载器得到的都是同一个结果\",{\"1\":{\"433\":1}}],[\"这样更简单便捷并且性能更好\",{\"1\":{\"281\":1}}],[\"这样更麻烦并且性能要差很多\",{\"1\":{\"270\":1}}],[\"这样对内存更加友好\",{\"1\":{\"352\":1}}],[\"这样对\",{\"1\":{\"272\":1}}],[\"这样对性能不友好\",{\"1\":{\"54\":1}}],[\"这样的好处在于\",{\"1\":{\"1263\":1}}],[\"这样的好处非常明显\",{\"1\":{\"265\":1}}],[\"这样的具体实现\",{\"1\":{\"1161\":1}}],[\"这样的方案现在也有很多现成的\",{\"1\":{\"1159\":1}}],[\"这样的状态会保持到该任期结束\",{\"1\":{\"1112\":1}}],[\"这样的队列是什么数据结构呢\",{\"1\":{\"1002\":1,\"1016\":1}}],[\"这样的\",{\"1\":{\"894\":1,\"920\":1}}],[\"这样的处理方式让写的同学更加明确线程池的运行规则\",{\"1\":{\"889\":1,\"937\":1}}],[\"这样的字段\",{\"1\":{\"621\":1}}],[\"这样的话缓存就会从数据库中加载数据\",{\"1\":{\"316\":1}}],[\"这样的话就可以保证即使数据不一致的话影响也比较小\",{\"1\":{\"145\":1}}],[\"这样的话\",{\"1\":{\"54\":1,\"60\":1,\"188\":1,\"357\":1,\"869\":1,\"1037\":1,\"1087\":1,\"1098\":1,\"1142\":1}}],[\"这样用户\",{\"1\":{\"1308\":1}}],[\"这样用户的一部分请求会直接到缓存这里而不用经过数据库\",{\"1\":{\"246\":1}}],[\"这样用户请求可以直接在网关层得到响应数据\",{\"1\":{\"2\":1}}],[\"这样会很麻烦\",{\"1\":{\"1250\":1}}],[\"这样会带来消息被重新消费的问题\",{\"1\":{\"1205\":1}}],[\"这样会造成很大的效率问题\",{\"1\":{\"544\":1,\"862\":1}}],[\"这样会导致耗尽\",{\"1\":{\"957\":1}}],[\"这样会导致大量的上下文切换\",{\"1\":{\"895\":1,\"922\":1}}],[\"这样会导致有\",{\"1\":{\"218\":1}}],[\"这样会导致丢部分已提交事务的修改信息\",{\"1\":{\"136\":1}}],[\"这样会严重降低redis的速度\",{\"1\":{\"282\":1}}],[\"这样会严重降低\",{\"1\":{\"161\":1,\"231\":1}}],[\"这样会影响缓存命中率\",{\"1\":{\"145\":1}}],[\"这样会浪费存储空间\",{\"1\":{\"141\":1}}],[\"这样查询可以利用索引的排序\",{\"1\":{\"119\":1}}],[\"这样一致性检查会产生失败\",{\"1\":{\"1112\":1}}],[\"这样一轮探测式清理工作就完成了\",{\"1\":{\"1037\":1}}],[\"这样一来\",{\"1\":{\"584\":1,\"773\":1,\"793\":1,\"884\":1,\"899\":1}}],[\"这样一个真正可用的对象才算完全产生出来\",{\"1\":{\"506\":1}}],[\"这样一个节点就可以存储更多的key\",{\"1\":{\"101\":1}}],[\"这样一共14字节\",{\"1\":{\"110\":1}}],[\"这样\",{\"1\":{\"72\":1,\"800\":1,\"1131\":1,\"1249\":1,\"1271\":1}}],[\"这样客户端\",{\"1\":{\"53\":1}}],[\"这样做可以提高数据的缓存命中率\",{\"1\":{\"1184\":1}}],[\"这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响\",{\"1\":{\"499\":1}}],[\"这样做的好处是\",{\"1\":{\"433\":1,\"1184\":1}}],[\"这样做的好处是用户可以自定义类加载器\",{\"1\":{\"353\":1}}],[\"这样做的好处是可以结合\",{\"1\":{\"235\":1}}],[\"这样做的好处是增加新的\",{\"1\":{\"96\":1}}],[\"这样做的好处是减少了开发成本\",{\"1\":{\"8\":1}}],[\"这样做主要是为了保证续期操作的原子性\",{\"1\":{\"49\":1}}],[\"这样确实可以解决问题\",{\"1\":{\"48\":1}}],[\"这样就会出现数据不一致性问题了\",{\"1\":{\"1380\":1}}],[\"这样就会产生\",{\"1\":{\"1304\":1}}],[\"这样就会产生耦合问题\",{\"1\":{\"1281\":1}}],[\"这样就会导致数据不一致的情况了\",{\"1\":{\"1224\":1}}],[\"这样就不会出现刚刚消费过的消息再一次被消费了\",{\"1\":{\"1280\":1}}],[\"这样就可能产生重复的消息\",{\"1\":{\"1275\":1}}],[\"这样就可以保证每个\",{\"1\":{\"1206\":1}}],[\"这样就可以保证写操作不会影响读操作了\",{\"1\":{\"585\":1,\"793\":1}}],[\"这样就可以屏蔽掉一些网络细节\",{\"1\":{\"1154\":1}}],[\"这样就可以让高层的类加载器\",{\"1\":{\"359\":1}}],[\"这样就可以区分不同集群\",{\"1\":{\"38\":1}}],[\"这样就避免直接把后端服务打垮掉\",{\"1\":{\"1221\":1}}],[\"这样就避免了操作员\",{\"1\":{\"840\":1,\"989\":1}}],[\"这样就破坏了破坏循环等待条件\",{\"1\":{\"824\":1}}],[\"这样就导致\",{\"1\":{\"753\":1}}],[\"这样就导致大量过期\",{\"1\":{\"272\":1}}],[\"这样就能在一些场景中显著提高性能\",{\"1\":{\"499\":1}}],[\"这样就使每次的内存回收都是对内存区间的一半进行回收\",{\"1\":{\"397\":1}}],[\"这样就没办法处理后续的命令\",{\"1\":{\"163\":1,\"292\":1}}],[\"这样就发生了在一个事务内两次读到的数据是不一样的\",{\"1\":{\"128\":1}}],[\"这样就生成\",{\"1\":{\"30\":1}}],[\"这样可以指派更多的资源去处理高优先级的队列\",{\"1\":{\"1252\":1}}],[\"这样可以避免\",{\"1\":{\"1184\":1}}],[\"这样可以避免频繁加锁影响性能\",{\"1\":{\"838\":1,\"987\":1}}],[\"这样可以避免频繁失败和重试影响性能\",{\"1\":{\"838\":1,\"987\":1}}],[\"这样可以避免数据竞争和脏数据问题\",{\"1\":{\"60\":1}}],[\"这样可以在较短的时间内找到目标节点\",{\"1\":{\"730\":1}}],[\"这样可以防止生产者和消费者线程之间的锁争夺\",{\"1\":{\"542\":1,\"672\":1}}],[\"这样可以增加对象再年轻代的存活时间\",{\"1\":{\"464\":1}}],[\"这样可以减少连续执行字符串增长操作所需的内存重分配次数\",{\"1\":{\"256\":1}}],[\"这样可以方便在订单异常\",{\"1\":{\"18\":1}}],[\"这样可以把一些业务侧返回的异常细节隐藏\",{\"1\":{\"2\":1}}],[\"这样不仅支持一码多平台调起支付\",{\"1\":{\"17\":1}}],[\"这样以插件的形式在\",{\"1\":{\"7\":1}}],[\"这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能\",{\"1\":{\"1\":1}}],[\"实在是太强大了\",{\"1\":{\"1390\":1}}],[\"实线表示主从复制\",{\"1\":{\"1085\":1}}],[\"实践相关的文章\",{\"1\":{\"486\":1}}],[\"实用性太差\",{\"1\":{\"314\":1}}],[\"实例上\",{\"1\":{\"1263\":1}}],[\"实例就一系列值达成共识\",{\"1\":{\"1099\":1}}],[\"实例化\",{\"1\":{\"767\":2}}],[\"实例数据部分是对象真正存储的有效信息\",{\"1\":{\"507\":1}}],[\"实例数据和对齐填充\",{\"1\":{\"507\":1}}],[\"实例变量是对象初始化时赋值的\",{\"1\":{\"429\":1}}],[\"实例变量会在对象实例化时随着对象一块分配在\",{\"1\":{\"342\":1}}],[\"实例持有\",{\"1\":{\"425\":1}}],[\"实例\",{\"1\":{\"425\":1,\"779\":1,\"1097\":1,\"1196\":1,\"1263\":1}}],[\"实例分配内存\",{\"1\":{\"425\":1}}],[\"实例分析\",{\"1\":{\"334\":1}}],[\"实例之间相互隔离\",{\"1\":{\"359\":1}}],[\"实例会在试图亲自查找类或资源之前\",{\"1\":{\"356\":2}}],[\"实例都有一个相关的父类加载器\",{\"1\":{\"356\":1}}],[\"实例的容量\",{\"1\":{\"549\":1,\"564\":1}}],[\"实例的父类加载器\",{\"1\":{\"356\":1}}],[\"实例的操作情况\",{\"1\":{\"298\":1}}],[\"实例的\",{\"1\":{\"298\":1}}],[\"实例的每秒处理请求达到\",{\"1\":{\"296\":1}}],[\"实例对其他请求的正常处理\",{\"1\":{\"297\":1}}],[\"实例设置最大可用内存\",{\"1\":{\"168\":1}}],[\"实例依次请求申请加锁\",{\"1\":{\"51\":1}}],[\"实时计算\",{\"1\":{\"1236\":1}}],[\"实时数据处理平台\",{\"1\":{\"1236\":1}}],[\"实时地查看和调整虚拟机各项参数\",{\"0\":{\"367\":1}}],[\"实时分析\",{\"1\":{\"293\":1,\"298\":1}}],[\"实时变更的业务需求\",{\"1\":{\"72\":1}}],[\"实时监控请求的统计信息\",{\"1\":{\"2\":1}}],[\"实际存储文件中的位移标识\",{\"1\":{\"1250\":1}}],[\"实际存储字符串的数组\",{\"1\":{\"256\":1}}],[\"实际指的就是接收到客户端执行方法的请求后\",{\"1\":{\"1166\":1}}],[\"实际应用案例\",{\"0\":{\"1069\":1}}],[\"实际场景请手动赋值线程池参数\",{\"1\":{\"753\":1}}],[\"实际大小大于阈值则扩容\",{\"1\":{\"622\":1,\"686\":1}}],[\"实际项目使用线程池之前可以看看\",{\"1\":{\"963\":1}}],[\"实际项目不太可能直接按照公式来设置线程池参数\",{\"1\":{\"922\":1}}],[\"实际项目根本也不可能往\",{\"1\":{\"564\":1}}],[\"实际项目中可以优先考虑\",{\"1\":{\"1099\":1}}],[\"实际项目中可以根据实际情况调整\",{\"1\":{\"38\":1}}],[\"实际项目中推荐使用\",{\"1\":{\"747\":1,\"905\":1}}],[\"实际项目中根据\",{\"1\":{\"479\":1}}],[\"实际项目中也没见谁使用\",{\"1\":{\"251\":1}}],[\"实际项目中不建议使用\",{\"1\":{\"51\":1}}],[\"实际项目中\",{\"1\":{\"50\":1,\"52\":1,\"53\":1,\"782\":1,\"784\":1}}],[\"实际接口并没有消耗很多时间\",{\"1\":{\"412\":1}}],[\"实际使用中需要根据自己机器的性能\",{\"1\":{\"917\":1}}],[\"实际使用中\",{\"1\":{\"787\":1}}],[\"实际使用\",{\"1\":{\"319\":1}}],[\"实际也和元素字节数有关\",{\"1\":{\"287\":1}}],[\"实际开发过程中不会使用\",{\"1\":{\"282\":1}}],[\"实际电商场景下\",{\"1\":{\"257\":1}}],[\"实际只是在\",{\"1\":{\"146\":1}}],[\"实际是在\",{\"1\":{\"24\":1}}],[\"实际上如果连接到了另外一个实例\",{\"1\":{\"1263\":1}}],[\"实际上可以对应成为消息队列中的队列\",{\"1\":{\"1196\":1}}],[\"实际上在早期的时候\",{\"1\":{\"1191\":1}}],[\"实际上这是一个非常具有误导性质的说法\",{\"1\":{\"1068\":1}}],[\"实际上是会进行一轮探测式清理操作的\",{\"1\":{\"1033\":1}}],[\"实际上是继承了\",{\"1\":{\"934\":1}}],[\"实际上key并不是threadlocal本身\",{\"1\":{\"1029\":1}}],[\"实际上我们需要更多关注的是\",{\"1\":{\"934\":1}}],[\"实际上调用这两个方法的时候\",{\"1\":{\"883\":1}}],[\"实际上调用的是\",{\"1\":{\"756\":1,\"911\":1}}],[\"实际上只增加了\",{\"1\":{\"835\":1}}],[\"实际上无论hashset中是否已经存在了某元素\",{\"1\":{\"680\":1}}],[\"实际上初始化赋值的是一个空数组\",{\"1\":{\"555\":1}}],[\"实际上很多互联网业务数据就是1k左右\",{\"1\":{\"110\":1}}],[\"实际上大多数的数据库存储却并不使用二叉树\",{\"1\":{\"98\":1}}],[\"实际上\",{\"1\":{\"1\":1,\"266\":1,\"313\":1,\"835\":1,\"900\":1,\"971\":1,\"1346\":1}}],[\"实战入门\",{\"1\":{\"1178\":1}}],[\"实战分享\",{\"1\":{\"788\":1}}],[\"实战案例\",{\"1\":{\"412\":1}}],[\"实战45讲\",{\"1\":{\"90\":1,\"120\":1,\"141\":1}}],[\"实战\",{\"0\":{\"749\":1,\"753\":1,\"757\":1,\"1319\":1},\"1\":{\"11\":1,\"334\":1,\"345\":1,\"800\":1,\"801\":1,\"876\":1,\"913\":1}}],[\"实现互斥锁呗\",{\"1\":{\"1388\":1}}],[\"实现得还是比较鸡肋的\",{\"1\":{\"1370\":1}}],[\"实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系\",{\"1\":{\"1310\":1}}],[\"实现它可会付出巨大的代价\",{\"1\":{\"1299\":1}}],[\"实现订阅关系的管理和追溯\",{\"1\":{\"1297\":1}}],[\"实现高性能\",{\"1\":{\"1285\":1}}],[\"实现流原生的数据处理\",{\"1\":{\"1238\":1}}],[\"实现任务异步\",{\"1\":{\"1218\":1,\"1232\":1}}],[\"实现不同的重试逻辑以及业务逻辑等\",{\"1\":{\"1212\":1}}],[\"实现代码非常简单\",{\"1\":{\"1183\":1}}],[\"实现loadbalance接口\",{\"1\":{\"1131\":1}}],[\"实现数据的最终一致性\",{\"1\":{\"1087\":1}}],[\"实现可重入的方法\",{\"1\":{\"1018\":1}}],[\"实现可见性\",{\"1\":{\"979\":1}}],[\"实现对任务的排序\",{\"1\":{\"897\":1}}],[\"实现中已经考虑了这种情况\",{\"1\":{\"884\":1}}],[\"实现中通过16k的page来定\",{\"1\":{\"108\":1}}],[\"实现异步的任务链\",{\"1\":{\"781\":1}}],[\"实现多个线程开始执行任务的最大并行性\",{\"1\":{\"753\":1}}],[\"实现多线程之间等待唤醒的交互\",{\"1\":{\"601\":1}}],[\"实现键值对按照访问顺序排序\",{\"1\":{\"709\":1}}],[\"实现有什么不同\",{\"0\":{\"692\":1}}],[\"实现sortedmap接口让\",{\"1\":{\"679\":1}}],[\"实现上一般遵循\",{\"1\":{\"667\":1}}],[\"实现排队功能的叫号机\",{\"1\":{\"640\":1}}],[\"实现线程安全的方式\",{\"1\":{\"688\":1}}],[\"实现线程安全的关键\",{\"1\":{\"601\":1}}],[\"实现线程间的等待和唤醒操作\",{\"1\":{\"544\":1}}],[\"实现就是\",{\"1\":{\"583\":1,\"793\":1}}],[\"实现类都可以被\",{\"1\":{\"934\":1}}],[\"实现类\",{\"1\":{\"860\":1}}],[\"实现类中各个功能之间可能没有任何联系\",{\"1\":{\"520\":1}}],[\"实现类必须覆写这些抽象方法\",{\"1\":{\"520\":1}}],[\"实现接⼝并覆盖接⼝\",{\"1\":{\"518\":1}}],[\"实现且全部继承自java\",{\"1\":{\"354\":1}}],[\"实现是完全符合这种逻辑概念的\",{\"1\":{\"342\":1}}],[\"实现抽奖系统怎么做\",{\"0\":{\"260\":1}}],[\"实现一个简易的\",{\"1\":{\"1173\":1}}],[\"实现一个简单的抽奖系统的话\",{\"1\":{\"260\":1}}],[\"实现一个排行榜怎么做\",{\"0\":{\"258\":1}}],[\"实现一个最简易的分布式锁\",{\"0\":{\"47\":1}}],[\"实现消息队列演示\",{\"1\":{\"251\":1}}],[\"实现消息队列没有广播机制的问题\",{\"1\":{\"251\":1}}],[\"实现消息队列功能太简单\",{\"1\":{\"251\":1}}],[\"实现\",{\"1\":{\"209\":1,\"212\":1,\"353\":1,\"482\":1,\"533\":1,\"599\":2,\"658\":1,\"665\":1,\"678\":1,\"679\":1,\"688\":1,\"808\":1,\"996\":1,\"1007\":1,\"1078\":2,\"1129\":1,\"1131\":1,\"1168\":1,\"1199\":1,\"1299\":1}}],[\"实现分页查询\",{\"1\":{\"181\":1}}],[\"实现分布式事务\",{\"0\":{\"1223\":1}}],[\"实现分布式协调服务的重要特性\",{\"1\":{\"55\":1,\"1352\":1}}],[\"实现分布式锁的详细介绍\",{\"1\":{\"249\":1,\"250\":1}}],[\"实现分布式锁的时候\",{\"1\":{\"54\":1}}],[\"实现分布式锁这两种实现方式要用的更多一些\",{\"1\":{\"62\":1}}],[\"实现分布式锁可靠性更高\",{\"1\":{\"52\":1}}],[\"实现分布式锁性能较高\",{\"1\":{\"52\":1}}],[\"实现分布式锁\",{\"0\":{\"46\":1,\"52\":1,\"53\":1,\"250\":1},\"1\":{\"45\":1,\"49\":1,\"57\":2,\"62\":3,\"1346\":1}}],[\"实现栈\",{\"1\":{\"181\":1}}],[\"实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性\",{\"1\":{\"1360\":1}}],[\"实现了两种队列选择算法\",{\"1\":{\"1299\":1}}],[\"实现了真正的远程服务调用\",{\"1\":{\"1129\":1}}],[\"实现了在\",{\"1\":{\"669\":1}}],[\"实现了访问顺序相关逻辑\",{\"1\":{\"645\":1}}],[\"实现了线程间的等待和唤醒操作\",{\"1\":{\"608\":1}}],[\"实现了互斥访问和\",{\"1\":{\"608\":1}}],[\"实现了以下接口\",{\"1\":{\"586\":1,\"727\":1}}],[\"实现了双亲委派机制\",{\"1\":{\"354\":1}}],[\"实现了空间预分配和惰性空间释放两种优化策略\",{\"1\":{\"256\":1}}],[\"实现了\",{\"1\":{\"233\":1,\"549\":1,\"552\":1,\"600\":1,\"656\":1,\"658\":2,\"678\":1,\"857\":1,\"865\":1,\"934\":1,\"1280\":1}}],[\"实现了自己的链表数据结构\",{\"1\":{\"180\":1}}],[\"实现了异步\",{\"1\":{\"4\":1}}],[\"实现事务\",{\"1\":{\"141\":1}}],[\"实现原理是子线程是通过在父线程中通过调用new\",{\"1\":{\"1043\":1}}],[\"实现原理是当客户用\",{\"1\":{\"17\":1}}],[\"实现原理与\",{\"1\":{\"767\":1}}],[\"实现原理\",{\"0\":{\"141\":1},\"1\":{\"996\":1}}],[\"实现索引覆盖最常见的方法就是\",{\"1\":{\"115\":1}}],[\"实现更强大的网关流量控制\",{\"1\":{\"76\":1}}],[\"实现动态路由的方式有很多种\",{\"1\":{\"72\":1}}],[\"实现锁重入\",{\"1\":{\"56\":1}}],[\"实现的零拷贝\",{\"1\":{\"1311\":1}}],[\"实现的虚拟线程\",{\"1\":{\"1056\":1}}],[\"实现的轻量级线程\",{\"1\":{\"1052\":1}}],[\"实现的原理\",{\"1\":{\"1036\":1}}],[\"实现的一个无界队列\",{\"1\":{\"597\":1}}],[\"实现的类加载器在\",{\"1\":{\"353\":1}}],[\"实现的限流\",{\"1\":{\"76\":1}}],[\"实现的\",{\"1\":{\"53\":1,\"249\":1,\"601\":1,\"643\":1,\"678\":1,\"742\":1,\"748\":1,\"808\":1,\"838\":1,\"861\":1,\"865\":1,\"874\":1,\"904\":1,\"987\":1,\"999\":1}}],[\"实现简单\",{\"1\":{\"51\":1}}],[\"实现简易分布式锁\",{\"1\":{\"47\":1}}],[\"实现比较复杂\",{\"1\":{\"51\":1}}],[\"实现方式比较简单\",{\"1\":{\"47\":1}}],[\"实现方案总结\",{\"0\":{\"26\":1}}],[\"实现起来比较简单\",{\"1\":{\"33\":1}}],[\"实现同步非阻塞的\",{\"1\":{\"5\":1,\"68\":1}}],[\"对集群中机器进行上下线操作等等\",{\"1\":{\"1390\":1}}],[\"对吧\",{\"1\":{\"1369\":1}}],[\"对指定\",{\"1\":{\"1351\":1}}],[\"对指定哈希中的指定字段做运算操作\",{\"1\":{\"185\":1}}],[\"对下游消费者可见\",{\"1\":{\"1285\":1}}],[\"对消费者可见\",{\"1\":{\"1284\":1}}],[\"对消息一致性要求比较高的场景可以使用\",{\"1\":{\"1240\":1}}],[\"对路由\",{\"1\":{\"1245\":1}}],[\"对原有系统和业务没有任何影响\",{\"1\":{\"1222\":1}}],[\"对原有的号段模式进行改进\",{\"1\":{\"41\":1}}],[\"对新增业务\",{\"1\":{\"1222\":1}}],[\"对加权随机算法的实现\",{\"1\":{\"1141\":1}}],[\"对需要在网络传输的数据进行序列化\",{\"1\":{\"1130\":1}}],[\"对远程调用的抽象\",{\"1\":{\"1129\":1}}],[\"对客户来说的话\",{\"1\":{\"1104\":1}}],[\"对外暴露的\",{\"1\":{\"1003\":1}}],[\"对一个\",{\"1\":{\"975\":1,\"1275\":1}}],[\"对一个或多个\",{\"1\":{\"202\":1}}],[\"对主内存中的一个共享变量进行操作有可能诱发线程安全问题\",{\"1\":{\"972\":1}}],[\"对系统时钟的变化敏感\",{\"1\":{\"962\":1}}],[\"对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对\",{\"1\":{\"1252\":1}}],[\"对比方向\",{\"1\":{\"1231\":1,\"1240\":1}}],[\"对比创建的系统线程数和处理耗时\",{\"1\":{\"1062\":1}}],[\"对比\",{\"0\":{\"962\":1},\"1\":{\"1191\":1}}],[\"对比一下\",{\"1\":{\"618\":1,\"682\":1}}],[\"对中断操作支持也不友好\",{\"1\":{\"873\":1}}],[\"对锁的实现引入了大量的优化\",{\"1\":{\"854\":1}}],[\"对括号里指定的对象\",{\"1\":{\"848\":1}}],[\"对资源分配进行计算评估\",{\"1\":{\"824\":1}}],[\"对已获得的资源保持不放\",{\"1\":{\"823\":1}}],[\"对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整\",{\"1\":{\"800\":1}}],[\"对completablefuture的应用\",{\"1\":{\"788\":1}}],[\"对此我们不妨来看看两者之间节点类的类图\",{\"1\":{\"708\":1}}],[\"对此我们可以使用\",{\"1\":{\"599\":1}}],[\"对list进行二分查找\",{\"1\":{\"697\":1}}],[\"对同一\",{\"1\":{\"690\":1}}],[\"对同一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性\",{\"1\":{\"141\":1}}],[\"对整个逻辑进行了简化\",{\"1\":{\"941\":1}}],[\"对整个桶数组进行了分割分段\",{\"1\":{\"688\":1,\"792\":1}}],[\"对整个新生代和部分老年代进行垃圾收集\",{\"1\":{\"387\":1}}],[\"对付顺序的好帮手\",{\"1\":{\"640\":1}}],[\"对本文的改进做出的贡献\",{\"1\":{\"615\":1}}],[\"对本地资源消耗要小\",{\"1\":{\"30\":1}}],[\"对副本数组进行修改\",{\"1\":{\"585\":1,\"793\":1}}],[\"对mincapacity和max\",{\"1\":{\"559\":1}}],[\"对index进行界限检查\",{\"1\":{\"553\":2,\"561\":1}}],[\"对抽象的事物抽象化成一个对象\",{\"1\":{\"518\":1}}],[\"对齐填充部分不是必然存在的\",{\"1\":{\"507\":1}}],[\"对该算法做了重大改进\",{\"1\":{\"408\":1}}],[\"对垃圾内存的回收速度\",{\"1\":{\"392\":1}}],[\"对引用的概念进行了扩充\",{\"1\":{\"392\":1}}],[\"对堆垃圾回收前的第一步就是要判断哪些对象已经死亡\",{\"1\":{\"389\":1}}],[\"对类进行link操作\",{\"1\":{\"357\":1}}],[\"对象发布事件的用户代码\",{\"1\":{\"1182\":1}}],[\"对象可以判断任务是否执行成功\",{\"1\":{\"944\":1}}],[\"对象可以被回收\",{\"1\":{\"391\":1}}],[\"对象转换成\",{\"1\":{\"943\":1}}],[\"对象提交给\",{\"1\":{\"934\":1}}],[\"对象或callable\",{\"1\":{\"934\":1}}],[\"对象直接交给\",{\"1\":{\"934\":1}}],[\"对象也会在方法内部转换为callable\",{\"1\":{\"900\":1}}],[\"对象来指定任务之间的排序规则\",{\"1\":{\"897\":1}}],[\"对象为\",{\"1\":{\"883\":1}}],[\"对象锁的的拥有者线程才可以执行\",{\"1\":{\"851\":1}}],[\"对象监视器\",{\"1\":{\"851\":1}}],[\"对象这种使用方式可以看作是将\",{\"1\":{\"777\":1}}],[\"对象设置进\",{\"1\":{\"767\":1}}],[\"对象调用set方法设置的值\",{\"1\":{\"883\":1}}],[\"对象调用\",{\"1\":{\"756\":1,\"911\":1}}],[\"对象中某field的偏移量\",{\"1\":{\"841\":1,\"990\":1}}],[\"对象中\",{\"1\":{\"767\":1}}],[\"对象中的歌名和歌手名分别采用一种排序方法的话\",{\"1\":{\"661\":1}}],[\"对象中只有一个condition实例\",{\"1\":{\"544\":1,\"862\":1}}],[\"对象加锁\",{\"1\":{\"631\":1}}],[\"对象时\",{\"1\":{\"555\":1,\"798\":1}}],[\"对象头\",{\"1\":{\"507\":1}}],[\"对象头会有不同的设置方式\",{\"1\":{\"505\":1}}],[\"对象创建才刚开始\",{\"1\":{\"506\":1}}],[\"对象所需的内存大小在类加载完成后便可确定\",{\"1\":{\"503\":1}}],[\"对象作为这块内存的引用进行操作\",{\"1\":{\"499\":1}}],[\"对象作为数据访问的入口\",{\"1\":{\"428\":1}}],[\"对象引用\",{\"1\":{\"493\":1}}],[\"对象引用该字符串常量的话\",{\"1\":{\"393\":1}}],[\"对象的格式化输出\",{\"1\":{\"1349\":1}}],[\"对象的话\",{\"1\":{\"883\":1}}],[\"对象的方法如下\",{\"1\":{\"776\":1}}],[\"对象的属性修改类型原子类\",{\"0\":{\"768\":1}}],[\"对象的属性修改类型\",{\"1\":{\"762\":1}}],[\"对象的构造方法\",{\"1\":{\"602\":1}}],[\"对象的访问方式由虚拟机实现而定\",{\"1\":{\"508\":1}}],[\"对象的访问定位\",{\"0\":{\"508\":1},\"1\":{\"509\":1,\"510\":1}}],[\"对象的访问定位的两种方式\",{\"1\":{\"489\":1}}],[\"对象的内存布局\",{\"0\":{\"507\":1}}],[\"对象的\",{\"1\":{\"505\":1,\"975\":1,\"1202\":1,\"1333\":1}}],[\"对象的哈希码\",{\"1\":{\"505\":1}}],[\"对象的创建\",{\"0\":{\"501\":1}}],[\"对象的创建过程我建议最好是能默写出来\",{\"1\":{\"501\":1}}],[\"对象的创建过程\",{\"1\":{\"489\":1}}],[\"对象使用\",{\"1\":{\"485\":1}}],[\"对象超过多大是直接在旧生代分配\",{\"1\":{\"449\":1}}],[\"对象持有的引用定位到方法区中\",{\"1\":{\"425\":1}}],[\"对象没有在任何地方被引用\",{\"1\":{\"394\":1}}],[\"对象之间循环引用\",{\"1\":{\"390\":1}}],[\"对象晋升到老年代的年龄阈值\",{\"1\":{\"386\":1,\"495\":1}}],[\"对象在内存中的布局可以分为\",{\"1\":{\"507\":1}}],[\"对象在\",{\"1\":{\"386\":1}}],[\"对象在新生代中\",{\"1\":{\"384\":1}}],[\"对象都会首先在\",{\"1\":{\"386\":1,\"495\":1}}],[\"对象优先在\",{\"0\":{\"384\":1}}],[\"对象被\",{\"1\":{\"345\":1}}],[\"对象一起存放在\",{\"1\":{\"342\":1}}],[\"对象\",{\"1\":{\"340\":1,\"349\":1,\"351\":1,\"425\":2,\"444\":1,\"445\":1,\"593\":1,\"733\":1,\"753\":2,\"767\":1,\"777\":1,\"781\":3,\"900\":2,\"934\":2,\"943\":1,\"1166\":2,\"1182\":1,\"1226\":1,\"1333\":1}}],[\"对象数据存储场景\",{\"1\":{\"186\":1}}],[\"对常量池的引用\",{\"1\":{\"331\":2}}],[\"对性能影响比较大\",{\"1\":{\"319\":1}}],[\"对性能更友好\",{\"1\":{\"54\":1}}],[\"对给定元素再次进行相同的哈希计算\",{\"1\":{\"307\":1}}],[\"对数据进行修改\",{\"1\":{\"1388\":1}}],[\"对数据库造成了巨大的压力\",{\"1\":{\"306\":2,\"309\":2,\"313\":2}}],[\"对数据的修改就是永久的\",{\"1\":{\"125\":1}}],[\"对其进行强制硬盘同步\",{\"1\":{\"230\":1}}],[\"对相同元素对应的\",{\"1\":{\"193\":1}}],[\"对设置到指定哈希表中\",{\"1\":{\"185\":1,\"286\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"117\":1}}],[\"对请求进行拦截和修改\",{\"1\":{\"73\":1}}],[\"对请求的流量进行控制\",{\"1\":{\"2\":1}}],[\"对可重入锁的实现来介绍\",{\"1\":{\"56\":1}}],[\"对应节点为\",{\"1\":{\"1356\":1}}],[\"对应于每个\",{\"1\":{\"1350\":1}}],[\"对应于get\",{\"1\":{\"552\":1,\"656\":1}}],[\"对应到\",{\"1\":{\"1199\":1}}],[\"对应到现实生活中来\",{\"1\":{\"985\":1}}],[\"对应到虚拟机参数为\",{\"1\":{\"444\":1}}],[\"对应公平模式\",{\"1\":{\"748\":1}}],[\"对应非公平模式\",{\"1\":{\"748\":1}}],[\"对应的节点为\",{\"1\":{\"1356\":2}}],[\"对应的节点会转为树节点\",{\"1\":{\"708\":1}}],[\"对应的活跃\",{\"1\":{\"1142\":1}}],[\"对应的服务提供者的活跃数\",{\"1\":{\"1142\":1}}],[\"对应的slot中\",{\"1\":{\"1036\":1}}],[\"对应的线程就会继续往下执行\",{\"1\":{\"1014\":1}}],[\"对应的偏移量\",{\"1\":{\"1011\":1}}],[\"对应的源码如下\",{\"1\":{\"1007\":1}}],[\"对应的还有两个子类\",{\"1\":{\"748\":1}}],[\"对应的两个构造方法如下\",{\"1\":{\"747\":1,\"905\":1}}],[\"对应的所有\",{\"1\":{\"286\":1}}],[\"对应的官方文档地址\",{\"1\":{\"205\":1}}],[\"对应的名字是什么\",{\"1\":{\"96\":1}}],[\"对应的接口是\",{\"1\":{\"76\":1}}],[\"对应的子节点由于是临时顺序节点\",{\"1\":{\"53\":1}}],[\"对应的是add\",{\"1\":{\"729\":1}}],[\"对应的是\",{\"1\":{\"48\":1,\"309\":1,\"311\":1}}],[\"对应的\",{\"1\":{\"47\":1,\"48\":1,\"163\":1,\"177\":1,\"185\":1,\"291\":1}}],[\"对应\",{\"1\":{\"47\":1,\"293\":1,\"888\":1,\"937\":1}}],[\"对应且仅对应\",{\"1\":{\"28\":1}}],[\"对应且仅对应一个订单\",{\"1\":{\"28\":1}}],[\"对应且仅对应一个人\",{\"1\":{\"28\":2}}],[\"对应且仅对应一件商品\",{\"1\":{\"28\":1}}],[\"对\",{\"1\":{\"40\":1,\"205\":1,\"406\":1,\"446\":1,\"485\":1,\"622\":1,\"677\":1,\"752\":2,\"835\":3,\"968\":1,\"974\":1,\"1120\":1,\"1292\":1}}],[\"对兑换码的数据需要进行校验\",{\"1\":{\"19\":1}}],[\"对在线业务更加友好\",{\"1\":{\"18\":1}}],[\"对订单进行操作\",{\"1\":{\"18\":1}}],[\"对于身份认证\",{\"1\":{\"1351\":1}}],[\"对于消息可靠性是通过不同的刷盘策略保证的\",{\"1\":{\"1314\":1}}],[\"对于消费者来说\",{\"1\":{\"1304\":1}}],[\"对于历史版本服务端\",{\"1\":{\"1296\":1}}],[\"对于生产者的创建和初始化\",{\"1\":{\"1289\":1}}],[\"对于主题是无顺序的\",{\"1\":{\"1275\":1}}],[\"对于主流的\",{\"1\":{\"1159\":1}}],[\"对于典型的路由功能\",{\"1\":{\"1237\":1,\"1246\":1}}],[\"对于死信队列的处理\",{\"1\":{\"1213\":1}}],[\"对于如何保证\",{\"1\":{\"1202\":1}}],[\"对于同一个\",{\"1\":{\"1199\":1}}],[\"对于同一份数据\",{\"1\":{\"818\":2}}],[\"对于上面的技术细节\",{\"1\":{\"1166\":1}}],[\"对于上边提到的问题\",{\"1\":{\"1002\":1}}],[\"对于threadlocal\",{\"1\":{\"1026\":1}}],[\"对于我们自定义的同步工具\",{\"1\":{\"1006\":1}}],[\"对于问题\",{\"1\":{\"1002\":1}}],[\"对于会改变程序执行结果的重排序\",{\"1\":{\"974\":1}}],[\"对于处理器\",{\"1\":{\"969\":1}}],[\"对于编译器\",{\"1\":{\"969\":1}}],[\"对于可伸缩的应用程序\",{\"1\":{\"936\":1}}],[\"对于可变集合\",{\"1\":{\"634\":1}}],[\"对于一些基本参数的说明\",{\"1\":{\"1333\":1}}],[\"对于一些微服务来说\",{\"1\":{\"1275\":1}}],[\"对于一些比较耗时的操作\",{\"1\":{\"925\":1}}],[\"对于一个集群\",{\"1\":{\"1358\":1}}],[\"对于一个单链表\",{\"1\":{\"800\":1}}],[\"对于一个查询和排序分页的\",{\"1\":{\"412\":1}}],[\"对于一个类加载器来说\",{\"1\":{\"352\":1}}],[\"对于一个\",{\"1\":{\"98\":1}}],[\"对于多线程这个场景来说主要是增加了上下文切换\",{\"1\":{\"922\":1}}],[\"对于多线程这个场景来说主要是增加了上下文切换成本\",{\"1\":{\"895\":1}}],[\"对于性能方面的影响\",{\"1\":{\"897\":1}}],[\"对于单核\",{\"1\":{\"819\":1}}],[\"对于单机多线程来说\",{\"1\":{\"60\":1}}],[\"对于存在前后顺序关系的接口调用\",{\"1\":{\"772\":1}}],[\"对于两个对象来说\",{\"1\":{\"678\":1}}],[\"对于删除\",{\"1\":{\"653\":1}}],[\"对于插入\",{\"1\":{\"653\":1}}],[\"对于基本类型数据\",{\"1\":{\"649\":1}}],[\"对于collection\",{\"1\":{\"639\":1}}],[\"对于缓存过期这个场景而言\",{\"1\":{\"609\":1}}],[\"对于延迟任务优先级的管理就变得十分方便了\",{\"1\":{\"607\":1}}],[\"对于没有到期的任务只有等待\",{\"1\":{\"601\":1}}],[\"对于每个节点的\",{\"1\":{\"1389\":1}}],[\"对于每个来自于先前的表的行组合\",{\"1\":{\"120\":1}}],[\"对于每个来自于前面的表的行组合\",{\"1\":{\"120\":2}}],[\"对于每次读取都进行加锁其实是一种资源浪费\",{\"1\":{\"584\":1,\"793\":1}}],[\"对于增删改查等方法基本都加了\",{\"1\":{\"583\":1,\"793\":1}}],[\"对于大部分业务场景来说\",{\"1\":{\"584\":1,\"793\":1,\"897\":1}}],[\"对于大数据的\",{\"1\":{\"558\":1}}],[\"对于大型应用程序来说\",{\"1\":{\"484\":1}}],[\"对于锁的争抢是随机的\",{\"1\":{\"534\":1}}],[\"对于集合的操作无非是增删改查\",{\"1\":{\"533\":1}}],[\"对于集合类型还可以使用\",{\"1\":{\"293\":1}}],[\"对于任意一个类都能够知道这个类所有的属性和方法\",{\"1\":{\"523\":1}}],[\"对于年老代比较多的应用\",{\"1\":{\"464\":1}}],[\"对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收\",{\"1\":{\"445\":1}}],[\"对于栈来说\",{\"1\":{\"440\":1}}],[\"对于已经加载的类会被放在\",{\"1\":{\"352\":1}}],[\"对于初始化阶段\",{\"1\":{\"344\":1}}],[\"对于<clinit>\",{\"1\":{\"344\":1}}],[\"对于该阶段有以下几点需要注意\",{\"1\":{\"342\":1}}],[\"对于业务的数据规模考虑不周到\",{\"1\":{\"292\":1}}],[\"对于业务服务返回的异常响应\",{\"1\":{\"2\":1}}],[\"对于过期\",{\"1\":{\"289\":1}}],[\"对于不可变集合\",{\"1\":{\"634\":1}}],[\"对于不支持批量操作的命令\",{\"1\":{\"287\":1}}],[\"对于不等于\",{\"1\":{\"117\":1}}],[\"对于读写命令来说\",{\"1\":{\"264\":1}}],[\"对于后四种实现都包含了下面这\",{\"1\":{\"256\":1}}],[\"对于这一点资源空间的浪费是可以接受的\",{\"1\":{\"708\":1}}],[\"对于这个问题\",{\"1\":{\"708\":1}}],[\"对于这个问题的回答\",{\"1\":{\"693\":1}}],[\"对于这种需求\",{\"1\":{\"287\":1}}],[\"对于这种情况可以将响应缓存起来\",{\"1\":{\"2\":1}}],[\"对于这部分知识点大家了解就好了\",{\"1\":{\"251\":1}}],[\"对于持久化机制做了什么优化\",{\"0\":{\"235\":1}}],[\"对于小\",{\"1\":{\"167\":1}}],[\"对于复合类型的\",{\"1\":{\"163\":1,\"291\":1}}],[\"对于热点数据可以提前放入缓存中\",{\"1\":{\"146\":1}}],[\"对于更新和删除操作\",{\"1\":{\"141\":1}}],[\"对于未分区的表\",{\"1\":{\"120\":1}}],[\"对于非主键查询来说\",{\"1\":{\"108\":1}}],[\"对于客户端输入的命令\",{\"1\":{\"86\":1}}],[\"对于实际工作中分布式\",{\"1\":{\"43\":1}}],[\"对于\",{\"1\":{\"35\":1,\"49\":1,\"168\":1,\"412\":1,\"480\":1,\"490\":1,\"622\":1,\"772\":1,\"897\":1,\"971\":2,\"1067\":1,\"1166\":1,\"1251\":1,\"1351\":1,\"1374\":1}}],[\"对于公司业务以\",{\"1\":{\"10\":1}}],[\"对用户请求进行身份验证并仅允许可信客户端访问\",{\"1\":{\"2\":1}}],[\"+formatter\",{\"1\":{\"882\":2}}],[\"+thread\",{\"1\":{\"882\":2}}],[\"+i\",{\"1\":{\"882\":1}}],[\"+inc\",{\"1\":{\"233\":1}}],[\"+1\",{\"1\":{\"835\":2,\"895\":2,\"922\":2,\"1142\":1}}],[\"+lua\",{\"1\":{\"747\":1,\"905\":1}}],[\"+b\",{\"1\":{\"562\":1}}],[\"++j\",{\"1\":{\"624\":1,\"1038\":1}}],[\"++size\",{\"1\":{\"622\":1,\"686\":3,\"712\":1,\"1036\":1}}],[\"++sshift\",{\"1\":{\"570\":1}}],[\"++bincount\",{\"1\":{\"577\":1,\"622\":1,\"683\":1}}],[\"++retries\",{\"1\":{\"571\":1}}],[\"++modcount\",{\"1\":{\"571\":2,\"622\":1,\"710\":1,\"711\":1,\"712\":1}}],[\"++c\",{\"1\":{\"570\":1}}],[\"++count\",{\"1\":{\"531\":1}}],[\"++i\",{\"1\":{\"538\":1,\"629\":1,\"631\":1}}],[\"++takeindex\",{\"1\":{\"535\":1}}],[\"++putindex\",{\"1\":{\"535\":1}}],[\"+optimizestringconcat\",{\"1\":{\"485\":1}}],[\"+collectgen0first\",{\"1\":{\"471\":1}}],[\"+aggressiveopts\",{\"1\":{\"465\":1}}],[\"+disableexplicitgc\",{\"1\":{\"449\":1,\"463\":1}}],[\"+uselargepages\",{\"1\":{\"485\":1}}],[\"+uselwpsynchronization\",{\"1\":{\"485\":1}}],[\"+usestringcache\",{\"1\":{\"485\":1}}],[\"+usestringdeduplication\",{\"1\":{\"485\":1}}],[\"+useserialgc\",{\"1\":{\"482\":1}}],[\"+usegcoverheadlimit\",{\"1\":{\"484\":1}}],[\"+usegclogfilerotation\",{\"1\":{\"483\":1}}],[\"+useg1gc\",{\"1\":{\"482\":1}}],[\"+usebiasedlocking\",{\"1\":{\"466\":1}}],[\"+usefastaccessormethods\",{\"1\":{\"462\":1}}],[\"+useparnewgc\",{\"1\":{\"482\":1}}],[\"+useparalleloldgc\",{\"1\":{\"403\":2}}],[\"+useparallelgc\",{\"1\":{\"403\":3,\"482\":1}}],[\"+usepsadaptivesurvivorsizepolicy\",{\"1\":{\"443\":1}}],[\"+usezgc\",{\"1\":{\"408\":1}}],[\"+usecompressedstrings\",{\"1\":{\"485\":1}}],[\"+usecompressedoops\",{\"1\":{\"403\":1}}],[\"+usecompressedclasspointers\",{\"1\":{\"403\":1}}],[\"+printsafepointstatistics\",{\"1\":{\"483\":1}}],[\"+printreferencegc\",{\"1\":{\"483\":1}}],[\"+printheapatgc\",{\"1\":{\"483\":1}}],[\"+printtenuringdistribution\",{\"1\":{\"483\":1}}],[\"+printcommandlineflags\",{\"1\":{\"400\":1,\"403\":2}}],[\"+printgcapplicationstoppedtime\",{\"1\":{\"483\":1}}],[\"+printgcdatestamps\",{\"1\":{\"483\":1}}],[\"+printgcdetails\",{\"1\":{\"384\":1,\"451\":1,\"483\":1}}],[\"+printgc\",{\"1\":{\"367\":2}}],[\"+=\",{\"1\":{\"386\":1,\"495\":1,\"553\":2,\"629\":1,\"1141\":1,\"1142\":1}}],[\"+heapdumponoutofmemoryerror\",{\"1\":{\"368\":1,\"455\":1,\"484\":1}}],[\"+|\",{\"1\":{\"367\":1}}],[\"+map\",{\"1\":{\"625\":7}}],[\"+m\",{\"1\":{\"157\":2,\"301\":2}}],[\"+\",{\"1\":{\"1\":1,\"7\":1,\"19\":2,\"22\":3,\"49\":6,\"53\":4,\"56\":1,\"76\":1,\"125\":18,\"135\":1,\"161\":1,\"184\":1,\"231\":1,\"249\":1,\"270\":1,\"353\":1,\"370\":6,\"400\":1,\"403\":1,\"449\":2,\"450\":2,\"451\":25,\"531\":2,\"553\":14,\"555\":1,\"557\":1,\"558\":2,\"561\":4,\"564\":2,\"571\":3,\"573\":2,\"575\":3,\"579\":3,\"588\":1,\"591\":1,\"593\":10,\"599\":1,\"619\":2,\"621\":3,\"624\":1,\"625\":5,\"649\":1,\"653\":66,\"663\":2,\"677\":3,\"688\":3,\"691\":2,\"692\":2,\"704\":2,\"705\":2,\"713\":6,\"733\":8,\"748\":1,\"749\":1,\"753\":1,\"757\":8,\"763\":9,\"765\":1,\"766\":9,\"767\":48,\"779\":8,\"781\":9,\"782\":2,\"807\":3,\"823\":6,\"824\":3,\"871\":2,\"882\":2,\"894\":4,\"920\":4,\"940\":5,\"974\":1,\"1007\":1,\"1018\":2,\"1028\":1,\"1036\":2,\"1043\":2,\"1062\":2,\"1132\":1,\"1141\":1,\"1152\":2,\"1178\":1,\"1204\":3,\"1206\":1,\"1271\":2,\"1308\":1,\"1310\":1}}],[\"身份证等隐私信息\",{\"1\":{\"18\":1}}],[\"身份\",{\"1\":{\"1\":1}}],[\"一台机器不够用再加一台抗压呗\",{\"1\":{\"1367\":1}}],[\"一下吧\",{\"1\":{\"1315\":1}}],[\"一点一点的查出来\",{\"1\":{\"1264\":1}}],[\"一套规则\",{\"1\":{\"1253\":1}}],[\"一套名称\",{\"1\":{\"1226\":1}}],[\"一位球友之前投稿的面经\",{\"1\":{\"1177\":1}}],[\"一言蔽之\",{\"1\":{\"1165\":1}}],[\"一轮选举结束\",{\"1\":{\"1111\":1}}],[\"一组server的状态机计算相同状态的副本\",{\"1\":{\"1106\":1}}],[\"一万字详解\",{\"1\":{\"1092\":1}}],[\"一开始的向前查找数据并未找到过期的entry\",{\"1\":{\"1036\":1}}],[\"一开始向前查找过期数据时并未找到过期的entry数据\",{\"1\":{\"1036\":1}}],[\"一步步往下看\",{\"1\":{\"1031\":1}}],[\"一步一步分析\",{\"0\":{\"556\":1}}],[\"一枝花算不算浪漫\",{\"1\":{\"1028\":2}}],[\"一把锁只能被一个线程获得\",{\"1\":{\"867\":1,\"871\":1}}],[\"一把锁可以被多个线程同时获得\",{\"1\":{\"867\":1}}],[\"一把是\",{\"1\":{\"865\":2}}],[\"一对一\",{\"1\":{\"808\":1}}],[\"一对多\",{\"1\":{\"71\":1}}],[\"一句话简单了解堆和方法区\",{\"0\":{\"813\":1}}],[\"一句话概括\",{\"1\":{\"808\":1}}],[\"一句话便是\",{\"1\":{\"437\":1}}],[\"一口气说出\",{\"1\":{\"612\":1}}],[\"一致了\",{\"1\":{\"1142\":1}}],[\"一致则替换值\",{\"1\":{\"571\":1}}],[\"一致性协议和算法\",{\"0\":{\"1369\":1}}],[\"一致性问题\",{\"0\":{\"1368\":1},\"1\":{\"1224\":1}}],[\"一致性检查会在下一次\",{\"1\":{\"1112\":1}}],[\"一致性不依赖时序\",{\"1\":{\"1106\":1}}],[\"一致性是通过原子性\",{\"1\":{\"133\":1}}],[\"一致性才能得到保障\",{\"1\":{\"125\":1}}],[\"一致性\",{\"1\":{\"125\":2,\"133\":1,\"281\":2,\"1067\":2,\"1068\":1}}],[\"一文彻底搞懂\",{\"1\":{\"996\":1}}],[\"一文详解\",{\"1\":{\"320\":1}}],[\"一文给你整的明明白白\",{\"1\":{\"307\":1}}],[\"一些不合法的参数请求直接抛出异常信息返回给客户端\",{\"1\":{\"307\":1}}],[\"一些特殊的场景可能会需要使用可重入的分布式锁\",{\"1\":{\"50\":1}}],[\"一段时间之后\",{\"1\":{\"773\":1,\"899\":1}}],[\"一段时间内多次请求获取到的数据很可能是一样的\",{\"1\":{\"2\":1}}],[\"一段\",{\"1\":{\"283\":2,\"288\":2}}],[\"一直致力于\",{\"1\":{\"1062\":1}}],[\"一直找到\",{\"1\":{\"1033\":1}}],[\"一直到\",{\"1\":{\"1018\":1}}],[\"一直被阻塞在队列中\",{\"1\":{\"919\":1}}],[\"一直等待\",{\"1\":{\"815\":1}}],[\"一直等到队列可以放入新元素时再放入\",{\"1\":{\"670\":1}}],[\"一直是单线程模型\",{\"1\":{\"264\":1}}],[\"一直阻塞\",{\"1\":{\"140\":1}}],[\"一旦一次更改请求被应用\",{\"1\":{\"1345\":1}}],[\"一旦某个\",{\"1\":{\"1281\":1}}],[\"一旦\",{\"1\":{\"1112\":1}}],[\"一旦选出了\",{\"1\":{\"1112\":1}}],[\"一旦命令被正确地复制\",{\"1\":{\"1106\":1}}],[\"一旦任务暂停\",{\"1\":{\"895\":1,\"922\":1}}],[\"一旦使用不当\",{\"1\":{\"873\":1}}],[\"一旦线程申请了锁\",{\"1\":{\"863\":1}}],[\"一旦发现被查找的元素大于当前链表中的取值\",{\"1\":{\"800\":1}}],[\"一旦发现了只具有弱引用的对象\",{\"1\":{\"392\":1,\"884\":1}}],[\"一旦插入操作让\",{\"1\":{\"718\":1}}],[\"一旦创建就一直存在\",{\"1\":{\"1382\":1}}],[\"一旦创建就一直存在即使\",{\"1\":{\"54\":1,\"1335\":1,\"1349\":1}}],[\"一旦创建\",{\"1\":{\"541\":1,\"797\":1}}],[\"一旦出现内存泄漏和溢出方面的问题\",{\"1\":{\"490\":1}}],[\"一旦没有分配足够长度的内存空间\",{\"1\":{\"256\":1}}],[\"一种比较简单粗暴的方法就是\",{\"1\":{\"1083\":1}}],[\"一种在操作失败后会抛出异常\",{\"1\":{\"667\":1}}],[\"一种是在运行时确定\",{\"1\":{\"519\":1}}],[\"一种是在编译期确定\",{\"1\":{\"519\":1}}],[\"一种是抛出异常\",{\"1\":{\"493\":1}}],[\"一种是\",{\"1\":{\"493\":1}}],[\"一种规范\",{\"1\":{\"417\":1}}],[\"一种用途是在\",{\"1\":{\"404\":1}}],[\"一种二进制安全的数据类型\",{\"1\":{\"195\":1}}],[\"一种低级汇编语言\",{\"1\":{\"8\":1}}],[\"一样也是点号\",{\"1\":{\"1252\":1}}],[\"一样执行相同的逻辑并进入\",{\"1\":{\"604\":1}}],[\"一样抛出\",{\"1\":{\"456\":1}}],[\"一样\",{\"1\":{\"146\":1,\"749\":1,\"865\":1,\"873\":1,\"955\":1,\"1311\":1,\"1367\":1,\"1372\":1,\"1378\":1,\"1379\":1}}],[\"一是因为这两个分布式基础理论是学习分布式知识的必备前置基础\",{\"1\":{\"1065\":1}}],[\"一是\",{\"1\":{\"141\":1}}],[\"一列不是索引\",{\"1\":{\"118\":1}}],[\"一行数据记录大小为1k\",{\"1\":{\"110\":1}}],[\"一行代码就行了\",{\"1\":{\"37\":1}}],[\"一棵b+树可以存放多少条数据\",{\"0\":{\"110\":1}}],[\"一次处理多个元素\",{\"1\":{\"1184\":1}}],[\"一次操作或者多次操作\",{\"1\":{\"978\":1}}],[\"一次\",{\"1\":{\"904\":1}}],[\"一次性申请所有的资源\",{\"1\":{\"824\":1}}],[\"一次是在遍历所有key的时候\",{\"1\":{\"625\":1}}],[\"一次是在获取keyset的时候\",{\"1\":{\"625\":1}}],[\"一次编写\",{\"1\":{\"515\":1}}],[\"一次大量\",{\"1\":{\"412\":1,\"486\":1}}],[\"一次线上\",{\"1\":{\"412\":1,\"486\":1}}],[\"一次即可定位\",{\"1\":{\"103\":1}}],[\"一次查询可能需要访问\",{\"1\":{\"98\":1}}],[\"一往无前～\",{\"1\":{\"93\":1}}],[\"一条消息会发送给\",{\"1\":{\"1281\":1}}],[\"一条消息只能被一个消费者使用\",{\"1\":{\"1193\":1,\"1228\":1}}],[\"一条\",{\"1\":{\"86\":1}}],[\"一\",{\"0\":{\"81\":1,\"417\":1}}],[\"一起看看\",{\"1\":{\"604\":1}}],[\"一起高效学习～\",{\"1\":{\"80\":1}}],[\"一起传递给下游服务\",{\"1\":{\"21\":1}}],[\"一书的作者\",{\"1\":{\"51\":1}}],[\"一共有两种指定\",{\"1\":{\"479\":1}}],[\"一共\",{\"1\":{\"38\":3}}],[\"一共需要\",{\"1\":{\"35\":1}}],[\"一个父节点可以为其子节点\",{\"1\":{\"1382\":1}}],[\"一个主从不行那就多个主从的呗\",{\"1\":{\"1314\":1}}],[\"一个来自官网的例子\",{\"1\":{\"1293\":1}}],[\"一个队列只会被一个消费者消费\",{\"1\":{\"1280\":1,\"1305\":1}}],[\"一个消费者集群多台机器共同消费一个\",{\"1\":{\"1280\":1}}],[\"一个消息可投入一个或多个队列\",{\"1\":{\"1250\":1}}],[\"一个消息只有一个消费者\",{\"1\":{\"1222\":1}}],[\"一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则\",{\"1\":{\"1249\":1}}],[\"一个数据多个副本\",{\"1\":{\"1240\":1}}],[\"一个数据时的处理流程\",{\"1\":{\"571\":1}}],[\"一个提供统一消息服务的应用层标准\",{\"1\":{\"1230\":1}}],[\"一个提案被选定需要被半数以上的\",{\"1\":{\"1098\":1}}],[\"一个序列化的\",{\"1\":{\"1226\":1}}],[\"一个字节的数据流\",{\"1\":{\"1226\":1}}],[\"一个字符串对象\",{\"1\":{\"1226\":1}}],[\"一个字段还会拥有一些额外的属性\",{\"1\":{\"331\":1}}],[\"一个或多个消息接受者\",{\"1\":{\"1222\":1}}],[\"一个或多个\",{\"1\":{\"1109\":1}}],[\"一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障\",{\"1\":{\"1106\":1}}],[\"一个典型应用场景就是启动一个服务时\",{\"1\":{\"753\":1}}],[\"一个平台线程可以在不同的时间执行不同的虚拟线程\",{\"1\":{\"1053\":1}}],[\"一个被其他线程锁定住的变量\",{\"1\":{\"972\":1}}],[\"一个变量在同一个时刻只允许一条线程对其进行\",{\"1\":{\"972\":1}}],[\"一个新的变量只能在主内存中\",{\"1\":{\"972\":1}}],[\"一个新的对象已经产生了\",{\"1\":{\"506\":1}}],[\"一个执行读取\",{\"1\":{\"972\":1}}],[\"一个执行修改\",{\"1\":{\"972\":1}}],[\"一个请求创建一个线程\",{\"1\":{\"928\":1}}],[\"一个进程中可以有多个线程\",{\"1\":{\"810\":1}}],[\"一个进程在其执行的过程中可以产生多个线程\",{\"1\":{\"807\":1}}],[\"一个用户线程对应一个内核线程\",{\"1\":{\"808\":1}}],[\"一个用户的事务不被其他事务所干扰\",{\"1\":{\"281\":1}}],[\"一个接口可能需要调用\",{\"1\":{\"772\":1}}],[\"一个操作一旦开始\",{\"1\":{\"762\":1}}],[\"一个线程获取锁失败了\",{\"1\":{\"1012\":1}}],[\"一个线程内\",{\"1\":{\"975\":1}}],[\"一个线程因请求资源而阻塞时\",{\"1\":{\"823\":1}}],[\"一个线程一次最多只能在\",{\"1\":{\"820\":1}}],[\"一个线程被\",{\"1\":{\"816\":1}}],[\"一个线程必须释放与获取的次数相同的锁\",{\"1\":{\"742\":1}}],[\"一个线程可以多次获取同一个锁而不会被阻塞\",{\"1\":{\"742\":1}}],[\"一个节点可以身兼多个角色\",{\"1\":{\"1098\":1}}],[\"一个节点表示一个线程\",{\"1\":{\"742\":1,\"904\":1}}],[\"一个节点获取了锁之后\",{\"1\":{\"61\":1}}],[\"一个是过期key相关entry的启发式清理\",{\"1\":{\"1036\":1}}],[\"一个是\",{\"1\":{\"639\":1}}],[\"一个支持延迟获取元素的阻塞队列\",{\"1\":{\"529\":1}}],[\"一个支持更多操作的阻塞队列\",{\"1\":{\"529\":1}}],[\"一个不存储元素的阻塞队列\",{\"1\":{\"529\":1}}],[\"一个对象的\",{\"1\":{\"446\":1}}],[\"一个对象后\",{\"1\":{\"444\":1}}],[\"一个简单的学生类\",{\"1\":{\"425\":1}}],[\"一个非数组类的加载阶段\",{\"1\":{\"340\":1}}],[\"一个类不能被继承\",{\"1\":{\"521\":1}}],[\"一个类及其依赖类由同一个类加载器加载\",{\"1\":{\"359\":1}}],[\"一个类\",{\"1\":{\"344\":1}}],[\"一个类的完整生命周期\",{\"1\":{\"338\":1}}],[\"一个类会可以有个字段\",{\"1\":{\"331\":1}}],[\"一个类可以有个多个方法\",{\"1\":{\"325\":1,\"332\":1}}],[\"一个类可以有多个字段\",{\"1\":{\"325\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"325\":1,\"330\":1}}],[\"一个事务被提交之后\",{\"1\":{\"281\":1}}],[\"一个事务执行过程中看到的数据\",{\"1\":{\"132\":1}}],[\"一个事务提交之后\",{\"1\":{\"132\":1}}],[\"一个事务还没提交时\",{\"1\":{\"132\":1}}],[\"一个事务中的所有操作\",{\"1\":{\"125\":1}}],[\"一个编辑人员两次读取同一文档\",{\"1\":{\"128\":1}}],[\"一个表innodb只能创建一个聚簇索引\",{\"1\":{\"114\":1}}],[\"一个表只能有一个主键\",{\"1\":{\"104\":1}}],[\"一个高度为3的b+树可以存放\",{\"1\":{\"110\":1}}],[\"一个路由规则可以包含多个断言\",{\"1\":{\"71\":1}}],[\"一个好的分布式锁还需要满足下面这些条件\",{\"1\":{\"61\":1}}],[\"一个比较好的分布式\",{\"1\":{\"30\":1}}],[\"一个最基本的分布式锁需要满足\",{\"1\":{\"61\":1}}],[\"一个最基本的分布式\",{\"1\":{\"30\":1}}],[\"一个\",{\"1\":{\"21\":1,\"195\":1,\"285\":1,\"293\":1,\"425\":1,\"433\":1,\"442\":1,\"449\":1,\"657\":2,\"690\":2,\"807\":1,\"827\":1,\"883\":1,\"1108\":1,\"1111\":1,\"1196\":1,\"1251\":1,\"1262\":1,\"1263\":1,\"1281\":3}}],[\"一个系统被拆分为多个服务\",{\"1\":{\"1\":1}}],[\"一定会配置上打印\",{\"1\":{\"483\":1}}],[\"一定会出现这样一种情况\",{\"1\":{\"307\":1}}],[\"一定不要光看不实践\",{\"1\":{\"1199\":1}}],[\"一定不要频繁创建线程池比如一个用户请求到了就单独创建一个线程池\",{\"1\":{\"927\":1}}],[\"一定不要搞混了\",{\"1\":{\"694\":1}}],[\"一定不要误认为used\",{\"1\":{\"219\":1}}],[\"一定不能是连号的\",{\"1\":{\"18\":1}}],[\"一定要自己搭建一个\",{\"1\":{\"1199\":1}}],[\"一定要手动自定义线程池\",{\"1\":{\"928\":1}}],[\"一定要注意当\",{\"1\":{\"630\":1}}],[\"一定要保证设置指定\",{\"1\":{\"48\":1}}],[\"一定要结合实际项目来选择最适合自己的方案\",{\"1\":{\"43\":1}}],[\"一定要仔细看各支付产品的\",{\"1\":{\"17\":1}}],[\"一码付\",{\"0\":{\"17\":1}}],[\"一般地\",{\"1\":{\"1313\":1}}],[\"一般地适用于金融等特定业务场景\",{\"1\":{\"1313\":1}}],[\"一般适用于如发验证码等对于消息保证要求不太高的业务场景\",{\"1\":{\"1313\":1}}],[\"一般而言\",{\"1\":{\"1299\":1}}],[\"一般就是你本地启动了玩玩儿的\",{\"1\":{\"1263\":1}}],[\"一般有两种方式\",{\"1\":{\"1257\":1}}],[\"一般情况是你在你的简历上涉及到消息队列这方面的内容\",{\"1\":{\"1219\":1}}],[\"一般情况下一个\",{\"1\":{\"1255\":1}}],[\"一般情况下我们还需要设置\",{\"1\":{\"1206\":1}}],[\"一般情况下我们是这样设计\",{\"1\":{\"307\":1}}],[\"一般情况下\",{\"1\":{\"1\":1,\"35\":1,\"270\":1,\"1112\":1,\"1179\":1}}],[\"一般会指定一个\",{\"1\":{\"1249\":1}}],[\"一般会采用这种方式\",{\"1\":{\"1207\":1}}],[\"一般会有专门的中间服务去保存服务名和\",{\"1\":{\"1157\":1}}],[\"一般推荐设置成\",{\"1\":{\"1206\":1}}],[\"一般的\",{\"1\":{\"1184\":1}}],[\"一般用在系统内部中线程间的消息传递\",{\"1\":{\"1180\":1}}],[\"一般用在系统或者服务之间的消息传递\",{\"1\":{\"1180\":1}}],[\"一般用于公司内部集群里\",{\"1\":{\"1155\":1}}],[\"一般也没必要去换了\",{\"1\":{\"1160\":1}}],[\"一般也不会采用\",{\"1\":{\"298\":1}}],[\"一般为一两个月\",{\"1\":{\"1116\":1}}],[\"一般为\",{\"1\":{\"1116\":1}}],[\"一般为30秒一次\",{\"1\":{\"282\":1}}],[\"一般通过使用复制日志来实现复制状态机\",{\"1\":{\"1106\":1}}],[\"一般比较被大家推荐的是下面\",{\"1\":{\"1067\":1}}],[\"一般建议是不同的业务使用不同的线程池\",{\"1\":{\"919\":1}}],[\"一般默认即可\",{\"1\":{\"890\":1,\"936\":1}}],[\"一般锁进行并发控制的规则\",{\"1\":{\"865\":1}}],[\"一般使用的是\",{\"1\":{\"1097\":1}}],[\"一般使用\",{\"1\":{\"744\":1}}],[\"一般面试中这样介绍就差不多\",{\"1\":{\"685\":1}}],[\"一般应用是很难出现碰撞的\",{\"1\":{\"684\":1}}],[\"一般我们不会直接使用\",{\"1\":{\"1147\":1}}],[\"一般我们做异步化处理都是使用的线程池\",{\"1\":{\"1043\":1}}],[\"一般我们需要对一个集合使用自定义排序时\",{\"1\":{\"661\":1}}],[\"一般我们也可以通过编写脚本的方式来让\",{\"1\":{\"455\":1}}],[\"一般只会使用前者\",{\"1\":{\"543\":1}}],[\"一般设置这个值就可以了\",{\"1\":{\"449\":1}}],[\"一般将\",{\"1\":{\"399\":1}}],[\"一般都提供了\",{\"1\":{\"293\":1,\"298\":1}}],[\"一般都是自己判断过期\",{\"1\":{\"270\":1}}],[\"一般都用来当做缓存使用\",{\"1\":{\"245\":1}}],[\"一般像\",{\"1\":{\"246\":1}}],[\"一般是\",{\"1\":{\"1204\":1}}],[\"一般是在数据表中加上一个数据版本号\",{\"1\":{\"840\":1,\"989\":1}}],[\"一般是在建表的时候同时创建主键索引\",{\"1\":{\"104\":1}}],[\"一般是通过\",{\"1\":{\"249\":1}}],[\"一般是配合\",{\"1\":{\"4\":1}}],[\"一般语法错误会提示第一个出现错误的位置\",{\"1\":{\"86\":1}}],[\"一般不会采用随机的节点进行反熵\",{\"1\":{\"1087\":1}}],[\"一般不会使用\",{\"1\":{\"541\":1}}],[\"一般不会使用这种方式\",{\"1\":{\"62\":1}}],[\"一般不会存在过度碎片化的问题\",{\"1\":{\"218\":1}}],[\"一般不需要你自己再造轮子\",{\"1\":{\"38\":1}}],[\"一般来说\",{\"1\":{\"38\":1,\"120\":1,\"125\":1,\"743\":1,\"819\":1,\"971\":1,\"1007\":1,\"1116\":1}}],[\"一般实现以下业务场景\",{\"1\":{\"18\":1}}],[\"一般着重于技术原理剖析\",{\"1\":{\"15\":1}}],[\"一般还需要结合其他网关一起使用比如\",{\"1\":{\"10\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
